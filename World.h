
#pragma warning(push)
#pragma warning(disable: 26812)
#pragma warning(disable: 6054)
#pragma warning(disable: 6385)
#pragma warning(disable: 4267)
#pragma warning(disable: 4244)
#pragma warning(disable: 4267)

#pragma once
#include <chrono>
#include <filesystem>
using namespace chrono;
namespace fs = std::filesystem;
int current_uid = 1;
string read_file(const std::string filename)
{
	try {
		std::ifstream ifs(filename, std::ios::binary);
		string txt = std::string((std::istreambuf_iterator<char>(ifs)), (std::istreambuf_iterator<char>()));
		return txt;
	}
	catch (const std::exception& e) {
		return "";
	}
}
#define HOME_TIME (15 * 1000)
#define CONNECT_TIME (100 * 1000)
string best_player = "", best_world = "", best_guild = "", best_quote = "";
vector <string> random_quotes{ "Any type Rocks might drop DNA'","Acid blocks drop more Rubbles", "Fossil Rocks may appear in active world", "Mystery Item pack in shop has all the newest items", "Breaking Grass has a chance to drop Butterly", "Breaking Cow has a chance to drop Cow Pet", "Leonidas Scythe is extremely rare to obtain", "Premium World Lock drop item exists", "Obtain Voucher's by depositing"};
bool f_saving_ = false, credit_payment = false, comet_dust = false, zombie_apocalypse = false, can_event = false, beach_party_game = false;
int main_port = 16099, event_item = 0, old_event_item = 0,  x_gems = 1, dl_price = 28, last_onl = 0;
// int beach = 2,
int item1 = 0, item2 = 0, day_ = 0, theitemtoday = 0, punched = 0, item1c = 0, item2c = 0, thedaytoday = 0, today_month = -1, today_day = -1, beach = 5;
string basher_event = "pgag2";
int  _10938_ = 0, angelic_aura = 0, laser_light = 0, grow_pass_item_price = 0, experience_rayman = 0, zeus_crown = 0, recycling_machine = 0, dracula_set = 0, building_machine = 0, e_scepter = 0, island_blast = 0, cursed_eyes = 0, vapor_blade = 0;
// int halloween_rarity;
// role prices
//
int rainbow_color = 0;
int total_pineapple_eaten = 0;
long long int total_wls_recycled = 0;

vector<int> phoenix_items_all, all_phoenix_items { 1674, 2854, 3696, 4820, 6312, 8588, 9730, 13572 };

string recycle_event_name = "7/11";

int grow_pass_item = 13552;

vector <string> random_color{ "`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4","`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4", "`#", "`5", "`e", "`2" , "`9", "`8", "`4" };

struct { 
	int growpass_price = 8 * 10000 / dl_price, 
		vip_price = 3 * 10000 / dl_price, 
		vip_price_permament = (3 * 12) * 10000 / dl_price, 
		lrayman_price = 75000000, 
		glory_price = 3 * 10000 / dl_price, 
		allin_price = 50 * 10000 / dl_price, 
		mod_price = 10 * 10000 / dl_price, 
		moderator_price = 60 * 10000 / dl_price, 
		cheater_price2 =0 ,
		cheater_price = 50 * 10000 / dl_price, 
		cheater7days_price =10 * 10000 / dl_price, 
		dev_price = 400 * 10000 / dl_price, 
		ghost_price = 80 * 10000 / dl_price; 
} role_price;
//janeway items
struct { vector<int> random_janeway_payout { 10394, 4298 , 3936, 4134, 928, 866, 1632, 872, 2242,2244,2246 }; int janeway_payout = 0; vector<pair<int, int>> janeway_items = { {2, 1}, {4, 2},  {10,1},{14, 1}, {22, 2}, {26, 3}, {28, 3}, {30, 4}, {52, 5}, {54, 5} }, janeway_item; } janeway_;
vector<int> the_special{ 7960, 7960,9902, 9350, 9902,9814, 7954, 7484, 5948, 9380, 11038, 3432 }, leonidas{ 7960,7960, 7960, 7960, 7954, 7484, 5948, 9380, 11038, 3432, 7954, 7484, 5948, 9380, 11038, 3432, 7954, 7484, 5948, 9380, 11038, 3432, 7954, 7484, 5948, 9380, 11038, 3432, 7954, 7484, 5948, 9380, 11038, 3432, 7954, 7484, 5948, 9380, 11038, 3432 };
//int planted = 0;
string news_texture = "", top_basher_list_shop = "", top_guild_list_shop = "", top_wls_list = "", top_list = "", top_yesterday_list = "", top_overall_list = "", top_basher_list = "", top_guild_list = "", top_old_guild_winners = "", top_old_winners = "";
string  update_List = "", update_news_list = "";
vector<pair<long long int, string>> top_guild, top_basher, top_wls;
vector<pair<int, string>>  top_guild_winners, top_points, top_player_points, top_ratings, top_yesterday, top_overall, top_basher_winners;
long long last_time2_ = 0, last_time = 0, last_fire_time = 0, last_firehouse = 0, last_autofarm = 0, last_rainbow_reset = 0, last_beach_event = 0;
//, last_growganoth_time = 0, last_beach_event = 0;

string server_name = "", discord_url = "http://discord.gg/saops", news_title = "", news_banner = "";
vector<string> updates{ {" `$Rubble salesman is waiting for you in `8TRASH`` with awesome offers``:`` `2Rubble``" },{" `$Worlds Locks - Recycle Event" },{" `$Worlds Locks - Recycle Event" }, {" `$Janeway the Buyer is waiting for you in `8TRADE`` with awesome offers and rewards``:`` `2Janeway``" },{" `$Happy Easter, added Easter Week Pack & Golden Egg Carton event``:`` `2Easter Week``" },{" `$Fully with awesome prizes``:`` `2Egg-Hunting Basket``" },{" `$Set your world session time``:`` `2World Session Timer``" }, {" `$Full functions``:`` `2Infinity Crown, Crown of Seasons, Banner Bandolier``" },{" `$Full functions & available in premium shop``:`` `2Magic Magnet, Grow Air Balloon, Golem's Gift``" }, {" `$Exchange your items or World Locks``:`` `2Golden Ticket Booth``" }, {" `$Extract`` `8DNA's`` `$from`` `$Amber Blocks, Dino Ribcages, T-Rex Skulls or Ancient Plant Seeds``:`` `2DNA Extractor``"}, {" `$Combine your`` `8DNA's`` `$in:`` `2DNA Processor``"}, {" `$Quests:`` `2Carnival Quests``"}, {" `$Available through locke store & functions of:`` `2Ancient Altar``"},  {" `$Available through gems voucher store & functions of:`` `2Kranken's Galactic Block``"}, {" `$Available through gems store & functions of:`` `2Rift Wings/Cape``"},  {" `$Available via Locke and functions:`` `2Lock-Bot``"},  {" `$All of the quests and one`` `8custom quest```$:`` `2Legendary Wizard``"},  {" `$Very fun gamemode with huge rewards:`` `2Hide And Seek``"},  {" `$Interested in investing? Invest in over 3 crypto currency:`` `2Crypto``"}, {" `$Available via Locke & functions of:`` `2Extractor Dynamo``"}, {" `$Fully working Voucher update, you can gain Voucher's by purchasing premium world locks:`` `2Voucher``"},  {" `$Availabla through gems store & works only for DigiVend Machine:`` `2Vending Hub``"}, {" `$Full of exotic cheats & cool interface and only available via premium world locks shop:`` `2Cheater Role``"},  {" `$Rate /5.99! Set up your world category and gain some ratings:`` `2World Rating``"},  {" `$Fully working guild events & updated personal events, the prize is amazing aswell:`` `2Guild Events``"}, {"Maximum Level 250"} ,{"Trasnmutabooth"}, {"Washing Machine"},{"Mail"}, {"Credit Card"}, {"Custom Boombox"}, {"Lunar Week"}, {"Vending Machine Price"}, {"Growtopia Anniversary"}, {"New Rayman"}, {"Winterfest"},{"Guild"},{"Subscribtion"},{"Balloon Warz"}, {"Black Gem"},{"Cheats"}, {"Wolf World"}, {"Growganoth"}, {"Fire"}, {"Guidebook"},{"Captcha"}, {"Offering Table"}, {"Harvest Festival"}, {"Ultra World Spray"}, {"Tesseract Manipulator & Heart of Gaia"}, {"Zombie Apocalypse & Infection"} , {"Comet Dust Event"}, {"Special Event"}};
//int winterfest_sold = 0, winterfest_stock = 400, winterfest_rarity = 0, winterfest_total_toys = 0, winterfest_rarity_250 = 0;
//long long int winterfest_gift = 0;
string guild_name_player = "fully_guild";
vector<uint16_t> change_id_beach{ 3358,3359,3360,3361,3362,3363,3364,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,3375,3376,3377,3378 };

vector<string>beach_players;

vector<uint16_t> bountiful_seeds = { 8623 , 8671 , 8695 , 8647 }, small_seeds = { 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1155,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683 }, small_seed_pack{ 3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };

vector<pair<int, int>> play_items = { {4374, 300}, {7670, 500}, {9250, 600}, {11536, 700} , {12992, 800} };
vector<pair<string, string>>  mails;
/*
int ubi_item_1 = 200, ubi_item_2 = 200, ubi_item_3 = 350, ubi_item_4 = 200, ubi_item_5 = 200, ubi_item_6 = 200, ubi_item_7 = 200, ubi_item_8 = 200, ubi_item_9 = 200, ubi_item_10 = 200;
int ubi_sold_1 = 0, ubi_sold_2 = 0, ubi_sold_3 = 0, ubi_sold_4 = 0, ubi_sold_5 = 0, ubi_sold_6 = 0, ubi_sold_7 = 0, ubi_sold_8 = 0, ubi_sold_9 = 0, ubi_sold_10 = 0;*/

/*
int bonanza_item = 100, bonanza_sold = 0,  bonanza_item_current = 0;
vector<int> bonanza_items{ 13324 , 13322 , 13320 , 13326 };
long long int bonanza_time = 0;
*/
//vector <int> iotm_items { 4802,4534,4590,4628,4746,4988,5020,5088,5206,5322,5712,6294,6338,6758,6892,7192,7196,7384,7568,7570,7572,7574,7676,7678,7680,7682,7836,7838,7840,7842,8006,8008,8010,8012,8288,8290,8292,8294,8432,8434,8436,8438,8576,8578,8580,8582,8816,8818,8820,8822,8898,8900,8902,8904,9008,9010,9012,9014,9116,9118,9120,9122,9136,9138,9236,9348,9408,9462,9464,9606,9648,9760,10044,10128,10166,10246,10426,10496,10618,10666,10718,10810,10914,11006,11116,11232,6016 };
//vector<vector<int>> current_iotm;
//long long int iotm_time = 0, ubitoken_time = 0,
long long int  next_event = 0, current_event = 0, wls_event_time = 0;
//int total_iotm_items = 0, total_iotm_found = 0;
string a = "";


string cchs = "", cchs2 = "", cchs3 = "";
void doLog(string txt) {
}
void doLog2(string txt) {
}
struct {
	int login_count = 0, enter_world_count = 0, update_item_data = 0;
	vector<pair<string, long long int>> banned_ip_temporary, home_timed;
	bool dev_access = true, buy_enabled = false;
	string log_player, last_registered;
	long long up_time_;
	long long int login_time = 0, world_enter_time = 0;
	double version = 4.39, maximum_version = 5.00;
	vector<string> ridbans;
	int restart_server_time = 10;
	bool restart_server_status = false, restart_server_status_seconds = false;
	vector<pair<string, string>>  logs;
}
Server_Security;

struct {
	vector<pair<int, string>>  top_active_worlds;
	long long last_world_menu;
	string top_list_world_menu, lastsbworld , lastsdbworld, depositworld , report_world , active_world_list;
	vector<string>  t_worlds, wotd, wotd_worlds;
}
World_Stuff;

struct {
	int16_t param1 = 0, param2 = 0, param3 = 0, param4 = 0, param5 = 0, param6 = 0;
} 
DaylightDragon;

struct {
string hidenseekworld = "HIDENSEEK";
vector<string> hide_worlds{ {"HIDENSEEK"}, {"HIDENSEEK2"}, {"HIDENSEEK3"} , {"HIDENSEEK4"} }, hide_players, seeker;
long long last_hide_event = 0;
long long int hide_time = 0;
int hide_gamemode_time = 330, wait_players_time = 0, total_players = 0;
bool seeker_start = false, hider_start = false;
}
Hide_N_Seek;

struct {
	string balloon_leaderboard = "", balloon_leaderboard2 = "", top_balloon_list = "";
	vector<pair<int, string>>  top_balloon_winners, top_balloon;
	vector<pair<int, int>> balloon_warz;
}
Balloon_Warz;

struct {
	long long  last_honors_reset = 0, last_old_honors = 0;
	vector<pair<string, string>> world_honors;
}
Honors_Update;

/*
struct {
	int volcanic_cape = 0, volcanic_wings = 0, volcanic_pauldrons = 0;
}
Cinco_De_Mayo;*/

struct {
	int crypto_sold = 0, crypto_bought = 0;
	vector<string>  crypto_history;
	vector<pair<string, int>> crypto = { {"Bitcoin", 27991}, {"Ethereum", 1811 }, {"Litecoin", 85} }, crypto_sale = { {"Bitcoin", 24500}, {"Ethereum", 1601}, {"Litecoin", 76} };
	string crypto_list = "", crypto_sale_list = "";
	long long int  crypto_time = 0;
}
Crypto_Update;

vector<vector<double>> winterfest_calendar{ 
	{ 11244,263, 263,7088, 7088, 7094, 7094, 11520, 11520, 7864, 7864, 8976, 8976, 12918, 12918 , 12918, 5428, 5428, 5428, 5430, 5430, 5430, 5432, 5432, 5432, 5434, 5434, 5434, 10486, 10486, 10486, 10444, 10444, 10444, 11202, 11202, 11202, 7498, 7498, 7498, 7498, 10488, 10488,10488,10488 , 8280, 8280, 8280, 8280, 8278, 8278, 8278, 8278  },
	{10054, 9202, 1384, 11192,5446, 11514, 8480, 8554, 7496, 7090, 9202, 1384, 11192,5446, 11514, 8480, 8554, 7496, 7090, 12918, 5428, 5430, 5432, 5434, 8546, 12918, 5428, 5430, 5432, 5434, 8546, 12918, 5428, 5430, 5432, 5434, 8546, 10488, 2564.5, 1360.5, 10488, 2564.5, 1360.5, 10488, 2564.5, 1360.5, 10488, 2564.5, 1360.5 },
	{11158, 7490, 8556, 10258, 11520, 3676, 7086, 7082, 10036, 10042, 7490, 8556, 10258, 11520, 3676, 7086, 7082, 10036, 10042, 11202, 12918, 5446, 11202, 12918, 5446, 11202, 12918, 5446, 10444,5428, 5430, 5432, 5434, 10444,5428, 5430, 5432, 5434, 10444,5428, 5430, 5432, 5434, 10444,5428, 5430, 5432, 5434 },
	{12302, 9202, 6414, 7080, 7422, 7758, 6384, 10032, 9202, 6414, 7080, 7422, 7758, 6384, 10032,11514, 11192, 1368.10, 12918,11514, 11192, 1368.10, 12918,11514, 11192, 1368.10, 12918, 5382.2, 5428, 5430, 5432, 5434, 1360.5, 5382.2, 5428, 5430, 5432, 5434, 1360.5, 5382.2, 5428, 5430, 5432, 5434, 1360.5, 5382.2, 5428, 5430, 5432, 5434, 1360.5 },
	{11080, 11082, 7092, 10922, 10440, 263, 11078, 11500, 10440, 263, 11078, 11500, 9184, 7096, 7760, 10038, 7420, 10040, 7418, 9184, 7096, 7760, 10038, 7420, 10040, 7418, 9184, 7096, 7760, 10038, 7420, 10040, 7418, 8960, 9692, 8948, 8722, 8960, 9692, 8948, 8722, 8960, 9692, 8948, 8722, 8960, 9692, 8948, 8722 },
	{8358, 11084, 8372, 10878, 9182, 11468, 10878, 9182, 11468, 5456, 7084, 7424, 7396, 10442, 5456, 7084, 7424, 7396, 10442, 5456, 7084, 7424, 7396, 10442,812, 802, 1758, 1758, 7738, 5018, 8468, 8556, 7752, 8474,812, 802, 1758, 1758, 7738, 5018, 8468, 8556, 7752, 8474,812, 802, 1758, 1758, 7738, 5018, 8468, 8556, 7752, 8474,812, 802, 1758, 1758, 7738, 5018, 8468, 8556, 7752, 8474 }
};

void refresh_wotd_worlds() {
	World_Stuff.wotd_worlds.clear();
	vector<string> a_;
	for (int i = 0; i < World_Stuff.wotd.size(); i++) {
		a_ = explode("|", World_Stuff.wotd[i]);
		World_Stuff.wotd_worlds.push_back(a_[0].c_str());
	}
}

struct WorldRate {
	string name = "", category = "";
	vector<int> rating;
};

void to_json(json& j, const WorldRate& p) {
	j = json{
		{"n", p.name},
		{"c", p.category},
		{"r", p.rating}
	};
}
void from_json(const json& j, WorldRate& p) {
	j["n"].get_to(p.name);
	j["c"].get_to(p.category);
	j["r"].get_to(p.rating);
}


vector<WorldRate> world_rating;

vector<vector<string>> world_rate_types{{},	{},{},{},{},{},	{},{},{},{},{},	{},{},{},{},{}};

struct Account_Rid_Switch {
	string name;
	vector<string> rids;
};

vector<Account_Rid_Switch> account_rid_detect;
long long int  server_event_spawn = 0;

//vector<pair<int, int>> growganoth_platform;
//int halloween_quest = 1994;

struct Position2D {
	int x, y;
};

string fixchar(string name) {
	string newS;
	for (char c : name) newS += (c >= 'A' && c <= 'Z') ? c - ('A' - 'a') : c;
	string ret;
	for (int i = 0; i < newS.length(); i++) if (newS[i] == '`') i++; else ret += newS[i];
	string ret2;
	for (char c : ret) if ((c >= 'a' && c <= 'z') || (c >= '0' && c <= '9')) ret2 += c;
	return ret2;
}

int get_encrypt_text(string name) {
	int result = 1;
	for (auto& elem : to_lower(name)) result *= elem - 'A' + 1;  //corresponding int value is multiplied to the result
	return result;
}

vector<vector<vector<int>>> legendary_quests = {
	{{0, 2000, 442}, {0, 100}, {0, 5000}, {0, 600, 1422}, {0, 50000}, {0, 50}, {0, 3, 1462}, {0, 10000}, {0,1000, 784}, {0,100000}, {0,100000}, {0,100}, {0,1000}, {0,3, 1458}, {0,100000}, {0,1, 1614}, {0,3, 1680}, {0,10, 1672}, {0,3, 1280}, {0,1, 1794}},
	{{0, 2000, 4}, {0, 100}, {0, 5000}, {0, 600, 598}, {0, 50000}, {0, 50}, {0, 10, 900}, {0, 10000}, {0,1000, 1114}, {0,100000}, {0,100000}, {0,100}, {0,1000}, {0,3, 1576}, {0,100000}, {0,1, 394}, {0,3, 1378}, {0,1000, 1128}, {0,3, 1206}, {0,1, 1794}},
	{{0, 2000, 914}, {0, 100}, {0, 5000}, {0, 600, 254}, {0, 50000}, {0, 50}, {0, 3, 1274}, {0, 10000}, {0,1000, 324}, {0,100000}, {0,100000}, {0,100}, {0,1000}, {0,3, 1250}, {0,100000}, {0,1, 1602}, {0,5, 1354}, {0,5, 1396}, {0,2, 8284}, {0,1, 1794}},
	{{0, 1000, 728}, {0, 100}, {0, 5000}, {0, 600, 156}, {0, 50000}, {0, 50}, {0, 3, 1550}, {0, 10000}, {0,800, 678}, {0,100000}, {0,100000}, {0,100}, {0,1000}, {0,20, 1672}, {0,100000}, {0,3, 1460}, {0,100, 818}, {0,1, 1674}, {0,50, 1574}, {0,1, 1794}},
	{{0, 1000, 684}, {0, 100}, {0, 5000}, {0, 600, 604}, {0, 50000}, {0, 50}, {0, 3, 2386}, {0, 10000}, {0,800, 690}, {0,100000}, {0,100000}, {0,100}, {0,100}, {0,20, 810}, {0,100000}, {0,1, 2002}, {0,10, 2456}, {0,20, 2572}, {0,20, 2266}, {0,1, 1794}},
	{{0, 2000, 1050}, {0, 100}, {0, 10000}, {0, 1000, 6080}, {0, 100000}, {0, 50}, {0, 10, 4880}, {0, 20000}, {0,5, 5202}, {0,140000}, {0,200000}, {0,100}, {0,20}, {0,3, 5276}, {0,200000}, {0,5, 6028}, {0,3,  5650}, {0,1, 6094}, {0,3, 5078}, {0,1, 1794}},
	{{0, 2000, 5042}, {0, 100}, {0, 10000}, {0, 1000, 1736}, {0, 100000}, {0, 50}, {0, 10, 2982}, {0, 20000}, {0,800, 1936}, {0,140000}, {0,100000}, {0,100}, {0,10}, {0,10, 1824}, {0,200000}, {0,1, 4302}, {0,5, 7762}, {0,1, 5754}, {0,10, 7728}, {0,1, 1794}},
	{{0, 2000, 8206}, {0, 100}, {0, 10000}, {0, 50, 10160}, {0, 100000}, {0, 50}, {0, 50, 11152}, {0, 20000}, {0,10, 10130}, {0,100000}, {0,200000}, {0,100}, {0,10}, {0,1, 10634}, {0,200000}, {0,2, 7416}, {0,3, 11050}, {0,1, 10724}, {0,1, 10576}, {0,1, 1794}},
	{{0, 2000, 9390}, {0, 100}, {0, 10000}, {0, 150, 10214}, {0, 100000}, {0, 50}, {0, 15, 8952}, {0, 20000}, {0,10, 10332}, {0,100000}, {0,200000}, {0,100}, {0,1000}, {0,3, 2952}, {0,200000}, {0,10, 11076}, {0,5,  9376}, {0,1, 11008}, {0,1, 10806}, {0,1,1794}},
	{{0, 50, 2386}, {0, 400}, {0, 500000}, {0, 5, 1614}, {0, 750000}, {0, 200}, {0, 3, 9488}, {0, 1000000}, {0,2000, 2590}, {0,10000000}, {0,750000}, {0,1000}, {0,69420}, {0,20, 1458}, {0,100000}, {0,30, 7188}, {0,100, 1068}, {0,2, 9548}, {0,250, 7960}, {0,1, 1794}}
};


/*

void iotm_reset() {
	items[7672].rare_item = { {13030,1}, {12996,1}, {13002,1}, { 9256,1},{ 11544,1},{ 10492,1},{ 9262,1},{ 7660,1},{ 10494,1},{ 11534,1},{ 10534,1 } };
	current_iotm.clear();
	iotm_time = time(nullptr) + 10800;
	total_iotm_items = 0, total_iotm_found = 0;
	for (int i = 0; i < 20; i++) {
		if (rand() % 3 < 1) {
			int given_ = rand() % 8 + 1, item_ = iotm_items[rand() % iotm_items.size()];
			total_iotm_items += given_;
			current_iotm.push_back({ {item_}, {0}, {given_} });
			items[7672].rare_item.push_back({ { item_ }, {1} });
		}
	}
}*/

struct Portrait
{
	uint32_t c_expression = 1;
	/*
	* 1: Unconcerned
	* 2: Happy
	* 3: Sad
	* 4: Tongue Out
	* 5: Surprised
	* 6: Angry
	* 7: Talking
	* 9: Ecstatic
	* 24: Wry
	* 12: Sleeping
	* 14: Winking
	* 16: Trolling
	* 18: Vampire
	* 22: Underwater
	* 26: Blushed
	*
	*/
	uint32_t c_hair_colour = 0;
	uint32_t c_skin = 0;
	uint16_t c_face = 0;
	uint16_t c_head = 0;
	uint16_t c_hair = 0;
};
void to_json(json& j, const Portrait& p) {
	j = json{
		{"c_expression", p.c_expression},
		{"c_hair_colour", p.c_hair_colour},
		{"c_skin", p.c_skin},
		{"c_face", p.c_face},
		{"c_head", p.c_head},
		{"c_hair", p.c_hair}
	};
}
void from_json(const json& j, Portrait& p) {
	j["c_expression"].get_to(p.c_expression);
	j["c_hair_colour"].get_to(p.c_hair_colour);
	j["c_skin"].get_to(p.c_skin);
	j["c_face"].get_to(p.c_face);
	j["c_head"].get_to(p.c_head);
	j["c_hair"].get_to(p.c_hair);
}

string fixint(int jumlah) {
	string result = to_string(jumlah);
	for (int i = result.size() - 3; i > 0; i -= 3)
		result.insert(i, ",");
	return result;
}
struct Mannequin
{
	uint16_t c_head = 0;
	uint16_t c_shirt = 0;
	uint16_t c_pants = 0;
	uint16_t c_feet = 0;
	uint16_t c_mask = 0;
	uint16_t c_hand = 0;
	uint16_t c_back = 0;
	uint16_t c_hair = 0;
	uint16_t c_neck = 0;
};
void to_json(json& j, const Mannequin& p) {
	j = json{
		{"c_head", p.c_head},
		{"c_shirt", p.c_shirt},
		{"c_pants", p.c_pants},
		{"c_feet", p.c_feet},
		{"c_mask", p.c_mask},
		{"c_hand", p.c_hand},
		{"c_back", p.c_back},
		{"c_hair", p.c_hair},
		{"c_neck", p.c_neck}
	};
}
void from_json(const json& j, Mannequin& p) {
	j["c_head"].get_to(p.c_head);
	j["c_shirt"].get_to(p.c_shirt);
	j["c_pants"].get_to(p.c_pants);
	j["c_feet"].get_to(p.c_feet);
	j["c_mask"].get_to(p.c_mask);
	j["c_hand"].get_to(p.c_hand);
	j["c_back"].get_to(p.c_back);
	j["c_hair"].get_to(p.c_hair);
	j["c_neck"].get_to(p.c_neck);
}
struct Donate
{
	int item = 0, count = 0;
	string name = "", text = "";
};

void to_json(json& j, const Donate& p) {
	j = json{
		{"item", p.item},
		{"count", p.count},
		{"name", p.name},
		{"text", p.text}
	};
}
void from_json(const json& j, Donate& p) {
	j["item"].get_to(p.item);
	j["count"].get_to(p.count);
	j["name"].get_to(p.name);
	j["text"].get_to(p.text);
}
struct WorldDrop
{
	int id = 0, count = 0, uid = 0, x = 0, y = 0, flag = 0;
	int fromx = 0, fromy = 0;
	long long int time = 0;
};
struct GameGenerator
{
	string Game_Name = "";
	int Teams = 0, Lives = 0, Time = 0, Score = 0, MinSize = 0, MaxSize = 0;
	long long int GameTime = 0;
	// Point Values
	int Kill = 0, Last = 0, Goal = 0, Flag = 0, Smash = 0, Die = 0;
	bool Respawn = false, Reset = false, Owner = false, Late = false, Smash1 = false, Smash2 = false, NoMusic = false, NoLog = false, AutoStart = false;
	int Punch = 0, Block = 0;
};

void to_json(json& j, const GameGenerator& p) {
	j = json{
		{"Game_Name", p.Game_Name},
		{"Teams", p.Teams},
		{"Lives", p.Lives},
		{"Time", p.Time},
		{"Score", p.Score},
		{"MinSize", p.MinSize},
		{"MaxSize", p.MaxSize},
		{"GameTime", p.GameTime},
		{"Kill", p.Kill},
		{"Last", p.Last},
		{"Goal", p.Goal},
		{"Flag", p.Flag},
		{"Smash", p.Smash},
		{"Die", p.Die},
		{"Respawn", p.Respawn},
		{"Reset", p.Reset},
		{"Owner", p.Owner},
		{"Late", p.Late},
		{"Smash1", p.Smash1},
		{"Smash2", p.Smash2},
		{"NoMusic", p.NoMusic},
		{"NoLog", p.NoLog},
		{"AutoStart", p.AutoStart},
		{"Punch", p.Punch},
		{"Block", p.Block}
	};
}
void from_json(const json& j, GameGenerator& p) {
	j["Game_Name"].get_to(p.Game_Name);
	j["Teams"].get_to(p.Teams);
	j["Lives"].get_to(p.Lives);
	j["Time"].get_to(p.Time);
	j["Score"].get_to(p.Score);
	j["MinSize"].get_to(p.MinSize);
	j["MaxSize"].get_to(p.MaxSize);
	j["GameTime"].get_to(p.GameTime);
	j["Kill"].get_to(p.Kill);
	j["Last"].get_to(p.Last);
	j["Goal"].get_to(p.Goal);
	j["Flag"].get_to(p.Flag);
	j["Smash"].get_to(p.Smash);
	j["Die"].get_to(p.Die);
	j["Respawn"].get_to(p.Respawn);
	j["Reset"].get_to(p.Reset);
	j["Owner"].get_to(p.Owner);
	j["Late"].get_to(p.Late);
	j["Smash1"].get_to(p.Smash1);
	j["Smash2"].get_to(p.Smash2);
	j["NoMusic"].get_to(p.NoMusic);
	j["NoLog"].get_to(p.NoLog);
	j["AutoStart"].get_to(p.AutoStart);
	j["Punch"].get_to(p.Punch);
	j["Block"].get_to(p.Block);
}

struct WorldBlock
{
	uint16_t fg = 0, bg = 0;
	uint8_t fruit = 0;
	int pr = 0, wl = 0, id = 0, c_ = 0, hp = -1, flags = 0x00000000, lock_origin = -1;
	long long lp = 0, planted = 0;
	uint8_t roll = 0;
	string txt = "", door_destination = "", door_id = "", owner_name = "", owner_named = "", heart_monitor = "", block_day = "";
	uint8_t open = 1;
	bool spin = false, invert = false, locked = false, build_only = false, limit_admins = false, enabled = false;
	int rate_of_fire = 10, projectile_speed = 100;
	GameGenerator GameGen{};
	// magplants
	uint16_t gravity = 50;
	vector<string> admins;
	vector<vector<int>> crystals{};
	Mannequin mannequin{};
	vector<Donate> donates{};
	uint16_t r = 255, g = 128;
	uint8_t b = 64;
	Portrait portrait{};
	uint16_t shelf_1 = 0, shelf_2 = 0, shelf_3 = 0, shelf_4 = 0;
	vector<int> offering_items;
	uint8_t kranken_pattern = 0;

	//temporary
	bool applied_fire = false, scanned = false;
	int fire_try = 0;
};
struct WorldMachines
{
	uint16_t id = 0, x = 0, y = 0, target_item = 0;
	bool enabled = false;
	long long last_ = 0;
};

void to_json(json& j, const WorldMachines& p) {
	j = json{
		{"i", p.id},
		{"x", p.x},
		{"y", p.y},
		{"ti", p.target_item},
		{"en", p.enabled},
		{"l", p.last_}
	};
}
void from_json(const json& j, WorldMachines& p) {
	j["i"].get_to(p.id);
	j["x"].get_to(p.x);
	j["y"].get_to(p.y);
	j["ti"].get_to(p.target_item);
	j["en"].get_to(p.enabled);
	j["l"].get_to(p.last_);
}

int ancesupgradeto(ENetPeer* peer, int c) {
	switch (c) {
	case 0:
		return pInfo(peer)->ances = 0;
	case 5080:
		return 5144;
	case 5078:
		return 5126;
	case 5082:
		return 5162;
	case 5084:
		return 5180;
	case 7166:
		return 7168;
	case 5144: //checkpoint
		return 5146;
	case 5126:
		return 5128;
	case 5162:
		return 5164;
	case 5180:
		return 5182;
	case 7168:
		return 7170;
	case 5146: //checkpoint
		return 5148;
	case 5128:
		return 5130;
	case 5164:
		return 5168;
	case 5182:
		return 5184;
	case 7170:
		return 7172;
	case 5148: //checkpoint
		return 5150;
	case 5130:
		return 5132;
	case 5168:
		return 5170;
	case 5184:
		return 5186;
	case 7172:
		return 7174;
	case 5150: //checkpoint
		return 5152;
	case 5132:
		return 5134;
	case 5170:
		return 5172;
	case 5186:
		return 5188;
	case 7174:
		return 9212;
	default:
		return 0;
	}
}


struct WorldNPC
{
	uint16_t id = 0, x = 0, y = 0, rate_of_fire = 10, projectile_speed = 100;
	float kryptis = 0;
	int uid = 0;
	bool enabled = false;
	long long last_ = 0, started_moving = 0;
};

void to_json(json& j, const WorldNPC& p) {
	j = json{
		{"i", p.id},
		{"x", p.x},
		{"y", p.y},
		{"ps", p.projectile_speed},
		{"rf", p.rate_of_fire},
		{"kr", p.kryptis},
		{"en", p.enabled},
		{"l", p.last_},
		{"sm", p.started_moving}
	};
}
void from_json(const json& j, WorldNPC& p) {
	j["i"].get_to(p.id);
	j["x"].get_to(p.x);
	j["y"].get_to(p.y);
	j["ps"].get_to(p.projectile_speed);
	j["rf"].get_to(p.rate_of_fire);
	j["kr"].get_to(p.kryptis);
	j["en"].get_to(p.enabled);
	j["l"].get_to(p.last_);
	j["sm"].get_to(p.started_moving);
}

struct WorldSBOX1
{
	int id = 0, count = 0, x = 0, y = 0;
};

void to_json(json& j, const WorldSBOX1& p) {
	j = json{
		{"i", p.id},
		{"c", p.count},
		{"x", p.x},
		{"y", p.y}
	};
}
void from_json(const json& j, WorldSBOX1& p) {
	j["i"].get_to(p.id);
	j["c"].get_to(p.count);
	j["x"].get_to(p.x);
	j["y"].get_to(p.y);
}


struct WorldCCTV
{
	int x = 0, y = 0;
	string logs;
};

void to_json(json& j, const WorldCCTV& p) {
	j = json{
		{"x", p.x},
		{"y", p.y},
		{"l", p.logs}
	};
}
void from_json(const json& j, WorldCCTV& p) {
	j["x"].get_to(p.x);
	j["y"].get_to(p.y);
	j["l"].get_to(p.logs);
}
struct WorldBulletin
{
	int x = 0, y = 0;
	string name = "", text = "";
};

void to_json(json& j, const WorldBulletin& p) {
	j = json{
		{"x", p.x},
		{"y", p.y},
		{"n", p.name},
		{"t", p.text}
	};
}
void from_json(const json& j, WorldBulletin& p) {
	j["x"].get_to(p.x);
	j["y"].get_to(p.y);
	j["n"].get_to(p.name);
	j["t"].get_to(p.text);
}
/*
struct GlobalMonitors
{
	string world_name = "";
	int x = -1, y = -1;
	uint32_t active = 0;
};*/

//vector<GlobalMonitors> monitors;
struct World
{
	string honors = "", name = "", owner_name = "", owner_named = "", category = "";
	int total_drop_uid = 0, npc_uid = 0, guild_id = 0, xenonite = 0, world_settings = 0, fire_try = 0, total_fires = 0, music_bpm = 100, entry_level = 1, World_Time = 0;
	int max_x = 0, max_y = 0;
	bool fresh_world = false;
	string nuked_by = "";
	vector<pair<string, int>>Game_Score;
	vector<string> admins, whitelist;
	vector<WorldBlock> blocks{};
	vector<vector<int>> drop_new, cctv_settings;
	vector<WorldCCTV> cctv{};
	vector<WorldSBOX1> sbox1{};
	vector<WorldBulletin> bulletin{};
	uint8_t weather = 0, d_weather = 0;
	vector<pair<string, long long int>> bannedPlayers{};
	vector<int> active_jammers, world_event_items;
	vector<WorldNPC> npc{};
	vector<WorldMachines> machines{};
	long long last_special_event = 0, last_comet_spawn = 0;
	long long int kickall;
	int special_event_item = 0, special_event_item_taken = 0;
	bool special_event = false;
	uint16_t r = 255, g = 128;
	uint8_t b = 64;
};
vector<World> worlds;
map<string, vector<WorldMachines>> active_machines;



int get_free_slots(Player* p_) {
	int free = 0; // -1
	for (int i_ = 0; i_ < p_->inv.size(); i_++) {
		if (p_->inv[i_].first == 0 and p_->inv[i_].second == 0)
			free++;
	}
	return free;
}

int percent(int a, int b)
{
	float result = 0;
	result = ((b - a) * 100) / a;

	return abs(result);
}



void add_item_price(int item, int price) {
	//if (items[item].price.size() > 4 && percent(item_average2(items[item].price), price) >= 15) return;
	items[item].price.push_back(price);
	if (items[item].price.size() >= 90) items[item].price.erase(items[item].price.begin() + 0);
}


string item_average(vector<int> const& v, int offer_price = 0) {
	if (v.size() == 0) return " `2relatively close`` to the current average.";
	else {
		int average_price = 1.0 * accumulate(v.begin(), v.end(), 0LL) / v.size();
		if (percent(average_price, offer_price) == 0) return " `2relatively close`` to the current average.";
		if (average_price > offer_price) return " at roughly `2" + to_string(percent(average_price, offer_price)) + "% cheaper`` than the current average.";
		else if (average_price < offer_price) return " at roughly `8" + to_string(percent(average_price, offer_price)) + "% more`` than the current average.";
		else return " `2relatively close`` to the current average.";
	}
}

string xenonite_text(int xenonite) {
	return "Xenonite has changed everyone's powers!" + a + (xenonite & Gtps3::XENONITE_FORCE_DOUBLE_JUMP ? " `2Double Jump granted!``" : xenonite & Gtps3::XENONITE_BLOCK_DOUBLE_JUMP ? " `6Double Jump blocked!``" : "") + (xenonite & Gtps3::XENONITE_FORCE_HIGH_JUMP ? " `2High Jump granted!``" : xenonite & Gtps3::XENONITE_BLOCK_HIGH_JUMP ? " `6High Jump blocked!``" : "") + (xenonite & Gtps3::XENONITE_FORCE_STRONG_PUNCH ? " `2Strong Punch granted!`` " : xenonite & Gtps3::XENONITE_BLOCK_STRONG_PUNCH ? " `6Strong Punch blocked!``" : "") + (xenonite & Gtps3::XENONITE_FORCE_SPEEDY ? " `2Super Speed granted!``" : xenonite & Gtps3::XENONITE_BLOCK_SPEEDY ? " `6Super Speed blocked!``" : "") + (xenonite & Gtps3::XENONITE_FORCE_LONG_PUNCH ? " `2Long Punch granted!``" : xenonite & Gtps3::XENONITE_BLOCK_LONG_PUNCH ? " `6Long Punch blocked!``" : "") + (xenonite & Gtps3::XENONITE_FORCE_LONG_BUILD ? " `2Long Build granted!``" : xenonite & Gtps3::XENONITE_BLOCK_LONG_BUILD ? " `6Long Build blocked!``" : "");
}

vector<double> get_winterfest_calendar(int id) {
	if (id == 1 || id == 5 || id == 9 || id == 13 || id == 17 || id == 21)return winterfest_calendar[0];
	else if (id == 2 || id == 6 || id == 10 || id == 14 || id == 19 || id == 23)return winterfest_calendar[1];
	else if (id == 3 || id == 7 || id == 11 || id == 20 || id == 24)return winterfest_calendar[2];
	else if (id == 4 || id == 8 || id == 12 || id == 16 || id == 21)return winterfest_calendar[3];
	else if (id == 15)return winterfest_calendar[4];
	else if (id == 25)return winterfest_calendar[5];
	else return winterfest_calendar[0];
}

void punch_tile(ENetPeer* peer, int x, int y, int t_, int n_, int net_, int state_, bool tree_ = false, int count_ = 1, bool every_ = true) {
	PlayerMoving data{ net_, 0, t_, state_, n_, x, y, 0, (float)x, (float)y, 0, 0 };
	BYTE* p_ = packPlayerMoving(&data);
	p_[2] = 0, p_[3] = tree_ ? count_ : 0;
	//int32_t item = pInfo(peer)->hand;
	*(__int16*)(p_ + 8) = pInfo(peer)->hand;
	//memcpy(p_ + 8, &item, 4);
	if (every_) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			send_raw(currentPeer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	else {
		send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
	}
	delete[]p_;
}

inline void console_msg(ENetPeer* peer, string t_) {
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert(t_);
	p.CreatePacket(peer);
}

inline void talk_bubble(ENetPeer* peer, int netID, string txt, int chat_Color, bool overlay) {
	gamepacket_t p;
	p.Insert("OnTalkBubble");
	p.Insert(netID);
	p.Insert(txt);
	p.Insert(chat_Color);
	p.Insert(overlay ? 1 : 0);
	p.CreatePacket(peer);
}

void update_tile(ENetPeer* peer, int16_t x, int16_t y, int16_t n_, bool add = false, bool everyone = false, string world = "") {
	if (peer != NULL) world = pInfo(peer)->world;
	else world = "BEACHPARTYGAME";
	BYTE* p_ = packBlockType(3, n_, x, y);
	if (everyone or peer == NULL) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world) continue;
			send_raw(currentPeer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	else send_raw(peer, 4, p_, 56, ENET_PACKET_FLAG_RELIABLE);
	delete[]p_;
}


/*
void update_growganoth(ENetPeer* peer) {
	vector<BYTE*>blocks;
	for (int i_ = 0; i_ < growganoth_platform.size(); i_++) blocks.push_back(packBlockType(3, 0, growganoth_platform[i_].first % 100, growganoth_platform[i_].first / 100));
	growganoth_platform.clear();
	for (int i_ = 0; i_ < 50; i_++) {
		int x = rand() % 60 + 20, y = rand() % 32 + 20, item = (i_ < 40 ? 1222 : 9832);
		growganoth_platform.push_back(make_pair(x + (y * 100), item));
		blocks.push_back(packBlockType(3, item, x, y));
	}
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != "GROWGANOTH") continue;
		for (auto& b : blocks) {
			send_raw(currentPeer, 4, b, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	for (auto& b : blocks) free(b);
	blocks.clear();
}

void update_growganoth_self(ENetPeer* peer) {
	vector<BYTE*>blocks;
	for (int i_ = 0; i_ < growganoth_platform.size(); i_++) blocks.push_back(packBlockType(3, growganoth_platform[i_].second, growganoth_platform[i_].first % 100, growganoth_platform[i_].first / 100));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != "GROWGANOTH") continue;
		for (auto& b : blocks) send_raw(currentPeer, 4, b, 56, ENET_PACKET_FLAG_RELIABLE);
	}
	for (auto& b : blocks) free(b);
	blocks.clear();
}*/

World create_world(const string& name_, int s_) {
	World world_;
	world_.name = name_;
	world_.fresh_world = true;
	int d_ = rand() % (s_ / (s_ / 100) - 4) + 2;
	for (int i_ = 0; i_ < s_; i_++) {
		WorldBlock block_{ 0, 0, 0 }; // buvo WorldBlock block_{0, 0, -1}; 
		if (i_ >= 3800 && i_ < 5400 && !(rand() % 50))
			block_.fg = 10;
		else if (i_ >= 3700 && i_ < 5400) {
			if (i_ > 5000) {
				if (rand() % 8 < 3)
					block_.fg = 4;
				else
					block_.fg = 2;
			}
			else
				block_.fg = 2;
		}
		else if (i_ >= 5400)
			block_.fg = 8;
		if (i_ == 3600 + d_)
			block_.fg = 6;
		if (i_ == 3700 + d_)
			block_.fg = 8;
		if (i_ >= 3700)
			block_.bg = 14;
		world_.blocks.push_back(block_);
	}
	world_.max_y = world_.blocks.size() / 100;
	world_.max_x = world_.blocks.size() / world_.max_y;
	worlds.push_back(world_);
	world_ = {};
	return worlds[worlds.size() - 1];
}

World get_world(const string& name_, int huge_size = 0) {
	//int start = clock();
	/*galima buvo daryti pagal worldid o ne name bet jeigu worldus trinti is memory tai nk gero nebus*/
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		return worlds[p - worlds.begin()]; // return worldo struktura   
	}
	// Worldo Nera bet jis gali buti issaugotas  
	string path_ = "worlds/" + name_ + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		World world_;
		bool add_tworld = false;
		try {
			// Pakrauti worlda is json      

			/*
			jeigu nera naudoti sita
						if (world_read.find("rainbows") != world_read.end()) world_.rainbows = world_read["rainbows"].get<bool>();
						*/
			json world_read;
			ifstream world_file(path_, ifstream::binary);
			world_file >> world_read;
			world_file.close();
			world_.name = name_;
			world_.entry_level = world_read["entry_level"].get<int>();
			world_.nuked_by = world_read["n_b"].get<string>();
			world_.music_bpm = world_read["music_bpm"].get<int>();
			world_.weather = world_read["weather"].get<uint8_t>();
			world_.owner_name = world_read["owner"].get<string>();
			world_.guild_id = (!(world_read.find("guild_world_id") != world_read.end()) ? world_.guild_id : world_read["guild_world_id"].get<int>());
			world_.world_settings = (!(world_read.find("w_s") != world_read.end()) ? world_.world_settings : world_read["w_s"].get<int>());
			world_.World_Time = (!(world_read.find("wt") != world_read.end()) ? world_.World_Time : world_read["wt"].get<int>());
			world_.r = (!(world_read.find("r") != world_read.end()) ? world_.r : world_read["r"].get<uint16_t>());
			world_.g = (!(world_read.find("g") != world_read.end()) ? world_.g : world_read["g"].get<uint16_t>());
			world_.b = (!(world_read.find("b") != world_read.end()) ? world_.b : world_read["b"].get<uint8_t>());
			world_.category = (!(world_read.find("ct") != world_read.end()) ? world_.category : world_read["ct"].get<string>());
			world_.whitelist = (!(world_read.find("whitelist") != world_read.end()) ? world_.whitelist : world_read["whitelist"].get<vector<string>>());
			//	world_.guild_id = (!(world_read.find("guild_world_id") != world_read.end()) ? world_.guild_id : world_read["guild_world_id"].get<int>());
			world_.d_weather = world_read["d_weather"].get<uint8_t>();
			world_.owner_named = world_read["o2"].get<string>();
			world_.xenonite = world_read["xeno"].get<int>();
			json  p_ = world_read["blocks"].get<json>();
			world_.admins = world_read["admins"].get<vector<string>>();
			for (int i_ = 0; i_ < p_.size(); i_++) {
				WorldBlock b_{};
				if (p_[i_].find("f") != p_[i_].end()) {
					b_.fg = p_[i_]["f"].get<uint16_t>();
					if (b_.fg == 5814 && world_.guild_id == 0) b_.fg = 242;
					if (items[b_.fg].blocked_place) b_.fg = 0;
					if (world_.name != "TRADE") {
						if (b_.fg == 9828 && b_.planted - time(nullptr) <= 0) {
							b_.planted = 0;
							b_.fg = 0;
						}
					}
					if (p_[i_].find("p") != p_[i_].end()) b_.planted = p_[i_]["p"].get<long long>();
					if (p_[i_].find("fc") != p_[i_].end()) b_.fruit = p_[i_]["fc"].get<uint8_t>();
					if (p_[i_].find("t") != p_[i_].end()) b_.txt = p_[i_]["t"].get<string>();
					if (p_[i_].find("wl") != p_[i_].end()) {
						b_.wl = p_[i_]["wl"].get<int>();
						if (b_.wl < 0) b_.wl = 0;
					}
					if (p_[i_].find("dd") != p_[i_].end()) b_.door_destination = p_[i_]["dd"].get<string>();
					if (p_[i_].find("di") != p_[i_].end()) b_.door_id = p_[i_]["di"].get<string>();
					if (p_[i_].find("mq") != p_[i_].end()) b_.mannequin = p_[i_]["mq"].get<Mannequin>();
					if (p_[i_].find("cr") != p_[i_].end()) b_.crystals = p_[i_]["cr"].get<vector<vector<int>>>();
					if (p_[i_].find("dnt") != p_[i_].end()) b_.donates = p_[i_]["dnt"].get<vector<Donate>>();
					if (p_[i_].find("r1") != p_[i_].end()) b_.r = p_[i_]["r1"].get<int>();
					if (p_[i_].find("g1") != p_[i_].end()) b_.g = p_[i_]["g1"].get<int>();
					if (p_[i_].find("b1") != p_[i_].end()) b_.b = p_[i_]["b1"].get<int>();
					if (p_[i_].find("prs") != p_[i_].end()) b_.portrait = p_[i_]["prs"].get<Portrait>();
					if (p_[i_].find("bep") != p_[i_].end()) b_.shelf_1 = p_[i_]["bep"].get<uint32_t>();
					if (p_[i_].find("hm") != p_[i_].end()) b_.heart_monitor = p_[i_]["hm"].get<string>();
					if (p_[i_].find("sh2") != p_[i_].end()) b_.shelf_2 = p_[i_]["sh2"].get<uint32_t>();
					if (p_[i_].find("sh3") != p_[i_].end()) b_.shelf_3 = p_[i_]["sh3"].get<uint32_t>();
					if (p_[i_].find("sh4") != p_[i_].end()) b_.shelf_4 = p_[i_]["sh4"].get<uint32_t>();
					if (p_[i_].find("ps") != p_[i_].end()) b_.projectile_speed = p_[i_]["ps"].get<int>();
					if (p_[i_].find("rf") != p_[i_].end()) b_.rate_of_fire = p_[i_]["rf"].get<int>();
				}
				if (p_[i_].find("b") != p_[i_].end()) b_.bg = p_[i_]["b"].get<uint16_t>();
				if (p_[i_].find("n") != p_[i_].end()) b_.roll = p_[i_]["n"].get<uint8_t>();
				if (p_[i_].find("id") != p_[i_].end()) b_.id = p_[i_]["id"].get<int>();
				if (p_[i_].find("c") != p_[i_].end()) b_.c_ = p_[i_]["c"].get<int>();
				if (p_[i_].find("pr") != p_[i_].end()) b_.pr = p_[i_]["pr"].get<int>();
				if (p_[i_].find("o") != p_[i_].end()) b_.open = p_[i_]["o"].get<uint8_t>();
				if (p_[i_].find("fl") != p_[i_].end()) {
					b_.flags = p_[i_]["fl"].get<int>();
					if (b_.flags & 0x00100000) world_.total_fires++;
					if (b_.flags & 0x00400000 && (b_.fg == 4992 || b_.fg == 226 or b_.fg == 3616 or b_.fg == 1276 or b_.fg == 1278 or b_.fg == 4758 or b_.fg == 3750 or b_.fg == 4992 or b_.fg == 3072 or b_.fg == 4884)) world_.active_jammers.push_back(b_.fg);
					if (b_.flags & 0x00400000) if (items[b_.fg].blockType == BlockTypes::TRICKSTER) add_tworld = true;
				}
				if (p_[i_].find("en") != p_[i_].end()) b_.enabled = p_[i_]["en"].get<bool>();
				if (p_[i_].find("in") != p_[i_].end()) b_.invert = p_[i_]["in"].get<bool>();
				if (p_[i_].find("sn") != p_[i_].end()) b_.spin = p_[i_]["sn"].get<bool>();
				if (p_[i_].find("g") != p_[i_].end()) b_.gravity = p_[i_]["g"].get<int>();
				if (p_[i_].find("l") != p_[i_].end()) b_.locked = p_[i_]["l"].get<bool>();
				if (p_[i_].find("lq") != p_[i_].end()) b_.lock_origin = p_[i_]["lq"].get<int>();
				if (p_[i_].find("lo") != p_[i_].end()) b_.owner_name = p_[i_]["lo"].get<string>();
				if (p_[i_].find("a") != p_[i_].end()) b_.admins = p_[i_]["a"].get<vector<string>>();
				if (p_[i_].find("bo") != p_[i_].end()) b_.build_only = p_[i_]["bo"].get<bool>();
				if (p_[i_].find("la") != p_[i_].end()) b_.limit_admins = p_[i_]["la"].get<bool>();
				if (p_[i_].find("gamegen") != p_[i_].end()) b_.GameGen = p_[i_]["gamegen"].get<GameGenerator>();
				world_.blocks.push_back(b_);
			}
			world_.max_y = world_.blocks.size() / 100;
			world_.max_x = world_.blocks.size() / world_.max_y;
			world_.drop_new = world_read["drop_new"].get<vector<vector<int>>>();
			if (world_.drop_new.size() == 0)world_.total_drop_uid = 0;
			else  world_.total_drop_uid = world_.drop_new[world_.drop_new.size() - 1][2];
			world_.sbox1 = world_read["sbox1"].get<vector<WorldSBOX1>>(),
				world_.cctv_settings = world_read["cc_s"].get<vector<vector<int>>>();
			world_.cctv = world_read["cctv"].get<vector<WorldCCTV>>();
			world_.bulletin = world_read["bulletin"].get<vector<WorldBulletin>>();
			world_.npc = (!(world_read.find("npc") != world_read.end()) ? world_.npc : world_read["npc"].get<vector<WorldNPC>>());
			world_.machines = world_read["machine"].get<vector<WorldMachines>>();
		}
		catch (exception err) {
			cout << "world load error name: " << name_ << endl;
			//remove(path_.c_str());
			world_ = create_world(name_, 6000);
		}
		worlds.push_back(world_);
		if (world_.npc.size() != 0 or world_.machines.size() != 0 or add_tworld) {
			if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_.name) == World_Stuff.t_worlds.end()) 	World_Stuff.t_worlds.push_back(world_.name);
		}
		return world_;
	}
	return create_world(name_, 6000);
}

void top_wls_leaderboard() {
	if (wls_event_time - time(nullptr) <= 0) {
		sort(top_wls.begin(), top_wls.end());
		reverse(top_wls.begin(), top_wls.end());
		top_wls.resize((top_wls.size() >= 100 ? 100 : top_wls.size()));
	}
	top_wls_list.clear();
	vector<pair<long long int, string>> top_tiers = top_wls;
	sort(top_tiers.begin(), top_tiers.end());
	reverse(top_tiers.begin(), top_tiers.end());
	top_tiers.resize((top_tiers.size() >= 100 ? 100 : top_tiers.size()));
	for (uint8_t i = 0; i < top_tiers.size(); i++) {
		top_wls_list += "\nadd_smalltext|" + to_string(i + 1) + " : " + top_tiers[i].second + ", Score: " + setGems_(top_tiers[i].first) + "|";
	}
	if (top_wls_list.empty()) top_wls_list = "\nadd_smalltext|The list should update in few minutes..|";
}
void OnSetPos(ENetPeer* peer, int x, int y, int instant = 0, bool cooldown = false) {
	if (cooldown == false) pInfo(peer)->anticheat_cooldown = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
	gamepacket_t p(instant, pInfo(peer)->netID);
	p.Insert("OnSetPos");
	p.Insert(float(x), float(y));
	p.CreatePacket(peer);
	pInfo(peer)->temp_x = x;
	pInfo(peer)->temp_y = y;
}

World create_world_blast(ENetPeer* peer, const string& name_, int blast) {
	vector<uint16_t> id;
	World world_;
	if (blast == 9164 || blast == 1402 || blast == 1060 || blast == 8738) {
		if (blast == 1060) world_.d_weather = 6;
		if (blast == 8738) world_.d_weather = 46;
		int sign = 4;
		vector<string> sign_text = {"Enjoy your rewards, then combine `2Root Cuttings`` in a `2Chemical Combiner`` to get better bountiful seeds and other items!", "First, you'll need to find some bountiful seeds. Plant these in `2Fertile Soil Blocks``.", "Bountiful trees will grow `2Roots``. When you harvest the tree, its root will remain.", "Plant the `2SAME type of bountiful seed`` on old roots to continue growing the roots!"};
		int d_ = rand() % (6000 / (6000 / 100) - 4) + 2;
		for (int i_ = 0; i_ < 6000; i_++) {
			WorldBlock block_{ 0, 0, 0 }; // buvo WorldBlock block_{0, 0, -1};
			if (blast == 9164) {
				if (i_ >= 1800 && i_ < 5400 && !(rand() % 50)) block_.fg = 8532;
				else if (i_ > 1600 && i_ < 1700 && !(rand() % 2)) block_.fg = 8532;
				else if (i_ >= 1700 && i_ < 5400) {
					if (i_ > 5000) {
						if (rand() % 8 < 3) block_.fg = 9162;
						else block_.fg = 8532;
					}
					else block_.fg = 8532;
				}
				else if (i_ >= 5400) block_.fg = 8;
				if (i_ == 1600 + d_) block_.fg = 6;
				if (i_ == 1700 + d_) block_.fg = 8;
				if (i_ >= 1700) block_.bg = 14;
			}
			else if (blast == 1402) {
				if (i_ >= 5400) block_.fg = 8;
				if (i_ == 5200) block_.fg = 6;
				if (i_ == 5300)block_.fg = 8;
			}
			else if (blast == 1060) {
				if (i_ >= 3800 && i_ < 5400 && !(rand() % 50)) block_.fg = 10;
				else if (i_ >= 3600 && i_ < 3700) {
					id = small_seeds;
					block_.fg = id[rand() % id.size()], block_.fruit = items[block_.fg].rarity == 999 ? 1 : (rand() % 4) + 1, block_.planted = time(nullptr) - (items[block_.fg].growTime);
				}
				else if (i_ >= 3700 && i_ < 5400) {
					if (i_ > 5000) {
						if (rand() % 8 < 3) block_.fg = 4;
						else block_.fg = 2;
					}
					else block_.fg = 2;
				}
				else if (i_ >= 5400) block_.fg = 8;
				if (i_ == 3600 + d_) block_.fg = 6;
				if (i_ == 3700 + d_) block_.fg = 8;
				if (i_ >= 3700) block_.bg = 14;
			}
			else if (blast == 8738) {
				if (i_ >= 3800 && i_ < 5400 && !(rand() % 30)) {
					if (rand() % 10 < 7) block_.fg = 8772;
					else block_.fg = 10;
				}
				else if (i_ >= 3500 && i_ < 3600) {
						if (rand() % 4 < 1) block_.fg = 2;
				}
				else if (i_ >= 3600 && i_ < 3700) {
					int timas = rand() % 5;
					if (timas < 3) {
						id = bountiful_seeds;
						block_.fg = id[rand() % id.size()], block_.fruit = items[block_.fg].rarity == 999 ? 1 : (rand() % 4) + 1, block_.planted = time(nullptr) - (items[block_.fg].growTime);
					}
					else if (i_ > 3630 && timas < 4 && timas > 3 && sign != 0) {
						sign -= 1;
						block_.fg = 20;
						block_.txt = sign_text[rand() % sign_text.size()];
					}
					else {
						if (rand() % 2 < 1) block_.fg = 2;
					}
				}
				else if (i_ >= 3700 && i_ < 5400) {
					if (i_ >= 3700 && rand() % 2 < 1 && i_ <= 3800 && world_.blocks[3600 + (i_ - 3700)].fg == 0) {
						if (rand() % 2 < 1) {
							id = bountiful_seeds;
							block_.fg = id[rand() % id.size()], block_.fruit = items[block_.fg].rarity == 999 ? 1 : (rand() % 4) + 1, block_.planted = time(nullptr) - (items[block_.fg].growTime);
						}
						else block_.fg = 0;
					}
					else {
						if (i_ > 5000) {
							if (rand() % 8 < 3) block_.fg = 4;
							else block_.fg = 2;
						}
						else block_.fg = 2;
					}
				}
				else if (i_ >= 5400) block_.fg = 8;
				if (i_ == 3600 + d_) block_.fg = 6;
				if (i_ == 3600 + d_ + 1 && i_ == 3600 + d_ + 1 < 3700) {
					block_.fg = 20;
					block_.txt = "Welcome to Roots! These signs will help you your underground empire!";
				}
				if (i_ == 3700 + d_) block_.fg = 8;
				if (i_ >= 3700) block_.bg = 14;
			}
			world_.blocks.push_back(block_);
		}
	}
	else if (blast == 1532) {
		world_ = get_world("GENERATED_UNDERSEA_BLAST99971");
		world_.d_weather = 14;
	}
	else if (blast == 830) {
		world_ = get_world("GENERATED_SUMMER_BLAST464");
		world_.d_weather = 1;
			id = { 836, 836, 836, 836, 836,834 ,834 ,834 ,834 ,834 ,13626  };
			int give_ = 1, id_ = id[rand() % id.size()];
			if (id_ == 834) give_ = 25;
			world_.drop_new.push_back({ {id_}, {give_}, {world_.total_drop_uid += 1}, {3077}, {1482} });
	}
	else if (blast == 10380) {
		vector<pair<int, int>> random_door = { {3817,3917}, {945, 1045}, {7348, 7448}, {2686, 2786} };
		int random_pick = rand() % random_door.size();
		world_ = get_world("GENERATE_HUGE_WORLD");
		world_.blocks[random_door[random_pick].first].fg = 6;
		world_.blocks[random_door[random_pick].first].bg = 0;
		world_.blocks[random_door[random_pick].second].fg = 10378;
		world_.blocks[random_door[random_pick].second].bg = 0;
		world_.d_weather = 66;
	}
	else if (blast == 9602) {
		world_ = get_world("GENERATED_FARM_BLAST");
		if (pInfo(peer)->name_color == "`p@" || pInfo(peer)->name_color == "`e@" || pInfo(peer)->name_color == "`8@" || pInfo(peer)->name_color == "`6@" || pInfo(peer)->name_color == "`#@") world_.blocks[5202].heart_monitor = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
		else world_.blocks[5202].heart_monitor = "`0" + pInfo(peer)->tankIDName + "``";
		world_.blocks[5204].txt = "Welcome to " + world_.blocks[5202].heart_monitor + " farm!";
	}
	else if (blast == 830) {
		world_ = get_world("GENERATED_SUMMER_BLAST464");
		world_.d_weather = 1;
	}
	else if (blast == 1136) {
		world_ = get_world("GENERATED_MARS_BLAST_15");
		world_.d_weather = 7;
	}
	else if (blast == 3562) {
		world_ = get_world("GENERATED_CAVE_BLAST_1554");
		world_.blocks[5000 - rand() % 700].fg = 3604;
		world_.blocks[5300 - rand() % 700].fg = 3604;
	}
	else if (blast == 9582) {
		int random_door = rand() % 95 + 1;
		world_ = get_world("GENERATED_MINECRAFT_WORLD_1647");

		world_.d_weather = 255;
		world_.blocks[5400 - rand() % 600].fg = 9568;
		world_.blocks[5400 - rand() % 600].fg = 9566;
		world_.blocks[5400 - rand() % 600].fg = 9566;
		world_.blocks[5400 - rand() % 600].fg = 9568;
		world_.blocks[5400 - rand() % 600].fg = 9566;
		if (rand() % 50 < 1) world_.blocks[5400 - rand() % 600].fg = 9566;



		for (int i_ = 3700; i_ < 5400; i_++) {
			if (i_ >= 3700 && i_ < 5400) {
				if (i_ > 5000) {
					if (rand() % 8 < 3) world_.blocks[i_].fg = 9892;
				}
			}
		}
		world_.blocks[3600 + random_door].fg = 6;
		world_.blocks[3700 + random_door].fg = 9570;
	}
	else if (blast == 7588) {
		world_ = get_world("GENERATED_TREASURE_BLAST_156");
		world_.d_weather = 44;
	}
	else if (blast == 942) {
		world_ = get_world("GENERATED_DESRT_BLAST");
		world_.d_weather = 3;
		if (rand() % 100 < 10) {
			id = { 12292 , 12294 };
			world_.drop_new.push_back({ {id[rand() % id.size()]}, {1}, {world_.total_drop_uid += 1}, {1536}, {544} });
		}
	}
	else if (blast == 4774) {
		id = { 4778, 4714,4778, 4714, 10066, 11188 };
		world_ = get_world("GENERATE_JUNGLE_BLAST_156");
		world_.d_weather = 32;
		world_.drop_new.push_back({ {id[rand() % id.size()]}, {1}, {world_.total_drop_uid += 1}, {835}, {1485} });
	}
	else if (blast == 7380) {
		world_ = get_world("GENERATE_MONOCHROME_BL_15");
		world_.d_weather = 43;
	}
	else if (blast == 8556) {
		world_ = get_world("GEENRATE_SURG_188");
		world_.d_weather = 45;
	}
	else {
		world_ = get_world("GENERATED_DESRT_BLAST");
		world_.d_weather = 3;
	}
	world_.name = name_;
	world_.fresh_world = true;
	world_.max_y = world_.blocks.size() / 100;
	world_.max_x = world_.blocks.size() / world_.max_y;
	worlds.push_back(world_);
	world_ = {};
	return worlds[worlds.size() - 1];
}

void save_world(const string& name_, bool erase = true) {
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		__int64 id_ = p - worlds.begin();
		World* world_ = &worlds[id_];
		if (world_->fresh_world == false && erase and name_ != "CARNIVAL") {
			World_Stuff.t_worlds.erase(remove(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), name_), World_Stuff.t_worlds.end());
			worlds.erase(worlds.begin() + id_);
			return;
		}
		/*
		if (world_->fresh_world == false && erase) {
			vector<WorldMachines>::iterator p = find_if(world_->machines.begin(), world_->machines.end(), [&](const WorldMachines& a) { return (world_->blocks[a.x + (a.y * 100)].enabled && a.target_item != 0 && world_->blocks[a.x + (a.y * 100)].pr != 0) && world_->blocks[a.x + (a.y * 100)].fg == 6950 || world_->blocks[a.x + (a.y * 100)].fg == 6952 || world_->blocks[a.x + (a.y * 100)].fg == 6954; });
			if (p != world_->machines.end() or world_->special_event) {
			}
			else {
				t_worlds.erase(remove(t_worlds.begin(), t_worlds.end(), world_->name), t_worlds.end());
				worlds.erase(worlds.begin() + id_);
			}
			return;
		}*/
		json save_, blocks_ = json::array();
		if (find(World_Stuff.wotd_worlds.begin(), World_Stuff.wotd_worlds.end(), name_) != World_Stuff.wotd_worlds.end()) {
			world_->world_settings &= ~Gtps3::SETTINGS_1;
			world_->world_settings |= Gtps3::SETTINGS_1;
		}
		else {
			world_->world_settings &= ~Gtps3::SETTINGS_1;
		}
		save_["entry_level"] = world_->entry_level;
		save_["n_b"] = world_->nuked_by;
		save_["music_bpm"] = world_->music_bpm;
		save_["weather"] = world_->weather;
		save_["owner"] = world_->owner_name;
		save_["guild_world_id"] = world_->guild_id;
		save_["d_weather"] = world_->d_weather;
		save_["o2"] = world_->owner_named;
		save_["xeno"] = world_->xenonite;
		save_["w_s"] = world_->world_settings;
		save_["wt"] = world_->World_Time;
		save_["r"] = world_->r;
		save_["g"] = world_->g;
		save_["b"] = world_->b;
		save_["admins"] = world_->admins;
		save_["ct"] = world_->category;
		save_["whitelist"] = world_->whitelist;
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			json block_ = {};
			if (items[world_->blocks[i_].fg].fossil_rock && rand() % 500 < 1) block_["f"] = items[world_->blocks[i_].fg].fossil_rock;
			else if (world_->blocks[i_].fg != 0) block_["f"] = world_->blocks[i_].fg;
			if (world_->blocks[i_].fg != 0) block_["f"] = world_->blocks[i_].fg;
			if (world_->blocks[i_].bg != 0) block_["b"] = world_->blocks[i_].bg;
			if (world_->blocks[i_].planted != 0) block_["p"] = world_->blocks[i_].planted;
			if (world_->blocks[i_].fruit > 0 and world_->blocks[i_].fruit < 8) block_["fc"] = world_->blocks[i_].fruit;
			if (not world_->blocks[i_].txt.empty()) block_["t"] = world_->blocks[i_].txt;
			if (world_->blocks[i_].roll != 0) block_["n"] = world_->blocks[i_].roll;
			if (world_->blocks[i_].id != 0) block_["id"] = world_->blocks[i_].id;
			if (world_->blocks[i_].c_ != 0) block_["c"] = world_->blocks[i_].c_;
			if (world_->blocks[i_].wl != 0) block_["wl"] = world_->blocks[i_].wl;
			if (world_->blocks[i_].pr != 0) block_["pr"] = world_->blocks[i_].pr;
			if (world_->blocks[i_].open != 1) block_["o"] = (world_->blocks[i_].open ? 1 : 0);
			if (not world_->blocks[i_].door_destination.empty()) block_["dd"] = world_->blocks[i_].door_destination;
			if (not world_->blocks[i_].door_id.empty()) block_["di"] = world_->blocks[i_].door_id;
			if (world_->blocks[i_].flags != 0x00000000) block_["fl"] = world_->blocks[i_].flags;
			if (world_->blocks[i_].rate_of_fire != 10) block_["rf"] = world_->blocks[i_].rate_of_fire;
			if (world_->blocks[i_].projectile_speed != 100) block_["ps"] = world_->blocks[i_].projectile_speed;
			if (world_->blocks[i_].enabled != false) block_["en"] = world_->blocks[i_].enabled;
			if (world_->blocks[i_].invert != false) block_["in"] = world_->blocks[i_].invert;
			if (world_->blocks[i_].spin != false) block_["sn"] = world_->blocks[i_].spin;
			if (world_->blocks[i_].gravity != 50) block_["g"] = world_->blocks[i_].gravity;
			if (world_->blocks[i_].locked != false) block_["l"] = world_->blocks[i_].locked;
			if (world_->blocks[i_].lock_origin != -1) block_["lq"] = world_->blocks[i_].lock_origin;
			if (not world_->blocks[i_].owner_name.empty()) block_["lo"] = world_->blocks[i_].owner_name;
			if (world_->blocks[i_].admins.size() != 0) block_["a"] = world_->blocks[i_].admins;
			if (world_->blocks[i_].build_only != false) block_["bo"] = world_->blocks[i_].build_only;
			if (world_->blocks[i_].limit_admins != false) block_["la"] = world_->blocks[i_].limit_admins;
			if (world_->blocks[i_].crystals.size() != 0) block_["cr"] = world_->blocks[i_].crystals;
			if (world_->blocks[i_].mannequin.c_head != 0 or world_->blocks[i_].mannequin.c_shirt != 0 or world_->blocks[i_].mannequin.c_pants != 0 or world_->blocks[i_].mannequin.c_feet != 0 or world_->blocks[i_].mannequin.c_mask != 0 or world_->blocks[i_].mannequin.c_hand != 0 or world_->blocks[i_].mannequin.c_back != 0 or world_->blocks[i_].mannequin.c_hair != 0 or world_->blocks[i_].mannequin.c_neck != 0) {
				block_["mq"] = world_->blocks[i_].mannequin;
			}
			if (world_->blocks[i_].donates.size() != 0) block_["dnt"] = world_->blocks[i_].donates;
			if (world_->blocks[i_].r != 255) block_["r1"] = world_->blocks[i_].r;
			if (world_->blocks[i_].g != 128) block_["g1"] = world_->blocks[i_].g;
			if (world_->blocks[i_].b != 64) block_["b1"] = world_->blocks[i_].b;
			if (world_->blocks[i_].portrait.c_expression != 1 or world_->blocks[i_].portrait.c_hair_colour != 0 or world_->blocks[i_].portrait.c_skin != 0 or world_->blocks[i_].portrait.c_face != 0 or world_->blocks[i_].portrait.c_head != 0 or world_->blocks[i_].portrait.c_hair != 0) {
				block_["prs"] = world_->blocks[i_].portrait;
			}
			if (world_->blocks[i_].shelf_1 != 0) block_["bep"] = world_->blocks[i_].shelf_1;
			if (not world_->blocks[i_].heart_monitor.empty()) block_["hm"] = world_->blocks[i_].heart_monitor;
			if (world_->blocks[i_].shelf_2 != 0)block_["sh2"] = world_->blocks[i_].shelf_2;
			if (world_->blocks[i_].shelf_3 != 0)block_["sh3"] = world_->blocks[i_].shelf_3;
			if (world_->blocks[i_].shelf_4 != 0)block_["sh4"] = world_->blocks[i_].shelf_4;
			if (world_->blocks[i_].GameGen.Game_Name != "") {
				block_["gamegen"] = world_->blocks[i_].GameGen;
			}
			blocks_.push_back(block_);
		}
		/*
		if (f_saving_ && world_->drop_new.size() > 80000) {
			for (int i_ = 0, add_up = 0; i_ < world_->drop_new.size(); i_++) {
				if (world_->drop_new[i_][0] == 0) {
					world_->drop_new.erase(world_->drop_new.begin() + i_);
					i_--;b
				}
				else {
					world_->drop_new[i_][2] = add_up;
					add_up++;
				}
			}
		}*/
		save_["drop_new"] = world_->drop_new;
		save_["cc_s"] = world_->cctv_settings;
		save_["sbox1"] = world_->sbox1;
		save_["cctv"] = world_->cctv;
		save_["bulletin"] = world_->bulletin;
		save_["npc"] = world_->npc;
		save_["machine"] = world_->machines;
		save_["blocks"] = blocks_;
		ofstream w_("worlds/" + name_ + "_.json");
		w_ << save_ << endl;
		w_.close();
		if (erase and name_ != "CARNIVAL") {
			World_Stuff.t_worlds.erase(remove(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name), World_Stuff.t_worlds.end());
			worlds.erase(worlds.begin() + id_);
			/*
			vector<WorldMachines>::iterator p = find_if(world_->machines.begin(), world_->machines.end(), [&](const WorldMachines& a) { return (world_->blocks[a.x + (a.y * 100)].enabled && a.target_item != 0 && world_->blocks[a.x + (a.y * 100)].pr != 0) && items[world_->blocks[a.x + (a.y * 100)].fg].magplant; });
			if (p != world_->machines.end() or world_->special_event) {
			}
			else {
				map<string, vector<WorldNPC>>::iterator it;
				for (it = active_npc.begin(); it != active_npc.end(); it++) {
					if (it->first == world_->name) {
						it->second.clear();
						break;
					}
				}
				t_worlds.erase(remove(t_worlds.begin(), t_worlds.end(), world_->name), t_worlds.end());
				worlds.erase(worlds.begin() + id_);
			}*/
		}
	}
}


/*
void wipe_carnival(ENetPeer* peer) {
	if (pInfo(peer)->world == "CARNIVAL" && pInfo(peer)->tankIDName != "") {
		vector<pair<int, string>>::iterator p23 = find_if(carnival_game_playing.begin(), carnival_game_playing.end(), [&](const pair < int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
		if (p23 != carnival_game_playing.end()) {
			carnival_game_playing.erase(p23);
		}

		vector<pair<int, string>>::iterator p24 = find_if(carnival_game_players.begin(), carnival_game_players.end(), [&](const pair < int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
		if (p24 != carnival_game_players.end()) {
			carnival_game_players.erase(p24);
		}
	}
}*/


void wipe_beach(ENetPeer* peer) {
	beach_players.erase(remove(beach_players.begin(), beach_players.end(), pInfo(peer)->tankIDName), beach_players.end());
}

bool complete_gpass_task(ENetPeer* peer, string task) {
	if (find(pInfo(peer)->growpass_quests.begin(), pInfo(peer)->growpass_quests.end(), task) == pInfo(peer)->growpass_quests.end()) {
		pInfo(peer)->growpass_quests.push_back(task);
		int get_points = 10;
		if (task == "Growtoken") get_points = 40;
		else if (task == "Claim 4,000 gems") get_points = 150, pInfo(peer)->gems += 4000;
		else get_points = 10;
		if (pInfo(peer)->growpass_points < 2100) {
			string text = "`9Completed Grow Pass Task '" + task + "' and received " + to_string(get_points) + " points!``";
			if (not pInfo(peer)->world.empty()) {
				talk_bubble(peer, pInfo(peer)->netID, text, 0, 0);
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 198, data_.YSpeed = 198, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
				BYTE* raw = packPlayerMoving(&data_);
				send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				delete[] raw;
			}
			console_msg(peer, text);
			pInfo(peer)->growpass_points += get_points;
			return true;
		}
		else return false;
	}
	else return false;
}

void has_subscribtion(Player* p_, int& id) {
	vector<PlayMods>::iterator p = find_if(p_->playmods.begin(), p_->playmods.end(), [&](const PlayMods& a) { return a.id == 129 || a.id == 130 || a.id == 131 || a.id == 132 || a.id == 133; });
	if (p != p_->playmods.end()) {
		p_->subscriber = true;
		id = p_->playmods[p - p_->playmods.begin()].id;
	}
	else id = 0;
}
inline void OnSetGems(ENetPeer* peer, int amount = 0) {
	if (pInfo(peer)->gp) {
		if (amount >= 30) {
			if (complete_gpass_task(peer, "Gems")) amount += 3;
		}
	}
	gamepacket_t p;
	p.Insert("OnSetBux");
	p.Insert(pInfo(peer)->gems += amount);
	p.Insert(0);
	p.Insert((pInfo(peer)->supp >= 1 || pInfo(peer)->subscriber ? 1 : 0));
	if (pInfo(peer)->supp >= 2 || pInfo(peer)->subscriber) p.Insert((float)33796, (float)1, (float)0);
	p.CreatePacket(peer);
}

inline void OnSetEvent(ENetPeer* peer, int amount = 0) {
	gamepacket_t p;
	p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->egg_carton += amount), p.Insert(0);
	p.CreatePacket(peer);
}

inline void OnSetVoucher(ENetPeer* peer, int amount = 0) {
	gamepacket_t p;
	p.Insert("OnSetVouchers");
	p.Insert(pInfo(peer)->voucher += amount);
	p.CreatePacket(peer);
}

int item_crypto(string crypto) {
	if (crypto == "Bitcoin") return 10002;
	else if (crypto == "Ethereum") return 10012;
	else if (crypto == "Litecoin") return 10014;
	else return 752;
}

bool crypto_exchange(ENetPeer* peer, string crypto_name, int count, bool purchase) {
	if (purchase) {
		vector<pair<string, int>>::iterator p = find_if(Crypto_Update.crypto.begin(), Crypto_Update.crypto.end(), [&](const pair < string, int>& element) { return element.first == crypto_name; });
		if (p != Crypto_Update.crypto.end()) {
			int crypto_price = Crypto_Update.crypto[p - Crypto_Update.crypto.begin()].second, crypto_price_total = crypto_price * count, crypto_sold = Crypto_Update.crypto_sale[p - Crypto_Update.crypto_sale.begin()].second, crypto_sold_total = crypto_price * count;
			if (pInfo(peer)->gems >= crypto_price_total) {
				Crypto_Update.crypto_bought += count;
				pInfo(peer)->crypto_history.push_back("`2+`` Buy " + to_upper(crypto_name) + " " + to_string(count) + " for " + setGems(crypto_price_total) + " [RATE - 1:" + to_string(crypto_price) + "]");
				Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small| "+pInfo(peer)->tankIDName + " `2+`` "+to_string(count) + "x " + to_upper(crypto_name) + " for " + setGems(crypto_price_total) + " ė [RATE - 1:" + to_string(crypto_price) + "]|left|" + to_string(item_crypto(crypto_name)) + "|");
				if (pInfo(peer)->crypto_history.size() >= 15) pInfo(peer)->crypto_history.erase(pInfo(peer)->crypto_history.begin() + 0);
				if (Crypto_Update.crypto_history.size() >= 15) Crypto_Update.crypto_history.erase(Crypto_Update.crypto_history.begin() + 0);
				OnSetGems(peer, (crypto_price_total) * -1);
				vector<pair<string, int>>::iterator p = find_if(pInfo(peer)->crypto.begin(), pInfo(peer)->crypto.end(), [&](const pair < string, int>& element) { return element.first == crypto_name; });
				if (p != pInfo(peer)->crypto.end())pInfo(peer)->crypto[p - pInfo(peer)->crypto.begin()].second += count;
				else pInfo(peer)->crypto.push_back(make_pair(crypto_name, count));
				return true;
			}
			else return false;
		}
		else return false;
	}
	else {
		vector<pair<string, int>>::iterator p = find_if(Crypto_Update.crypto_sale.begin(), Crypto_Update.crypto_sale.end(), [&](const pair < string, int>& element) { return element.first == crypto_name; });
		if (p != Crypto_Update.crypto_sale.end()) {
			int crypto_price = Crypto_Update.crypto_sale[p - Crypto_Update.crypto_sale.begin()].second, crypto_price_total = crypto_price * count;
			vector<pair<string, int>>::iterator p = find_if(pInfo(peer)->crypto.begin(), pInfo(peer)->crypto.end(), [&](const pair < string, int>& element) { return element.first == crypto_name; });
			if (p != pInfo(peer)->crypto.end()) {
				if (pInfo(peer)->crypto[p - pInfo(peer)->crypto.begin()].second >= count) {
					pInfo(peer)->crypto[p - pInfo(peer)->crypto.begin()].second -= count;
					OnSetGems(peer, (crypto_price_total));
					Crypto_Update.crypto_sold += count;
					Crypto_Update.crypto_history.push_back("\nadd_label_with_icon|small| " + pInfo(peer)->tankIDName + " `4-`` " + to_string(count) + "x " + to_upper(crypto_name) + " for " + setGems(crypto_price_total) + " (gems) [RATE - 1:" + to_string(crypto_price) + "]|left|" + to_string(item_crypto(crypto_name)) + "|");
					pInfo(peer)->crypto_history.push_back("`4-`` Sell " + to_upper(crypto_name) + " " + to_string(count) + " for " + setGems(crypto_price_total) + " [RATE - 1:" + to_string(crypto_price) + "]");
					if (pInfo(peer)->crypto_history.size() >= 15) pInfo(peer)->crypto_history.erase(pInfo(peer)->crypto_history.begin() + 0);
					if (Crypto_Update.crypto_history.size() >= 15) Crypto_Update.crypto_history.erase(Crypto_Update.crypto_history.begin() + 0);
					return true;
				}
				else return false;
			}
			else return false;
		}
		else return false;
	}
}

string get_player_nick(ENetPeer* peer, string nick = "") {
	string name = "";
	if (nick.empty()) {
		if (not pInfo(peer)->d_name.empty()) name += pInfo(peer)->d_name;
		else {
			if (pInfo(peer)->black_color)name += "`b";
			if (pInfo(peer)->drt && name.empty()) name += "`4";
			if (pInfo(peer)->is_legend && name.empty())name += "`9";

			if (pInfo(peer)->black_color || pInfo(peer)->drt || pInfo(peer)->is_legend) {
				if (pInfo(peer)->tmod == 0) name += fixchar2(pInfo(peer)->name_color);
			}
			else {
				if (pInfo(peer)->tmod == 0) name += pInfo(peer)->name_color;
				else name += "`0";
			}
			if (pInfo(peer)->drt) name += "Dr.";
			name += pInfo(peer)->tankIDName;
			if (pInfo(peer)->is_legend)name += " of Legend";
		}
	}
	else name += nick;
	string::difference_type count_of_symbol = std::count(name.begin(), name.end(), '`');
	for (int i = 0; i < count_of_symbol; i++) name += "``";
	return name;
}

string get_player_nick_main(ENetPeer* peer, string nick = "") {
	string name = "";
	if (nick.empty()) {
		if (not pInfo(peer)->d_name.empty()) name += pInfo(peer)->d_name;
		else {
			if (pInfo(peer)->black_color)name += "`b";
			if (pInfo(peer)->drt && name.empty()) name += "`4";
			if (pInfo(peer)->is_legend && name.empty())name += "`9";

			if (pInfo(peer)->black_color || pInfo(peer)->drt || pInfo(peer)->is_legend) {
				if (pInfo(peer)->tmod == 0) name += fixchar2(pInfo(peer)->name_color);
			}
			else {
				if (pInfo(peer)->tmod == 0) name += pInfo(peer)->name_color;
				else name += "`0";
			}
			if (pInfo(peer)->drt) name += "Dr.";
			name += pInfo(peer)->tankIDName;
			if (pInfo(peer)->is_legend)name += " of Legend";
		}
	}
	else name += nick;
	return name;
}
void add_event_xp(ENetPeer* peer, uint8_t amount, string eventname) {
	int required = 0;
	bool levelup = false;
	int nowlevel = 0;
	if (eventname == "provider") {
		pInfo(peer)->p_xp += amount;
		required = 75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2);
		if (pInfo(peer)->p_xp >= 75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2)) {
			pInfo(peer)->p_lvl++;
			nowlevel = pInfo(peer)->p_lvl;
			pInfo(peer)->p_xp -= required;
			levelup = true;
		}
		if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 10 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress++;
			if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
				pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
	else if (eventname == "geiger") {
		pInfo(peer)->g_xp += amount;
		required = 5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2);
		if (pInfo(peer)->g_xp >= 5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2)) {
			pInfo(peer)->g_lvl++;
			nowlevel = pInfo(peer)->g_lvl;
			pInfo(peer)->g_xp -= required;
			levelup = true;
		}
		if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 13 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress++;
			if (pInfo(peer)->C_QuestProgress == pInfo(peer)->C_ProgressNeeded) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
	else if (eventname == "farmer") {
		pInfo(peer)->t_xp += amount;
		required = 100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2);
		if (pInfo(peer)->t_xp >= 100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2)) {
			pInfo(peer)->t_lvl++;
			nowlevel = pInfo(peer)->t_lvl;
			pInfo(peer)->t_xp -= required;
			levelup = true;
		}
	}
	else if (eventname == "builder") {
		pInfo(peer)->bb_xp += amount;
		required = 100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2);
		if (pInfo(peer)->bb_xp >= 100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2)) {
			pInfo(peer)->bb_lvl++;
			nowlevel = pInfo(peer)->bb_lvl;
			pInfo(peer)->bb_xp -= required;
			levelup = true;
		}
	}
	else if (eventname == "fishing") {
		pInfo(peer)->ff_xp += amount;
		required = 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2);
		if (pInfo(peer)->ff_xp >= 5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2)) {
			pInfo(peer)->ff_lvl++;
			nowlevel = pInfo(peer)->ff_lvl;
			pInfo(peer)->ff_xp -= required;
			levelup = true;
		}
	}
	else if (eventname == "surgeon") {
		pInfo(peer)->s_xp += amount;
		required = 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2);
		if (pInfo(peer)->s_xp >= 10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2)) {
			pInfo(peer)->s_lvl++;
			nowlevel = pInfo(peer)->s_lvl;
			pInfo(peer)->s_xp -= required;
			levelup = true;
		}
		if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 9 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress++;
			if (pInfo(peer)->C_QuestProgress == pInfo(peer)->C_ProgressNeeded) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
		}
	}
	if (levelup) {
		if (pInfo(peer)->gp) pInfo(peer)->growpass_points += 20;
		OnSetGems(peer, 500);
		gamepacket_t p, p2, p3;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(get_player_nick(peer) + " " + eventname + " quest is now level " + to_string(nowlevel) + "!"), p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage"), p2.Insert(get_player_nick(peer)+ " " + eventname + " quest is now level " + to_string(nowlevel) + "!");
		p3.Insert("OnParticleEffect"), p3.Insert(46), p3.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y +16);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
			p2.CreatePacket(currentPeer);
			p3.CreatePacket(currentPeer);
		}
	}
}

void get_players(const string& name_, int& c_, int& t_, int& net_, int& r_c) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->tankIDName.empty()) continue;
		if (not name_.empty() && pInfo(currentPeer)->world == name_) {
			if (not pInfo(currentPeer)->invis)
				c_++;
			if (pInfo(currentPeer)->netID >= net_)
				net_ = pInfo(currentPeer)->netID + 1;
			r_c++;
		}
		if (server_port == 53181 and secret_standopowah) t_ += 3 + rand() % 4;
		else t_ += 1;
	}

	last_onl = t_;
	if (server_port != 17098) {
		ofstream m;
		m.open("C:/laragon/www/stats/" + server_name + "/online.txt"), m << to_string(last_onl), m.close();
	}
}


int get_players_world(const string& name_) {
	int return_players = 0;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == name_) {
			return_players++;
		}
	}
	return return_players;
}

void packet_(ENetPeer* p_, string t_, string l_ = "", string w_ = "google.com") {
	if (l_ != "")
		t_ = "action|log\nmsg|" + t_;
	int y_ = 3;
	BYTE z_ = 0;
	BYTE* const d_ = new BYTE[5 + t_.length()];
	memcpy(d_, &y_, 4);
	memcpy(d_ + 4, t_.c_str(), t_.length());
	memcpy(d_ + 4 + t_.length(), &z_, 1);
	ENetPacket* const p = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
	enet_peer_send(p_, 0, p);
	delete[]d_;
	if (l_ != "") {
		l_ = "action|set_url\nurl|" + w_ + "\nlabel|" + l_ + "\n";
		BYTE* const u_ = new BYTE[5 + l_.length()];
		memcpy(u_, &y_, 4);
		memcpy(u_ + 4, l_.c_str(), l_.length());
		memcpy(u_ + 4 + l_.length(), &z_, 1);
		ENetPacket* const p3 = enet_packet_create(u_, 5 + l_.length(), ENET_PACKET_FLAG_RELIABLE);
		enet_peer_send(p_, 0, p3);
		delete[]u_;
	}
}


bool check_name(string& name_) {
	if (name_ == "EXIT") {
		name_ = "Exit from what? Press back if you're done playing.";
		return false;
	}
	for (char c : name_) if ((c < 'A' || c>'Z') && (c < '0' || c>'9')) {
		name_ = "Sorry, spaces and special characters are not allowed in world or door names.  Try again.";
		return false;
	}
	for (int i = 0; i < swear_words.size(); i++) {
		if (name_.find(swear_words[i]) != string::npos) {
			name_ = "DISNEYLAND";
			break;
		}
	}
	if (name_.size() < 1 || name_.size() >= 24) {
		name_ = "`4To reduce confusion, that is not a valid world name.``  Try another?";
		return false;
	} if (name_ .empty()) {
		name_ = "START";
	}
	return true;
}
bool check_blast(string& name_) {
	if (name_ == "EXIT" || name_.empty() || name_.size() < 1 || name_.size() >= 24) {
		return false;
	}
	for (char c : name_) if ((c < 'A' || c>'Z') && (c < '0' || c>'9')) {
		return false;
	}
	for (int i = 0; i < swear_words.size(); i++) {
		if (name_.find(swear_words[i]) != string::npos) return false;
	}
	return true;
}

bool check_password(string& name_) {
	if (name_.empty() || name_.size() < 1 || name_.size() >= 24) {
		return false;
	}
	return true;
}
void form_emoji(ENetPeer* peer, bool notification = false, int timeout = 0) {
	if (notification) {
		gamepacket_t p(timeout);
		p.Insert("OnAddNotification");
		p.Insert("interface/large/friend_button.rttex");
		p.Insert("You've unlocked some new `$Growmojis``!");
		p.Insert("audio/hub_open.wav");
		p.Insert(0);
		p.CreatePacket(peer);
	}
	{
		gamepacket_t p;
		p.Insert("OnEmoticonDataChanged");
		p.Insert(0);
		p.Insert(pInfo(peer)->growmoji + "(yes)|Ă|" + (pInfo(peer)->supp == 2 ? "1" : "0") + "&(no)|ă|" + (pInfo(peer)->supp != 0 ? "1" : "0") + "&" + (pInfo(peer)->supp == 2 ? "(love)|Ą|1" : "(love)|Ą|0") + "&" + (pInfo(peer)->supp != 0 ? "(shy)|Ć|1&(wink)|ć|1" : "(shy)|Ć|0&(wink)|ć|0") + "&(tongue)|Ĉ|" + (pInfo(peer)->level >= 5 ? "1" : "0") + "&(agree)|ĉ|" + (pInfo(peer)->friends.size() >= 20 ? "1" : "0") + "&(music)|Č|" + (pInfo(peer)->supp != 0 ? "1" : "0") + "&(build)|č|" + (pInfo(peer)->friends.size() >= 50 ? "1" : "0") + "&(megaphone)|Ď|" + (pInfo(peer)->supp == 2 ? "1" : "0") + "&" + (pInfo(peer)->level >= 5 ? "(sigh)|ď|1&(mad)|Đ|1&(wow)|đ|1" : "(sigh)|ď|0&(mad)|Đ|0&(wow)|đ|0") + "&(dance)|Ē|" + (pInfo(peer)->friends.size() >= 40 ? "1" : "0") + "&(see-no-evil)|ē|" + (pInfo(peer)->friends.size() >= 30 ? "1" : "0") + "&(heart)|ĕ|" + (pInfo(peer)->supp == 2 ? "1" : "0") + "&(kiss)|Ę|" + (pInfo(peer)->friends.size() >= 10 ? "1" : "0") + "&(lol)|Ě|" + (pInfo(peer)->supp != 0 ? "1" : "1") + "&(smile)|Ā|" + (pInfo(peer)->level >= 5 ? "1" : "0") + "&(cool)|Ĝ|" + (pInfo(peer)->supp == 2 ? "1" : "0"));
		p.CreatePacket(peer);
	}
}



/*
void carnival_start(ENetPeer* peer, uint8_t game) {
	vector<pair<int, string>>::iterator p2 = find_if(carnival_game_players.begin(), carnival_game_players.end(), [&](const pair < int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
	if (p2 == carnival_game_players.end()) carnival_game_players.push_back(make_pair(game, pInfo(peer)->tankIDName));
}
*/






string get_quest_item(string text, int quest = 0) {
	if (text == "Quest For Honor" or quest == 1) return "Legendary Title";
	else if (text == "Quest For Fire" or quest == 2) return "Dragon of Legend";
	else if (text == "Quest Of Steel" or quest == 3) return "Legendbot-009";
	else if (text == "Quest Of The Heavens" or quest == 4) return "Legendary Wings";
	else if (text == "Quest For The Blade" or quest == 5) return "Legendary Katana";
	else if (text == "Quest For Candour" or quest == 6) return "Whip of Truth";
	else if (text == "Quest For The Sky" or quest == 7) return "Legendary Dragon Knight's Wings";
	else if (text == "Quest Of The Owl" or quest == 8) return "Legendary Owl";
	else if (text == "Quest Of The Mech" or quest == 9) return "Legendary Destroyer";
	else if (text == "Quest Of The Dark" or quest == 10) return "Quest Of The Dark";
	else return "";
}

void add_lwiz_points(ENetPeer* peer, int points) {
	pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] += points;
	if (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] >= pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) {
		pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] = pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1];
		if (pInfo(peer)->lwiz_notification == 0) pInfo(peer)->lwiz_notification = 1;
	}
	if (pInfo(peer)->lwiz_notification == 1) {
		pInfo(peer)->lwiz_notification = 2;
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!``");
		p.CreatePacket(peer);
		{
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Legendary Quest step complete! I'm off to see a Wizard!``");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
}


string get_quest_name(ENetPeer* peer, int quest, int step) {
	if (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1].size() == 3) {
		string item = items[pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][2]].ori_name;
		if (pInfo(peer)->lwiz_step == 20)  return "And finally, I dare you to ascend to the peak of LEGENDARYMOUNTAIN and collect a Legendary Orb. This is the final challenge in any truly legendary quest.";
		else return "I challenge you to bring me "+ setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step-1][1]) +" of those " + item + " thingies!";
	}
	else if (step == 2) {
		return "Prove your might by defeating " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " Growtopians in a single combat! You can battle them in Hide And Seek events.";
	}
	else if (step == 3) {
		return "You must defeat " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " blocks in battle! Smash them!";
	}
	else if (step == 5) {
		return "You must plant " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " rarity worth of trees! Bring life to this land!";
	}
	else if (step == 6) {
		return "Prove your skill! Earn " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " Growtokens in whatever way you want! You can keep the Growtokens, I'm not a greedy wizard.";
	}
	else if (step == 8) {
		return "Here's a freeform quest for you - I don't care what you do, just earn " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " XP doing it!";
	}
	else if (step == 10) {
		return "Look, it's not cheap being a Legendary Wizard. These aren't just purple robes, they're `9Legendary Purple Robes``! So if you could just spot me like " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " Gems, I swear I'll think about paying you back. I'll think hard. Whaddya say?";
	}
	else if (step == 11) {
		return "You must crush " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " rarity worth of blocks! Destroy!";
	}
	else if (step == 12) {
		return "Save Growtopia by completeting " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " successful surgeries!";
	}
	else if (step == 13) {
		return ""+(pInfo(peer)->lwiz_quest == 5 || pInfo(peer)->lwiz_quest == 6 || pInfo(peer)->lwiz_quest == 7 || pInfo(peer)->lwiz_quest == 8? "I seem to have lost some mystical energy. Could you go find " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " radioactive items with a Geiger Counter? You can keep them, I just want the energy." : "I need you to go pick up some groceries for me. Collect " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " items from Providers.") + ".";
	}
	else if (step == 15) {
		return "You must pluck " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + " rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
	}
	else return "";
}

bool is_number(const std::string& s)
{
	char* end = nullptr;
	double val = strtod(s.c_str(), &end);
	return end != s.c_str() && *end == '\0' && val != HUGE_VAL;
}

string to_playmod_time(int seconds, bool onlydays = false, bool hrs = false) {
	int day = seconds / 86400;
	if (day != 0) seconds -= day * 86400;
	int hour = seconds / 3600;
	int minute = (seconds % 3600) / 60;
	int second = seconds % 60;
	if (hour == 0 and minute == 0 and second == 0 and day == 0) return "Removing now ";
	string extra = (hour == 0 && day > 0 ? ", " : "");
	if (day == 0 && onlydays) if (hour != 0 || minute != 0 || second != 0) return "today";
	if (onlydays) return to_string(day);
	vector<string> times;
	if (onlydays == false) {
		if (day != 0) times.push_back(to_string(day) + " days");
		if (hour != 0) times.push_back(to_string(hour) + " hours");
		if (minute != 0) times.push_back(to_string(minute) + " minutes");
		if (second != 0) times.push_back(to_string(second) + " seconds");
	}
	if (hrs) {
		if (minute == 0 && day == 0 && hour == 0) return (to_string(second) + " secs");
		else return (day > 0 ? to_string(day) + " days" : "") + (minute != 0 && second != 0 && hour != 0 ? extra : "") + (hour > 0 ? (day > 0 ? ", " : "") + to_string(hour) + " hours" : "") + (minute > 0 ? (hour > 0 ? ", " : "") + to_string(minute) + " mins" : "");
	}
	return join(times, ", ");
}
void daily_quest(ENetPeer* peer, bool open, string type, uint16_t count) {
	if (open) {
		gamepacket_t p(500);
		p.Insert("OnDialogRequest");
		if (type == "tab_tasks") {
			p.Insert("start_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,0;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,1;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_textbox|Daily Tasks `7(resets in `2" + to_playmod_time(pInfo(peer)->grow_reset_day - time(nullptr)) + "```7)``|left|" + (pInfo(peer)->grow4good_30mins == -1 ? "" : "\nadd_label_with_icon|small|Play for 60 minutes (" + to_string((pInfo(peer)->grow4good_30mins >= 60 ? 60 : pInfo(peer)->grow4good_30mins)) + "/60)|left|2946|\nadd_smalltext|`5          100 points`s + (100 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_surgery == -1 ? "" : "\nadd_label_with_icon|small|Successfully Complete Surgeries (" + to_string(pInfo(peer)->grow4good_surgery) + "/5)|left|2946|\nadd_smalltext|`5          100 points`s + (100 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_fish == -1 ? "" : "\nadd_label_with_icon|small|Catch lbs of Fish (" + to_string(pInfo(peer)->grow4good_fish) + "/450)|left|2946|\nadd_smalltext|`5          75 points`s + (75 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_break == -1 ? "" : "\nadd_label_with_icon|small|Break blocks (" + to_string(pInfo(peer)->grow4good_break) + "/1,000)|left|2946|\nadd_smalltext|`5          50 points`s + (50 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_place == -1 ? "" : "\nadd_label_with_icon|small|Place blocks (" + to_string(pInfo(peer)->grow4good_place) + "/1,000)|left|2946|\nadd_smalltext|`5          50 points`s + (50 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_trade == -1 ? "" : "\nadd_label_with_icon|small|Trade people (" + to_string(pInfo(peer)->grow4good_trade) + "/15)|left|2946|\nadd_smalltext|`5          15 points`s + (15 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_sb == -1 ? "" : "\nadd_label_with_icon|small|Broadcast (" + to_string(pInfo(peer)->grow4good_sb) + "/10)|left|2946|\nadd_smalltext|`5          30 points`s + (30 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_provider == -1 ? "" : "\nadd_label_with_icon|small|Harvest provider (" + to_string(pInfo(peer)->grow4good_provider) + "/" + to_string(pInfo(peer)->grow4good_provider2) + ")|left|2946|\nadd_smalltext|`5          35 points`s + (45 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + (pInfo(peer)->grow4good_geiger == -1 ? "" : "\nadd_label_with_icon|small|Geiger Hunting (" + to_string(pInfo(peer)->grow4good_geiger) + "/" + to_string(pInfo(peer)->grow4good_geiger2) + ")|left|2946|\nadd_smalltext|`5          50 points`s + (100 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|") + "\nadd_label_with_icon|small|Login once per day (" + to_string(pInfo(peer)->grow4good_enter) + "/1)|left|2946|\nadd_smalltext|`5          10 points`s + (15 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|\nadd_spacer|small|\nadd_textbox|Weekly Tasks `7(resets in `2" + to_playmod_time(pInfo(peer)->grow_reset_week - time(nullptr)) + "```7)``|left|\nadd_label_with_icon|small|Plant " + items[pInfo(peer)->grow4good_seed].ori_name + " (" + to_string(pInfo(peer)->grow4good_seed2) + "/100)|left|2946|\nadd_smalltext|`5          250 points`s + (50 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|\nadd_label_with_icon|small|Combine Items (" + to_string(pInfo(peer)->grow4good_combine) + "/6)|left|2946|\nadd_smalltext|`5          100 points`s + (50 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|\nadd_spacer|small|\nadd_textbox|Monthly Tasks `7(resets in `2" + to_playmod_time(pInfo(peer)->grow_reset_month - time(nullptr)) + "```7)``|left|\nadd_label_with_icon|small|Harmonize Crystals (" + to_string(pInfo(peer)->grow4good_crystal) + "/4)|left|2946|\nadd_smalltext|`5          200 points`s + (200 points) For Grow Pass Members``|left|\nadd_label_with_icon|small|Change Email (" + to_string(pInfo(peer)->grow4good_email) + "/1)|left|2946|\nadd_smalltext|`5          250 points`s + (250 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|\nadd_label_with_icon|small|World Yesterday Honors (" + to_string(pInfo(peer)->grow4good_honors) + "/1)|left|2946|\nadd_smalltext|`5          65 points`s + (65 points) For Grow Pass Members``|left|\nadd_custom_textbox|`5        - Earn 20 Grow Pass Points.``|size:small|\nadd_label_with_icon|small|Spend Gems (" + setGems((pInfo(peer)->grow4good_gems >= 100000 ? 100000 : pInfo(peer)->grow4good_gems)) + "/100,000)|left|2946|\nadd_smalltext|`5          150 points``|left|disable|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|`6*NOTE: Daily Tasks can only be completed once per day. Any progress on Daily Tasks that are not completed before the end of the day will be lost.``|left|\nadd_quick_exit|\nend_dialog|grow4goodtasks_dialog|Close||\nadd_spacer|small|\n");
		}
		else p.Insert("start_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,0;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,1;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_image_button||interface/large/gtps_daily_quest.rttex|bannerlayout|flag_frames:1,1,0,0|flag_surfsize:985,256|\nadd_spacer|small|\nadd_textbox|Complete daily tasks to get personal points and earn yourself awesome rewards along the way. After reaching `5400`` points you can claim your reward, the tasks will reset everyday.|left|\nadd_spacer|small|\ntext_scaling_string|iiiiiiiiiiiiiiiiiiiiiiiiiii|\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|4|" + to_string(pInfo(peer)->grow4good_points) + "/400|" + (pInfo(peer)->grow4good_points >= 400 ? "400" : to_string(pInfo(peer)->grow4good_points)) + "|400|pre_icon|6|0.05|0|1000|64|0.005|barBG_0|\nreset_placement_x|\nadd_spacer|small|\nadd_textbox|You can claim one of those `5rewards``:|left|\nadd_label_with_icon|small| 50 Provider Spray Fertilizer|left|7962|\nadd_label_with_icon|small| 50 Rare Seed Pack|left|9526|\nadd_label_with_icon|small| Cashback Coupon|left|10394|\nadd_label_with_icon|small| Cashback Coupon 10,000 Gems|left|5138|\nadd_label_with_icon|small| Cashback Coupon 50,000 Gems|left|5140|\nadd_label_with_icon|small| Cashback Coupon 100,000 Gems|left|5142|\nadd_label_with_icon|small| Fishing Supply Crate|left|10838|\nadd_label_with_icon|small| Surgery Supply Crate|left|10836|\nadd_spacer|small|\nadd_textbox|Unclaimed `2Personal Points``: " + setGems(pInfo(peer)->grow4good_points) + "|left|\nadd_button|" + (pInfo(peer)->grow4good_points >= 300 ? "claimrewardsg4g|Claim Reward" : "|`sClaim Reward``") + "|" + (pInfo(peer)->grow4good_points >= 300 ? "" : "off|") + "0|0|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|grow4goodtasks_dialog|Close||\n");
		p.CreatePacket(peer);
	}
	else {
		uint16_t current_points = pInfo(peer)->grow4good_points;
		string completed = "";
		if (type == "gems") {
			pInfo(peer)->grow4good_gems += count;
			if (pInfo(peer)->grow4good_gems >= 100000) pInfo(peer)->grow4good_points += 150, completed = "You completed the task: Spend Gems and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "30mins") {
			pInfo(peer)->grow4good_30mins += count;
			if (pInfo(peer)->grow4good_30mins >= 60) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 200 : 100), completed = "You completed the task: `2Successfully Play for 60 minutes`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "surgery") {
			pInfo(peer)->grow4good_surgery += count;
			if (pInfo(peer)->grow4good_surgery >= 5) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 200 : 100), completed = "You completed the task: `2Successfully Complete Surgeries`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "break") {
			pInfo(peer)->grow4good_break += count;
			if (pInfo(peer)->grow4good_break >= 1000) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 100 : 50), completed = "You completed the task: `2Break 1,000 blocks`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "place") {
			pInfo(peer)->grow4good_place += count;
			if (pInfo(peer)->grow4good_place >= 1000) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 100 : 50), completed = "You completed the task: `2Place 1,000 blocks`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "trade") {
			pInfo(peer)->grow4good_trade += count;
			if (pInfo(peer)->grow4good_trade >= 10) {
				pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 30 : 15), completed = "You completed the task: `2Trade 10 people`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
			}
		}
		else if (type == "email") {
			pInfo(peer)->grow4good_email = 1;
			pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 500 : 250), completed = "You completed the task: `2Change Email`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "sb") {
			pInfo(peer)->grow4good_sb += count;
			if (pInfo(peer)->grow4good_sb >= 10) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 60 : 30), completed = "You completed the task: `2Broadcast 10 times`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "fish") {
			pInfo(peer)->grow4good_fish += count;
			if (pInfo(peer)->grow4good_fish >= 450) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 150 : 75), completed = "You completed the task: `2Catch lbs of Fish`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "enter") {
			pInfo(peer)->grow4good_enter = true;
			if (pInfo(peer)->grow4good_enter) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 15 : 10), completed = "You completed the task: `2Login once per day`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "provider") {
			pInfo(peer)->grow4good_provider += count;
			if (pInfo(peer)->grow4good_provider >= pInfo(peer)->grow4good_provider2) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 45 : 35), completed = "You completed the task: `2Harvest provider`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "geiger") {
			pInfo(peer)->grow4good_geiger += count;
			if (pInfo(peer)->grow4good_geiger >= pInfo(peer)->grow4good_geiger2) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 150 : 50), completed = "You completed the task: `2Geiger Hunting`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "seed") {
			pInfo(peer)->grow4good_seed2 += count;
			if (pInfo(peer)->grow4good_seed2 >= 100) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 300 : 250), completed = "You completed the task: `2Plant 100 " + items[pInfo(peer)->grow4good_seed].ori_name + "`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "combine") {
			pInfo(peer)->grow4good_combine += count;
			if (pInfo(peer)->grow4good_combine >= 6) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 150 : 100), completed = "You completed the task: `2Combine Items`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "crystal") {
			pInfo(peer)->grow4good_crystal += count;
			if (pInfo(peer)->grow4good_crystal >= 4) pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 400 : 200), completed = "You completed the task: `2Harmonize Crystals`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
		}
		else if (type == "honors") {
			if (count < 50 && pInfo(peer)->grow4good_honors == 0) {
				pInfo(peer)->grow4good_honors = 1, pInfo(peer)->grow4good_points += (pInfo(peer)->gp ? 130 : 65), completed = "You completed the task: `2Honors`` and Earned " + to_string(pInfo(peer)->grow4good_points - current_points) + " points.";
			}
		}
		if (completed != "") {
			if (pInfo(peer)->gp) pInfo(peer)->growpass_points += 20;
			talk_bubble(peer, pInfo(peer)->netID, completed, 0, 0);
			console_msg(peer, completed);
		}
	}
}

/*
void daily_quest_winterfest(ENetPeer* peer, bool open = true, string type = "", uint16_t count = 0) {
	if (open) {
		gamepacket_t p(500);
		p.Insert("OnWinterRallyRequest");
		p.Insert("add_image_button||interface/large/gui_shop_winter_rally.rttex|bannerlayout|flag_frames:1,1,0,0|flag_surfsize:985,256|\nadd_spacer|small|\ntext_scaling_string|iiiiiiiiiiiiiiiiiiiiiiiiiii|\nadd_button_with_icon||`550``|disabled|568||\nadd_button_with_icon|10538|`5100``|staticBlueFrame|10538|1|\nadd_button_with_icon||`5150``|disabled|568||\nadd_button_with_icon|10538|`5200``|staticBlueFrame|10538|1|\nadd_button_with_icon||`5250``|disabled|568||\nadd_button_with_icon|10536|`5300``|staticBlueFrame|10536|1|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|0|`5Wishes: " + to_string(pInfo(peer)->winterfest_wishes) + "/300|"+(pInfo(peer)->winterfest_wishes > 300 ? "300" : to_string(pInfo(peer)->winterfest_wishes)) + "|300``|iconlist||0.05|0|1000|64|0.005\nadd_smalltext|`5*Winter Club members exclusive rewards!*``|left|\nadd_spacer|small|\nadd_textbox|Earn wishes by completing tasks! Once you have enough wishes, you can claim your rewards.|left|\nadd_button|" + (pInfo(peer)->winterfest_wishes < 100 ? "claimbutton" : "claim") + "|`" + (pInfo(peer)->winterfest_wishes < 100 ? "s" : "0") + "Claim Rewards``|" + (pInfo(peer)->winterfest_wishes < 100 ? "disabled" : "noflags") + "|0|0|\nadd_spacer|small|\nadd_textbox|Repeatable Tasks:|left|\nadd_label_with_icon|small|Purchase Winterfest Cracker Packs (" + to_string(pInfo(peer)->winterfest_quest_1) + "/5) |left|2946|\nadd_smalltext|`5          75 wishes``|left|enable|\nadd_label_with_icon|small|Open Winterfest Crackers (" + to_string(pInfo(peer)->winterfest_quest_2) + "/20) |left|2946|\nadd_smalltext|`5          10 wishes``|left|enable|\nadd_label_with_icon|small|Open Deluxe Winterfest Crackers (" + to_string(pInfo(peer)->winterfest_quest_3) + "/1) |left|2946|\nadd_smalltext|`5          50 wishes``|left|enable|\nadd_spacer|small|\nadd_textbox|Daily Tasks:|\nadd_label_with_icon|small|Claim an item from the Winterfest Calendar (" + to_string(pInfo(peer)->reset_winterfest_quest_1) + "/1) |left|2946|\nadd_smalltext|`5          30 wishes``|left|enable|\nadd_label_with_icon|small|Claim an item from the Diamond Builder's Bonanza (" + to_string(pInfo(peer)->reset_winterfest_quest_2) + "/1) |left|2946|\nadd_smalltext|`5          20 wishes``|left|enable|\nadd_label_with_icon|small|Collect an Icy Heart of Winter (" + to_string(pInfo(peer)->reset_winterfest_quest_3) + "/1) |left|2946|\nadd_smalltext|`5          10 wishes``|left|enable|\nadd_label_with_icon|small|Give Winter Gifts to Growch (" + to_string(pInfo(peer)->reset_winterfest_quest_4) + "/200) |left|2946|\nadd_smalltext|`5          10 wishes``|left|enable|\nadd_label_with_icon|small|Donate Rarity to Stuff 4 Toys (" + to_string(pInfo(peer)->reset_winterfest_quest_5) + "/20000) |left|2946|\nadd_smalltext|`5          10 wishes``|left|enable|\nadd_spacer|small|\nadd_spacer|small|\nadd_smalltext|`6*NOTE: Daily Tasks can only be completed once per day. Any progress on Daily Tasks that are not completed before the end of the day will be lost.``|left|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|winterrally_dialog|Close||");
		p.CreatePacket(peer);
	}
	else {
		uint16_t current_task_points = 0, need_for_task = 0, prize = 0;
		bool show_ = false;
		string task = "";
		if (type == "1") {
			show_ = true;
			pInfo(peer)->winterfest_quest_1 += count;
			current_task_points = pInfo(peer)->winterfest_quest_1;
			need_for_task = 5;
			prize = 75;
			task = "Purchase Winterfest Cracker Packs";
			if (current_task_points >= need_for_task) pInfo(peer)->winterfest_quest_1 = 0, pInfo(peer)->winterfest_wishes += prize;
		}
		else if (type == "2") {
			show_ = true;
			pInfo(peer)->winterfest_quest_2 += count;
			current_task_points = pInfo(peer)->winterfest_quest_2;
			need_for_task = 20;
			prize = 10;
			task = "Open Winterfest Crackers";
			if (current_task_points >= need_for_task) pInfo(peer)->winterfest_quest_2 = 0, pInfo(peer)->winterfest_wishes += prize;
		}
		else if (type == "3") {
			show_ = true;
			pInfo(peer)->winterfest_quest_3 += count;
			current_task_points = pInfo(peer)->winterfest_quest_3;
			need_for_task = 1;
			prize = 50;
			task = "Open Deluxe Winterfest Crackers";
			if (current_task_points >= need_for_task) pInfo(peer)->winterfest_quest_3 = 0, pInfo(peer)->winterfest_wishes += prize;
		}
		else if (type == "11") {
			need_for_task = 1;
			if (pInfo(peer)->reset_winterfest_quest_1 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_1 < need_for_task) pInfo(peer)->reset_winterfest_quest_1 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_1;
				prize = 30;
				task = "Claim an item from the Winterfest Calendar";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		else if (type == "22") {
			need_for_task = 1;
			if (pInfo(peer)->reset_winterfest_quest_2 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_2 < need_for_task) pInfo(peer)->reset_winterfest_quest_2 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_2;
				prize = 20;
				task = "Claim an item from the Diamond Builder's Bonanza";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		else if (type == "33") {
			need_for_task = 1;
			if (pInfo(peer)->reset_winterfest_quest_3 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_3 < need_for_task) pInfo(peer)->reset_winterfest_quest_3 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_3;
				prize = 10;
				task = "Collect an Icy Heart of Winter";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		else if (type == "44") {
			need_for_task = 200;
			if (pInfo(peer)->reset_winterfest_quest_4 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_4 < need_for_task) pInfo(peer)->reset_winterfest_quest_4 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_4;
				prize = 10;
				task = "Give Winter Gifts to Growch";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		else if (type == "55") {
			need_for_task = 20000;
			if (pInfo(peer)->reset_winterfest_quest_5 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_5 < need_for_task) pInfo(peer)->reset_winterfest_quest_5 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_5;
				prize = 10;
				task = "Donate Rarity to Stuff 4 Toys";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		else if (type == "66") {
			need_for_task = 50;
			if (pInfo(peer)->reset_winterfest_quest_6 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_6 < need_for_task) pInfo(peer)->reset_winterfest_quest_6 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_6;
				prize = 10;
				task = "Give Winter Gifts to Growtopians";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		else if (type == "77") {
			need_for_task = 1;
			if (pInfo(peer)->reset_winterfest_quest_7 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_7 < need_for_task) pInfo(peer)->reset_winterfest_quest_7 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_7;
				prize = 10;
				task = "Rescue a Winter Polar Bear";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		else if (type == "88") {
			need_for_task = 1;
			if (pInfo(peer)->reset_winterfest_quest_8 < need_for_task) {
				if (pInfo(peer)->reset_winterfest_quest_8 < need_for_task) pInfo(peer)->reset_winterfest_quest_8 += count, show_ = true;
				current_task_points = pInfo(peer)->reset_winterfest_quest_8;
				prize = 10;
				task = "Rescua a Snow Husky";
				if (current_task_points >= need_for_task) pInfo(peer)->winterfest_wishes += prize;
			}
		}
		if (show_) {
			console_msg(peer, "" + a + (current_task_points >= need_for_task ? "(`9COMPLETED!`` Received " + to_string(prize) + " wishes!``) " : "") + "`5Winter Wish List Task: ```2" + task + " " + to_string(current_task_points) + "/" + to_string(need_for_task) + "``");
		}
	}
}*/


bool find_phoenix_item(uint16_t item) {
	if (find(phoenix_items_all.begin(), phoenix_items_all.end(), item) != phoenix_items_all.end()) return false;
	else return true;
}

void save_server_events() {
	try {
		json j;
		if (mails.size() != 0) j["mail"] = mails;
		if (top_basher.size() != 0) j["2"] = top_basher;
		if (top_basher_winners.size() != 0) j["3"] = top_basher_winners;
		if (top_old_winners.size() != 0) j["4"] = top_old_winners;
		if (top_guild.size() != 0) j["5"] = top_guild;
		if (top_guild_winners.size() != 0) j["6"] = top_guild_winners;

		j["top_wls"] = top_wls;
		j["total_wls_recycled"] = total_wls_recycled;
		j["wls_event_time"] = wls_event_time;

		if (top_old_guild_winners.size() != 0) j["7"] = top_old_guild_winners;
		j["top_player_points"] = top_player_points;
		j["angelic_aura2"] = angelic_aura;
		j["buy_enabled"] = Server_Security.buy_enabled;
		j["helicopter_price2s1"] = grow_pass_item_price;
		j["zeus_crown2"] = zeus_crown;
		j["vapor_blade"] = vapor_blade;
		j["dracula_set"] = dracula_set;
		j["recycling_machine2"] = recycling_machine;
		//j["phoenix_items_all"] = phoenix_items_all;


		j["building_machine2"] = building_machine;
		j["island_blast2"] = island_blast;
		j["cursed_eyes"] = cursed_eyes;
		j["e_scepter"] = e_scepter;
		j["_10938_"] = _10938_;
		j["experience_rayman2"] = experience_rayman;
		j["laser_light2"] = laser_light;
		j["rid"] = Server_Security.ridbans;
		j["c_event"] = current_event;
		j["n_event"] = next_event;
		//j["halloween_rarity"] = halloween_rarity;
		j["can_event"] = can_event;
		j["event_id"] = event_item;
		j["old_event_id"] = old_event_item;
		//	j["winterfest_sold"] = winterfest_sold;

		/*
		j["ubi_sold_1"] = ubi_sold_1;
		j["ubi_sold_2"] = ubi_sold_2;
		j["ubi_sold_3"] = ubi_sold_3;
		j["ubi_sold_4"] = ubi_sold_4;
		j["ubi_sold_5"] = ubi_sold_5;
		j["ubi_sold_6"] = ubi_sold_6;
		j["ubi_sold_7"] = ubi_sold_7;
		j["ubi_sold_8"] = ubi_sold_8;
		j["ubi_sold_9"] = ubi_sold_9;
		j["ubi_sold_10"] = ubi_sold_10;*/
		//j["planted"] = planted;
		j["crypto_sold"] = Crypto_Update.crypto_sold;
		j["crypto_bought"] = Crypto_Update.crypto_bought;
		j["logs"] = Server_Security.logs;
		//	j["crypto_1"] = crypto;
		//	j["crypto_2"] = crypto_sale;
		j["crypto_3"] = Crypto_Update.crypto_history;
		//j["ubi_token_time"] = ubitoken_time;

		/*
		j["bonanza_item"] = bonanza_item;
		j["bonanza_sold"] = bonanza_sold;
		j["bonanza_item_current"] = bonanza_item_current;
		j["bonanza_time"] = bonanza_time;*/
		/*j["winterfest_gift"] = winterfest_gift;
		j["winterfest_rarity_250"] = winterfest_rarity_250;
		j["winterfest_rarity"] = winterfest_rarity;
		j["winterfest_total_toys"] = winterfest_total_toys;*/
		if (Balloon_Warz.balloon_warz.size() != 0) j["balloon_warz2"] = Balloon_Warz.balloon_warz;
		if (Balloon_Warz.top_balloon.size() != 0) j["ballon_list2"] = Balloon_Warz.top_balloon;
		j["balloon_winners"] = Balloon_Warz.top_balloon_winners;
		j["cheater_role3"] = role_price.cheater_price2;
		j["lrayman_price"] = role_price.lrayman_price;
		j["wotd"] = World_Stuff.wotd;
		j["rate"] = world_rating;
		j["total_pineapple_eaten"] = total_pineapple_eaten;
		if (top_points.size() != 0) j["top_today" + to_string(today_day)] = top_points;
		if (top_yesterday.size() != 0) j["top_today" + to_string(today_day - 1)] = top_yesterday;
		if (top_overall.size() != 0) j["top_overall"] = top_overall;
		ofstream o("db/server_events.json");
		o << j << endl;
		cout << "SAVED SERVER EVENTS" << endl;
	}
	catch (...) {}
}
/*
void captcha(ENetPeer* peer) {
	pInfo(peer)->captcha_type = rand() % 20 + 1;
	gamepacket_t p;
	p.Insert("onShowCaptcha");
	p.Insert("add_puzzle_captcha|0098/captcha/generated/gtps_capgaw84g9w479a_" + to_string(pInfo(peer)->captcha_type) + ".rttex|0098/captcha/generated/gtps_capgaw84g9w479a_" + to_string(pInfo(peer)->captcha_type) + "p.rttex|www.growtopia1.com|" + to_string(pInfo(peer)->captcha_type) + "|\nend_dialog|puzzle_captcha_submit||Submit|");
	p.CreatePacket(peer);
}*/

void onsupermain(ENetPeer* peer, string error = "") {
	if (not Server_Security.log_player.empty() && Server_Security.log_player == to_lower(pInfo(peer)->tankIDName)) {
		cout << "LOGGING: " << pInfo(peer)->tankIDName << " | " << "connected in supermain" << "|" << endl;
	}
	if (server_port != main_port)  pInfo(peer)->bypass2 = true;
	if (pInfo(peer)->fa_ip == pInfo(peer)->ip) pInfo(peer)->bypass2 = true;
	if (pInfo(peer)->mod && pInfo(peer)->bypass2 == false) {
		if (pInfo(peer)->fa2 <= 999) pInfo(peer)->fa2 = 0;
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		if (pInfo(peer)->fa2) {
			//pInfo(peer)->give_role = 0;
			p.Insert("\nadd_spacer|small|\nadd_textbox|This account has `52FA`` `2enabled`` for " + pInfo(peer)->tankIDName + ". (2nd Step Verification)|\nadd_smalltext|Two-factor authentication (`w2FA``) is an identity and access management security method that requires two forms of identification to access resources and data.|left|" + (error.empty() ? "" : "\nadd_textbox|`4OOPS:`` `0" + error + "``|") + "\nadd_textbox|`5Enter your 2FA 4-digit number:``|\nadd_text_input_password|verificationcode|Code||4|\nend_dialog|2fa||Submit|");
		}
		else p.Insert("\nadd_spacer|small|\nadd_textbox|Create new `52FA`` code|\nadd_textbox|This account has `52FA`` `4disabled`` for " + pInfo(peer)->tankIDName + ". (2nd Step Verification)|\nadd_smalltext|Two-factor authentication (`w2FA``) is an identity and access management security method that requires two forms of identification to access resources and data.|left|" + (error.empty() ? "" : "\nadd_textbox|`4OOPS:`` `0" + error + "``|") + "\nadd_textbox|`5Create your 4-digit number:``|\nadd_text_input|verificationcode|Code||4|\nend_dialog|2fa||Submit|");
		p.CreatePacket(peer);
	}
	else pInfo(peer)->bypass2 = true;
	if (pInfo(peer)->bypass2) {
		pInfo(peer)->bypass = true;
		gamepacket_t p;
		p.Insert("OnSuperMainStartAcceptLogonHrdxs47254722215a");
		//p.Insert(pInfo(peer)->ios_player ? ios_hash : item_hash);
		p.Insert(pInfo(peer)->load_item2 ? item_hash_ios : item_hash);
		p.Insert("www.growtopia1.com");
		p.Insert("cache/");
		p.Insert("cc.cz.madkite.freedom org.aqua.gg idv.aqua.bulldog com.cih.gamecih2 com.cih.gamecih com.cih.game_cih cn.maocai.gamekiller com.gmd.speedtime org.dax.attack com.x0.strai.frep com.x0.strai.free org.cheatengine.cegui org.sbtools.gamehack com.skgames.traffikrider org.sbtoods.gamehaca com.skype.ralder org.cheatengine.cegui.xx.multi1458919170111 com.prohiro.macro me.autotouch.autotouch com.cygery.repetitouch.free com.cygery.repetitouch.pro com.proziro.zacro com.slash.gamebuster");
		p.Insert("proto=200|choosemusic=audio/mp3/doctor.mp3|active_holiday=6|wing_week_day=0|ubi_week_day=0|server_tick=8310098|clash_active=1|drop_lavacheck_faster=1|isPayingUser=0|usingStoreNavigation=1|enableInventoryTab=1|bigBackpack=1|");
		//p.Insert("654171113"); //nzn kas tas paskutinis gal player_tribute hash   
		p.CreatePacket(peer);
	}
}

int get_next_event() {
	if (event_item == 6238) return 6828;
	else if (event_item == 6828) return 6256;
	else if (event_item == 6256) return 6244;
	else if (event_item == 6244) return 6834;
	else if (event_item == 6834) return 6250;
	else return 6238;
}
string web_url = "";
void load_config() {
	std::ifstream ifs("db/config.json");
	json j = json::parse(ifs);
	server_name = j["server_name"].get<string>();
	discord_url = j["discord_url"].get<string>();
	web_url = j["web_url"].get<string>();
	secret_standopowah = j["secret_standopowah"].get<bool>();
	World_Stuff.depositworld = j["deposit_world"].get<string>();

	if (web_url.find("gtps7") != string::npos) { // ROLE PRICE
		cout << "GTPS7 URL DETECTED, changing role price" << endl;
		role_price.cheater_price = 3500;
		role_price.cheater7days_price = 1000;
		role_price.allin_price = 1250;
		role_price.moderator_price = 4000;
		role_price.mod_price = 1500;
		role_price.growpass_price = 2500;
		role_price.vip_price = 1000;
		role_price.vip_price_permament = 300;
		role_price.glory_price = 750;
	}
}


void load_item_price(bool reload = false) {
	ifstream ifs("db/item_prices.json");
	json j = json::parse(ifs);
	vector<vector<int>> item_prices = j["items"].get<vector<vector<int>>>();
	for (int i = 0; i < item_prices.size(); i++) items[i].price = item_prices[i];

	if (reload) {
		string item_names = "";
		for (int i_ = 0; i_ < items.size(); i_++) {
			if (i_ % 2 == 0 && items[i_].buy_price > 0 && items[i_].ori_name.find("null") == string::npos)item_names += to_string(i_) + "|" + to_string(items[i_].buy_price) + "|\n";
		}
		ofstream m;
		m.open("db/kainos.txt"), m << item_names, m.close();
		kainos.clear();
	}
	ifstream file_info("db/kainos.txt");
	if (file_info.is_open()) {
		string line_info;
		while (getline(file_info, line_info)) {
			vector<string> ok = explode("|", line_info);
			int item_idas = atoi(ok[0].c_str());
			if (item_idas == 9812 || item_idas == 9918 || item_idas == 9496 || item_idas == 9570 || item_idas == 9916 || item_idas == 10644 || item_idas == 9228) {
			}
			else {
				kainos.push_back({ atoi(ok[0].c_str()), atoi(ok[1].c_str()) * 3 });
				items[item_idas].buy_price = atoi(ok[1].c_str());
			}
		}
	}
	file_info.close();
}

void guild_flag_dialog(ENetPeer* peer, string error = "") {
	bool taken_ = false;
	if (pInfo(peer)->set_guild_fg != 0 && pInfo(peer)->set_guild_bg != 0) {
		for (Guild check_guild_name : guilds) {
			if (check_guild_name.guild_mascot[0] == pInfo(peer)->set_guild_fg && check_guild_name.guild_mascot[1] == pInfo(peer)->set_guild_bg) {
				taken_ = true;
				break;
			}
		}
	}
	int price = 100000;
	uint32_t guild_id = pInfo(peer)->guild_id;
	vector<Guild>::iterator px = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
	if (px != guilds.end()) {
		Guild* guild_information = &guilds[px - guilds.begin()];
		if (guild_information->guild_mascot[0] == 0 && guild_information->guild_mascot[1] == 0) price = 100000;
		else price = 250000;
	}
	if (not error.empty()) error = "\nadd_spacer|small|\nadd_smalltext|`4"+ error +"``|left|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild Mascot Editor``|left|5814|\nadd_spacer|small|\nadd_smalltext|Create a unique Guild Mascot for your guild! Only `9"+setGems(price) + " Gems!``|left|\nadd_smalltext|Choose items from your inventory to use as your Guild Mascot.|left|" + error + "\nadd_spacer|small|\nadd_item_picker|select_bg|`wChoose Background Item``|Choose the mascot background item!|\nadd_item_picker|select_fg|`wChoose Foreground Item``|Choose the mascot foreground item!|" + (pInfo(peer)->set_guild_fg + pInfo(peer)->set_guild_bg == 0 ? "" : "\nadd_spacer|small|\nadd_dual_layer_icon_label|small|`wGuild Mascot Preview``|left|" + to_string(pInfo(peer)->set_guild_bg) + "|" + to_string(pInfo(peer)->set_guild_fg) + "|3.0|1|") + "\nadd_spacer|small|\nadd_smalltext|Increase your membership to `030`` or more for access exclusive foreground only mascots!|left|" + (pInfo(peer)->set_guild_fg + pInfo(peer)->set_guild_bg == 0 ? "" : (taken_ ? "\nadd_smalltext|Sorry that Guild Mascot is already taken, please try a different combination!|left|" : "\nadd_button|create|`oConfirm Guild Mascot``|noflags|0|0|")) + "\nend_dialog|create_guild_mascot|Cancel||\nadd_quick_exit|");
	p.CreatePacket(peer);
}

void set_Guilds(ENetPeer* peer) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (world_->guild_id != 0) 	pInfo(peer)->guild_id = world_->guild_id;
		else pInfo(peer)->guild_id = 0;
	}
}

inline void SendDialogInfinityCrown(ENetPeer* peer, bool Instructions = false, string error = "") {
	string dialog;
	dialog += "set_default_color|`o\nadd_label_with_icon|big|`wInfinity Crown``|left|12958|\nadd_spacer|small|";
	dialog += error != "" ? "\nadd_textbox|`4" + error + "``|left|\nadd_spacer|small|" : "";
	dialog += Instructions ? "\nadd_textbox|This Crown has several special functions!|left|\nadd_spacer|small|\nadd_textbox|Set the Time Dilation Cycle Time to define how often the Crown will change between the two Crown Styles. Cycle time is in seconds; maximum number of seconds allowed is: 86400 seconds (24 hours).|left|\nadd_spacer|small|\nadd_textbox|To set the colors for the styles you need to enter RGB(Red, Green, Blue) values. To separate the individual values, you need to use a comma.|left|" : "\nadd_button|button_manual|Instructions|noflags|0|0|";
	dialog += "\nadd_text_input|text_input_time_cycle|Time Dilation Cycle Time:|" + to_string(pInfo(peer)->Crown_Cycle_Time) + "|5|\nadd_checkbox|checkbox_time_cycle|Time Dilation On / Off|" + string(pInfo(peer)->Crown_Time_Change ? "1" : "0") + "\nadd_spacer|small|\nadd_spacer|small|";
	dialog += "\nadd_label|big|Crown Style 1|left\nadd_spacer|small|\nadd_checkbox|checkbox_floating0|Floating Effect|" + string(pInfo(peer)->Crown_Floating_Effect_0 ? "1" : "0") + "\nadd_spacer|small|\nadd_label|small|Crown Base:|left\nadd_text_input|text_input_base_color0|Color - R,G,B:|" + to_string(pInfo(peer)->Base_R_0) + "," + to_string(pInfo(peer)->Base_G_0) + "," + to_string(pInfo(peer)->Base_B_0) + "|11|\nadd_spacer|small|\nadd_label|small|Crown Gem:|left\nadd_text_input|text_input_gem_color0|Color - R,G,B:|" + to_string(pInfo(peer)->Gem_R_0) + "," + to_string(pInfo(peer)->Gem_G_0) + "," + to_string(pInfo(peer)->Gem_B_0) + "|11|\nadd_checkbox|checkbox_laser_beam0|Laser Beam On/Off|" + string(pInfo(peer)->Crown_Laser_Beam_0 ? "1" : "0") + "\nadd_spacer|small|\nadd_label|small|Crown Crystal/Rays:|left\nadd_text_input|text_input_crystal_color0|Color - R,G,B:|" + to_string(pInfo(peer)->Crystal_R_0) + "," + to_string(pInfo(peer)->Crystal_G_1) + "," + to_string(pInfo(peer)->Crystal_B_1) + "|11|\nadd_checkbox|checkbox_crystals0| Crystals On/Off|" + string(pInfo(peer)->Crown_Crystals_0 ? "1" : "0") + "\nadd_checkbox|checkbox_rays0| Rays On/Off|" + string(pInfo(peer)->Crown_Rays_0 ? "1" : "0") + "\nadd_spacer|small|";
	dialog += "\nadd_label|big|Crown Style 2|left\nadd_spacer|small|\nadd_checkbox|checkbox_floating1|Floating Effect|" + string(pInfo(peer)->Crown_Floating_Effect_1 ? "1" : "0") + "\nadd_spacer|small|\nadd_label|small|Crown Base:|left\nadd_text_input|text_input_base_color1|Color - R,G,B:|" + to_string(pInfo(peer)->Base_R_1) + "," + to_string(pInfo(peer)->Base_G_1) + "," + to_string(pInfo(peer)->Base_B_1) + "|11|\nadd_spacer|small|\nadd_label|small|Crown Gem:|left\nadd_text_input|text_input_gem_color1|Color - R,G,B:|" + to_string(pInfo(peer)->Gem_R_1) + "," + to_string(pInfo(peer)->Gem_G_1) + "," + to_string(pInfo(peer)->Gem_B_1) + "|11|\nadd_checkbox|checkbox_laser_beam1|Laser Beam On/Off|" + string(pInfo(peer)->Crown_Laser_Beam_1 ? "1" : "0") + "\nadd_spacer|small|\nadd_label|small|Crown Crystal/Rays:|left\nadd_text_input|text_input_crystal_color1|Color - R,G,B:|" + to_string(pInfo(peer)->Crystal_R_1) + "," + to_string(pInfo(peer)->Crystal_G_1) + "," + to_string(pInfo(peer)->Crystal_B_1) + "|11|\nadd_checkbox|checkbox_crystals1| Crystals On/Off|" + string(pInfo(peer)->Crown_Crystals_1 ? "1" : "0") + "\nadd_checkbox|checkbox_rays1| Rays On/Off|" + string(pInfo(peer)->Crown_Rays_1 ? "1" : "0") + "\nadd_spacer|small|";
	dialog += "\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_infinity_crown|Cancel|Update|\nadd_quick_exit|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(dialog);
	p.CreatePacket(peer);
}
inline void SendCernuousEdit(ENetPeer* peer) {
	string dialog;
	string C0, C1, C2, C3, C4, P0, P1, P2, P3, P4;
	switch (pInfo(peer)->Aura_Season) {
	case 0: {
		C0 = "1", C1 = "0", C2 = "0", C3 = "0", C4 = "0";
		break;
	}
	case 1: {
		C0 = "0", C1 = "1", C2 = "0", C3 = "0", C4 = "0";
		break;
	}
	case 2: {
		C0 = "0", C1 = "0", C2 = "1", C3 = "0", C4 = "0";
		break;
	}
	case 3: {
		C0 = "0", C1 = "0", C2 = "0", C3 = "1", C4 = "0";
		break;
	}
	case 4: {
		C0 = "0", C1 = "0", C2 = "0", C3 = "0", C4 = "1";
		break;
	}
	default:
		break;
	}
	switch (pInfo(peer)->Trail_Season) {
	case 0: {
		P0 = "1", P1 = "0", P2 = "0", P3 = "0", P4 = "0";
		break;
	}
	case 1: {
		P0 = "0", P1 = "1", P2 = "0", P3 = "0", P4 = "0";
		break;
	}
	case 2: {
		P0 = "0", P1 = "0", P2 = "1", P3 = "0", P4 = "0";
		break;
	}
	case 3: {
		P0 = "0", P1 = "0", P2 = "0", P3 = "1", P4 = "0";
		break;
	}
	case 4: {
		P0 = "0", P1 = "0", P2 = "0", P3 = "0", P4 = "1";
		break;
	}
	default:
		break;
	}
	dialog += "set_default_color|`o\nadd_label_with_icon|big|`wCrown of Seasons``|left|10674|\nadd_spacer|small|\nadd_textbox|You can choose seperate Auras and Trails for this item. Each one represents a different season. Mix and match to get your perfect look.|left|\nadd_spacer|small|";
	dialog += "\nadd_label|big|Aura Season|left\nadd_spacer|small|";
	dialog += "\nadd_checkbox|checkbox_none0|None|" + C0;
	dialog += "\nadd_checkbox|checkbox_spring0|Spring|" + C1;
	dialog += "\nadd_checkbox|checkbox_summer0|Summer|" + C2;
	dialog += "\nadd_checkbox|checkbox_autumn0|Autumn|" + C3;
	dialog += "\nadd_checkbox|checkbox_winter0|Winter|" + C4;
	dialog += "\nadd_spacer|small|";
	dialog += "\nadd_label|big|Trail Season|left\nadd_spacer|small|";
	dialog += "\nadd_checkbox|checkbox_none1|None|" + P0;
	dialog += "\nadd_checkbox|checkbox_spring1|Spring|" + P1;
	dialog += "\nadd_checkbox|checkbox_summer1|Summer|" + P2;
	dialog += "\nadd_checkbox|checkbox_autumn1|Autumn|" + P3;
	dialog += "\nadd_checkbox|checkbox_winter1|Winter|" + P4;
	dialog += "\nadd_spacer|small|";
	dialog += "\nadd_button|restore_default|Restore to Default|noflags|0|0|";
	dialog += "\nend_dialog|dialog_cernuous_mask|Cancel|Update|\nadd_quick_exit|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(dialog);
	p.CreatePacket(peer);
}
inline void SendBannerBandolier2(ENetPeer* peer) {
	if (pInfo(peer)->CBanner_Item > items.size() || pInfo(peer)->necklace != 11748) return;
	string dialog;
	dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|11748|\nadd_spacer|small|";
	dialog += "\nadd_textbox|Create a stylish banner by choosing an item from yout inventory.|left|\nadd_spacer|small|";
	dialog += pInfo(peer)->CBanner_Item != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(peer)->CBanner_Item].ori_name + "``|left|" + to_string(pInfo(peer)->CBanner_Item) + "|\nadd_spacer|small|" : "";
	dialog += "\nadd_item_picker|banneritem|`wChange Banner Item``|Choose the banner item!|";
	dialog += "\nadd_textbox|Pick a pattern for your banner.|left|\nadd_spacer|small|";
	if (pInfo(peer)->CBanner_Flag == 0) dialog += "\nadd_label_with_icon_button|big|Harlequin|left|5838|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->CBanner_Flag == 1) dialog += "\nadd_label_with_icon_button|big|Slant|left|5844|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->CBanner_Flag == 2) dialog += "\nadd_label_with_icon_button|big|Stripe|left|5848|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->CBanner_Flag == 3) dialog += "\nadd_label_with_icon_button|big|Panel|left|5846|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->CBanner_Flag == 4) dialog += "\nadd_label_with_icon_button|big|Cross|left|5842|patternpicker|\nadd_spacer|small|";
	dialog += "\nadd_button|reset|Reset|noflags|0|0|";
	dialog += "\nend_dialog|bannerbandolier|Cancel|Update|";
	dialog += "\nadd_quick_exit|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(dialog);
	p.CreatePacket(peer);
}
inline void SendBannerBandolier(ENetPeer* peer) {
	if (pInfo(peer)->Banner_Item > items.size() || pInfo(peer)->necklace != 11748) return;
	string dialog;
	dialog += "set_default_color|`o\nadd_label_with_icon|big|`wBanner Bandolier``|left|11748|\nadd_spacer|small|";
	dialog += "\nadd_textbox|Create a stylish banner by choosing an item from yout inventory.|left|\nadd_spacer|small|";
	dialog += pInfo(peer)->Banner_Item != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(peer)->Banner_Item].ori_name + "``|left|" + to_string(pInfo(peer)->Banner_Item) + "|\nadd_spacer|small|" : "";
	dialog += "\nadd_item_picker|banneritem|`wChange Banner Item``|Choose the banner item!|";
	dialog += "\nadd_textbox|Pick a pattern for your banner.|left|\nadd_spacer|small|";
	if (pInfo(peer)->Banner_Flag == 0) dialog += "\nadd_label_with_icon_button|big|Harlequin|left|5838|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->Banner_Flag == 1) dialog += "\nadd_label_with_icon_button|big|Slant|left|5844|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->Banner_Flag == 2) dialog += "\nadd_label_with_icon_button|big|Stripe|left|5848|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->Banner_Flag == 3) dialog += "\nadd_label_with_icon_button|big|Panel|left|5846|patternpicker|\nadd_spacer|small|";
	else if (pInfo(peer)->Banner_Flag == 4) dialog += "\nadd_label_with_icon_button|big|Cross|left|5842|patternpicker|\nadd_spacer|small|";
	dialog += "\nadd_button|reset|Reset|noflags|0|0|";
	dialog += "\nend_dialog|bannerbandolier|Cancel|Update|";
	dialog += "\nadd_quick_exit|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert(dialog);
	p.CreatePacket(peer);
}

void PSendRiftcapeDialog(ENetPeer* peer, string error = "\nadd_button|button_manual|Instructions|noflags|0|0|") {
	if (pInfo(peer)->back == 10424) {
		int portalAura0 = 0, portalAura1 = 0;
		int starfieldAura0 = 0, starfieldAura1 = 0;
		int electricalAura0 = 0, electricalAura1 = 0;

		if (pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_PORTAL_AURA && pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_STARFIELD_AURA) {
			electricalAura0 = 1;
		}
		else if (pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_PORTAL_AURA) {
			portalAura0 = 1;
		}
		else if (pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_STARFIELD_AURA) {
			starfieldAura0 = 1;
		}

		if (pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_PORTAL_AURA && pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_STARFIELD_AURA) {
			electricalAura1 = 1;
		}
		else if (pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_PORTAL_AURA) {
			portalAura1 = 1;
		}
		else if (pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_STARFIELD_AURA) {
			starfieldAura1 = 1;
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wRift Cape``|left|10424|\nadd_spacer|small|\nadd_text_input|text_input_time_cycle|Time Dilation Cycle Time:|" + to_string(pInfo(peer)->TimeDilation) + "|5|\nadd_checkbox|checkbox_time_cycle|Time Dilation On / Off|" + (to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_TIME_DILATION_ON ? 1 : 0)) + ""+error+"\nadd_spacer|small|\nadd_label|big|Cape Style 1|left\nadd_spacer|small|\nadd_label|small|Cape Color:|left\nadd_text_input|text_input_cape_color0|Cape - R,G,B:|" + pInfo(peer)->CapeStyleColor_1 + "|11|\nadd_spacer|small|\nadd_checkbox|checkbox_cape_collar0|Cape Collar On / Off|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_COLLAR_ON) + "\nadd_label|small|Cape Collar Color:|left\nadd_text_input|text_input_collar_color0|Collar - R,G,B:|" + pInfo(peer)->CapeCollarColor_1 + "|11|\nadd_spacer|small|\nadd_checkbox|checkbox_closed_cape0|Closed Cape|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_CLOSED_CAPE) + "\nadd_checkbox|checkbox_open_on_move0|Open Cape on Movement|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_OPEN_CAPE_ON_MOVEMENT ? 1 : 0) + "\nadd_checkbox|checkbox_aura0|Aura On / Off|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_1_AURA_ON ? 1 : 0) + "\nadd_checkbox|checkbox_aura_1st0|      Portal Aura|" + to_string(portalAura0) + "\nadd_checkbox|checkbox_aura_2nd0|      Starfield Aura|" + to_string(starfieldAura0) + "\nadd_checkbox|checkbox_aura_3rd0|      Electrical Aura|" + to_string(electricalAura0) + "\nadd_label|big|Cape Style 2|left\nadd_spacer|small|\nadd_label|small|Cape Color:|left\nadd_text_input|text_input_cape_color1|Cape - R,G,B:|" + pInfo(peer)->CapeStyleColor_2 + "|11|\nadd_spacer|small|\nadd_checkbox|checkbox_cape_collar1|Cape Collar On / Off|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_COLLAR_ON ? 1 : 0) + "\nadd_label|small|Cape Collar Color:|left\nadd_text_input|text_input_collar_color1|Collar - R,G,B:|" + pInfo(peer)->CapeCollarColor_2 + "|11|\nadd_spacer|small|\nadd_checkbox|checkbox_closed_cape1|Closed Cape|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_CLOSED_CAPE ? 1 : 0) + "\nadd_checkbox|checkbox_open_on_move1|Open Cape on Movement|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_OPEN_CAPE_ON_MOVEMENT ? 1 : 0) + "\nadd_checkbox|checkbox_aura1|Aura On / Off|" + to_string(pInfo(peer)->flags & Gtps3::RIFTCAPE_FLAGS_STYLE_2_AURA_ON ? 1 : 0) + "\nadd_checkbox|checkbox_aura_1st1|      Portal Aura|" + to_string(portalAura1) + "\nadd_checkbox|checkbox_aura_2nd1|      Starfield Aura|" + to_string(starfieldAura1) + "\nadd_checkbox|checkbox_aura_3rd1|      Electrical Aura|" + to_string(electricalAura1) + "\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_rift_cape|Cancel|Update|\nadd_quick_exit|\n");
		p.CreatePacket(peer);
	}
}

void PSendRiftwingsDialog(ENetPeer* peer, string error = "\nadd_button|button_manual|Instructions|noflags|0|0|") {
	if (pInfo(peer)->back == 11478) {
		int portalAura0 = 0, portalAura1 = 0;
		int starfieldAura0 = 0, starfieldAura1 = 0;
		int electricalAura0 = 0, electricalAura1 = 0;

		int feathers0 = 0, feathers1 = 0;
		int blades0 = 0, blades1 = 0;
		int scales0 = 0, scales1 = 0;

		if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_PORTAL_AURA && pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_STARFIELD_AURA) {
			electricalAura0 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_PORTAL_AURA) {
			portalAura0 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_STARFIELD_AURA) {
			starfieldAura0 = 1;
		}

		if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_PORTAL_AURA && pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_STARFIELD_AURA) {
			electricalAura1 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_PORTAL_AURA) {
			portalAura1 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_STARFIELD_AURA) {
			starfieldAura1 = 1;
		}


		if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_FEATHERS && pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_BLADES) {
			scales0 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_FEATHERS) {
			feathers0 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_MATERIAL_BLADES) {
			blades0 = 1;
		}

		if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_FEATHERS && pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_BLADES) {
			scales1 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_FEATHERS) {
			feathers1 = 1;
		}
		else if (pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_MATERIAL_BLADES) {
			blades1 = 1;
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wRift Wings``|left|11478|\nadd_spacer|small|\nadd_text_input|text_input_time_cycle|Time Dilation Cycle Time:|" + to_string(pInfo(peer)->_TimeDilation) + "|5|\nadd_checkbox|checkbox_time_cycle|Time Dilation On / Off|" + (to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_TIME_DILATION_ON ? 1 : 0)) + ""+error+"\nadd_spacer|small|\nadd_spacer|small|\nadd_label|big|Wings Style 1|left\nadd_spacer|small|\nadd_label|small|Wings Color:|left\nadd_text_input|text_input_wings_color0|Wings - R,G,B:|" + pInfo(peer)->_CapeStyleColor_1 + "|11|\nadd_spacer|small|\nadd_label|small|Wings Metal Color:|left\nadd_text_input|text_input_metal_color0|Metal Color - R,G,B:|" + pInfo(peer)->_CapeCollarColor_1 + "|11|\nadd_spacer|small|\nadd_spacer|small|\nadd_checkbox|checkbox_open_wings0|Always Open Wings|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_OPEN_WINGS ? 1 : 0) + "\nadd_checkbox|checkbox_closed_wings0|Always Closed Wings|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_CLOSE_WINGS ? 1 : 0) + "\nadd_spacer|small|\nadd_checkbox|checkbox_stamp_particle0|Stamp Particle|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_STAMP_PARTICLE ? 1 : 0) + "\nadd_spacer|small|\nadd_checkbox|checkbox_trail0|Trail On / Off|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_1_TRAIL_ON ? 1 : 0) + "\nadd_checkbox|checkbox_trail_1st0|      Portal Trail|" + to_string(portalAura0) + "\nadd_checkbox|checkbox_trail_2nd0|      Starfield Trail|" + to_string(starfieldAura0) + "\nadd_checkbox|checkbox_trail_3rd0|      Electrical Trail|" + to_string(electricalAura0) + "\nadd_spacer|small|\nadd_label|small|Wings Material:|left\nadd_spacer|small|\nadd_checkbox|checkbox_material_1st0|      Feathers|" + to_string(feathers0) + "\nadd_checkbox|checkbox_material_2nd0|      Blades|" + to_string(blades0) + "\nadd_checkbox|checkbox_material_3rd0|      Scales|" + to_string(scales0) + "\nadd_spacer|small|\nadd_label|big|Wings Style 2|left\nadd_spacer|small|\nadd_label|small|Wings Color:|left\nadd_text_input|text_input_wings_color1|Wings - R,G,B:|" + pInfo(peer)->_CapeStyleColor_2 + "|11|\nadd_spacer|small|\nadd_label|small|Wings Metal Color:|left\nadd_text_input|text_input_metal_color1|Metal Color - R,G,B:|" + pInfo(peer)->_CapeCollarColor_2 + "|11|\nadd_spacer|small|\nadd_spacer|small|\nadd_checkbox|checkbox_open_wings1|Always Open Wings|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_OPEN_WINGS ? 1 : 0) + "\nadd_checkbox|checkbox_closed_wings1|Always Closed Wings|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_CLOSE_WINGS ? 1 : 0) + "\nadd_spacer|small|\nadd_checkbox|checkbox_stamp_particle1|Stamp Particle|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_STAMP_PARTICLE ? 1 : 0) + "\nadd_spacer|small|\nadd_checkbox|checkbox_trail1|Trail On / Off|" + to_string(pInfo(peer)->_flags & Gtps3::RIFTWINGS_FLAGS_STYLE_2_TRAIL_ON ? 1 : 0) + "\nadd_checkbox|checkbox_trail_1st1|      Portal Trail|" + to_string(portalAura1) + "\nadd_checkbox|checkbox_trail_2nd1|      Starfield Trail|" + to_string(starfieldAura1) + "\nadd_checkbox|checkbox_trail_3rd1|      Electrical Trail|" + to_string(electricalAura1) + "\nadd_spacer|small|\nadd_label|small|Wings Material:|left\nadd_spacer|small|\nadd_checkbox|checkbox_material_1st1|      Feathers|" + to_string(feathers1) + "\nadd_checkbox|checkbox_material_2nd1|      Blades|" + to_string(blades1) + "\nadd_checkbox|checkbox_material_3rd1|      Scales|" + to_string(scales1) + "\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_rift_wings|Cancel|Update|\nadd_quick_exit|");
		p.CreatePacket(peer);
	}
}

void nick_update(ENetPeer* clicked_on, ENetPeer* send_to, string name = "") {
	gamepacket_t p2(0, pInfo(clicked_on)->netID);
	p2.Insert("OnNameChanged");
	p2.Insert(get_player_nick_main(clicked_on, name));
	if (send_to == NULL) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(clicked_on)->world) continue;
			p2.CreatePacket(currentPeer);
		}
	}
	else p2.CreatePacket(send_to);
}

void nick_update_2(ENetPeer* clicked_on, ENetPeer* send_to, string name = "") {
	gamepacket_t p2(0, pInfo(clicked_on)->netID);
	p2.Insert("OnNameChanged");
	p2.Insert(get_player_nick(clicked_on, name));
	if (send_to == NULL) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(clicked_on)->world) continue;
			p2.CreatePacket(currentPeer);
		}
	}
	else p2.CreatePacket(send_to);
}

/*
void wildlife_info(ENetPeer* peer, bool store) {
	gamepacket_t p(500);
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAbout Ecologi``|left|13292|\nadd_image_button||interface/large/wtr_lvl9_krdvbn.rttex|bannerlayout|||\nadd_spacer|small|\nadd_textbox|Climate action at your fingertips!|left|\nadd_spacer|small|\nadd_smalltext|Ecologi calls on individuals & businesses to take personal responsibility and help tackle the biggest threat of our generation. Just like here in Growtopia, collectively, with a little input from a lot of people, we have the power to secure our future together, so go out there and play your part to help our world...|left|\nadd_spacer|small|\nadd_smalltext|The Growtopian community has planted:|left|\nadd_textbox|`2" + setGems(planted) + " Eco Seeds``!|left|\nadd_spacer|small|\nadd_image_button||interface/large/wtr_lvl10_dleups.rttex|bannerlayout|||\nadd_spacer|small|\nadd_smalltext|Ecologi is a platform for real climate action. They facilitate the funding of carbon offset projects and tree planting around the world. Their mission is to reduce 50% of global CO2 emissions by 2040 and responsibly plant billions of trees every year.|left|\nadd_spacer|small|\nadd_smalltext|To support these initiatives, Ubisoft will be giving `5$2 for every purchase of the Wildlife Supporter Pack``.|left|\nadd_spacer|small|\nadd_button|openggjui|View Rewards|no_flags|0|0|" + (store == true ? "\nadd_button|open_store|Back|no_flags|0|0|" : "") + "\nend_dialog|openggjui||\nadd_quick_exit|");
	p.CreatePacket(peer);
}

void wildlife_rewards(ENetPeer* peer) {
	gamepacket_t p(500);
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAbout Wildlife Event``|left|13292|\nadd_spacer|small|\nadd_textbox|During the Wildlife Weekend you will gain points for each Eco Seed you plant. Earn enough points to claim a bonus reward. Play your part and help our world...|left|\nadd_spacer|small|\nadd_textbox|Current Progress: " + to_string(pInfo(peer)->planted) + "/20|left|\nadd_spacer|small|\nadd_textbox|Reward:|left|\nadd_label_with_icon|small|Golden Eco Seed|left|13319|\nadd_smalltext|        - Exclusive rare wildlife creatures and items.|left|\nadd_spacer|small|\n" + (pInfo(peer)->planted >= 20 ? "\nadd_button|claimreward|Claim Reward|no_flags|0|0|\nadd_spacer|small|\n" : "") + "add_smalltext|Growtopia is partnering with Ecologi as a part of the Playing for the Planet initiative and the Green Game Jam!|left|\nadd_button|OPEN_GREEN_GAMEJAM_INFO_POPUP|Find out more?|no_flags|0|0|\nadd_quick_exit|\nend_dialog|greengamejam||OK|");
	p.CreatePacket(peer);
}*/

void cheats(ENetPeer* peer) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`0\nadd_label_with_icon|big|`4" + server_name + " `wCheat Options``|left|9726|\nadd_spacer|small|\nadd_textbox|To use cheat simply check the checkbox of the cheat you want to enable and press \"OK\".|left|\nadd_textbox|Auto Farming cheat will be turned off if you leave the world.|left|\nadd_spacer|small|\nadd_smalltext|`7When enabled select any item from your backpack that you want to farm, place it somewhere and autofarming begins until you ran out of blocks.|left|\nadd_smalltext|<CR>This cheat places blocks for you, and farms them for you.|left|" + (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_0 ? "\nadd_checkbox|check_autofarm|Autofarm" + (pInfo(peer)->last_used_block > 0 && pInfo(peer)->last_used_block < items.size() ? " (`w" + items[pInfo(peer)->last_used_block].ori_name + "``)" : "") + "|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_0) + "|" : "\nadd_item_picker|itemid|`wChoose autofarm item``|Choose an item to autofarm|") + "\nadd_text_input|slot|Slots (1-" + (pInfo(peer)->hand != 13700 ? "3" : "6") + a + "):|" + to_string(pInfo(peer)->autofarm_slot) + "|2|\nadd_spacer|small|\nadd_smalltext|`7When enabled it will catch the fish automatically.|\nadd_checkbox|checkbox_cheat_autofish|Autofishing|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_16) + "|\nadd_smalltext|`7When enabled grants you to immune from spike or lava.|\nadd_checkbox|checkbox_cheat_antibounce|Antibounce|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_3) + "|\nadd_smalltext|`7When enabled grants you to move more faster.|\nadd_checkbox|checkbox_cheat_speed|Super Speed|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_4) + "|\nadd_smalltext|`7When enabled grants you to have double jump.|\nadd_checkbox|checkbox_cheat_double_jump|Double Jump|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_2) + "|\nadd_smalltext|`7When enabled grants you to jump higher.|\nadd_checkbox|checkbox_cheat_jump|Super Jump|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_7) + "|\nadd_smalltext|`7When enabled grants you Heat Resist and prevents you dying on lava.|\nadd_checkbox|checkbox_cheat_heat_resist|Heat Resist|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_8) + "|\nadd_smalltext|`7When enabled grants you Strong Punch.|\nadd_checkbox|checkbox_cheat_strong_punch|Strong Punch|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_9) + "|\nadd_smalltext|`7When enabled grants you Long Punch.|\nadd_checkbox|checkbox_cheat_long_punch|Long Punch|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_10) + "|\nadd_smalltext|`7When enabled grants you Long Build.|\nadd_checkbox|checkbox_cheat_long_build|Long Build|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_11) + "|\nadd_smalltext|`7When enabled gems will be directly added to your account when you breaking blocks/harvesting trees.|\nadd_checkbox|checkbox_cheat_autocollect|Auto Pickup Gems|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_6) + "|\nadd_spacer|small|\nadd_textbox|Miscellaneous|size:medium|"/*"\nadd_smalltext|`7When enabled you won't see any other characters inside a world.|\nadd_checkbox|checkbox_cheat_hideother|Hide Other's Character|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_12) + "|\nadd_smalltext|`7When enabled you won't see any other's chat inside a world.|\nadd_checkbox|checkbox_cheat_hidechat|Hide Other's Chat|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_13) + "|*/"\nadd_smalltext|`7When enabled and you wrench someone, it pulls them to you. Of course, you will need permission to do that in that world.|\nadd_checkbox|checkbox_cheat_fastpull|Fast Pull|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_14) + "|\nadd_smalltext|`4Warning: `wBecareful of this cheat turn it off immediately when u done using it.|\nadd_checkbox|checkbox_cheat_fastdrop|Fast Drop [Be Careful With This Cheat]|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_5) + "|\nadd_checkbox|checkbox_cheat_fasttrash|Fast Trash [Be Careful With This Cheat]|" + to_string(pInfo(peer)->cheater_settings & Gtps3::SETTINGS_15) + "|\nadd_smalltext|To use set the set the text`w|\nadd_text_input|chat|Chat prefix/color:|" + pInfo(peer)->chat_prefix + "|20|\nadd_small_font_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|cheats|Cancel|OK|\nadd_quick_exit|");
	p.CreatePacket(peer);
}

/*
void egg_corton_dialog(ENetPeer* peer, int delay = 0) {
	gamepacket_t p(delay);
	p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEaster Gold Streak``|left|10756|\nadd_spacer|small|\nadd_textbox|When the Golden Egg Carton unlocks in the store, you will be given a free reward for every 20 Golden Egg Carton that is purchased.|left|\nadd_spacer|small|\nadd_textbox|Current progress: " + to_string(pInfo(peer)->egg_carton) + "/20|left|\nadd_button|egse_claim_reward|Claim|" + (pInfo(peer)->egg_carton >= 20 ? "noflags" : "off") + "|0|0|\nadd_spacer|small|\nadd_textbox|Claim for a chance to get one of these Epic rewards:|left|\nadd_label_with_icon|small|`2EXCLUSIVE`` - Easter Viking Cape|left|13372|\nadd_label_with_icon|small|Easter Egg - Golden|left|10762|\nadd_label_with_icon|small|Easter Egg - Rainbow|left|2554|\nadd_spacer|small|\nadd_label|big|`wClaim Milestone``|left|\nadd_spacer|small|\nadd_textbox|Claiming rewards during the event increases your chance of getting an Epic reward. You now have a `55.17%`` chance of getting an Epic item.|left|\nadd_spacer|small|\nadd_textbox|Milestones:|left|\ndud_checkbox||1st Claim (2x chance on next claim)|"+(pInfo(peer)->egg_chance >=1 ? "1" : "0") + "|useLabel\ndud_checkbox||2nd Claim (3x chance on next claim)|" + (pInfo(peer)->egg_chance >= 2 ? "1" : "0") + "|useLabel\ndud_checkbox||3rd Claim (4x chance on next claim)|" + (pInfo(peer)->egg_chance >= 3 ? "1" : "0") + "|useLabel\ndud_checkbox||4th Claim (5x chance on next claim)|" + (pInfo(peer)->egg_chance >= 4 ? "1" : "0") + "|useLabel\ndud_checkbox||5th Claim (6x chance on next claim)|" + (pInfo(peer)->egg_chance >= 5 ? "1" : "0") + "|useLabel\nadd_spacer|small|\nend_dialog|egseeventinfo||Thanks!|\nadd_quick_exit|"), p.CreatePacket(peer);
}*/

void sendDeposit(ENetPeer* peer, int timer_ = 0) {
	gamepacket_t p(timer_);
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDonation Box``|left|1452|\nadd_textbox|Deposit in world `w" + World_Stuff.depositworld + "``.|left|\nadd_spacer|small|\nadd_checkbox|checkbox|Diamond Lock (`w<?>``) from `w<?>```#- \"" + pInfo(peer)->tankIDName + "``\"                   |0\nadd_checkbox|checkbox|World Lock (`w<?>``) from `w<?>```#- \"" + pInfo(peer)->tankIDName + "``\"                   |0\nadd_spacer|small|\nadd_url_button|comment|`4Purchase with Credit Card/PayPal``|noflags|" + web_url + "purchase/|Open premium wls shop?|0|0|\nadd_button|shop|`4GTPS Premium Shop``|noflags|0|0|\nadd_image_button||interface/large/deposit_banner.rttex|bannerlayout|flag_frames:1,1,0,0|flag_surfsize:985,256|\nadd_spacer|small|\nadd_label_with_icon|big|`95X BONUS EVENT``|left|9436|\nadd_textbox|`bAUTO-DEPOSIT BOT:``|\nadd_smalltext|`w1.`` Enter the deposit world `2" + World_Stuff.depositworld + "``.|left|\nadd_smalltext|`w2.`` Register your name by messaging bot in Real Growtopia deposit world, example: GTPSBOT = CHECK SIGN! `2/msg GTPSBOT " + pInfo(peer)->tankIDName + "``.|left|\nadd_smalltext|`w3.`` Put any wls you want into the donation box and `4DO NOT ENTER ANY TEXT INTO THE DBOX``! (we accept: Diamond Locks/World Locks/Blue Gem Locks).|left|\nadd_smalltext|`w4.`` Done! Log into gtps and type /shop (next time when you deposit you don't need to register/msg again!).|left|"/*"\nadd_textbox|(`4new``) `0Purchase rate (1 WL = 1 PREMIUM WL):``              Don't forget to add your GTPS Name in the donation box.|\nadd_smalltext|`41000 WL+ = 4% MORE!``|left|\nadd_smalltext|`22500 WL+ = 6% MORE!``|left|\nadd_smalltext|`95000 WL+ = 10% MORE!``|left|*/"\nadd_spacer|small|\nadd_textbox|Deposit in world `w" + World_Stuff.depositworld + "``.|left|\nend_dialog|gazette|Cancel||");
	p.CreatePacket(peer);
}

void growpass_tasks(ENetPeer* peer) {
	gamepacket_t p(500);
	p.Insert("OnDialogRequest");
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	string reset = "`2" + to_string(24 - newtime.tm_hour) + " hours" + (60 - newtime.tm_min != 0 ? ", " + to_string(60 - newtime.tm_min) + " mins" : "") + "``";
	if (pInfo(peer)->gp == 0) p.Insert("set_default_color|`o\nstart_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,0;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,1;width:0.15;min_width:60;|\nadd_custom_button|tab_perks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,2;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_label_with_icon|big|Grow Pass Tasks|left|9222|\nadd_spacer|small|\nadd_progress_bar|Grow Pass Points:|small||" + to_string((pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points)) + "|2100| (" + to_string((pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points)) + "/2100)|\nadd_spacer|small|\nadd_smalltext|All daily activities will reset in " + reset + "|left|\nadd_custom_textbox|`5Royal Grow Pass ONLY``|size:medium;state:disabled|\nadd_label_with_icon|small|`8Claim Daily Gems:`` Claim 4,000 gems once per day.|left|2946|state:disabled;|\nadd_custom_textbox|`5          150 Grow Pass Points``|size:small;state:disabled|\nadd_button|daily_quests|`wDaily Quests``|noflags|0|0|\nadd_custom_textbox|`5          40 Grow Pass Points``|size:small|\nadd_button|daily_quests|`wLife Tasks``|noflags|0|0|\nadd_custom_textbox|`5          20 Grow Pass Points each``|size:small|\nadd_button|life_goals|`wDaily Tasks``|noflags|0|0|\nadd_custom_textbox|`5          20 Grow Pass Points each``|size:small|\nadd_spacer|small|\nadd_custom_textbox|Purchase a Royal Grow Pass to unlock daily bonuses.|size:medium|\nadd_spacer|small|\nadd_label_with_icon|small|`8Gem Bonus``: Earn 30 Gems, for 3 bonus Gems|left|2946|state:disabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:disabled|\nadd_label_with_icon|small|`8Fish Bonus``: Double fish for your first catch when Fishing.|left|2946|state:disabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:disabled|\nadd_label_with_icon|small|`8Surgery Bonus``: Double prize for your first Surgery.|left|2946|state:disabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:disabled|\nadd_label_with_icon|small|`8Geiger Bonus``: Double items with your first Geiger Counter use.|left|2946|state:disabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:disabled|\nadd_label_with_icon|small|`8Token Bonus``: Get 1,000xp with your first Growtoken.|left|2946|state:disabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:disabled|\nadd_label_with_icon|small|`8Wolf Bonus``: Double prize for your first Wolfworld.|left|2946|state:disabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:disabled|\nadd_label_with_icon|small|`8Mega Bonus``: Get 2 Growtokens for earning all other Daily Bonuses!|left|2946|state:disabled;|\nadd_custom_textbox|`5          40 Grow Pass Points``|size:small;state:disabled|\nadd_spacer|small|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|battlepass_tasks||Close|");
	else p.Insert("set_default_color|`o\nstart_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,0;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,1;width:0.15;min_width:60;|\nadd_custom_button|tab_perks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,2;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_label_with_icon|big|Grow Pass Tasks|left|9222|\nadd_spacer|small|\nadd_progress_bar|Grow Pass Points:|small||" + to_string((pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points)) + "|2100| (" + to_string((pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points)) + "/2100)|\nadd_spacer|small|\nadd_smalltext|All daily activities will reset in "+ reset +"|left|\nadd_custom_textbox|`5Royal Grow Pass ONLY``|size:medium;state:enabled|\nadd_label_with_icon|small|`8Claim Daily Gems:`` Claim 4,000 gems once per day.|left|2946|state:enabled;|\nadd_custom_textbox|`5          150 Grow Pass Points``|size:small;state:enabled|\nadd_button|daily_quests|`wDaily Quests``|noflags|0|0|\nadd_custom_textbox|`5          40 Grow Pass Points``|size:small|\nadd_button|daily_quests|`wLife Tasks``|noflags|0|0|\nadd_custom_textbox|`5          20 Grow Pass Points each``|size:small|\nadd_button|life_goals|`wDaily Tasks``|noflags|0|0|\nadd_custom_textbox|`5          20 Grow Pass Points each``|size:small|\nadd_spacer|small|\nadd_custom_textbox|Daily Bonuses|size:medium|\nadd_spacer|small|\nadd_label_with_icon|small|`8Gem Bonus``: Earn 30 Gems, for 3 bonus Gems|left|2946|state:enabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:enabled|\nadd_label_with_icon|small|`8Fish Bonus``: Double fish for your first catch when Fishing.|left|2946|state:enabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:enabled|\nadd_label_with_icon|small|`8Surgery Bonus``: Double prize for your first Surgery.|left|2946|state:enabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:enabled|\nadd_label_with_icon|small|`8Geiger Bonus``: Double items with your first Geiger Counter use.|left|2946|state:enabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:enabled|\nadd_label_with_icon|small|`8Token Bonus``: Get 1,000xp with your first Growtoken.|left|2946|state:enabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:enabled|\nadd_label_with_icon|small|`8Wolf Bonus``: Double prize for your first Wolfworld.|left|2946|state:enabled;|\nadd_custom_textbox|`5          10 Grow Pass Points``|size:small;state:enabled|\nadd_label_with_icon|small|`8Mega Bonus``: Get 2 Growtokens for earning all other Daily Bonuses!|left|2946|state:enabled;|\nadd_custom_textbox|`5          40 Grow Pass Points``|size:small;state:enabled|\nadd_spacer|small|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|battlepass_tasks||Close|");
	p.CreatePacket(peer);
}

void growpass_rewards(ENetPeer* peer) {
	int second_part = 0;
	second_part = (pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points) - 900;
	if (second_part < 0) second_part = 0;
	gamepacket_t p(500);
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nstart_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,0;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,1;width:0.15;min_width:60;|\nadd_custom_button|tab_perks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,2;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_image_button|growpass_buy|interface/large/gui_shop_grow_pass_buy.rttex|bannerlayout|OPENSTORE|main/rt_grope_battlepass_bundle01|-5.0|\nadd_spacer|small|\nadd_custom_textbox|`wGrow Pass Points: " + to_string((pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points)) + "/2100``|size:medium|\nadd_spacer|small|\nadd_custom_margin|x:0;y:150|\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|6||" + to_string(pInfo(peer)->growpass_points > 900 ? 900 : pInfo(peer)->growpass_points) + "|900|pre_icon|6|0.05|0|1000|64|0.005|barBG_0|\nadd_custom_margin|x:0;y:150|\nadd_custom_button|claim_p2p_150|icon:"+to_string(grow_pass_item) + ";state:enabled;color:" + (pInfo(peer)->growpass_points < 150 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.166667;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_150;top:0.25;left:0.25;size:small|\nadd_custom_label|`5150|target:claim_p2p_150;top:0.62;|\nadd_custom_button|claim_p2p_300|icon:13472;state:enabled;color:" + (pInfo(peer)->growpass_points < 300 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.333333;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_300;top:0.25;left:0.25;size:small|\nadd_custom_label|`5300|target:claim_p2p_300;top:0.62;|\nadd_custom_button|claim_p2p_450|icon:10858;state:enabled;color:" + (pInfo(peer)->growpass_points < 450 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.5;display:inline_free;|\nadd_custom_label|2|target:claim_p2p_450;top:0.25;left:0.25;size:small|\nadd_custom_label|`5450|target:claim_p2p_450;top:0.62;|\nadd_custom_button|claim_p2p_600|icon:1486;state:enabled;color:" + (pInfo(peer)->growpass_points < 600 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.666667;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_600;top:0.25;left:0.25;size:small|\nadd_custom_label|`5600|target:claim_p2p_600;top:0.62;|\nadd_custom_button|claim_p2p_750|icon:2478;state:enabled;color:" + (pInfo(peer)->growpass_points < 750 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:0.833333;display:inline_free;|\nadd_custom_label|10|target:claim_p2p_750;top:0.25;left:0.25;size:small|\nadd_custom_label|`5750|target:claim_p2p_750;top:0.62;|\nadd_custom_button|claim_p2p_900|icon:2480;state:enabled;color:" + (pInfo(peer)->growpass_points < 900 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_0;top:-1.0;left:1;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_900;top:0.25;left:0.25;size:small|\nadd_custom_label|`5900|target:claim_p2p_900;top:0.62;|\nadd_custom_button|claim_f2p_300|icon:10836;state:enabled;color:" + (pInfo(peer)->growpass_points < 300 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:0.333333;display:inline_free;|\nadd_custom_label|1|target:claim_f2p_300;top:0.25;left:0.25;size:small|\nadd_custom_button|claim_f2p_600|icon:10838;state:enabled;color:" + (pInfo(peer)->growpass_points < 600 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:0.666667;display:inline_free;|\nadd_custom_label|1|target:claim_f2p_600;top:0.25;left:0.25;size:small|\nadd_custom_button|claim_f2p_900|icon:1486;state:enabled;color:" + (pInfo(peer)->growpass_points < 900 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,0.25;anchor:barBG_0;top:1.0;left:1;display:inline_free;|\nadd_custom_label|1|target:claim_f2p_900;top:0.25;left:0.25;size:small|\nreset_placement_x|\nadd_custom_margin|x:0;y:150|\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|6||" + to_string((second_part > 1200 ? 1200 : second_part)) + "|1200|pre_icon|6|0.05|0|1000|64|0.005|barBG_1|\nadd_custom_margin|x:0;y:150|\nadd_custom_button|claim_p2p_1100|icon:8196;state:enabled;color:" + (pInfo(peer)->growpass_points < 1100 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_1;top:-1.0;left:0.166667;display:inline_free;|\nadd_custom_label|4|target:claim_p2p_1100;top:0.25;left:0.25;size:small|\nadd_custom_label|`51100|target:claim_p2p_1100;top:0.62;|\nadd_custom_button|claim_p2p_1300|icon:1486;state:enabled;color:" + (pInfo(peer)->growpass_points < 1300 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_1;top:-1.0;left:0.333333;display:inline_free;|\nadd_custom_label|2|target:claim_p2p_1300;top:0.25;left:0.25;size:small|\nadd_custom_label|`51300|target:claim_p2p_1300;top:0.62;|\nadd_custom_button|claim_p2p_1500|icon:6140;state:enabled;color:" + (pInfo(peer)->growpass_points < 1500 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_1;top:-1.0;left:0.5;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_1500;top:0.25;left:0.25;size:small|\nadd_custom_label|`51500|target:claim_p2p_1500;top:0.62;|\nadd_custom_button|claim_p2p_1700|icon:2480;state:enabled;color:" + (pInfo(peer)->growpass_points < 1700 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_1;top:-1.0;left:0.666667;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_1700;top:0.25;left:0.25;size:small|\nadd_custom_label|`51700|target:claim_p2p_1700;top:0.62;|\nadd_custom_button|claim_p2p_1900|icon:3562;state:enabled;color:" + (pInfo(peer)->growpass_points < 1900 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_1;top:-1.0;left:0.833333;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_1900;top:0.25;left:0.25;size:small|\nadd_custom_label|`51900|target:claim_p2p_1900;top:0.62;|\nadd_custom_button|claim_p2p_2100|icon:" + to_string(grow_pass_item+2) + ";state:enabled;color:" + (pInfo(peer)->growpass_points < 2100 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,-0.5;anchor:barBG_1;top:-1.0;left:1;display:inline_free;|\nadd_custom_label|1|target:claim_p2p_2100;top:0.25;left:0.25;size:small|\nadd_custom_label|`52100|target:claim_p2p_2100;top:0.62;|\nadd_custom_button|claim_f2p_1300|icon:10838;state:enabled;color:" + (pInfo(peer)->growpass_points < 1300 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,0.25;anchor:barBG_1;top:1.0;left:0.333333;display:inline_free;|\nadd_custom_label|1|target:claim_f2p_1300;top:0.25;left:0.25;size:small|\nadd_custom_button|claim_f2p_1700|icon:10836;state:enabled;color:" + (pInfo(peer)->growpass_points < 1700 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,0.25;anchor:barBG_1;top:1.0;left:0.666667;display:inline_free;|\nadd_custom_label|1|target:claim_f2p_1700;top:0.25;left:0.25;size:small|\nadd_custom_button|claim_f2p_2100|icon:2992;state:enabled;color:" + (pInfo(peer)->growpass_points < 2100 ? "128,128,128,180;border:grey;" : "255,255,255,255;border:blue;") + "preset:listitem;margin_rself:0,0.25;anchor:barBG_1;top:1.0;left:1;display:inline_free;|\nadd_custom_label|1|target:claim_f2p_2100;top:0.25;left:0.25;size:small|\nreset_placement_x|\nadd_custom_textbox|Available for purchase from the store upon reaching 2100 Grow Pass Points.``|size:small|\nadd_spacer|small|\nadd_custom_button|itemomonth|image:interface/large/store_buttons/store_buttons37.rttex;image_size:256,160;frame:3,2;width:0.35;action:store;state:disabled;url:main/itemomonth;|\nadd_custom_label|BUY IN STORE|target:itemomonth;top:0.85;left:0.5|\nadd_custom_spacer|x:0.15|\nadd_custom_button|itemomonth2|image:interface/large/store_buttons/store_buttons37.rttex;image_size:256,160;frame:1,2;width:0.35;action:store;state:disabled;url:main/itemomonth2;|\nadd_custom_label|BUY IN STORE|target:itemomonth2;top:0.85;left:0.5|\nadd_quick_exit|\nend_dialog|battlepass_tasks||Close|");
	p.CreatePacket(peer);
}

void growpass_perks(ENetPeer* peer) {
	gamepacket_t p(500);
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\ndisable_resize|\nstart_custom_tabs|\nadd_custom_button|tab_rewards|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,0;width:0.15;min_width:60;|\nadd_custom_button|tab_tasks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:0,1;width:0.15;min_width:60;|\nadd_custom_button|tab_perks|image:interface/large/btn_passtabs.rttex;image_size:228,92;frame:1,2;width:0.15;min_width:60;|\nend_custom_tabs|\nadd_label_with_icon|big|Royal Grow Pass Perks|left|9222|\nadd_spacer|small|\nadd_progress_bar|Grow Pass Points:|small||" + to_string((pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points)) + "|2100| (" + to_string((pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points)) + "/2100)|\nadd_spacer|small|\nadd_custom_textbox|`wExclusive buffs that are available for the entire month for all Royal Grow Pass members.``|size:medium|\nadd_image_button|growpass_buy|interface/large/gui_shop_grow_pass_buy.rttex|bannerlayout|OPENSTORE|main/rt_grope_battlepass_bundle01|-5.0|\nadd_spacer|small|\nadd_custom_textbox|`s  - Double Grow Pass Points for all Grow Pass Activities``|size:medium|\nadd_custom_textbox|`s  - Unlock all daily bonuses``|size:medium|\nadd_custom_textbox|`s  - Claim 4,000 gems every day``|size:medium|\nadd_custom_textbox|`s  - A Growth Time reduction on all seeds planted``|size:medium|\nadd_custom_textbox|`s  - A Chance for Bonus XP``|size:medium|\nadd_custom_textbox|`s  - Exclusive skin colours``|size:medium|\nadd_custom_textbox|`s  - Go in the draw to pick the \"sub item\" for next month's Royal Grow Pass.``|size:medium|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog|battlepass_tasks||Close|");
	p.CreatePacket(peer);
}

void daily_quest_info(ENetPeer* p_) {
	string CQ = "", quest_info = "";
	// Carnival Quest
	if (pInfo(p_)->C_QuestKind == 1) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Delivered";
	else if (pInfo(p_)->C_QuestKind == 2) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Rarity of fruits plucked";
	else if (pInfo(p_)->C_QuestKind == 3) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Rarity of trees planted";
	else if (pInfo(p_)->C_QuestKind == 4) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Blocks destroyed";
	else if (pInfo(p_)->C_QuestKind == 5) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Rarity of blocks destroyed";
	else if (pInfo(p_)->C_QuestKind == 6) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " XP earned";
	else if (pInfo(p_)->C_QuestKind == 7) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Gems delivered";
	else if (pInfo(p_)->C_QuestKind == 8) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " World Lock Delivered";
	else if (pInfo(p_)->C_QuestKind == 9) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Growtopians saved";
	else if (pInfo(p_)->C_QuestKind == 10) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Providers collected";
	else if (pInfo(p_)->C_QuestKind == 11) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Growtoken earned";
	else if (pInfo(p_)->C_QuestKind == 12) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Crystal shattered";
	else if (pInfo(p_)->C_QuestKind == 13) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " Radioactive found";
	else if (pInfo(p_)->C_QuestKind == 14) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + "lbs fish caught";
	else if (pInfo(p_)->C_QuestKind == 15) quest_info = "of " + fixint(pInfo(p_)->C_ProgressNeeded) + " DNA Spliced";
	if (pInfo(p_)->lwiz_quest != 0) {
		CQ += "\nadd_textbox|`9Legendary Quest``|left|\nadd_label_with_icon|small|`9" + get_quest_item("", pInfo(p_)->lwiz_quest) + " ``(Step " + to_string(pInfo(p_)->lwiz_step) + "/20) - " + setGems(pInfo(p_)->legendary_quest[pInfo(p_)->lwiz_step - 1][0]) + " of " + setGems(pInfo(p_)->legendary_quest[pInfo(p_)->lwiz_step - 1][1]) + " " + get_quest_name(p_, pInfo(p_)->lwiz_quest, pInfo(p_)->lwiz_step) + "|left|1794|";
	}
	if (pInfo(p_)->C_QuestActive) {
		CQ += "\nadd_textbox|`9Ringmaster Quest``|left|\nadd_label_with_icon|small|`9Quest For The Ring `` (Step " + to_string(pInfo(p_)->C_QuestStep) + "/10) - " + fixint(pInfo(p_)->C_QuestProgress) + " " + quest_info + "|left|1900|";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + pInfo(p_)->tankIDName + "'s Goals|left|982|\nadd_spacer|small|"/*"\nadd_textbox|`9Life Goals``|left|\nadd_smalltext|`9Awesomeness: 13%``|left|\nadd_label_with_icon|small|`3Seed Goal:`` Deliver 200 Rock (0/200)``|left|3|\nadd_label_with_icon|small|`3Gem Goal:`` Smash 5000 rarity of blocks (2884/5000)``|left|112|\nadd_label_with_icon|small|`3Experience Goal:`` Defeat 10 players in Games (0/10)``|left|1488|\nadd_smalltext|Completed Life Goals will reset in 4 hours, 20 mins|left|\nadd_spacer|small|"*/"\nadd_textbox|`9Daily Quest``|left|\nadd_label_with_icon|small|" + (pInfo(p_)->dd == 0 ? "Deliver `2" + to_string(item1c) + " " + items[item1].name + "`` and `2" + to_string(item2c) + " " + items[item2].name + "`` to Crazy Jim" : "`2COMPLETE!`` Check again tomorrow.") + "|left|1486|" + CQ + "\nadd_spacer|small|\nadd_label_with_icon|big|Life Tasks|left|8282|\nadd_spacer|small|\nadd_smalltext|`9Finish and receive awesome rewards from farming, geiger finding or trees harvesting, checkout the prizes below.``|left|\nadd_player_info|`oSurgeon``|" + to_string(pInfo(p_)->s_lvl) + "|" + to_string(pInfo(p_)->s_xp) + "|" + to_string(10 * ((pInfo(p_)->s_lvl * pInfo(p_)->s_lvl) + 2)) + "|\nadd_spacer|small|\nadd_small_font_button|reward_surgery|View Surgery Rewards|noflags|0|0|\nadd_player_info|`oFishing``|" + to_string(pInfo(p_)->ff_lvl) + "|" + to_string(pInfo(p_)->ff_xp) + "|" + to_string(5 * ((pInfo(p_)->ff_lvl * pInfo(p_)->ff_lvl) + 2)) + "|\nadd_spacer|small|\nadd_small_font_button|reward_fishing|View Fishing Rewards|noflags|0|0|\nadd_player_info|`oBuilder``|" + to_string(pInfo(p_)->bb_lvl) + "|" + to_string(pInfo(p_)->bb_xp) + "|" + to_string(100 * ((pInfo(p_)->bb_lvl * pInfo(p_)->bb_lvl) + 2)) + "|\nadd_spacer|small|\nadd_small_font_button|reward_builder|View Builder Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oFarmer``|" + to_string(pInfo(p_)->t_lvl) + "|" + to_string(pInfo(p_)->t_xp) + "|" + to_string(100 * ((pInfo(p_)->t_lvl * pInfo(p_)->t_lvl) + 2)) + "|\nadd_spacer|small|\nadd_small_font_button|reward_farmer|View Farmer Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oProvider``|" + to_string(pInfo(p_)->p_lvl) + "|" + to_string(pInfo(p_)->p_xp) + "|" + to_string(75 * ((pInfo(p_)->p_lvl * pInfo(p_)->p_lvl) + 2)) + "|\nadd_spacer|small|\nadd_small_font_button|reward_provider|View Provider Rewards|noflags|0|0|\nadd_spacer|small|\nadd_player_info|`oGeiger Hunting``|" + to_string(pInfo(p_)->g_lvl) + "|" + to_string(pInfo(p_)->g_xp) + "|" + to_string(5 * ((pInfo(p_)->g_lvl * pInfo(p_)->g_lvl) + 2)) + "|\nadd_spacer|small|\nadd_small_font_button|reward_geiger|View Geiger Hunting Rewards|noflags|0|0|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	p.CreatePacket(p_);
}
/*
void send_fruit_mixer(ENetPeer* peer, int time = 0) {
	gamepacket_t p(time);
	p.Insert("OnDialogRequest");
	p.Insert("add_label_with_icon|big|`wSuper Fruit Mixing Machine``|left|13548|\nadd_spacer|small|\nadd_textbox|Combine 3 different types of tropical fruit into the mixer! Depending on which fruit you mix, the chance of receiving a tropical item related to that fruit increases.|left|\nadd_spacer|small|\nadd_textbox|The total number of fruits should add up to 50 to juice a new item.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|\nadd_button_with_icon|spp_slot_btn_0||staticGreyFrame|" + to_string(pInfo(peer)->fruit_1) + "|" + (pInfo(peer)->fruit_1_c == 0 ? "" : to_string(pInfo(peer)->fruit_1_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|spp_slot_btn_1||staticGreyFrame|" + to_string(pInfo(peer)->fruit_2) + "|" + (pInfo(peer)->fruit_2_c == 0 ? "" : to_string(pInfo(peer)->fruit_2_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon|spp_slot_btn_2||staticGreyFrame|" + to_string(pInfo(peer)->fruit_3) + "|" + (pInfo(peer)->fruit_3_c == 0 ? "" : to_string(pInfo(peer)->fruit_3_c)) + "|\nadd_custom_margin|x:5;y:0|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_textbox|Total Fruits: `4" + to_string(pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c) + "``/50|left|\nadd_spacer|small|\nadd_button|" + (pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c == 50 ? "blend" : "") + "|Blend Fruits|" + (pInfo(peer)->fruit_1_c + pInfo(peer)->fruit_2_c + pInfo(peer)->fruit_3_c == 50 ? "noflags" : "off") + "|0|0|\nadd_quick_exit|\nend_dialog|fruit_mixer_dialog|Close||");
	p.CreatePacket(peer);
}*/
void news(ENetPeer* peer) {
	pInfo(peer)->temp_radio = false;
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	{
		const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
		string month = months[newtime.tm_mon], translated = "", str = to_string(today_day), locke = "";
		if (str == "1" || str == "2" || str == "3" || str == "4" || str == "5" || str == "6" || str == "7" || str == "8" || str == "9") str = "0" + str;
		if (str == "01" || str == "21") translated = "st";
		else if (str == "02" || str == "22") translated = "nd";
		else if (str == "03") translated = "rd";
		else translated = "th";
		locke+= "\nadd_spacer|small|\nadd_textbox|`5Recent updates:``|left|"+ update_news_list;
		//if (newtime.tm_wday == 5 or newtime.tm_wday == 6 or newtime.tm_wday == 0 or newtime.tm_wday == 1) locke += "\nadd_spacer|small|\nadd_textbox|`oToday Growtopia is being paid a visit by `5Locke`` the traveling salesman! He comes one day a month to hawk his fabulous wares, though this time he'll stick around a day and a half to introduce himself. Checkout the world `5LOCKETOWN``!``|left|";
		string wotd_text = (World_Stuff.wotd.size() == 0 ? "" : World_Stuff.wotd[World_Stuff.wotd.size() - 1]);
		if (not wotd_text.empty()) {
			vector<string> a_ = explode("|", wotd_text);
			wotd_text = "\nadd_spacer|small|\nadd_button|warp_to_"+ a + a_[0].c_str() +"|`wWOTD: `1" + a + a_[0].c_str() + "`` by `#" + a_[1].c_str() + "``|noflags|0|0|";
		}
		news_texture = "set_default_color|`o\nadd_label_with_icon|big|`wThe " + server_name + " Gazette``|left|5016|\nadd_image_button||interface/large/" + (news_banner.empty() ? server_name + "_banner.rttex" : news_banner) + "|bannerlayout|||\nadd_spacer|small|\nadd_image_button|iotm_layout|interface/gtps/discord.rttex|3imageslayout|" + discord_url + "|Do you want to join our Discord Server?|\nadd_image_button|rules|interface/gtps/rules.rttex|3imageslayout|||\nadd_image_button|promote|interface/gtps/features.rttex|3imageslayout|||\nadd_spacer|small|\nadd_textbox|`w" + month + " " + to_string(today_day) + "" + translated + ": ```5" + news_title + "``|left|\nadd_spacer|small|\nadd_image_button||interface/large/gazette/gtps_1.rttex|3imageslayout|||\nadd_image_button||interface/large/gazette/gtps_2.rttex|3imageslayout|||\nadd_image_button||interface/large/gazette/gtps_3.rttex|3imageslayout|||"/*"\nadd_spacer|small|\nadd_image_button|iotm_layout|interface/large/gazette/gazette_3columns_feature_btn04.rttex|3imageslayout|||\nadd_image_button|iotm_layout|interface/large/gazette/gazette_3columns_feature_btn03.rttex|3imageslayout|||\nadd_image_button|iotm_layout|interface/large/gazette/gazette_3columns_feature_btn10.rttex|3imageslayout|||"*/"" + locke + "\nadd_spacer|small|\nadd_textbox|`$For in-game updates and other information check our`` `2discord's`` `$server channel`` `2#updates``.|left|" + wotd_text + "\nadd_spacer|small|\nadd_image_button|deposit|interface/large/gtps_continue.rttex|3imageslayout|||\nend_dialog|gazette|\nadd_quick_exit|"; // \nadd_quick_exit|
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest"), p.Insert(news_texture), p.CreatePacket(peer);
}


void view_inventory(ENetPeer* peer) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
			string recently_visited = "";
			int total_items = 0;
			for (auto it = pInfo(currentPeer)->last_visited_worlds.rbegin(); it != pInfo(currentPeer)->last_visited_worlds.rend(); ++it) {
				string a_ = *it + (next(it) != pInfo(currentPeer)->last_visited_worlds.rend() ? "``, " : "``");
				recently_visited += "`#" + a_;
			}
			string inventory = "";
			for (int i_ = 0; i_ < pInfo(currentPeer)->inv.size(); i_++) {
				if (pInfo(currentPeer)->inv[i_].first == 0 || pInfo(currentPeer)->inv[i_].first == 18 || pInfo(currentPeer)->inv[i_].first == 32) continue;
				total_items++;
				inventory += "\nadd_button_with_icon|" + (pInfo(peer)->dev == 1 ? to_string(pInfo(currentPeer)->inv[i_].first) : "") + "||staticBlueFrame|" + to_string(pInfo(currentPeer)->inv[i_].first) + "|" + to_string(pInfo(currentPeer)->inv[i_].second) + "|";
			}
			string item_log = "\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|";
			for (int i_ = 0; i_ < pInfo(currentPeer)->bp.size(); i_++) item_log += "\nadd_button_with_icon||" + items[pInfo(currentPeer)->bp[i_].first].name + "|frame|" + to_string(pInfo(currentPeer)->bp[i_].first) + "|" + to_string(pInfo(currentPeer)->bp[i_].second) + "|";
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|small|`0Inventory of " + get_player_nick(currentPeer) + "'s (" + pInfo(currentPeer)->requestedName + ") - #" + to_string(pInfo(currentPeer)->netID) + "|left|3802|\nadd_spacer|small|\nadd_textbox|Last visited: " + recently_visited + "|\nadd_textbox|Gems: `w" + setGems(pInfo(currentPeer)->gems) + "|\nadd_textbox|Backpack items (`w" + to_string(pInfo(currentPeer)->bp.size()) + "``):|" + (pInfo(currentPeer)->bp.size() >= 1 ? item_log + "\nadd_button_with_icon||END_LIST|noflags|0||" : "no items in backpack.") + "\ntext_scaling_string|50,000OPC|\nadd_textbox|Inventory items (`w" + to_string(total_items) + "``)|" + inventory + (inventory.empty() ? "|" : "\nadd_button_with_icon||END_LIST|noflags|0||") + "\nend_dialog|view_inventory|Continue||\nadd_quick_exit|");
			p.CreatePacket(peer);
			break;
		}
	}
}



void autofarm_status(ENetPeer* peer) {
	if (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_0 && not pInfo(peer)->world.empty()) {
		pInfo(peer)->cheater_settings &= ~Gtps3::SETTINGS_0;
		console_msg(peer, "`oCheat Disabled: Autofarm (`$Cheat Active: Autofarm (cool) -> " + items[pInfo(peer)->last_used_block].ori_name + " ``mod removed)");
		pInfo(peer)->autofarm_x = -1;
		pInfo(peer)->autofarm_y = -1;
		pInfo(peer)->last_used_block = 0;
	}
}

void receive_subscribtion(ENetPeer* peer, int item) {
	pInfo(peer)->subscriber = true;
	if (item == 129) item = 9266;
	else if (item == 130)  item = 6856;
	else if (item == 131)  item = 6858;
	else if (item == 132)  item = 6860;
	else if (item == 133)  item = 8188;
	OnSetGems(peer, items[item].max_gems3);
	gamepacket_t p2;
	p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("Received `o" + setGems(items[item].max_gems3) + "`` Gems!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
}

void clear_event() {
	can_event = true;
	next_event = time(nullptr) + 259200;
	top_basher_list.clear();
	top_old_winners.clear();
	top_old_guild_winners.clear();
	top_guild_winners.clear();
	vector<pair<long long int, string>> top_tiers = top_basher;
	sort(top_tiers.begin(), top_tiers.end());
	reverse(top_tiers.begin(), top_tiers.end());
	top_tiers.resize(10);
	for (uint8_t i = 0; i < top_tiers.size(); i++) {
		if (not top_tiers[i].second.empty()) {
			top_basher_winners.push_back(make_pair(i + 1, top_tiers[i].second));
			if (i + 1 == 1 || i + 1 == 2 || i + 1 == 3) top_old_winners += "\nadd_label_with_icon|small|" + to_string(i + 1) + " : " + top_tiers[i].second + " , Score: " + setGems_(top_tiers[i].first) + "|left|" + (i + 1 == 1 ? "6094" : (i + 1 == 2 ? "6132" : "6130")) + "|";
			else top_old_winners += "\nadd_smalltext|" + to_string(i + 1) + " : " + top_tiers[i].second + " , Score: " + setGems_(top_tiers[i].first) + "|";
		}
	}
	top_tiers = top_guild;
	sort(top_tiers.begin(), top_tiers.end());
	reverse(top_tiers.begin(), top_tiers.end());
	top_tiers.resize(10);
	for (uint8_t i = 0; i < top_tiers.size(); i++) {
		if (not top_tiers[i].second.empty()) {
			top_guild_winners.push_back(make_pair(i + 1, top_tiers[i].second));
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [&](const Guild& a) { return a.guild_id == atoi(top_tiers[i].second.c_str()); });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				if (i + 1 == 1 || i + 1 == 2 || i + 1 == 3) top_old_guild_winners += "\nadd_label_with_icon|small|" + to_string(i + 1) + " : " + guild_information->guild_name + " , Score: " + setGems_(top_tiers[i].first) + "|left|" + (i + 1 == 1 ? "6094" : (i + 1 == 2 ? "6132" : "6130")) + "|";
				else top_old_guild_winners += "\nadd_smalltext|" + to_string(i + 1) + " : " + guild_information->guild_name + " , Score: " + setGems_(top_tiers[i].first) + "|";
			}
		}
	}
	if (top_old_winners.empty()) top_old_winners = "\nadd_smalltext|We couldn't find last winners.|";
	if (top_old_guild_winners.empty()) top_old_guild_winners = "\nadd_smalltext|We couldn't find last winners.|";
;	top_basher.clear();
	top_guild.clear();
}

void start_event() {
	old_event_item = event_item;
	event_item = get_next_event();
	can_event = false;
	current_event = time(nullptr) + 691200;
	gamepacket_t p;
	p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9Seasonal Clash event has started: " + items[event_item].hand_scythe_text + " - " + items[event_item].description + "``");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		p.CreatePacket(currentPeer);
	}
}


void clear_event2() {
	Balloon_Warz.top_balloon_winners.clear();
	vector<pair<int, string>> top_tier = Balloon_Warz.top_balloon;
	sort(top_tier.begin(), top_tier.end());
	reverse(top_tier.begin(), top_tier.end());
	top_tier.resize(10);
	for (uint8_t i = 0; i < top_tier.size(); i++) {
		Balloon_Warz.top_balloon_winners.push_back(make_pair(i + 1, top_tier[i].second));
	}
	Balloon_Warz.top_balloon.clear();
}
void guide_book(ENetPeer* peer) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_quick_exit\nadd_label_with_icon|big|`wGuidebook|left|6336|\nadd_spacer|small|\nset_custom_spacing|x:5;y:10|\nadd_custom_button|splicing|image:interface/gtps/gui_splicing.rttex;image_size:495,170;width:0.4;|\nadd_custom_button|combining|image:interface/gtps/gui_combining.rttex;image_size:495,170;width:0.4;|\nadd_custom_break|\nadd_custom_button|combusting|image:interface/gtps/gui_combusting.rttex;image_size:495,170;width:0.4;|\nadd_custom_button|crystals|image:interface/gtps/gui_crystals.rttex;image_size:495,170;width:0.4;|\nset_custom_spacing|x:0;y:0|\nadd_custom_break|\nadd_spacer|small|\nset_custom_spacing|x:5;y:10|\nadd_custom_button|news|image:interface/gtps/gui_news.rttex;image_size:495,170;width:0.4;|\nadd_custom_button|rules|image:interface/gtps/gui_rules.rttex;image_size:495,170;width:0.4;|\nset_custom_spacing|x:0;y:0|\nadd_custom_break|\nend_dialog|guide_book|Close||");
	p.CreatePacket(peer);
}
void splicing_recipe(ENetPeer* peer, vector<string>search) {
	if (search.size() == 0) return;
	if (pInfo(peer)->page_number > search.size()) pInfo(peer)->page_number = search.size() + 26;
	if (pInfo(peer)->page_number < 26) pInfo(peer)->page_number = 26;
	int type = 0, pages = 0;
	bool block = false;
	string error = "";
	if (not pInfo(peer)->page_item.empty() && pInfo(peer)->page_item.length() < 3) error = "\nadd_textbox|`4OOPS:`` You must enter atleast 3 characters.|", pInfo(peer)->page_item = "";
	if (search == splicing) type = 13;
	else if (search == combining) type = 912;
	else if (search == combusting) type = 3062;
	else if (search == crystals) type = 2244;
	string recipe = "", show_number = "", go_back = "";
	if (pInfo(peer)->page_item != "") {
		vector<string> search_item;
		for (int i = 0; i < search.size(); i++) if (to_lower(search[i]).find(to_lower(pInfo(peer)->page_item)) != string::npos) search_item.push_back(search[i]);
		pages = search_item.size();
		if (search_item.size() == 0) recipe = "\nadd_label_with_icon|small|`wRecipe not found!``|left|20|";
		else {
			int search_through = pInfo(peer)->page_number;
			int minimal = 26;
			if (search_through >= pages) search_through = search_item.size();
			show_number = (pInfo(peer)->page_number == 26 ? "1" : to_string(pInfo(peer)->page_number - 26)) + "-" + to_string(search_through);
			if (search_item.size() >= 26) {
				for (int i = pInfo(peer)->page_number - 26; i < search_through; i++) recipe += search_item[i];
				if (search_through > 26) go_back = "\nadd_small_font_button|last_pg|`5Previous Page``|";
			}
			else for (int i = 0; i < search_item.size(); i++) recipe += search_item[i];
		}
	}
	else {
		int search_through = pInfo(peer)->page_number, minimal = 26;
		if (search_through > search.size()) {
			int remove = search.size() - 26;
			if (remove < 26) pInfo(peer)->page_number = search.size() - remove;
			else   pInfo(peer)->page_number = remove;
			minimal = 0;
			show_number = to_string(pInfo(peer)->page_number) + "-" + to_string(search.size());
			block = true;
		}
		else {
			if (pInfo(peer)->page_number > search.size()) show_number = to_string(search.size()) + "-" + to_string(search_through);
			else show_number = (pInfo(peer)->page_number == 26 ? "1" : to_string(pInfo(peer)->page_number - 26)) + "-" + to_string(search_through);
		}
		for (int i = pInfo(peer)->page_number - minimal; i < (block ? search.size() : search_through); i++) recipe += search[i];
		if (search_through > 26) go_back = "\nadd_small_font_button|last_pg|`5Previous Page``|";
	}
	string next_page = "\nadd_small_font_button|next_pg|`5Next Page``|";
	if (block) next_page = "";
	gamepacket_t p;
	p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_quick_exit\nadd_label_with_icon|big|`w"+a + (type == 13 ? "Splicing" : type == 912 ? "Combining" : type == 3062 ? "Combusting" : "Crystals") + " recipes``|left|" + to_string(type) + "|"+ error +"\nadd_textbox|`$" +  (type == 13 ? "Splicing" : type == 912 ? "Combining" : type == 3062 ? "Combusting" : "Crystals") + " recipes``. View all or search by name.|left|\nadd_text_input|query|Search Items|" + pInfo(peer)->page_item + "|32|\nadd_button|search|`wSearch``|\nadd_spacer|small|" + (pInfo(peer)->page_item != "" && pages == 0 ? "" : "\nadd_textbox|`wShowing results " + (show_number)+"/" + (pages == 0 ? to_string(search.size()) : to_string(pages)) + "|") + ((pInfo(peer)->page_item .empty() && pages == 0) or (pInfo(peer)->page_number < pages and block == false) ? next_page : "") + go_back + "\n" + recipe + "\nadd_spacer|small|\nend_dialog|guide_book_" + (type == 13 ? "s" : type == 912 ? "c" : type == 3062 ? "f" : "r") + "||`wBack``|"), p.CreatePacket(peer);
}

void personalize_profile(ENetPeer* p_) {
	time_t s__;
	s__ = time(NULL);
	int days_ = int(s__) / (60 * 60 * 24);
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPersonalize Wrench Menu``|left|12436|\nadd_spacer|small|\nadd_label|small|`oSelect what you want to display to the other players when they view your info in the wrench menu.``|left|\nadd_spacer|small|\nadd_checkbox|checkbox_show_account_age|Display days since account creation?|" + to_string(pInfo(p_)->display_age) + "\nadd_custom_margin|x:30;y:-15|\nadd_custom_textbox|`1Account Age:`` " + to_string(days_ - pInfo(p_)->account_created) + " days|size:small|\nadd_custom_margin|x:-30;y:15|\nadd_spacer|small|" + (pInfo(p_)->home_world .empty() ? "\nadd_label|small|`sDisplay home world?``|left|\nadd_custom_textbox|No homeworld set|size:small|\nadd_custom_textbox|Use '/sethome' to assign the current world as your home world.|size:small|" : "\nadd_checkbox|checkbox_show_homeworld|Display home world?|" + to_string(pInfo(p_)->display_home) + "\nadd_button|visit_home_world_" + pInfo(p_)->home_world + "|`$Visit " + pInfo(p_)->home_world + "``|off|0|0|") + "\nadd_spacer|small|\nadd_button|preview|Preview|noflags|0|0|\nadd_spacer|small|\nadd_button|save|Save Changes|noflags|0|0|\nadd_button|discard|Discard Changes|noflags|0|0|\nend_dialog|personalize_profile|||\nadd_quick_exit|");
	p.CreatePacket(p_);
}


string detailMSTime(int milliseconds) {
	long hr = milliseconds / 3600000;
	milliseconds = milliseconds - 3600000 * hr;
	long min = milliseconds / 60000;
	milliseconds = milliseconds - 60000 * min;
	long sec = milliseconds / 1000;
	milliseconds = milliseconds - 1000 * sec;
	return (hr > 0 ? to_string(hr) + ":" : "") + to_string(min) + ":" + (sec >= 10 ? to_string(sec) + "." : "0" + to_string(sec) + ".") + to_string(milliseconds / 10);
}

void send_crypto(ENetPeer* peer, int times = 0) {
	string inventory = "", trade_history = "";
	for (int i = 0; i < Crypto_Update.crypto.size(); i++) {
		inventory += "\nadd_button_with_icon||" + Crypto_Update.crypto[i].first + "|staticBlueFrame|" + to_string(item_crypto(Crypto_Update.crypto[i].first)) + "|";
		vector<pair<string, int>>::iterator p = find_if(pInfo(peer)->crypto.begin(), pInfo(peer)->crypto.end(), [&](const pair < string, int>& element) { return element.first == Crypto_Update.crypto[i].first; });
		if (p != pInfo(peer)->crypto.end()) inventory += to_string(pInfo(peer)->crypto[p - pInfo(peer)->crypto.begin()].second) + "|";
		else inventory += "0|";
	}
	for (int i = 0; i < Crypto_Update.crypto_history.size(); i++) trade_history += Crypto_Update.crypto_history[i];
	if (trade_history.empty()) trade_history = "\nadd_smalltext|Nothing to show yet.|left|";
	gamepacket_t p(times);
	p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`9GTPS Crypto Currency``|left|9828|\nadd_spacer|small|\nadd_image_button||interface/large/crypto_ban.rttex||||\nadd_spacer|small|\nadd_smalltext|Ho there, friend! A cryptocurrency is a digital currency, which is an alternative form of payment created using encryption algorithms. The use of encryption technologies means that cryptocurrencies function both as a currency and as a virtual accounting system.|left|\nadd_smalltext|You can purchase Crypto Currency by using ė Gems!|left|\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|\nadd_smalltext|Prices are updating in: `2" + to_playmod_time(Crypto_Update.crypto_time - time(nullptr)) + "``|left|\nadd_spacer|small|\nadd_textbox|Available Crypto Currency [`9BUY``]:|left|" + Crypto_Update.crypto_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Available Crypto Currency [`5SELL``]:|left|" + Crypto_Update.crypto_sale_list + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Inventory:|left|" + inventory + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_textbox|Stats:|left|\nadd_smalltext|Crypto Sold (24hrs): " + setGems(Crypto_Update.crypto_sold) + "    Crypto Bought (24hrs): " + setGems(Crypto_Update.crypto_bought) + "    Crypto Tax 0,1%|left|\nadd_spacer|small|\nadd_textbox|Last 15 Transactions:|left|" + trade_history + "\nadd_spacer|small|\nadd_button|tradehistory|`wTrade History``|noflags|0|0|\nend_dialog|crypto|OK||\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

void add_honors(string world, string owner) {
	if (world.empty()) return;
	vector<pair<int, string>>::iterator p = find_if(top_points.begin(), top_points.end(), [&](const pair < int, string>& element) { return element.second.substr(0, element.second.find("|")) == world; });
	if (p != top_points.end()) {
		top_points[p - top_points.begin()].first++;
		top_points[p - top_points.begin()].second = world + "|`#" + owner;
	}
	else top_points.push_back(make_pair(1, world + "|" + owner));
	vector<pair<int, string>>::iterator p2 = find_if(top_overall.begin(), top_overall.end(), [&](const pair < int, string>& element) { return element.second.substr(0, element.second.find("|")) == world; });
	if (p2 != top_overall.end()) {
		top_overall[p2 - top_overall.begin()].first++;
		top_overall[p2 - top_overall.begin()].second = world + "|`#" + owner;
	}
	else top_overall.push_back(make_pair(1, world + "|" + owner));
}

void add_top_player(string name) {
	vector<pair<int, string>>::iterator p = find_if(top_player_points.begin(), top_player_points.end(), [&](const pair < int, string>& element) { return element.second == name; });
	if (p != top_player_points.end()) {
		top_player_points[p - top_player_points.begin()].first++;
		top_player_points[p - top_player_points.begin()].second = name;
	}
	else top_player_points.push_back(make_pair(1, name));
}
string world_category(int category_id) {
	if (category_id == 1) return "Adventure";
	else if (category_id == 2) return "Art";
	else if (category_id == 3) return "Farm";
	else if (category_id == 4) return "Game";
	else if (category_id == 5) return "Information";
	else if (category_id == 6) return "Parkour";
	else if (category_id == 7) return "Roleplay";
	else if (category_id == 8) return "Shop";
	else if (category_id == 9) return "Social";
	else if (category_id == 10) return "Storage";
	else if (category_id == 11) return "Story";
	else if (category_id == 12) return "Trade";
	else if (category_id == 13) return "Guild";
	else if (category_id == 14) return "Puzzle";
	else if (category_id == 15) return "Music";
	else return "";
}

int world_category_id(string category) {
	if (category == "Adventure") return 1;
	else if (category == "Art") return 2;
	else if (category == "Farm") return 3;
	else if (category == "Game") return 4;
	else if (category == "Information") return 5;
	else if (category == "Parkour") return 6;
	else if (category == "Roleplay") return 7;
	else if (category == "Shop") return 8;
	else if (category == "Social") return 9;
	else if (category == "Storage") return 10;
	else if (category == "Story") return 11;
	else if (category == "Trade") return 12;
	else if (category == "Guild") return 13;
	else if (category == "Puzzle") return 14;
	else if (category == "Music") return 15;
	else return 1;
}

void add_ratings(string world, string owner, string world_type, int points) {
	if (points < 100) points = 100;
	else if (points > 500) points = 500;
	if (world.empty() or world_type.empty()) return;
	vector<WorldRate>::iterator p = find_if(world_rating.begin(), world_rating.end(), [&](const WorldRate& a) { return a.name == world; });
	if (p != world_rating.end()) {
		WorldRate* rating = &world_rating[p - world_rating.begin()];
		if (world_type != rating->category) rating->rating.clear();
		rating->rating.push_back(points);
		rating->category = world_type;
	}
	else {
		WorldRate new_data;
		new_data.name = world;
		new_data.category = world_type;
		new_data.rating = { points};
		world_rating.push_back(new_data);
	}
}

int inventory_contains(ENetPeer* peer, int item_id) {
	vector<pair<int, int>>::iterator p = find_if(pInfo(peer)->inv.begin(), pInfo(peer)->inv.end(), [&](const pair < int, int>& element) { return element.first == item_id; });
	if (p != pInfo(peer)->inv.end()) return pInfo(peer)->inv[p - pInfo(peer)->inv.begin()].second;
	else return 0;
}

bool toolavailable(ENetPeer* peer, int tool, int& count) {
	bool have = false;
	count = inventory_contains(peer, tool);
	if (count != 0) have = true;
	if (pInfo(peer)->dirt == 10 && tool != 1258 && tool != 0)
		return false;
	else
		switch (tool) {
		case 1258:
			return have;
		case 1266:
			return have && pInfo(peer)->labworked;
		case 1296:
			return pInfo(peer)->fixable && !pInfo(peer)->fixed;
		case 4316:
			return have && !pInfo(peer)->sounded;
		case 4318:
			return have && !pInfo(peer)->labworked;
		case 4312:
			return have && pInfo(peer)->heart > 0;
		case 1268:
			return have && pInfo(peer)->broken > 0;
		case 4308:
			return have && pInfo(peer)->shattered > 0 && pInfo(peer)->incisions > 0;
		case 4314:
			return have && pInfo(peer)->incisions > 0 && pInfo(peer)->bleeding > 0;
		default:
			return have;
		}
}



void add_cctv(ENetPeer* peer, string type, string extra) {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	WorldCCTV cctv_{};
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		for (int i2_ = 0; i2_ < world_->cctv_settings.size(); i2_++) {
			cctv_.logs = "";
			if (world_->cctv_settings[i2_][6] && to_lower(pInfo(peer)->tankIDName) == to_lower(world_->owner_name)) break;
			if (world_->cctv_settings[i2_][8] && to_lower(pInfo(peer)->tankIDName) != to_lower(world_->owner_name) and !guild_access(peer, world_->guild_id) and  find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end()) break;
			if (world_->cctv_settings[i2_][7] && find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_->admins.end()) break;
			if (type == "entered" && world_->cctv_settings[i2_][4] or type == "left" && world_->cctv_settings[i2_][5] or type == "took" && world_->cctv_settings[i2_][2] or type == "dropped" && world_->cctv_settings[i2_][3] or type == "bought" && world_->cctv_settings[i2_][9]) cctv_.logs = "\nadd_label_with_icon|small|`w" + pInfo(peer)->tankIDName + "`w " + type + "" + (extra .empty() ? " " : " " + extra + " ") + "at " + to_string(newtime.tm_hour) + ":" + to_string(newtime.tm_min) + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "``|left|" + (type == "took" ? "18" : "1400") + "|";
			if (cctv_.logs != "") {
				if (world_->cctv.size() >= 50) world_->cctv.erase(world_->cctv.begin() + 0);
				if (world_->cctv.size() > 51) for (int i = 0; i < world_->cctv.size(); i++) if (i >= 51) world_->cctv.erase(world_->cctv.begin() + 0);
				cctv_.x = world_->cctv_settings[i2_][0], cctv_.y = world_->cctv_settings[i2_][1];
				world_->cctv.push_back(cctv_);
			}
		}
	}
}
void glory_show(ENetPeer* peer) {
	if (pInfo(peer)->glo >= 1) {
		string prizes = "";
		for (int i = 1; i < 10; i++) {
			if (std::find(pInfo(peer)->glo_p.begin(), pInfo(peer)->glo_p.end(), i) != pInfo(peer)->glo_p.end()) prizes += "\nadd_smalltext|`r#" + to_string(i + 1) + ": Level " + to_string(i * 10) + " claimed.``|left|\nadd_label_with_icon|small|`r" + setGems(i * 10000) + " Gems``|left|9438|\nadd_spacer|small|";
			else if (pInfo(peer)->level >= i * 10)prizes += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Level " + to_string(i * 10) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w" + setGems(i * 10000) + " Gems``|left|9438|\nadd_small_font_button|claimreward" + to_string(i) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->level < i * 10) prizes += "\nadd_smalltext|`s#" + to_string(i + 1) + ": Reach Level " + to_string(i * 10) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s" + setGems(i * 10000) + " Gems``|left|9438|";
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wRoad to Glory``|left|9436|\nadd_smalltext|Claim your Road to Glory Rewards Here|left|\nadd_spacer|small|\nadd_progress_bar|`wYour Level: " + to_string(pInfo(peer)->level) + "``|small|LVL 1|" + (pInfo(peer)->level > 90 ? "90" : to_string(pInfo(peer)->level)) + "|90|LVL 90|\nadd_spacer|small|\nadd_smalltext|`r#1: Road to Glory Pack instant reward claimed:``|left|\nadd_label_with_icon|small|`r100,000 Gems``|left|9438|\nadd_spacer|small|" + prizes + "\nadd_spacer|small|\nend_dialog|roadtoglory|Close||\nadd_quick_exit|\n");
		p.CreatePacket(peer);
	}
}


void reward_show(ENetPeer* peer, string reward) {
	string prize = "";
	vector<int> list;
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (reward == "farmer") {
		list = { 98, 228, 1746, 1778, 1830, 5078, 1966, 6948, 6946, 4956 };
		for (int i = 0, lvl = 0; i < list.size(); i++) {
			bool ok = (i == 9 ? true : false);
			if (find(pInfo(peer)->t_p.begin(), pInfo(peer)->t_p.end(), lvl += 5) != pInfo(peer)->t_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Farmer Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 228 || list[i] == 1746 || list[i] == 1778 ? "200" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`r(Unlocked) Unique Farmer's Flag and skin! - Show off your mastery with a flag beside your name``|left|7064|" : "") + "\nadd_spacer|small|";
			else if (pInfo(peer)->t_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Farmer Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 228 || list[i] == 1746 || list[i] == 1778 ? "200" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`w(Unlocked) Unique Farmer's Flag and skin! - Show off your mastery with a flag beside your name``|left|7064|" : "") + "\nadd_small_font_button|t_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->t_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Farmer Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 228 || list[i] == 1746 || list[i] == 1778 ? "200" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`s(Locked) Unique Farmer's Flag and skin! - Show off your mastery with a flag beside your name``|left|7064|" : "");
		}
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|Farmer Rewards|left|7064|\nadd_spacer|small|\nadd_textbox|`9Harvest your trees and receive awesome Farmer Rewards everyday by leveling up``|left|" + prize + "\nadd_player_info|`oFarmer``|" + to_string(pInfo(peer)->t_lvl) + "|" + to_string(pInfo(peer)->t_xp) + "|" + to_string(100 * ((pInfo(peer)->t_lvl * pInfo(peer)->t_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	}
	else if (reward == "builder") {
		list = { 6896, 9522, 6948, 1068, 1966, 1836, 5080, 10754, 1874, 6946 };
		for (int i = 0, lvl = 0; i < list.size(); i++) {
			bool ok = (i == 9 ? true : false);
			if (find(pInfo(peer)->bb_p.begin(), pInfo(peer)->bb_p.end(), lvl += 5) != pInfo(peer)->bb_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Builder Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 9522 ? "200" : "") + "" + (list[i] == 1068 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`r(Unlocked) Unique Builder's Flag and skin! - Show off your mastery with a flag beside your name``|left|7070|" : "") + "\nadd_spacer|small|";
			else if (pInfo(peer)->bb_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Builder Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 9522 ? "200" : "") + "" + (list[i] == 1068 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`w(Unlocked) Unique Builder's Flag and skin! - Show off your mastery with a flag beside your name``|left|7070|" : "") + "\nadd_small_font_button|b_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->bb_lvl < lvl)  prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Builder Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 9522 ? "200" : "") + "" + (list[i] == 1068 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`s(Locked) Unique Builder's Flag and skin! - Show off your mastery with a flag beside your name``|left|7070|" : "");
		}
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|Builder Rewards|left|7070|\nadd_spacer|small|\nadd_textbox|`9Keep breaking blocks and achieve awesome rewards everyday by leveling up``|left|" + prize + "\nadd_player_info|`oBuilder``|" + to_string(pInfo(peer)->bb_lvl) + "|" + to_string(pInfo(peer)->bb_xp) + "|" + to_string(100 * ((pInfo(peer)->bb_lvl * pInfo(peer)->bb_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	}
	else if (reward == "provider") {
		list = { 1008,1044,872,10450,870,5084,876,6950,6952,9166 };
		for (int i = 0, lvl = 0; i < list.size(); i++) {
			if (find(pInfo(peer)->p_p.begin(), pInfo(peer)->p_p.end(), lvl += 5) != pInfo(peer)->p_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Provider Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 1008 ? "5" : list[i] == 1044 ? "50" : list[i] == 872 ? "200" : list[i] == 10450 ? "3" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_spacer|small|";
			else if (pInfo(peer)->p_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Provider Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 1008 ? "5" : list[i] == 1044 ? "50" : list[i] == 872 ? "200" : list[i] == 10450 ? "3" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_small_font_button|p_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->p_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Provider Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 1008 ? "5" : list[i] == 1044 ? "50" : list[i] == 872 ? "200" : list[i] == 10450 ? "3" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|";
		}
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|Provider Rewards|left|866|\nadd_spacer|small|\nadd_textbox|`9A provider is a non-solid foreground block which can be harvested periodically (time depends on the provider) for an item. Harvest your providers and earn awesome rewards by leveling up!``|left|" + prize + "\nadd_player_info|`oProvider``|" + to_string(pInfo(peer)->p_lvl) + "|" + to_string(pInfo(peer)->p_xp) + "|" + to_string(75 * ((pInfo(peer)->p_lvl * pInfo(peer)->p_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	}
	else if (reward == "fishing") {
		list = { 3010, 3018, 3020, 3044, 5740, 3042, 3098, 3100, 3040, 10262 };
		for (int i = 0, lvl = 0; i < list.size(); i++) {
			bool ok = (i == 9 ? true : false);
			if (find(pInfo(peer)->ff_p.begin(), pInfo(peer)->ff_p.end(), lvl += 5) != pInfo(peer)->ff_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Fishing Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 3018 ? "200" : list[i] == 3020 || list[i] == 3098 ? "25" : list[i] == 3044 || list[i] == 3218 ? "50" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`r(Unlocked) Unique Fisherman's Flag and skin! - Show off your mastery with a flag beside your name``|left|7072|" : "") + "\nadd_spacer|small|";
			else if (pInfo(peer)->ff_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Fishing Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 3018 ? "200" : list[i] == 3020 || list[i] == 3098 ? "25" : list[i] == 3044 || list[i] == 3218 ? "50" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`w(Unlocked) Unique Fisherman's Flag and skin! - Show off your mastery with a flag beside your name``|left|7072|" : "") + "\nadd_small_font_button|f_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->ff_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Fishing Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 3018 ? "200" : list[i] == 3020 || list[i] == 3098 ? "25" : list[i] == 3044 || list[i] == 3218 ? "50" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`s(Locked) Unique Fisherman's Flag and skin! - Show off your mastery with a flag beside your name``|left|7072|" : "");
		}
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|Fishing Rewards|left|7072|\nadd_spacer|small|\nadd_textbox|`9In Growtopia, fishing can be done by using bait on water while holding a Fishing Rod. The result from fishing can either be Fish or some random items that are obtainable through fishing.``|left|" + prize + "\nadd_player_info|`oFishing``|" + to_string(pInfo(peer)->ff_lvl) + "|" + to_string(pInfo(peer)->ff_xp) + "|" + to_string(5 * ((pInfo(peer)->ff_lvl * pInfo(peer)->ff_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	}
	else if (reward == "geiger") {
		list = { 4654,262,826,828,9712,3146,2266,5072,5070,9716 };
		for (int i = 0, lvl = 0; i < list.size(); i++) {
			if (find(pInfo(peer)->g_p.begin(), pInfo(peer)->g_p.end(), lvl += 5) != pInfo(peer)->g_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Geiger Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 262 || list[i] == 826 || list[i] == 828 ? "50" : list[i] == 3146 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_spacer|small|";
			else if (pInfo(peer)->g_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Geiger Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 262 || list[i] == 826 || list[i] == 828 ? "50" : list[i] == 3146 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|\nadd_small_font_button|g_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->g_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Geiger Hunting Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 262 || list[i] == 826 || list[i] == 828 ? "50" : list[i] == 3146 ? "10" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|";
		}
		p.Insert("set_default_color|`o\nadd_label_with_icon|small|Geiger Hunting Rewards|left|2204|\nadd_spacer|small|\nadd_textbox|`9Once the player stands for a few moments on the source of radioactivity, the item they found will be added into their inventory. Hunt the items with your geiger and claim your prizes for leveling up!``|left|" + prize + "\nadd_player_info|`oGeiger Hunting``|" + to_string(pInfo(peer)->g_lvl) + "|" + to_string(pInfo(peer)->g_xp) + "|" + to_string(5 * ((pInfo(peer)->g_lvl * pInfo(peer)->g_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	}
	else if (reward == "surgery") {
		list = { 6900, 6982, 6212, 3172, 9068, 6912, 10836, 5142, 3130, 8284 };
		for (int i = 0, lvl = 0; i < list.size(); i++) {
			bool ok = (i == 9 ? true : false);
			if (find(pInfo(peer)->surg_p.begin(), pInfo(peer)->surg_p.end(), lvl += 5) != pInfo(peer)->surg_p.end()) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Surgeon Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`r(Unlocked) " + (list[i] == 6212 ? "50" : list[i] == 3172 || list[i] == 6912 ? "25" : list[i] == 10836 ? "100" : list[i] == 5142 ? "5" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`r(Unlocked) Unique Surgeon's Flag and skin! - Show off your mastery with a flag beside your name``|left|7068|" : "") + "\nadd_spacer|small|";
			else if (pInfo(peer)->s_lvl >= lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Surgeon Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`w(Unlocked) " + (list[i] == 6212 ? "50" : list[i] == 3172 || list[i] == 6912 ? "25" : list[i] == 10836 ? "100" : list[i] == 5142 ? "5" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`w(Unlocked) Unique Surgeon's Flag and skin! - Show off your mastery with a flag beside your name``|left|7068|" : "") + "\nadd_small_font_button|s_claimreward" + to_string(i + 1) + "|Claim Reward|noflags|0|0|";
			else if (pInfo(peer)->s_lvl < lvl) prize += "\nadd_smalltext|`w#" + to_string(i + 1) + ": Reach Surgeon Level " + to_string(lvl) + " to claim this reward:``|left|\nadd_label_with_icon|small|`s(Locked) " + (list[i] == 6212 ? "50" : list[i] == 3172 || list[i] == 6912 ? "25" : list[i] == 10836 ? "100" : list[i] == 5142 ? "5" : "") + " " + items[list[i]].name + "``|left|" + to_string(list[i]) + "|" + (ok ? "\nadd_label_with_icon|small|`s(Locked) Unique Surgeon's Flag and skin! - Show off your mastery with a flag beside your name``|left|7068|" : "");
		}
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|Surgeon Rewards|left|7068|\nadd_spacer|small|\nadd_textbox|`9Surgery is a feature in Growtopia that allows players to perform various types of surgeries on other players using various tools. It was first introduced in the Growtopia General Hospital update on November 21, 2013.`` `2Surgery XP is only added if the surgery was performed on a real patient.``|left|" + prize + "\nadd_player_info|`oSurgeon``|" + to_string(pInfo(peer)->s_lvl) + "|" + to_string(pInfo(peer)->s_xp) + "|" + to_string(10 * ((pInfo(peer)->s_lvl * pInfo(peer)->s_lvl) + 2)) + "|\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
	}
	p.CreatePacket(peer);
}


void backpack_show(ENetPeer* peer) {
	string item_log = "\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|";
	for (int i_ = 0; i_ < pInfo(peer)->bp.size(); i_++) item_log += "\nadd_button_with_icon|" + to_string(i_) + "|" + items[pInfo(peer)->bp[i_].first].name + "|frame|" + to_string(pInfo(peer)->bp[i_].first) + "|" + to_string(pInfo(peer)->bp[i_].second) + "|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBackpack - Level " + to_string(pInfo(peer)->b_l) + "``|left|8430|\nadd_textbox|`w" + to_string(pInfo(peer)->bp.size()) + "/" + to_string(pInfo(peer)->b_l * 10) + "`` items stored.|left|" + (pInfo(peer)->bp.size() >= 1 ? item_log + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nadd_spacer|small|" + (pInfo(peer)->b_l * 10 < 200 ? "\nadd_button|backpack_upgrade_request|`2Upgrade for " + setGems((1000 * ((pInfo(peer)->b_l * pInfo(peer)->b_l) + 25)) * 2) + " gems``|noflags|0|0|" : "") + "" + (pInfo(peer)->bp.size() >= pInfo(peer)->b_l * 10 ? "" : "\nadd_item_picker|itemid|`wStore Item``|Choose an item to store|") + "\nend_dialog|backpack_menu|Exit||\nadd_quick_exit|");
	p.CreatePacket(peer);
}

void shop_tab(ENetPeer* peer, string tab) {

	// \nadd_button|assassin|`oAssassin's Creed Costumes``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` Assassin's Creed: Renaissance House, 10 Assassin's Creed: Renaissance Balustrade, 10 Assassin's Creed: Renaissance Road, 10 Assassin's Creed: Renaissance Arch, 10 Assassin's Creed: Renaissance Roof, 10 Assassin's Creed: Renaissance Scaffolding, 10 Assassin's Creed: Renaissance Topiary, 10 Assassin's Creed: Wanted Poster, 10 Assassin's Creed: Hay Checkpoint<CR><CR>`5Description:`` " + items[12678].description + "``|3|2|25000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|3|6||1||||||0|0|
	
	/*
	* valentine :
	* 
	* \nadd_button|valentines|`oValentine's Goodies``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 5 Golden Booty Chests and 1 Valentine's Card.<CR><CR>`5Description:`` Contains 5 Golden Booty Chests and a bonus Valentine's Card to share the love. Smash the Golden Booty Chests to find a random assortment of Valentine's surprises.|0|4|7500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|wishing_well|`oWell of Love``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 1 Well of Love.<CR><CR>`5Description:`` This Well of Love grants you the one best item out of a stack of Golden Booty Chests. Once the well is full it will provide Pure Love Essence that increases the chance of getting a Golden Heart Crystal when opening Golden Booty Chests, Super Golden Booty Chests and Heartstones.|0|0|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|valentines_weather|`oWeather Machine - Valentine's``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:``1 Weather Machine - Valentine's.<CR><CR>`5Description:`` Love is in the air! Send hearts sailing through pink and fluffy skies with this adorable weather machine and everyone will know what a romantic you are! `5It's a perma-item, is never lost when destroyed.``|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|
	harvest festival:
	\nadd_button|10158|`oMooncake Magnificence``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 3 Mooncake Magnificence. <CR><CR>`5Description:`` A Magnificent Mooncake Pendant! When equipped, this magical pendant emits a balanced glow that responds in harmony with Balance Mooncakes. Whenever a Balance Mooncake is found, there is a chance of dropping up to X3 of them but also the item breaking. The item will only break when 2 or more Balance Mooncakes are dropped at a time. However, it repels Peace, Harmony, Prosperity and Longevity Mooncakes making them less likely to be found when harvesting trees.|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|10158_3|`oMooncake Magnificence Sale!``|interface/large/store_buttons/store_buttons30.rttex|`2You Get:`` 3 Mooncake Magnificence. <CR><CR>`5Description:`` Congratulations! It's community sale time! A pack of 3 Magnificent Mooncake Pendants! When equipped, this magical pendant emits a balanced glow that responds in harmony with Balance Mooncakes. Whenever a Balance Mooncake is found, there is a chance of dropping up to X3 of them but also the item breaking. The item will only break when 2 or more Balance Mooncakes are dropped at a time. However, it repels Peace, Harmony, Prosperity and Longevity Mooncakes making them less likely to be found when harvesting trees.|0|6|12500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12384|`oMystical Lantern``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Mystical Lantern.<CR><CR>`5Description:`` Light the way on your journey.<CR><CR>`#This item is only available during Harvest Festival.``|2|1|300000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12598|`oOffering Table``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Offering Table.<CR><CR>`5Description:`` Offer 10 mooncakes on the table to receive 1 random reward from the Harvest Moon!<CR><CR>`#This item is only available during Harvest Festival.``|1|1|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|1060|`oHarvest Blast``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` A Harvest Moon Blast.<CR><CR>`5Description:`` Celebrate the harvest with a new `2Harvest Moon Blast`` to create a world with a unique harvest moon sky, filled with random trees that are fully grown and ready to harvest!``)|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|
	pineapple:
	string event_happening = "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|\nadd_image_button|image_button|interface/large/wtr_lvl1_salkjd.rttex|bannerlayout|OPENDIALOG|pineapplepartycommunity|\nadd_label|" + setGems(total_pineapple_eaten) + "|target:_button_image_button;size:large;top:0.61;left:0.5|\nadd_button|13500|`oDragon Fruit Dragon``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 1 Dragon Fruit Dragon. <CR><CR>`5Description:`` " + items[13500].description + "|0|7|850000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|tropical_fruits_crate|`oTropical Fruit Crate``|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` 1 Tropical Fruit Crate.<CR><CR>`5Description:`` A crate filled with a large pile of Tropical Fruits! You are guaranteed to receive a Dragon Fruit from it!``|2|3|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pineapple_panic_0_0|`oSuper Pineapple Panic Special``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 2 Pineapple Party Crates.<CR><CR>`5Description:`` A super pineapply crate of juicy `2Pineapples``. You can also get the `5RARE Slippery Pineapple Squishers`` and have a chance of getting a `5Pineapple Roots Gatcha`` ! Note: You get a Super Pineapple Party Crate, place it in your world and break it to get pineapply goodies! This item is `#Untradeable.``|1|6|18000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_label|0/20|target:pineapple_panic_0_0;top:0.69;left:0.15;size:tiny|\nadd_label|<CR><CR>2,000|target:pineapple_panic_0_0;top:0.65;left:0.87;size:tiny|\nadd_label|2x|target:pineapple_panic_0_0;top:0.42;left:0.23;size:tiny|\nadd_button|pineapple_party_pack|`oSuper Pineapple Party Pack``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Pineapple Party Crate.<CR><CR>`5Description:`` A super pineapply crate of juicy `2Pineapples``. You can also get the `5RARE Slippery Pineapple Squishers`` and have a chance of getting a `5Pineapple Gift Box`` ! Note: You get a Super Pineapple Party Crate, place it in your world and break it to get pineapply goodies! This item is `#Untradeable.``|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pineapple_dummy||interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&handle_super_pinappleparty_info|3|4|0|0|||-1|-1||-1|-1||1||||||0|0|";

	summerfest:
	\nadd_image_button|image_button|interface/large/gui_shop_summerfest1.rttex|bannerlayout|OPENDIALOG|showphoenixreturns|\nadd_button|phoenix_dummy||interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&showphoenixreturns|0|6|0|0|`6" + to_string(24 - newtime.tm_hour) + " hours, " + to_string(60 - newtime.tm_min) + " mins``||-1|-1||-1|-1||1||||||0|0|\nadd_spacer|small|\nadd_label|`6"+to_string(6 - phoenix_items_all.size()) + "/6 Found``|target:phoenix_dummy;size:small;top:0.28;left:0.5|\nadd_button|830|`oBeach Blast Bingo!``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Beach Blast, 1 Summer Surprise, 100 Fireworks. <CR><CR>`5Description:`` It's hot out there! Don't you want to go to the beach? Now you can make your own beach with a Beach Blast device and the 100 Fireworks needed to power it. The Beach Blast creates a brand new world set up as a beach, full of cool new Summer items. As a bonus, you'll get a Summer Surprise and a chance of a Ultra White Fragment or Ultra Purple Fragment too! (available during Summerfest week only!|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|

	beach party:
\nadd_image_button|image_button|interface/large/gui_event_beachparty.rttex|bannerlayout|OPENDIALOG||\nadd_button|beach_party_ticket|`oBeach Party Ticket``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Beach Party Ticket.<CR><CR>`5Description:`` A ticket for the most exclusive beach party of your life! Go to BEACHPARTYGAME world and punch the Bouncer NPC to be entered in the game! Then when the game starts break the sand to uncover clams and smash them for some sweet pearls!|3|5|5000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|0|3||1||||||0|0|\nadd_button|pearl_dummy|`oPearl Sparkled Shield``|interface/large/store_buttons/store_buttons40.rttex|OPENDIALOG&warp_player_into_beach_world|3|4|0|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|beachparty_dummy|`oJoin to Beach Party!``|interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&warp_player_into_beach_world|2|5|0|0|||-1|-1||-1|-1||1||||||0|0|
\nadd_image_button|image_button|interface/large/gui_event_beachparty.rttex|bannerlayout|OPENDIALOG||\nadd_button|beach_party_ticket|`oBeach Party Ticket``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Beach Party Ticket.<CR><CR>`5Description:`` A ticket for the most exclusive beach party of your life! Go to BEACHPARTYGAME world and punch the Bouncer NPC to be entered in the game! Then when the game starts break the sand to uncover clams and smash them for some sweet pearls!|3|5|5000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|0|3||1||||||0|0|\nadd_button|beachparty_item_of_the_weekend|`oThis weekend only!``|interface/large/store_buttons/store_buttons40.rttex|OPENDIALOG&warp_player_into_beach_world|3|4|0|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|beachparty_dummy|`oJoin to Beach Party!``|interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&warp_player_into_beach_world|2|5|0|0|||-1|-1||-1|-1||1||||||0|0|
	garuda glory:
	\nadd_image_button|image_button|interface/large/gui_shop_garuda.rttex|bannerlayout|OPENDIALOG|claimgoldengarudachest|\nadd_button|12354|`oGaruda Wings ``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Garuda Wings.<CR><CR>`5Description:`` Fire yourself up with the wings of the ancient Garuda!|4|5|1500000|0|||-1|-1||-1|-1||1||||||0|0|" + (pInfo(peer)->garuda < 15 ? "\nadd_button|garuda_chest_progress|`oGaruda Chest Progress! ``|interface/large/store_buttons/store_buttons39.rttex|OPENDIALOG&showgarudachestprogress|2|0|0|OPENDIALOG&showgarudachestprogress|||-1|-1||-1|-1||1|||||        " + to_string(pInfo(peer)->garuda) + "/15        ||0|0|" : "\nadd_button|garuda_dummy||interface/large/store_buttons/store_buttons39.rttex|OPENDIALOG&claimgoldengarudachest|4|0|0|OPENDIALOG&claimgoldengarudachest|CLAIM NOW||-1|-1||-1|-1|||0|0|") + "\nadd_button|12566|`oGaruda Chest ``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Garuda Chest.<CR><CR>`5Description:`` Who knows what ancient legends lie inside this chest? Use it on yourself to find out!|3|0|25000|0|||-1|-1||-1|-1||1||||||0|0|


	minecraft blast:andle_daily_quest
	\nadd_button|9582|Minecraft Blast|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Minecraft Blast, 25 Minecraft Dirt, 25 Minecraft Wood, 50 Minecraft Leaves, 10 Minecraft Portal, 10 Minecraft Obsidian<CR><CR>`5Description:`` Find awesome treasures in this Minecraft blasted world, first find a `2hidden password door`` in a world, enter the `2password`` and collect the dropped `2tnt`` and `2rock hammers``, `2tnt`` are used to explode the `2unbreakable`` stones, `2rock hammers`` are used to break `2gold`` and `2diamond`` ores.``|1|5|25000|0|||-1|-1||-1|-1||1||||||0|
*/

// \nadd_image_button|image_button|interface/large/salesman.rttex|bannerlayout|OPENDIALOG|warp_salesman|
//	string halloween = "\nadd_button|growganoth|`oGift of Growganoth Pack``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 10 Gifts of Growganoth.<CR><CR>`5Description:`` `4Available only during Halloween!`` Would you like to donate to the cause?  Give Growganoth a few gems, and it will reward you with vast power beyond imagining!  Or, perhaps, a box containing a random Halloween item.  Opening each is equivalent to feeding 1 item of rarity 75 into the Maw of Growganoth.  What you will get is random, so don't buy this unless you're ready to be surprised! Each gift has the chance of getting `#Dark King's Offering`` or any of it's Components, including the `#Rare Spooky Gift``! Only available for purchase during `2Halloween Week.`` This item is `#Untradeable.``|0|1|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|halloween_dummy|`oGo To Growganoth!``|interface/large/store_buttons/store_buttons39.rttex|OPENDIALOG&warp_player_into_halloween_world|3|3|0|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dark_ticket|`oDark Ticket``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Dark Ticket.<CR><CR>`5Description:`` Enter the Tomb of Growganoth at your own peril! Find the `5Sacrificial Wells`` to earn `5Corrupted Souls`` and locate the `5Corruption Altar`` to get rewards... beware of the darkness!|0|6|6000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dark_mountains|`oDark Mountains``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Weather Machine - Dark Mountains.<CR><CR>`5Description:`` Bring some terror to your world with these mountains!|2|3|50000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|0|7||1||||||0|0|\nadd_button|riding_raven|`oRiding Raven``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Riding Raven.<CR><CR>`5Description:`` Only the darkest magic could breed a raven so massive that you could ride on it. And Growganoth only permits such magic during `2Halloween Week``, so buy this now before Halloween is over! Riding on this bird gives you the ability to double-jump. Only available for purchase during `2Halloween Week``!|0|1|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|spirit_hat|`oSpiritual Resonator``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Spiritual Resonator.<CR><CR>`5Description:`` `4Available only during Halloween!`` This fantabulous contraption is worn on the head, where it sends out signals into the great beyond, attracting friendly spirits.  The ghost that follows you around when you wear this has a special ability - if you wear a pet leash on your wrist at the same time, the ghost will replace the pet, but imitate its abilities (such as breathing fire if you wear a Dragon Hand).|0|0|40000|0|||-1|-1||-1|-1||1||||||0|0|

// winter fest  	int percent = (winterfest_stock - winterfest_sold) * 0.1;
// \nadd_button|winterfest_calendar_2022|`oWinterfest Calendar - 2022``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Winterfest Calendar - 2022.<CR><CR>`5Description:`` A wonderful Winterfest Calendar for 2022, jam-packed with joy and gifts to celebrate the holidays. Buying this item will give you access to exclusive Winterfest Club Items as they become available in store.|0|0|200000|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||" + a + (winterfest_sold <= winterfest_stock ? "1||-1|-1||" + to_string((winterfest_stock / 10) - percent) + "% remaining" : "0|interface/large/store_buttons/store_buttons34.rttex|1|0||Out Of Stock") + "||0|0| |1|0|Out of Stock||0|0|
	// \nadd_button|snow_husky|`oSnow Husky``|interface/large/store_buttons/store_buttons25.rttex|`2You Get:`` 1 Snow Husky.<CR><CR>`5Description:`` Who wouldn't want this adorable ball of snuggly goodness following them around? This Snow Husky will be your friend forever!|0|5|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|winter_armour_fist|`oArmored WinterBot - Fists``|interface/large/store_buttons/store_buttons28.rttex|`2You Get:`` 1 Armoured WinterBot Fists Fist.<CR><CR>`5Description:`` One of five legendary pieces of the great WinterBot, guardian of the Winter Fortress. Ice shards envelope your hand, punching with this might do some damage.|0|5|300000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12886|`o" + items[12886].ori_name + "``|interface/large/store_buttons/store_buttons28.rttex|`2You Get:`` 1 " + items[12886].ori_name + ".<CR><CR>`5Description:`` " + items[12886].description + "|0|6|750000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|crackers|`oFestive Crackers``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 10 Festive Crackers.<CR><CR>`5Description:`` Contains WinterFest Crackers. Fun holidays crackers loaded with Winterfest cheer and - hopefully - awesome gifts. What will you find? Pop one open and see!|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_snowy|`oWeather Machine - Snowy``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Weather Machine - Snowy.<CR><CR>`5Description:`` Winter is coming. This will turn the background of your world into a snowy mountain scene with snowflakes constantly drifting down. Only available for purchase during `2WinterFest``! `5It's a perma-item, is never lost when destroyed.``|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|Diamond_Provider|`oDiamond Builders Bonanza``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Diamond Builders Bonanza.<CR><CR>`5Description:`` Eager to add some new diamond building materials to your construction stockpile? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the `#Rare`` Diamond Dog and Diamond Warrior's Pauldrons amongst a heap of diamond blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch! <CR><CR>This item is available to Winterfest Club members only. Purchase the `2Winterfest 2022 Calendar`` to join the club.|0|" + (thedaytoday == 6 ? "2" : "1") + "|45000|0|||-1|-1||-1|-1||" + (thedaytoday == 6 ? "1||-1|-1" : "0|interface/large/store_buttons/store_buttons34.rttex|1|1") + "|||0|0|\nadd_button|9582|Minecraft Blast|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Minecraft Blast<CR><CR>`5Description:`` Find awesome treasures in this Minecraft blasted world, first find a `2hidden password door`` in a world, enter the `2password`` and collect the dropped `2tnt`` and `2rock hammers``, `2tnt`` are used to explode the `2unbreakable`` stones, `2rock hammers`` are used to break `2gold`` and `2diamond`` ores.``|1|5|15000|0|||-1|-1||-1|-1||1||||||0|
	/*
	anniversary: \nadd_button|anniversary_dummy||interface/large/store_buttons/store_buttons39.rttex|OPENDIALOG&showanniversarygoldenbox|4|6|0|0|`6" + to_playmod_time(iotm_time - time(nullptr), false, true) + "``||-1|-1||-1|-1||1||||||0|0|\nadd_spacer|small|\nadd_label|`6"+to_string(total_iotm_found)+"/" + to_string(total_iotm_items) + " Found``|target:anniversary_dummy;size:small;top:0.28;left:0.5|
	\nadd_button|mega_party_pack|`oMega Party Pack``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 5 Party-In-A-Box.<CR><CR>`5Description:`` The ultimate way to get you party started. Turn any world into a party world with the mega party pack. Each box will cause the Anniversary Party event to occur in your world instantly, and is consumed when used. `8Only available during Anniversary Week!``<CR><CR>`5BONUS: With every purchase there is a chance that 1 Party-In-A-Box will be a `2Golden Party-In-A-Box``!``|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|
	\nadd_button|party_box|`oParty-In-A-Box``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Party-In-A-Box.<CR><CR>`5Description:`` Keep missing the party? Start your own with this handy box! This causes the Anniversary Party event to occur in your world instantly, and is consumed when used. `8Only available during Anniversary Week!``|0|3|10000|0|||-1|-1||-1|-1||1||||||0|0|

	*/

	/*
	ubitoken hunt
	"+(ubitoken_time - time(nullptr) >= 0 ? "\nadd_button|ubicrate|`oUbiCrate``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 UbiCrate.<CR><CR>`5Description:`` Break one of these special crates to receive a reward! This crate is totally jam packed with cool items and blocks inspired from many Ubisoft games.|4|7|25000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|3|7||1|||||  " + to_playmod_time(ubitoken_time - time(nullptr)) + "     ||0|0|" : "\nadd_button|ubiweek_item_ubisoftcratedummy|`oUbisoft Chest Progress! ``|interface/large/store_buttons/store_buttons39.rttex|OPENDIALOG&showubisoftcrateinfopopup|3|7|0|0|||-1|-1||-1|-1||1|||||     " + to_string(ubi_percent_3) + "% Found     ||0|0|") + "
	*/
	//balloon warz \nadd_button|balloon_warz|`wBalloon Warz Pack``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 50 `wSmall War Balloon``, 20 `wMedium War Balloon``, 5 `wLarge War Balloon``, 1 `wTowel Rack Checkpoint``, and a `#Rare Balloon-O-Matic``.<CR><CR>`5Description:`` Everything you need to dominate the Balloon Warz! Pack includes 50 Small War Balloon, 20 Medium War Balloon, 5 Large War Balloon, 1 Towel Rack Checkpoint, and a Rare Balloon-O-Matic.|0|7|25000|0|||-1|-1||-1|-1||1||||||0|0|
	//gemsshop = "\nadd_button|custom_item|`oCreate Custom Item``|interface/large/store_buttons/store_gtps.rttex|https://sowl.co/Y9mQf|0|7|0|0|$ USD 59.99||-1|-1||0|0|`4It takes up to 12 hours to create your custom item!``<CR><CR>`2You Get:`` Your own custom item.<CR><CR>`5Description:`` Get Your own custom item. Item will be created in less then 12 hours.<CR><CR>You can decide `9item name``,`9description``,`9playmods``,`9everything about the item you create you decide!``|1||||||0|0|";
	
	/*st patrick
	* 		int bonanza = ((bonanza_sold * 100) / bonanza_item), ubi_percent_1 = ((ubi_sold_1 * 100) / ubi_item_1), ubi_percent_2 = ((ubi_sold_2 * 100) / ubi_item_2), ubi_percent_3 = ((ubi_sold_3 * 100) / ubi_item_3), ubi_percent_4 = ((ubi_sold_4 * 100) / ubi_item_4), ubi_percent_5 = ((ubi_sold_5 * 100) / ubi_item_5), ubi_percent_6 = ((ubi_sold_6 * 100) / ubi_item_6), ubi_percent_7 = ((ubi_sold_7 * 100) / ubi_item_7), ubi_percent_8 = ((ubi_sold_8 * 100) / ubi_item_8), ubi_percent_9 = ((ubi_sold_9 * 100) / ubi_item_9), ubi_percent_10 = ((ubi_sold_10 * 100) / ubi_item_10);
	// ubi anniversary \nadd_button|ubiweek_item15|Dagger of Time|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Dagger of Time.<CR><CR>`5Description:`` Prince of Persia! Embark on a journey to save your Kingdom with the weapon linked to the Sands of Time!|1|7|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|3|8||1|||||   " + to_string(ubi_percent_10) + "% Remaining   ||0|0|\nadd_button|ubiweek_item13|Just Dance Pack|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Just Dance Panda Mask and 1 Just Dance Panda Onesie.<CR><CR>`5Description:`` Just Dance! Get dancin' on the floor with the extravagant Panda!|0|7|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|1|8||1|||||   " + to_string(ubi_percent_8) + "% Remaining   ||0|0|\nadd_button|ubiweek_item14|Aurora and Igniculus|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Aurora and Igniculus.<CR><CR>`5Description:`` Child of Light! An adventure awaits you and the firefly Igniculus. Transform into Aurora and soar through the world!|4|6|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|0|8||1|||||   " + to_string(ubi_percent_9) + "% Remaining   ||0|0|\nadd_button|ubiweek_item12|Pet Chorizo|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Pet Chorizo.<CR><CR>`5Description:`` Far Cry! Look at this perfect little sausage, this furry friend fancies a fantastic feast!|1|0|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|2|8||1|||||   " + to_string(ubi_percent_7) + "% Remaining   ||0|0|\nadd_button|ubiweek_item11|" + items[13196].ori_name + "|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 " + items[13196].ori_name + ".<CR><CR>`5Description:`` " + items[13196].description + "|3|6|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|2|7||1|||||   " + to_string(ubi_percent_6) + "% Remaining   ||0|0|\nadd_button|ubiweek_item10|" + items[13200].ori_name + "|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 " + items[13200].ori_name + ".<CR><CR>`5Description:`` " + items[13200].description + "|0|0|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|0|9||1|||||   " + to_string(ubi_percent_5) + "% Remaining   ||0|0|\nadd_button|ubiweek_item9|" + items[13228].ori_name + "|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 " + items[13228].ori_name + ".<CR><CR>`5Description:`` " + items[13228].description + "|2|6|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|3|9||1|||||   " + to_string(ubi_percent_4) + "% Remaining   ||0|0|\nadd_button|ubiweek_item7|Slopestyle Bike|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Slopestyle Bike.<CR><CR>`5Description:`` Riders Republic! Unbeatable for quick spins and fast tricks, the lightweight Slopestyle bike has got you covered!|3|7|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|2|9||1|||||   " + to_string(ubi_percent_1) + "% Remaining   ||0|0|\nadd_button|ubiweek_item8|Iroquois Helmet|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Iroquois Helmet.<CR><CR>`5Description:`` Riders Republic! Perfect for high speed! Leave trails of smoke behind you with the Iroquois helmet!|4|7|350000|0|||-1|-1|/interface/large/gui_shop_buybanner.rttex|1|9||1|||||   " + to_string(ubi_percent_2) + "% Remaining   ||0|0|
	" + (bonanza < 100 ? "\nadd_button|blarney_dummy|`oBlarney Bonanza``|interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&showblarneyprogress|0|1|0|0||interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|||||    " + to_string(bonanza) + "% unlocked    ||0|0|" : "\nadd_button|" + to_string(bonanza_item_current) + "|`o" + items[bonanza_item_current].ori_name + "``|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` 1 " + items[bonanza_item_current].ori_name + ".<CR><CR>`5Description:`` " + items[bonanza_item_current].description + "|" + to_string(items[bonanza_item_current].shop_X) + "|" + to_string(items[bonanza_item_current].shop_Y) + "|800000|0|||-1|-1||-1|-1||1||||||0|0|") + "\nadd_button|stpats_pack|`oSt. Patrick's Pack``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Orange Beard, 1 Leprechaun Suit, 1 Leprechaun Shoes, 1 Green Pants, 1 Leprechaun Hat, 1 Personal Pot of Gold and a 6 Pack of Green Beer.<CR><CR>`5Description:`` Celebrate the greenest of holidays!|0|1|6000|0|||-1|-1|interface/large/gui_shop_buybanner.rttex|0|0||1||||||0|0|\nadd_button|paddy|`oWeather Machine - St. Paddy's Day``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Weather Machine - St. Paddy's Day.<CR><CR>`5Description:`` It's Paddy's Day here in Growtopia! Celebrate in style with fiddle music, floating shamrocks, rainbows, and a pot o' gold over emerald hills. This weather machine will let everyone know how lucky you are! `5It's a perma-item, is never lost when destroyed.``|0|7|20000|0|||-1|-1||-1|-1||1||||||0|0|
	*/

	/*
	lunar year
	\nadd_button|nian_lunar_chest|Lunar Chest|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Lunar Chest.<CR><CR>`5Description:`` Who knows what ancient treasures lie inside this chest? Use it on yourself to find out!|0|6|25000|0|||-1|-1|/interface/large/gui_shop_buybanner2.rttex|2|9||1||||||0|0|
	*/

	/*
	eco week
	\nadd_button|wildlife_pack|`oWildlife Supporter Pack``|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` 1 Arlequin Toad Pet, 5 Golden Eco Seed, 50 Eco Seed.<CR><CR>`5Description:`` Be a part of the solution and help responsibly plant billions of trees every year. Grow these little seeds and be rewards for your contribution. Also includes an endangered Arlequin Toad for you to look after and play your part in preserving the wildlife in Growtopia.|0|1|400000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|eco_seed_pack|`oEco Seed``|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` 1 Eco Seed.<CR><CR>`5Description:`` Grow this little seed and be rewards for your contribution. Help save our environment and the amazing creatures in it. Be a part of the solution and help responsibly plant billions of trees every year by supporting Ecologi and thier work.|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|
	*/
	/*
	easter week
	\nadd_button|easter_pack|`wEaster Basket``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Easter Crate.<CR><CR>`5Description:`` Spring is in the air, celebrate with Magic Eggs (you can now get between 20-40 Magic Eggs)!<CR><CR>You may also get an Easter egg, including the `5RARE Easter Egg - Rainbow``!|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|egg_carton|`oGolden Egg Carton``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 Golden Egg Carton.<CR><CR>`5Description:`` `wGo egg crazy with this`` `#Untradeable`` `wGolden Egg Carton!`` `2This can be unlocked multiple times.``<CR><CR>`wEvery carton contains one of the Golden Egg SHards including a chance of getting Easter Egg - Growtopia, Easter Egg - Pineapple and Easter Egg - Ghost!``|0|6|15000|0|||-1|-1||-1|-1||" + (pInfo(peer)->magic_egg >= 1000 ? "1||-1|-1||" : "0|interface/large/store_buttons/store_buttons29.rttex|0|5||" + to_string(pInfo(peer)->magic_egg) + " / 1000 Magic Eggs Used") + "||0|0| |1|0|Out of Stock||0|0|
	cinco de mayo
			struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		string cal_time = to_string(24 - newtime.tm_hour) + "" + (60 - newtime.tm_min != 0 ? ":" + to_string(60 - newtime.tm_min) : "");
	\nadd_button|pinata_value_pack|`oPinata Value Pack``|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` 5 Pinata Whistle & 2 Block De Mayo Block.<CR><CR>`5Description:`` Make a fiesta all of your own and invite all your friends with 5 Pinata Whistles and 2 Block de Mayo Blocks to celebrate with. There is a chance of getting a Rare Lava Pinata item from this pack.|0|2|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11880|`oWeather Machine - Plaza``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Weather Machine - Plaza.<CR><CR>`5Description:`` Bring all your friends to the plaza and let the celebrations never end!|4|3|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pinata_whistle|`oPinata Whistle``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Pinata Whistle.<CR><CR>`5Description:`` Having trouble finding a Piñata to smash? Want to keep the party going after Cinco De Mayo is over? Grab a Piñata Whistle and you can start a Piñata Bash anytime you want! Whistles only work once, and make sure you have some friends nearby, because it’s impossible to smash an Ultra Piñata yourself!|0|2|7500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cinco_dummy|`oThe Volcanic Cape``|interface/large/store_buttons/store_buttons29.rttex|OPENDIALOG&showcincovolcaniccape|0|7|0|0|" + cal_time + " remaining|interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|interface/large/gui_store_button_overlays1.rttex|0|0||" + to_string(Cinco_De_Mayo.volcanic_cape) + "/48 Volcanic Capes Found|0|0|\nadd_button|cinco_dummy2|`oThe Volcanic Wings``|interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&showcincovolcanicwings|3|3|0|0|" + cal_time + " remaining|interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|interface/large/gui_store_button_overlays1.rttex|0|0||" + to_string(Cinco_De_Mayo.volcanic_wings) + "/48 Volcanic Wings Found|0|0|\nadd_button|cinco_dummy3|`oThe Volcanic Pauldrons``|interface/large/store_buttons/store_buttons40.rttex|OPENDIALOG&showcincovolcanicpauldrons|2|2|0|0|" + cal_time + " remaining|interface/large/gui_store_button_overlays1.rttex|0|0||-1|-1||1|interface/large/gui_store_button_overlays1.rttex|0|0||" + to_string(Cinco_De_Mayo.volcanic_pauldrons) + "/48 Volcanic Pauldrons Found|0|0|
	
	*/
	//\nadd_image_button|image_button|interface/large/salesman_open.rttex|bannerlayout|OPENDIALOG|salesman_popup|
	string extra_tab = "", item_ = "";
	if (tab.length() > 5) {
		extra_tab = "_" + a + tab.substr(5, tab.length() - 5).c_str();
		item_ = tab.substr(5, tab.length() - 5).c_str();
	}
	gamepacket_t p(tab == "tab7" ? 500 : 0);
	p.Insert("OnStoreRequest");
	if (tab == "tab1" + extra_tab) {
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		//\nadd_button|kranken|Kranken's Galactic Block|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 5 Kranken's Galactic Block<CR><CR>`5Description:`` " + items[10962].description + "<CR><CR><CR>You currently have " + setGems(pInfo(peer)->voucher) + " Grow Vouchers.|0|0|0|0|||0|0|interface/large/gui_shop_buybanner3.rttex|1|1||1||||||0|1|\nadd_button|microphone_madness|Microphone Madness|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` 1 Microphone Madness<CR><CR>`5Description:`` Take center stage as you sing your heart out and give in to the music.<CR><CR><CR>You currently have " + setGems(pInfo(peer)->voucher) + " Grow Vouchers.|2|1|0|0|||0|0|interface/large/gui_shop_buybanner3.rttex|1|1||1||||||0|10|\nadd_button|voucher_dayz_world_lock_15_pack|`oVoucher Dayz World Lock Pack``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 15 World Locks.<CR><CR>`5Description:`` 15-pack of World Locks. Become the undisputed ruler of up to FIFTEEN kingdoms with these babies. Each works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.`` `wEach recycles for 200 Gems.``<CR><CR><CR>You currently have " + setGems(pInfo(peer)->voucher) + " Grow Vouchers.|2|7|0|0|||0|0||-1|-1||1||||||0|1|\nadd_button|superstar_block|Superstar Background|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 5 Superstar Background<CR><CR>`5Description:`` Make your world shine with this dazzling Superstar Background!<CR><CR><CR>You currently have " + setGems(pInfo(peer)->voucher) + " Grow Vouchers.|2|4|0|0|||0|0|interface/large/gui_shop_buybanner2.rttex|3|7||1||||||0|1|
		string voucher = "\nadd_banner|interface/large/gtps_store_overlays.rttex|0|5|\nadd_button|vd_black_tie_baller_set|Black Tie Baller Set|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` 1 Black Tie Baller Hat, 1 Black Tie Baller Monocle, 1 Black Tie Baller Coat, 1 Black Tie Baller Pants, 1 Black Tie Baller Shoes, 1 Black Tie Baller Cane<CR><CR>`5Description:`` From rags to riches, show off just how far you've come with these ballin' black tie set.``<CR><CR><CR>You currently have " + setGems(pInfo(peer)->voucher) + " Grow Vouchers.|4|4|0|0|||0|0|interface/large/gui_shop_buybanner3.rttex|2|2||1||||||0|10|\nadd_button|superstar_block|Superstar Background|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 5 Superstar Background<CR><CR>`5Description:`` Make your world shine with this dazzling Superstar Background!<CR><CR><CR>You currently have " + setGems(pInfo(peer)->voucher) + " Grow Vouchers.|2|4|0|0|||0|0|interface/large/gui_shop_buybanner2.rttex|3|7||1||||||0|1|\nadd_button|voucher_pack_vending|Voucher Day Vending Machine Mega Pack|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 10 Vending Machines.<CR><CR>`5Description:`` Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.``<CR><CR><CR>You currently have " + setGems(pInfo(peer)->voucher) + " Grow Vouchers.|0|4|0|0|||0|0||-1|-1||1||||||0|5|";
		string grow_pass = "\nadd_banner|interface/large/gtps_store_overlays.rttex|0|4|\nadd_image_button|image_button|interface/large/gui_shop_grow_pass.rttex|bannerlayout|OPENDIALOG|battlepasspopup|\nadd_button|growpass_item|`o" + items[grow_pass_item].ori_name + "``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 " + items[grow_pass_item].ori_name + ".<CR><CR>`5Description:`` " + items[grow_pass_item].description + "``<CR><CR> (Item price rises by `20,01%`` gems each purchase.|0|2|" + to_string(500000 + grow_pass_item_price) + "|0|||-1|-1|interface/large/gui_shop_buybanner.rttex|2|5||1||||||0|0|\nadd_button|growpass||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&growpass|3|1|0|0|||-1|-1||-1|-1||1|||||" + a + (pInfo(peer)->gp == 0? "OBTAIN ROYAL GROW PASS" : ""+to_string(pInfo(peer)->growpass_points > 2100 ? 2100 : pInfo(peer)->growpass_points) + "/2100 POINTS") + "|0|0|\nadd_button|crypto||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&crypto|2|13|0|0|||-1|-1||-1|-1||1||||||0|0|";
		string new_extra = "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|" + a + (comet_dust ? "\nadd_button|cosmic_cape|`oCosmic Cape ``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Cosmic Cape. <CR><CR>`5Description:`` The cosmic energy is even messing with our store! This Cosmic Cape can only be purchased during Night of the Comet! It grants you the power to double jump, as well as having a very tiny chance of finding whatever leftover Comet Dust inside blocks you break, even when it's not Night of the Comet.|0|6|200000|0|||-1|-1||-1|-1||1||||||0|0|" : "") + 
			// SUMMER //"\nadd_image_button|image_button|interface/large/gui_shop_summerfest1.rttex|bannerlayout|OPENDIALOG|showphoenixreturns|\nadd_button|phoenix_dummy||interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&showphoenixreturns|0|6|0|0|`6" + to_string(24 - newtime.tm_hour) + " hours, " + to_string(60 - newtime.tm_min) + " mins``||-1|-1||-1|-1||1||||||0|0|\nadd_spacer|small|\nadd_label|`6" + to_string(all_phoenix_items.size() - phoenix_items_all.size()) + "/"+to_string(all_phoenix_items.size()) + " Found``|target:phoenix_dummy;size:small;top:0.28;left:0.5|\nadd_button|summer_pack|`oBeach Blast Bingo``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Beach Blast Bingo, 100 Fireworks and 1 Summer Surprise.<CR><CR>`5Description:``It's hot out there! Don't you want to go to the beach? Now you can make your own beach with a `5Beach Blast`` device and the `5Fireworks`` needed to power it. The `5Beach Blast`` creates a brand new world set up as a beach, full of cool new Summer items.  As a bonus, you'll get a `5Summer Surprise`` and a chance of a `5Rare Ultra White Fragment`` or `5Ultra Purple Fragment`` too! (`pAvailable during Summerfest week only``)|0|7|50000|0|||-1|-1||-1|-1||1||||||0|0|"
			"\nadd_button|top_wls||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&top_wls|3|11|0|0|||-1|-1||-1|-1||1|||||      ā " + setGems_(total_wls_recycled) + "      |0|0|\nadd_button|mystery_item|`3Mystery Item``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 of the new item!<CR><CR>`5Description:`` Receive a random item of latest released items! (seeds not included) <CR><CR> The items are updated automatically each update!|3|0|250000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|island_blast|`oIsland Blast``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Island Blast. <CR><CR>`5Description:`` " + items[10380].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.|3|12|" + to_string(80000 + island_blast) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|building_blocks_machine|`oBuilding Blocks Machine``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Building Blocks Machine. <CR><CR>`5Description:`` Eager to add some new building materials to your construction stockpile? Tired of collecting them from random worlds and weirdos? Well, pop this beauty in your world and it'll start cranking out awesome blocks in no time! Contains the RARE Creepy Baby Block and Digital Dirt amongst a heap of other new blocks! Careful, though - blocks don't just come from nothing, and this machine will eventually run out of power once it makes a bunch!<CR><CR> (Item price rises by `20,01%`` gems each purchase.|0|3|" + to_string(100000 + building_machine) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|13408|Angelic Aura|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 1 Angelic Aura<CR><CR>`5Description:`` " + items[13408].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.|1|0|" + to_string(650000 + angelic_aura) + "|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|2|2||1||||||0|0|\nadd_button|13404|`wLaser Light``|interface/large/store_buttons/store_buttons40.rttex|`2You Get:`` `wLaser Light``.<CR><CR>`5Description:`` " + items[13404].description + ".<CR><CR> (Item price rises by `20,01%`` gems each purchase.|3|1|" + to_string(50000 + laser_light) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rift_wings|`oRift Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Rift Wings. <CR><CR>`5Description:`` Rip a hole in the fabric of reality with these amazing Waings!|1|5|10000000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rift_cape|`oRift Cape``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Rift Cape. <CR><CR>`5Description:`` Rip a hole in the fabric of reality with this amazing Cape! Create two unique looks and use a rift in time and space to change between them. Wrench yourself to customise the Cape. This item is available to buy for 2 days only and then will become available from a new Winterfest system afterwards. To avoid refund fraud, this item has been made untradeable until April 10th, 2021.|0|5|10000000|0|||-1|-1||-1|-1||1||||||0|0|";
		string guild_event = (can_event ? "" : "\nadd_banner|interface/large/gtps_store_overlays.rttex|0|2|\nadd_button|||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&|4|5|0|0|||-1|-1||-1|-1||1|||||Guild: " + best_guild + "|0|0|\nadd_button|" + to_string(event_item) + "|`o" + items[event_item].ori_name + "``|interface/large/store_buttons/" + items[event_item].texture_name + "|`2You Get:`` 1 " + items[event_item].ori_name + ".<CR><CR>`5Description:`` " + items[event_item].description + "``" + (top_basher_list_shop.empty() && top_guild_list_shop.empty() ? "" : "<CR><CR>`5Guild Leaderboard:`` " + top_guild_list_shop + "<CR><CR>`5Personal Leaderboard:`` " + top_basher_list_shop) + "|0|" + to_string(items[event_item].texture_y) + "|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|7190|`wGuild Name Changer``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Guild Name Changer.<CR><CR>`5Description:`` Fancy a change? Bored of your guild name or made a mistake when creating it? Fear not you can use up one of these to change your Guild's name! The usual name checks will be initiated to check if your new guild name is valid. Only usable by the guild leader!|0|6|200000|0|||-1|-1||-1|-1||1||||||0|0|");
		string featured = "\nadd_banner|interface/large/gtps_store_overlays.rttex|0|0|\nadd_button|dailyquests_dummy||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&handle_daily_quest|1|6|0|0|||-1|-1||-1|-1||1|||||"/* + (pInfo(peer)->grow4good_points >= 400 ? "`9**`` Claim Reward `9**``" : "") + */ "|0|0|\nadd_button|opc_shop||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&opc_shop|1|13|0|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|gems_shop||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&handle_gems_shop|0|11|0|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&|4|2|0|0|||-1|-1||-1|-1||1|||||Player: " + best_player + "|0|0|\nadd_button|||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&|4|3|0|0|||-1|-1||-1|-1||1|||||World: " + best_world + "|0|0|\nadd_button|||interface/large/store_buttons/store_gtps.rttex|OPENDIALOG&|4|4|0|0|||-1|-1||-1|-1||1|||||`b"+ best_quote +"``|0|0|" + grow_pass + guild_event  + new_extra + voucher;
		string event_happening = "\nadd_banner|interface/large/gui_shop_featured_header.rttex|0|1|";
		event_happening = "";
		p.Insert("set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `520000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/gtps_shop_btn.rttex|sw|1|0|0|0|sw|sw|sw|-1|-1|sw|sw|0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/gtps_shop_btn.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/gtps_shop_btn.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/gtps_shop_btn.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/gtps_shop_btn.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/gtps_shop_btn.rttex||0|2|0|0||||-1|-1|||0|0|" + a + (beach_party_game ? "\nadd_image_button|image_button|interface/large/gui_event_beachparty.rttex|bannerlayout|OPENDIALOG||\nadd_button|beach_party_ticket|`oBeach Party Ticket``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Beach Party Ticket.<CR><CR>`5Description:`` A ticket for the most exclusive beach party of your life! Go to BEACHPARTYGAME world and punch the Bouncer NPC to be entered in the game! Then when the game starts break the sand to uncover clams and smash them for some sweet pearls!|3|5|5000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|0|3||1||||||0|0|\nadd_button|beachparty_item_of_the_weekend|`oThis weekend only!``|interface/large/store_buttons/store_buttons40.rttex|OPENDIALOG&warp_player_into_beach_world|3|4|0|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|beachparty_dummy|`oJoin to Beach Party!``|interface/large/store_buttons/store_buttons38.rttex|OPENDIALOG&warp_player_into_beach_world|2|5|0|0|||-1|-1||-1|-1||1||||||0|0|" : "") + event_happening + featured + ""/*"\nadd_button|summer_pack|`oBeach Blast Bingo!``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:``Beach Blast, Summer Surprise and 100 Fireworks. <CR><CR>`5Description:`` It's hot out there! Don't you want to go to the beach? Now you can make your own beach with a Beach Blast device and the 100 Fireworks needed to power it. The Beach Blast creates a brand new world set up as a beach, full of cool new Summer items. As a bonus, you'll get a Summer Surprise too! (Available during Summerfest week only)|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|"*/"" + (extra_tab.empty() ? "" : "\nselect_item|" + item_));
	}
	else if (tab == "tab4" + extra_tab) {
		string extra = "\nadd_button|fairy_light_wings|`oFairy Light Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` Fairy Light Wings. <CR><CR>`5Description:`` Not only do these wings let you fly, they also light up as your make your way across town!|2|5|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11700|`oEnchanted Broomstick``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` `0Enchanted Broomstick``.<CR><CR>`5Description:`` Soar through the skies leaving a trail of magical mist!|4|0|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|radical|`oRadical Rider``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 1 Radical Rider. <CR><CR>`5Description:`` Totally Radical! Scoot across worlds with ease while looking stylish and ever so slightyl smug! Great for a /dance|0|3|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12172|Ethereal Chains|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Ethereal Chains<CR><CR>`5Description:`` Whip these ethereal chains powered by a burning energy from another world!|0|5|100000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11708|`oSuperstar Sneakers``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` `0Superstar Sneakers``.<CR><CR>`5Description:`` Walk down the red carpet with these super special shining shoes!|0|2|750000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11814|`oRabbit Top Hat``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` `0Rabbit Top Hat``.<CR><CR>`5Description:`` And now for his next trick, the rabbit will fire an endless supply of cards!|0|3|500000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11626|`oMythic Tiger Crown``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Mythic Tiger Crown.<CR><CR>`5Description:`` Summon the power of the White Tiger of the West with this glorious crown!|3|0|350000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12870|Candy Cane Bow|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Candy Cane Bow<CR><CR>`5Description:`` Dash your way through the snow with this holiday bow!|0|5|300000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|1|8||1||||||0|0|\nadd_button|candy_cane_elf_set|Candy Cane Elf Set|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Candy Cane Elf item set<CR><CR>`5Description:`` Dress up this holiday season as a jolly elf of St. Nick himself!|1|5|150000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|2|8||1||||||0|0|\nadd_button|12958|`oInfinity Crown``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Infinity Crown.<CR><CR>`5Description:`` Infinite possibilities! Wrench this crown to change its various features to make it your own!|2|5|850000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|3|8||1||||||0|0|\nadd_button|11818|`oEquinox Scarf ``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Equinox Scarf.<CR><CR>`5Description:`` Summon the elements of the Equinox! You can customise this item from the wrench menu.|1|0|750000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|1|1||1||||||0|0|\nadd_button|hooves|`oHooves of Cernunnos``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 Hooves of Cernunnos. <CR><CR>`5Description:`` Will the wild in every step you take! Roots form and wither at your command!|0|4|100000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pegasus_lance|`oPegasus Lance``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` 1 Pegasus Lance. <CR><CR>`5Description:`` A fine, feathery, lance. Made from the finest... checks notes... Horse feathers! To avoid refund fraud, this item has been made untradeble until November 3rd, 2021.|0|0|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|12640|`oMinokawa Wings``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Minokawa Wings.<CR><CR>`5Description:`` " + items[12640].description + "``|1|4|800000|0|||-1|-1|interface/large/gui_shop_buybanner.rttex|3|4||1||||||0|0|\nadd_button|one_winged_angel|`oOne Winged Angel``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` One Winged Angel. <CR><CR>`5Description:`` This single wing is a symbol for all those who strive to overcome adversity, no matter what the odds|2|3|190000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|riding_raven|`oRiding Raven``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Riding Raven. <CR><CR>`5Description:`` Only the darkest magic could breed a raven so massive that you could ride on it. And Growganoth only permits such magic during Halloween Week, so buy this now before Halloween is over! Riding on this bird gives you the ability to double jump. Only available for purchase during Halloween Week!|0|1|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zombie_horse|`oZombie Horse``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Zombie Horse. <CR><CR>`5Description:`` A zombified flaming horse to terrorize the town with! With hooves of flame, this fiery steed is perfect for the spooky season! Only available for purchase during Halloween Week.|1|3|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|1180|`oSpiritual Resonator``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Spiritual Resonator. <CR><CR>`5Description:`` Worm on the head, where it sends out signals into the great beyond, attracting friendly spirits. The ghost that follows you around when you wear this has a special ability - if you wear a pet leash on your wrist at the same time, the ghost will replace the pet, but imitate its abilities|0|0|40000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|apocalypse_scythe|`oApocalypse Scythe``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Apocalypse Scythe. <CR><CR>`5Description:`` Stolen from one of the four riders of the Apocalypse, this deadly blade is able to slice open the veil between life and death.|0|4|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|bumblebee|`oRiding Bumblebee``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Riding Bumblebee. <CR><CR>`5Description:`` Bumblebees are very large. Probably not so large that you can ride them, but this is a video game! Riding on this bee gives you the ability to double-jump. Only available for purchase during Easter Week!|0|0|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|balloon_bunny|`oBalloon Bunny``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Balloon Bunny. <CR><CR>`5Description:`` Bunny bunny bunny balloon balloon balloon bunny balloon bunny balloon bunny bunny balloon balloon! You may have guessed it... this is a Balloon Bunny! With a great balloon, comes great reasons to throw balloon bunny hats at fellow Growtopians! Only available for purchase during Easter Week!|0|5|250000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ouroboros_charm|`oOuroboros Charm``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` Ouroboros Charm. <CR><CR>`5Description:`` The endless loop of life and death, personified and celebrated. Is it a charm or is it a curse?|0|3|350000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11904|Golden Radical Rider|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Golden Radical Rider<CR><CR>`5Description:`` Totally Radical and Gold! `5This special, Anniversary edition will only be available this weekend and will not return.``|0|4|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|ponytail|`oPowerful Ponytail Hair ``|interface/large/store_buttons/store_buttons30.rttex|`2You Get:`` 1 Powerful Ponytail Hair. <CR><CR>`5Description:``  powerful hairstyle that's punching above its weight! Bleached platinum white for perfect preparation to apply hair dye and personalise to you heart's desire.|0|3|100000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zraei|`oZraei's Dragoscarf``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Zraei's Dragoscarf. <CR><CR>`5Description:`` April 2017: Dragoscarf! This dragon clings to you, granting extra punch damage, but only if you don't have it from another source. This item can only be purchased this month! It will never return, and cannot be obtained any other way! It is tradeable, though. There is a link in the /news if you'd like to see a short clip of the item in action before purchasing.|0|5|200000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|2214|`oIce Horse``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1  Ice Horse. <CR><CR>`5Description:`` You're probably gonna wish you had spent extra for the seat heater option with this particular ride. But it's faster than walking. Sponsored by @Aimster.|0|2|40000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|snow_husky|`oSnow Husky``|interface/large/store_buttons/store_buttons25.rttex|`2You Get:`` 1 Snow Husky. <CR><CR>`5Description:`` Who wouldn't want this adorable ball of snuggly goodness following them around! This Snow Husky will be your friend forever!|0|5|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|polar_bear|`oPolar Bear Leash``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Polar Bear Leash. <CR><CR>`5Description:`` If you look out your window and see this guy, you are looking south. Or at a zoo. Or at somebody playing Growtopia.|0|3|40000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|10170|`oAqua Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Aqua Wings. <CR><CR>`5Description:`` Cause a splash with these Aqua Wings! They are so realistic, even a few fish have managed ro sneak into them... they are flying fish now!|0|0|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10182|`oMusical Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Musical Wings. <CR><CR>`5Description:`` Musical wings for marauding Maestros! Wrench yourself to set a tune with these equipped, then walk along to play back the tune! It's how Beethoven would have composed music if Growtopia had existed all those years ago... probably.|0|2|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10180|`oParty Plume Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Party Plume Wings. <CR><CR>`5Description:`` A wing with some serious plumage! Surprise and dazzle Growtopians with this vibrant display of color and feathers. The Peacock has to be one of nature's biggest show offs, now you can be as well as you take to the dancefloor with your party plume!|0|3|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10178|`oGrowtopia Fried Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Growtopia Fried Wings. <CR><CR>`5Description:`` Wings to make your tummy rumble! These deep fried wings are literally straight from the oven! Covered in a golden breadcrumb made with a secret mix of Growtopia herbs and spices, cooked to create the perfect balance between flavor and aerodynamics!|0|1|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10188|`oGhoulish Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Ghoulish Wings. <CR><CR>`5Description:`` Get your Ghoul on! A mystery gas surrounds you and elevates you skyward... not sure where this gas comes from and it's probably best not to know!|1|1|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|neon_wings|`oNeon Wings``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Neon Wings. <CR><CR>`5Description:`` Light up the town in style! Don’t question how neon lights make you fly, just go with the glow and touch the sky!|1|2|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11158|`oZodiac Ring``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1  Zodiac Ring. <CR><CR>`5Description:`` Harness the power of the Zodiac! This ring pulls galaxies into its core. It use that galactic power to summon Zodiac symbols, which change depending on the current Zodiac sign.|3|0|300000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|zodiac|`oZodiac Wings``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Zodiac Wings. <CR><CR>`5Description:`` The power of the Zodiac fills your body. The 12 signs align perfectly and allow you to not only reach for the stars but jump amongst them as well! When jumping a Zodiac sign bursts onto the screen, these change with the actual Zodiac Calendar. Note: These are only available until the end of PAW Week.|0|4|300000|0|||-1|-1||-1|-1||1||||||0|0|";
		p.Insert("set_description_text|`2Locks And Stuff!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/gtps_shop_btn.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/gtps_shop_btn.rttex||1|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/gtps_shop_btn.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/gtps_shop_btn.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/gtps_shop_btn.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/gtps_shop_btn.rttex||0|2|0|0||||-1|-1|||0|0|" + (pInfo(peer)->inv.size() < 476 ? "\nadd_button|upgrade_backpack|`0Upgrade Backpack`` (`w10 Slots``)|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 10 Additional Backpack Slots.<CR><CR>`5Description:`` Sewing an extra pocket onto your backpack will allow you to store `$10`` additional item types.  How else are you going to fit all those toilets and doors?|0|1|" + to_string((100 * ((((pInfo(peer)->inv.size() - 17) / 10) * ((pInfo(peer)->inv.size() - 17) / 10)) + 1)) * 2) + "|0|||-1|-1||-1|-1||1||||||0|0|" : "") + "\nadd_button|clothes|`oClothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Wearble Items.<CR><CR>`5Description:`` Why not look the part? Some may even have special powers...|0|0|50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rare_clothes|`oRare Clothes Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 3 Randomly Chosen Wearbale Items.<CR><CR>`5Description:`` Enjoy the garb of kings! Some may even have special powers...|0|1|500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12474|`oInfernal Shades``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Infernal Shades.<CR><CR>`5Description:`` Head into town with hottest shades out right now... literally. `4Not available any other way!``|0|7|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12476|`oTidal Shades``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Tidal Shades.<CR><CR>`5Description:`` Make waves with these tidal shades. `4Not available any other way!``|1|7|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12478|`oVerdant Shades``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Verdant Shades.<CR><CR>`5Description:`` Go green and support the environment with these verdant shades. `4Not available any other way!``|2|7|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|contact_lenses|`oContact Lens Pack``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 20 Contact Lens Colors and 5 Contact Lens Cleaning Solution.<CR><CR>`5Description:`` Need a colorful new look? This pack includes 20 Contact Lens colors (and includes 5 Contact Lens Cleaning Solution, to return to your natural eye color)!|0|7|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|hairdye|`oHair Dye Pack``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 5 Red Hair Dye, 5 Green Hair Dye, 5 Blue Hair Dye and 5 Black Hair Dye.<CR><CR>`5Description:`` Want to paint your hair? This pack includes 20 dye of hair dye. Consuming one while standing on the same tile as Bathtub will give a stacking light of the color.|3|14|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|eye_drops|`oEye Drop Pack``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 `#Rare Bathroom Mirror``, 20 Eye Drop Colors and 5 Eye Cleaning Solution.<CR><CR>`5Description:`` Need a fresh new look?  This pack includes a 20 Eye Drop Colors (includes 5 Eye Cleaning Solution, to leave your eyes sparkly clean)!|0|6|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|nyan_hat|`oTurtle Hat``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Turtle Hat.<CR><CR>`5Description:`` It's the greatest hat ever. It bloops out bubbles as you run! `4Not available any other way!``|0|2|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|tiny_horsie|`oTiny Horsie``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Tiny Horsie.<CR><CR>`5Description:`` Tired of wearing shoes? Wear a Tiny Horsie instead! Or possibly a large dachshund, we're not sure. Regardless, it lets you run around faster than normal, plus you're on a horse! `4Not available any other way!``|0|5|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|star_ship|`oPleiadian Star Ship``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 Pleiadian Star Ship.<CR><CR>`5Description:`` Float on, my brother. It's all groovy. This star ship can't fly, but you can still zoom around in it, leaving a trail of energy rings and moving at enhanced speed. Sponsored by Pleiadian. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dragon_hand|`oDragon Hand``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Dragon Hand.<CR><CR>`5Description:`` Call forth the dragons of legend!  With the Dragon Hand, you will command your own pet dragon. Instead of punching blocks or players, you can order your dragon to incinerate them! In addition to just being awesome, this also does increased damage, and pushes other players farther. `4Not available any other way!``|0|1|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|corvette|`oLittle Red Corvette``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Little Red Corvette.<CR><CR>`5Description:`` Cruise around the neighborhood in style with this sweet convertible. It moves at enhanced speed and leaves other Growtopians in your dust. `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|stick_horse|`oStick Horse``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Stick Horse.<CR><CR>`5Description:`` Nobody looks cooler than a person bouncing along on a stick with a fake horse head attached. NOBODY. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ambulance|`oAmbulance``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Ambulance.<CR><CR>`5Description:`` Rush to the scene of an accident while lawyers chase you in this speedy rescue vehicle. `4Not available any other way!``|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|raptor|`oRiding Raptor``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Riding Raptor.<CR><CR>`5Description:`` Long thought to be extinct, it turns out that these dinosaurs are actually alive and easily tamed. And riding one lets you run around faster than normal! `4Not available any other way!``|0|7|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|owl|`oMid-Pacific Owl``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Mid-Pacific Owl.<CR><CR>`5Description:`` This owl is a bit lazy - if you stop moving around, he'll land on your head and fall asleep. Dedicated to the students of the Mid-Pacific Institute. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|unicorn|`oUnicorn Garland``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Unicorn Garland.<CR><CR>`5Description:`` Prance about in the fields with your very own pet unicorn! It shoots `1R`2A`3I`4N`5B`6O`7W`8S``. `4Not available any other way!``|0|4|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|starboard|`oStarBoard``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 StarBoard.<CR><CR>`5Description:`` Hoverboards are here at last! Zoom around Growtopia on this brand new model, which is powered by fusion energy (that means stars spit out of the bottom). Moves faster than walking. Sponsored by Miwsky, Chudy, and Dawid. `4Not available any other way!``|0|1|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|motorcycle|`oGrowley Motorcycle``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Growley Motorcycle.<CR><CR>`5Description:`` The coolest motorcycles available are Growley Dennisons. Get a sporty blue one today! It even moves faster than walking, which is pretty good for a motorcycle. `4Not available any other way!``|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|monkey_on_back|`oMonkey On Your Back``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Monkey On Your Back.<CR><CR>`5Description:`` Most people work really hard to get rid of these, but hey, if you want one, it's available! `4But not available any other way!`` Sponsored by SweGamerHD's subscribers, Kizashi, and Inforced. `#Note: This is a neck item, not a back item. He's grabbing your neck!``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|carrot_sword|`oCarrot Sword``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Carrot Sword.<CR><CR>`5Description:`` Razor sharp, yet oddly tasty. This can carve bunny symbols into your foes! `4Not available any other way!`` Sponsored by MrMehMeh.|0|3|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|red_bicycle|`oRed Bicycle``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Red Bicycle.<CR><CR>`5Description:`` It's the environmentally friendly way to get around! Ride this bicycle at high speed hither and zither throughout Growtopia. `4Not available any other way!``|0|5|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fire_truck|`oFire Truck``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fire Truck.<CR><CR>`5Description:`` Race to the scene of the fire in this speedy vehicle! `4Not available any other way!``|0|2|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|pet_slime|`oPet Slime``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Pet Slime.<CR><CR>`5Description:`` What could be better than a blob of greasy slime that follows you around? How about a blob of greasy slime that follows you around and spits corrosive acid, melting blocks more quickly than a normal punch? `4Not available any other way!``|0|4|100000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dabstep_shoes|`oDabstep Low Top Sneakers``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Dabstep Low Top Sneakers.<CR><CR>`5Description:`` Light up every footfall and move to a better beat with these dabulous shoes! When you're wearing these, the world is your dance floor! `4Not available any other way!``|0|2|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12302|`oLightning Horns``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Lightning Horns.<CR><CR>`5Description:`` A shocking display of power!``|3|7|350000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|3|5||1||||||0|0|\nadd_button|dynamite_sparks|Dynamite Sparks|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Dynamite Sparks<CR><CR>`5Description:`` Light it up like dynamite with these sparkling stars!|2|7|400000|0|||-1|-1|interface/large/gui_shop_buybanner.rttex|0|6||1||||||0|0|\nadd_button|13104|Boosted Boots|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Boosted Boots.<CR><CR>`5Description:`` " + items[13104].description + "|3|6|500000|0|||-1|-1|/interface/large/gui_shop_buybanner2.rttex|3|9||1||||||0|0|\nadd_button|12990|`oDisco Fever``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Disco Fever.<CR><CR>`5Description:`` " + items[12990].description + "|3|5|800000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|0|9||1||||||0|0|\nadd_button|12658|`oFist Of Vengeance``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Fist Of Vengeance.<CR><CR>`5Description:`` " + items[12658].description + "|0|4|900000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|1|7||1||||||0|0|\nadd_button|12656|`oPontianak Pet``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Pontianak Pet.<CR><CR>`5Description:`` " + items[12656].description + "|1|4|900000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|2|7||1||||||0|0|\nadd_button|12306|`oDIY Wings``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 DIY Wings.<CR><CR>`5Description:`` Fly with your very own DIY Wings!``|3|6|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|12350|`oPersonal Storm Cloud``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Personal Storm Cloud.<CR><CR>`5Description:`` Strike lightning down to the ground with your very own Personal Storm Cloud!``|4|6|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|12368|Strange Eddie Set|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Strange Eddie Hair, 1 Strange Eddie Jacket, 1 Strange Eddie Pants, 1 Strange Eddie Shoes, 1 Strange Eddie Axe<CR><CR>`5Description:`` Perfect for being a little strange and different! This pack gives you everything for rocking that Class of '86 look!``|2|6|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|dark|`oDark Assassin's Pack``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` Dark Assassin's Pack. <CR><CR>`5Description:`` This pack contains The Brother Hood item, previously exclusive to the console versions of Growtopia. Also included are Dark Assassin's Vest, Cape, Trousers, Boots and Armguards!|0|3|1000000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11546|`oMood Mask``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Mood Mask. <CR><CR>`5Description:`` Happy? Angry? Curious? Wear this super advanced mask to tell the world how you're feeling!|1|6|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11132|`oNoodle Bowl Hat``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Noodle Bowl Hat. <CR><CR>`5Description:`` A fine bowl of steaming hot noodles to wear on your head. Caution though, these are delicious so everyone might want a slurp from it!|1|0|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11284|`oPaper Wasp Pet``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Paper Wasp Pet. <CR><CR>`5Description:`` Folded and creased to paper perfection. This wasp packs a very unique sting in its tail.|0|1|150000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|11162|`oFinger Gun``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Finger Gun. <CR><CR>`5Description:`` To wield the finger gun, you must first become the gun. Old Growtopian Proverb|2|0|200000|0|||-1|-1||-1|-1||1||||||0|" + extra + (extra_tab.empty() ? "" : "\nselect_item|" + item_));
	}
	else if (tab == "tab2" + extra_tab) {
		string second = "\nadd_button|signal_jammer|`oSignal Jammer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Signal Jammer.<CR><CR>`5Description:`` Get off the grid! Install a `$Signal Jammer``! A single punch will cause it to whir to life, tireless hiding your world and its population from pesky snoopers - only those who know the world name will be able to enter. `5It's a perma-item, is never lost when destroyed.``|1|6|2000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|8878|`oSafe Vault``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Safe Vault. <CR><CR>`5Description:`` Protect your items with a password with GrowTech's new Safe Vault!|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|punch_jammer|`oPunch Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Punch Jammer.<CR><CR>`5Description:`` Tired of getting bashed around? Set up a Punch Jammer in your world, and people won't be able to punch each other! Can be turned on and off as needed. `5It's a perma-item, is never lost when destroyed.``|0|4|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zombie_jammer|`oZombie Jammer``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Zombie Jammer.<CR><CR>`5Description:`` Got a parkour or race that you don't want slowed down? Turn this on and nobody can be infected by zombie bites in your world. It does not prevent direct infection by the g-Virus itself though. `5It's a perma-item, is never lost when destroyed.``|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|recycling_machine|`oRecycling Machine``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Recycling Machine.<CR><CR>`5Description:`` " + items[10374].description + " `5It's a perma-item, is never lost when destroyed.``.<CR><CR> (Item price rises by `20,01%`` gems each purchase.|3|9|" + to_string(1000000 + recycling_machine) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|5196|`oATM Machine 3000``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` `#Rare`` `2ATM Machine 3000``.<CR><CR>`5Description:`` `#Rare`` `2ATM Machine 3000`` that dishes out gems once a day is very nice!|0|1|80000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|3798|" + items[3798].ori_name + "|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[3798].ori_name + "<CR><CR>`5Description:`` " + items[3798].description + "|2|9|100000|0|||-1|-1||-1|-1||1||||||0|"/*"\nadd_button|starship_blast|`oImperial Starship Blast``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Imperial Starship Blast.<CR><CR>`5Description:`` Command your very own Starship and explore the cosmos! This blast contains one of 3 possible Imperial ship types - which will you get? Note: Each Starship comes with a full tank of gas, an Imperial Helm - Mk. I, Imperial Reactor - Mk. I and an Imperial Viewscreen - Mk. I, so you'll be all set for your adventure among the stars! Note: A Starship also comes with an assortment of space-age blocks!|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|surg_blast|`oSurgWorld Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 SurgWorld Blast and 1 Caduceaxe.<CR><CR>`5Description:`` Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|bountiful_blast|`oBountiful Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Bountiful Blast.<CR><CR>`5Description:`` Enter a world of fertile soil, cheerful sunshine and lush green hills, and bountiful new trees! This blast is your ticket to a different kind of farming!|0|3|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|thermo_blast|`oThermonuclear Blast``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|bountiful_blast|`oBountiful Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 Bountiful Blast.<CR><CR>`5Description:`` Enter a world of fertile soil, cheerful sunshine and lush green hills, and bountiful new trees! This blast is your ticket to a different kind of farming!|0|3|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|1402|`oThermonuclear Blast``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Thermonuclear Blast.<CR><CR>`5Description:`` This supervillainous device will blast you to a new world that has been scoured completely empty - it contains nothing but Bedrock and a White Door. Remember: When using this, you are creating a NEW world by typing in a new name. It would be irresponsible to let you blow up an entire existing world.|0|5|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|antigravity_generator|`oAntigravity Generator``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Antigravity Generator.<CR><CR>`5Description:`` Disables gravity in your world when activated! Well, it reduces gravity, and lets everybody jump as much as they want! `5It's a perma-item - never lost when destroyed! `4Not available any other way!````|0|3|450000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|builders_lock|`oBuilder's Lock``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Builders Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles. Wrench the lock to limit it - it can either only allow building, or only allow breaking! `5It's a perma-item, is never lost when destroyed.``|0|2|100000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_sunny|`oWeather Machine - Sunny``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Sunny.<CR><CR>`5Description:`` You probably don't need this one... but if you ever have a desire to turn a sunset or desert world back to normal, grab a Sunny Weather Machine to restore the default Growtopia sky! `5It's a perma-item, is never lost when destroyed.``|0|5|1000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_night|`oWeather Machine - Night``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Night.<CR><CR>`5Description:`` You might not call it weather, but we do! This will turn the background of your world into a lovely night scene with stars and moon. `5It's a perma-item, is never lost when destroyed.``|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_arid|`oWeather Machine - Arid``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Weather Machine - Arid.<CR><CR>`5Description:`` Want your world to look like a cartoon desert? This will turn the background of your world into a desert scene with all the trimmings. `5It's a perma-item, is never lost when destroyed.``|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_rainy|`oWeather Machine - Rainy City``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Weather Machine - Rainy City.<CR><CR>`5Description:`` This will turn the background of your world into a dark, rainy city scene complete with sound effects. `5It's a perma-item, is never lost when destroyed.``|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_warp|`oWeather Machine - Warp Speed``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Weather Machine - Warp Speed.<CR><CR>`5Description:`` This Weather Machine will launch your world through space at relativistic speeds, which will cause you to age more slowly, as well as see stars flying by rapidly in the background. `5It's a perma-item, is never lost when destroyed.``|0|3|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|mars_blast|`oMars Blast``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Mars Blast.<CR><CR>`5Description:`` Blast off to Mars!  This powerful rocket ship will launch you to a new world set up like the surface of Mars, with a special martian sky background, and unique terrain not found elsewhere in the solar system. Mars even has lower gravity than Growtopia normally does! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to Mars, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|undersea_blast|`oUndersea Blast``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Undersea Blast.<CR><CR>`5Description:`` Explore the ocean!  This advanced device will terraform a new world set up like the bottom of the ocean, with a special ocean background, and special blocks like Seaweed, Coral, Jellyfish, Sharks, and maybe a special surprise... Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to an ocean, that would be dangerous.|0|7|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cave_blast|`oCave Blast``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Cave Blast.<CR><CR>`5Description:`` This explosive device will punch a hole in the ground, giving you a dark cavern to explore. There are even rumors of treasure and the entrance to ancient mines, hidden deep in the caves... but make sure you bring a World Lock. The blasted world is not locked when it's created, so lock it before somebody shows up! Remember: When using this, you are creating a NEW world by typing in a new name. You can't convert an existing world to a cave, that would be dangerous.|0|2|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_stuff|`oWeather Machine - Stuff``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Weather Machine - Stuff.<CR><CR>`5Description:`` This is the most fun weather imaginable - Choose any item from your inventory, adjust some settings, and watch it rain down from the sky! Or up, if you prefer reversing the gravity. `5It's a perma-item, is never lost when destroyed.``|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|4774|`oJungle Blast``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Jungle Blast.<CR><CR>`5Description:`` Use this astounding device to create an entirely new jungle world. One free ziggurat included.``|0|5|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|weather_backgd|`oWeather Machine - Background``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Weather Machine - Background.<CR><CR>`5Description:`` This amazing device can scan any Background Block, and will make your entire world look like it's been filled with that block. Also handy for hiding music notes! `5It's a perma-item, is never lost when destroyed.``|0|1|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|digital_rain_weather|`oWeather Machine - Digital Rain``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Weather Machine - Digital Rain.<CR><CR>`5Description:`` Take the grow pill, and we'll show you how deep the rabbit hole goes! Splash the scrolling code of creation across the skies of your worlds. They say you learn to understand it after a while... Note: You can only have one of these per world. `5It's a perma-item, is never lost when destroyed.``|0|6|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|treasure_blast|`oTreasure Blast``|interface/large/store_buttons/store_buttons26.rttex|`2You Get:`` 1 Treasure Blast.<CR><CR>`5Description:`` Enter a world of snow-capped peaks and long-forgotten mysteries! Riddles and secrets - and a ton of treasure - await those who brave this blast's blocks! Remember, when you use this, it'll create a new world by typing in a new name! No sense in searching for clues to great treasures in well-trod worlds, is there?|0|6|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|7380|`oMonochrome Blast``|interface/large/store_buttons/store_buttons24.rttex|`2You Get:`` 1 Monochrome Blast.<CR><CR>`5Description:`` Who needs colour when you have black and white? This advanced device will terraform a new world into a monochromatic marvel, with a special monochrome background, and special monochrome blocks! Includes Rare Onyx Blocks! Remember, by using this you are creating a NEW world by typing in a new name. You can't convert an existing world to a monochrome one, that would be too desaturating.|0|0|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|surg_blast|`oSurgWorld Blast``|interface/large/store_buttons/store_buttons27.rttex|`2You Get:`` 1 SurgWorld Blast and 1 Caduceaxe.<CR><CR>`5Description:`` Your gateway to a world of medical wonders! SurgWorld is a place of care and healing, with all kinds of interesting blocks, top tips on how to treat people with surgery, and an increased chance of getting maladies while you work! Also comes with 1 Caduceaxe to extract Vaccine Drops from blocks. `6Warning:`` May break when extracting vaccine.|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9164|`oDeadly Blast``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` `#1`` `2Deadly Blast``.<CR><CR>`5Description:`` `#1`` `2Deadly Blast`` that has dangerous deadly mushrooms and other cool stuff!|0|10|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9602|Farm Blast|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Farm Blast<CR><CR>`5Description:`` Create awesome farm using this blast!``|1|10|70000|0|||-1|-1||-1|-1||1||||||0|"/*"\nadd_button|infinity_weather_machine|`oInfinity Weather Machine``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Infinity Weather Machine.<CR><CR>`5Description:`` Imagine being able to predict the weather?! Well, with the Infinity Weather Machine you can! Add multiple Weather Machines to this machine and have them play on a loop, like a weather mix tape, kind of!|0|3|25000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|snowy|`oSnowy``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Weather Machine - Snowy. <CR><CR>`5Description:`` Winter is coming. This will turn the background of your world into a snowy mountain scene with snowflakes constantly drifting down. Only available for purchase during WinterFest! It's a perma-item, is never lost when destroyed.|0|2|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|valentines_weather|`oValentine's ``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Weather Machine - Valentine's. <CR><CR>`5Description:`` Love is in the air! Send hearts sailing through pink and fluffy skies with this adorable weather machine and everyone will know what a romantic you are! It's a perma-item, is never lost when destroyed.|0|5|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|paddy|`oWeather Machine - St. Paddy's Day``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Weather Machine - St. Paddy's Day. <CR><CR>`5Description:`` It's Paddy Day here in Growtopia! Celebrate in style with fiddle music, floating shamrocks, rainbows, and a pot o' gold over emerald hills. This Weather Machine will let everyone know how lucky you are!|0|7|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|10286|`oWeather Machine - Celebrity Hills``|interface/large/store_buttons/store_buttons33.rttex|`2You Get:`` 1 Weather Machine - Celebrity Hills. <CR><CR>`5Description:`` It's Thanksgiving in Growtopia! Celebrate in Celebrity Hills where dreams are made! This weather machine will let everyone know how glamorous you are! It's a perma-item, is never lost when destroyed.|1|4|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|4486|`oWeather Machine - Apocalypse``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 Weather Machine - Apocalypse. <CR><CR>`5Description:`` Feeling nostalgic for the end of the world? Let's bring it back! With this weather active, somebody in your world will get infected with the g-Virus every hour, and players can kill zombies in your world, with the appropriate weapon. This sensitive technology will not function while damaged.|0|2|150000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|11880|`oWeather Machine - Plaza``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Weather Machine - Plaza.<CR><CR>`5Description:`` Bring all your friends to the plaza and let the celebrations never end!|4|3|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|3694|Weather Machine - Heatwave|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Weather Machine - Heatwave<CR><CR>`5Description:`` This amazing new weather machine emits a vortex of howling flame, but if you wrench it, you'll find adjustable settings to control the color of the flames! You can only have one of these per world.``|1|1|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|4242|Weather Machine - Pagoda|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Weather Machine - Pagoda<CR><CR>`5Description:`` Wow, it's pagoda season already? They're sprouting up everywhere! This sensitive technology will not function while damaged.``|1|2|250000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|2284|Weather Machine - Party|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Weather Machine - Party<CR><CR>`5Description:`` Bring the party with you everywhere you go! This sensitive will not function while damaged.``|1|3|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|12054|Weather Machine - Nebula|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Weather Machine - Nebula<CR><CR>`5Description:`` As a weather machine, this item can be can be toggled on or off via punching. When toggled on, it will change its appearance, showing a 2-frame animation, and transform the world's background weather into a galactic scenery.``|1|8|1000000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|12056|Protostar Landing|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Weather Machine - Protostar Landing<CR><CR>`5Description:`` As a weather machine, this item can be toggled on or off via punching. When toggled on, it will change its appearance, showing a 2-frame animation, and transform the world's background weather into a otherworldly nature scenery with a giant landed spaceship.``|1|7|500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|crack_in_reality|`oWeather Machine - Crack in Reality``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Weather Machine - Crack in Reality.<CR><CR>`5Description:`` The multiverse is real! Stare into the different realities and ponder the question... what if?!|4|5|150000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|1|9||1||||||0|0|" + (extra_tab.empty() ? "" : "\nselect_item|" + item_);
		p.Insert("set_description_text|`2Item Packs!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/gtps_shop_btn.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/gtps_shop_btn.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/gtps_shop_btn.rttex||1|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/gtps_shop_btn.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/gtps_shop_btn.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/gtps_shop_btn.rttex||0|2|0|0||||-1|-1|||0|0|\nadd_button|world_lock|`oWorld Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 World Lock.<CR><CR>`5Description:`` Become the undisputed ruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 300 Gems.``|0|7|3000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|world_lock_10_pack|`oWorld Lock Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 World Locks.<CR><CR>`5Description:`` 10-pack of World Locks. Become the undisputed ruler of up to TEN kingdoms with these babies. Each works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.`` `wEach recycles for 200 Gems.``|0|3|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|1796|`oDiamond Lock``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Diamond Lock.<CR><CR>`5Description:`` Become the undisputed ruler of your domain with one of these babies.  It works like a normal lock except it locks the `$entire world``!  Won't work on worlds that other people already have locks on. You can even add additional normal locks to give access to certain areas to friends. `5It's a perma-item, is never lost when destroyed.``  `wRecycles for 30000 Gems.``|0|0|300000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|7188|`oBlue Gem Lock``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Blue Gem Lock.<CR><CR>`5Description:`` " + items[7188].description + "|1|4|30000000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12654|`o" + items[12654].ori_name + "``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 " + items[12654].ori_name + "<CR><CR>`5Description:`` " + items[12654].description + "``|1|2|150000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|1|6||1||||||0|0|\nadd_button|11902|Radical City Lock|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Radical City Lock<CR><CR>`5Description:`` Light up your world with this totally Radical Lock!!``<CR>|4|4|500000|0|||0|0|interface/large/gui_shop_buybanner2.rttex|3|3||1||||||0|\nadd_button|small_lock|`oSmall Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Lock.<CR><CR>`5Description:`` Protect up to `$10`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|3|50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|big_lock|`oBig Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Big Lock.<CR><CR>`5Description:`` Protect up to `$48`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|1|1|200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|huge_lock|`oHuge Lock``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Huge Lock.<CR><CR>`5Description:`` Protect up to `$200`` tiles.  Can add friends to the lock so others can edit that area as well. `5It's a perma-item, is never lost when destroyed.``|0|4|500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|door_pack|`oDoor And Sign Hello Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Door and 1 Sign.<CR><CR>`5Description:`` Own your very own door and sign! This pack comes with one of each. Leave cryptic messages and create a door that can open to, well, anywhere.|0|3|15|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|3898|" + items[3898].ori_name + "|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[3898].ori_name + "<CR><CR>`5Description:`` " + items[3898].description + "|2|10|50|0|||-1|-1||-1|-1||1||||||0|\nadd_button|door_mover|`oDoor Mover``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Door Mover.<CR><CR>`5Description:`` Unsatisfied with your world's layout?  This one-use device can be used to move the White Door to any new location in your world, provided there are 2 empty spaces for it to fit in. Disappears when used. `2Only usable on a world you have World Locked.``|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|3560|" + items[3560].ori_name + "|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[3560].ori_name + "<CR><CR>`5Description:`` " + items[3560].description + "|2|11|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|vending_machine|`oVending Machine``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Vending Machine.<CR><CR>`5Description:`` Tired of interacting with human beings? Try a Vending Machine! You can put a stack of items inside it, set a price in World Locks, and people can buy from the machine while you sit back and rake in the profits! `5It's a perma-item, is never lost when destroyed, and it is not available any other way.``|0|6|12000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|digivend_machine|`oDigiVend Machine``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 DigiVend Machine.<CR><CR>`5Description:`` " + items[9268].description + "``|0|2|16000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|vendhub|`oVending Hub - Checkout Counter``|interface/large/store_buttons/store_buttons29.rttex|`2You Get:`` 1 DigiVend Machine.<CR><CR>`5Description:`` " + items[9270].description + "``|0|3|50000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|1280|`oBirth Certificate``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 Change of Address.<CR><CR>`5Description:`` A little white-out, a little scribbling, and voila, you'll have a new name! Use this item to change your GrowID permanently. Can only be used once every 60 days. Requires a GrowID. Is consumed when used.|0|6|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|2580|`oChange of Address``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Change of Address.<CR><CR>`5Description:`` Don't like the name of your world? You can use up one of these to trade your world's name with the name of any other world that you own. You must have a `2World Lock`` in both worlds. Go lock up that empty world with the new name you want and swap away!|0|6|20000|0|||-1|-1||-1|-1||1||||||0|0|" + second);

	}
	else if (tab == "tab3" + extra_tab) {
		p.Insert("set_description_text|`2Awesome Items!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/gtps_shop_btn.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/gtps_shop_btn.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/gtps_shop_btn.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/gtps_shop_btn.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/gtps_shop_btn.rttex|Tired of the same sunny sky?  We offer alternatives within...|1|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/gtps_shop_btn.rttex||0|2|0|0||||-1|-1|||0|0|\nadd_button|5seed|`oSmall Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 1 Small Seed Pack.<CR><CR>`5Description:`` Contains one Small Seed Pack. Open it for `$5`` randomly chosen seeds, including 1 rare seed! Who knows what you'll get?!|1|4|100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ssp_10_pack|`oSmall Seed Pack Collection``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 10 Small Seed Packs.<CR><CR>`5Description:`` Open each one for `$5`` randomly chosen seeds apiece, including 1 rare seed per pack! Who knows what you'll get?!|0|4|1000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rare_seed|`oRare Seed Pack``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Randomly Chosen Rare Seeds.<CR><CR>`5Description:`` Expect some wondrous crops with these!|1|7|1000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|farmable_pack|`oFarmable Pack``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 50 Chandelier, 50 Laser Grid, 50 Pepper Tree.<CR><CR>`5Description:`` Get cheap farmables for a fair price, why not?...|0|8|3000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grow_spray|`o5-pack of Grow Spray Fertilizer``|interface/large/store_buttons/store_buttons.rttex|`2You Get:`` 5 Grow Spray Fertilizers.<CR><CR>`5Description:`` Why wait?!  Treat yourself to a `$5-pack`` of amazing `wGrow Spray Fertilizer`` by GrowTech Corp.  Each bottle instantly ages a tree by `$1 hour``.|0|6|200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|7962|`oProvider Spray``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` `#1`` `2Provider Spray``.<CR><CR>`5Description:`` `#1`` `2Provider Spray`` that can speed up any provider by 6 hours!|0|9|400|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|deluxe_grow_spray|`oDeluxe Grow Spray``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Deluxe Grow Spray.<CR><CR>`5Description:`` GrowTech's new `$Deluxe`` `wGrow Spray`` instantly ages a tree by `$24 hours`` per bottle! That's somewhere around 25 times as much as regular Grow Spray!|0|2|900|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|5764|`oOriental Spice Spray``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 Oriental Spice Spray. <CR><CR>`5Description:`` Packed with rich spices and wholesome powers, this spray will speed up the growth of one tree from the Chinese New Year event by 72 hours!|0|0|2500|0|||-1|-1||-1|-1||1||||||0|\nadd_button|12600|`oUltra World Spray``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Ultra World Spray.<CR><CR>`5Description:`` A shocking display of power!``|0|1|5000000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|2|5||1||||||0|0|\nadd_button|surg_starter_pack|`oSurgery Starter Pack``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 `#Rare Heart Monitor``, 1 Hospital Bed, 5 Train-E bots, 1 Scrub Cap, 1 Scrub Mask, 1 Scrub Top, and 1 Scrub Pants. <CR><CR>`5Description:`` Get all the furniture you need to start up your own private surgery practice! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, 5 Train-E bot to practice on, and a full set of scrubs to look the part.|1|0|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|surg|`oSurgical Kit``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 5 of each of the 13 different Surgical Tools and 1 Surg-E.<CR><CR>`5Description:`` Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do that surgery!|0|2|12000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|surg_value_pack|`oSurgical Tools Value Pack ``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 20 of each of the 13 different Surgical Tools and 5 Surg-E.<CR><CR>`5Description:`` Get all the tools you need and 5 Surg-E bots to perform surgery on at a discounted price! and 20 each of the thirteen different Surgical Tools you'll need to do that surgery!|0|0|40000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 `#Rare Tackle Box``, 10 Fish Tanks and 1 `#Rare Fish Tank Port`` .<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|bountiful_seed_pack|`oBountiful Seed Pack``|interface/large/store_buttons/store_buttons28.rttex|`2You Get:`` 1 Bountiful Seed Pack.<CR><CR>`5Description:`` Contains `$5`` randomly chosen bountiful seeds, including 1 rare seed! Who knows what you'll get?!|0|4|1000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|basic_splice|`oBasic Splicing Kit``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 10 Rock Seeds and 10 Random Seeds of Rarity 2.<CR><CR>`5Description:`` The basic seeds every farmer needs.|0|3|200|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|surgical_kit|`oSurgical Kit``|interface/large/store_buttons/store_buttons7.rttex|`2You Get:`` 1 `#Rare Heart Monitor``, 1 Hospital Bed, 1 Train-E Bot, 5 of each of the 13 different Surical Tools and 10 Med-a-Checks.<CR><CR>`5Description:`` Get all the tools you need to become Chief of Surgery at Growtopia General Hospital! `#Rare`` Heart Monitor that lets people know when you are online, Hospital Bed that lets you perform surgery on anybody laying (or standing) on it, Med-a-Checks to identify patients with maladies, The Train-E bot to practice on, and 5 each of the thirteen different Surgical Tools you'll need to do that surgery!|0|2|12000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|star_supplies|`oGalactic Goodies``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 60 Star Tools and 25 Star Fuel.<CR><CR>`5Description:`` Get all the Star Tools you need to boldly go where no Growtopian has gone! Use these to help you command a starship and seek victory in the Galactic Nexus! You'll get 5 each of the 12 Star Tools you'll need to complete missions and some bonus Star Fuel to help power a Starship!|0|0|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fishin_pack|`oFishin' Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Fishing Rod, 5 Wiggly Worms, 1 Hand Drill, 1 Nuclear Detonator,  1 `#Rare Tackle Box``, 10 Fish Tanks and 1 `#Rare Fish Tank Port`` .<CR><CR>`5Description:`` Relax and sit by the shore... this pack includes a Fishing Rod, Wiggly Worms for bait, Hand Drill, Nuclear Detonator, and a `#Rare`` Tackle Box which provides you with more free bait every two days, Fish Tanks, and a `#Rare`` Fish Tank Port to put the fish you catch into your fish tank!|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_training_pack|`oFish Trainin' Pack``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 2 Fish Flakes, 2 Fish Medicine, AND 1 `#Rare Training Port``.<CR><CR>`5Description:`` Get ready to train your favorite fish! Use the Training Port to put a perfect fish into your fish tank for training!|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_flakes|`oFish Flakes``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 5 Fish Flakes.<CR><CR>`5Description:`` Every fish adores these tasty flakes! Give a pinch to your Training Fish and fill their scaly bellies with aquatic goodness! Take the guesswork out of finnicky feedings with a treat you know they'll love!|0|2|7500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_medicine|`oFish Medicine``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 Fish Medicine.<CR><CR>`5Description:`` Make a sick Training Fish bright and healthy with this healing potion. One dose is enough to make even the sickest fish all better!|0|0|1500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fish_reviver|`oFish Reviver``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 `#Rare Fish Reviver``.<CR><CR>`5Description:`` Resurrect a dead Training Fish with a revivifying zap from this `#Rare`` Fish Reviver! One dose is enough to reach beyond the veil and bring a fish back from the dead! Comes with a 100% zombie-free guarantee!|0|1|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|crime_wave|`oCrime Wave``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 5 Random Superpower Cards and 1 `#Rare Crime Wave``.<CR><CR>`5Description:`` Get powered up with random Superpower Cards, and what good would that be without a `#Rare`` Crime Wave to use them on? A Crime Wave is a one-use item that calls four villains to your world for you to battle. `6Beware:`` Villains only stick around for 24 hours once they appear.|0|5|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|silkworm|`oSilkworm``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Silk Worm.<CR><CR>`5Description:`` It's the newest cuddly pet from Growtech Pharma! Thanks to genetic engineering, you can now raise your own giant mutant silkworm. They'll eat almost any food, but don't forget to give them water too! And if they get sick, you'll need to have some Antidotes on hand. `6Warning:`` `9Silkworms are living creatures. They will not live forever! Take good care of them, and enjoy them while you can.`` `4Not available any other way``.|0|7|7000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|geiger|`oGeiger Counter``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Geiger Counter.<CR><CR>`5Description:`` With this fantabulous device, you can detect radiation around you. It bleeps red, then yellow, then green as you get closer to the source. Who knows what you might find? `4Not available any other way!``|0|1|25000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zombie_pack|`oZombie Defense Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 `#Rare Sawed-Off Shotgun``, 1 Combat Vest, 1 Zombie Stompin' Boots, 3 Traffic Barricades, 1 Military Radio, 1 Antidote, 3 Toxic Waste Barrels, 3 Biohazard Signs, 3 Tombstones and 1 `#Rare Deadly G-Virus``!.<CR><CR>`5Description:`` The zombie invasion has come! Protect yourself with all the esential zombie fighting gear and best of all, you get an Antidote to cure yourself! Also includes the deadly g-Virus itself to infect your friends with!|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ssp200|`oSmall Seed Collection Pack``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` 200 Small Seed Pack. <CR><CR>`5Description:`` Open each one for 5 randomly chosen seed apiece, including 1 rare seed per pack! Who knows what you'll get?!|1|3|9000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12840|`oSuperstar Background``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 5 Superstar Background.<CR><CR>`5Description:`` " + items[12840].description + "``|2|4|5000|0|||-1|-1|interface/large/gui_shop_buybanner2.rttex|3|7||1||||||0|0|\nadd_button|arm_guy|`oWaving Inflatable Arm Guy``|interface/large/store_buttons/store_buttons35.rttex|`2You Get:`` Waving Inflatable Arm Guy. <CR><CR>`5Description:`` Great for showing everyone all the amazing things you have to offer! Also just great fun to be around.|1|2|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|12680|`oWonder Provider``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 Wonder Provider. <CR><CR>`5Description:`` A wonderous provider that will give wonderful things every day for 7 days from the time you place it!|1|3|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|pegasus_chest|`oPegasus Chest``|interface/large/store_buttons/store_buttons36.rttex|`2You Get:`` 1 Pegasus Chest. <CR><CR>`5Description:`` A chest of feathery delights! What might be inside, my fair feathered friend? Use it on yourself to find out!|1|7|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|race_pack|`oRacing Action Pack``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 1 Racing Start Flag, 1 Racing End Flag, 2 Checkpoints, 2 Big Old Sideways Arrows, 1 Big Old Up Arrow, 1 Big Old Down Arrow, 1 WristBand, 1 HeadBand, 1 Sports Ball Jersey and 1 Air Robinsons.<CR><CR>`5Description:`` Get all you need to host races in your worlds! You'll win the races too, with new Air Robinsons that make you run faster!|0|7|3500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|music_pack|`oComposer's Pack``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 20 Sheet Music: Blank, 20 Sheet Music: Piano Note, 20 Sheet Music: Bass Note, 20 Sheet Music Drums, 5 Sheet Music: Sharp Piano, 5 Sheet Music: Flat Piano, 5 Sheet Music: Flat Bass and 5 Sheet Music: Sharp Bass .<CR><CR>`5Description:`` With these handy blocks, you'll be able to compose your own music, using your World-Locked world as a sheet of music. Requires a World Lock (sold separately!).|0|0|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|school_pack|`oEducation Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 ChalkBoards, 3 School Desks, 20 Red Bricks, 1 Bulletin Board, 10 Pencils, 1 Growtopia Lunchbox, 1 Grey Hair Bun, 1 Apple and 1 Random School Uniform Item.<CR><CR>`5Description:`` If you want to build a school in Growtopia, here's what you need!|0|0|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dungeon_pack|`oDungeon Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 20 Grimstone, 20 Blackrock Wall, 20 Iron Bars, 3 Jail Doors, 3 Skeletons, 1 Headsman's Axe, 1 Worthless Rags. 5 Torches and a `#Rare Iron Mask!``.<CR><CR>`5Description:`` Lock up your enemies in a dank dungeon! Of course they can still leave whenever they want. But they won't want to, because it looks so cool! Iron Mask muffles your speech!|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fantasy_pack|`oFantasy Pack``|interface/large/store_buttons/store_buttons3.rttex|`2You Get:`` 1 Mystical Wizard Hat Seed, 1 Wizards Robe, 1 Golden Sword, 1 Elvish Longbow, 10 Barrels, 3 Tavern Signs, 3 Treasure Chests and 3 Dragon Gates.<CR><CR>`5Description:`` Hear ye, hear ye! It's a pack of magical wonders!|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|vegas_pack|`oVegas Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 10 Neon Lights, 1 Card Block Seed, 1 `#Rare Pink Cadillac`` 4 Flipping Coins, 1 Dice Block, 1 Gamblers Visor, 1 Slot Machine, 1 Roulette Wheel and 1 Showgirl Hat, 1 Showgirl top and 1 Showgirl Leggins.<CR><CR>`5Description:`` What happens in Growtopia stays in Growtopia!|0|5|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|farm_pack|`oFarm Pack``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Cow, 1 Chicken, 10 Wheat, 10 Barn Block, 10 Red Wood Walls, 1 Barn Door, 1 Straw Hat, 1 Overalls, 1 Pitchfork, 1 Farmgirl Hair, 1 `#Rare`` `2Dear John Tractor``.<CR><CR>`5Description:`` Put the `2Grow`` in Growtopia with this pack, including a Cow you can milk, a Chicken that lays eggs and a farmer's outfit. Best of all? You get a `#Rare`` `2Dear John Tractor`` you can ride that will mow down trees!|0|0|15000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|science_pack|`oMad Science Kit``|interface/large/store_buttons/store_buttons5.rttex|`2You Get:`` 1 Science Station, 1 Laboratory, 1 LabCoat, 1 Combover Hair, 1 Goggles, 5 Chemical R, 10 Chemical G, 5 Chemical Y, 5 Chemical B, 5 Chemical P and 1 `#Rare`` `2Death Ray``.<CR><CR>`5Description:`` It's SCIENCE! Defy the natural order with a Science Station that produces chemicals, a Laboratory in which to mix them and a full outfit to do so safely! You'll also get a starter pack of assorted chemicals. Mix them up! Special bonus: A `#Rare`` `2Death Ray`` to make your science truly mad!|0|3|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|city_pack|`oCity Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 10 Sidewalks, 3 Street Signs, 3 Streetlamps, 10 Gothic Building tiles, 10 Tenement Building tiles, 10 Fire Escapes, 3 Gargoyles, 10 Hedges, 1 Blue Mailbox, 1 Fire Hydrant and A `#Rare`` `2ATM Machine``.<CR><CR>`5Description:`` Life in the big city is rough but a `#Rare`` `2ATM Machine`` that dishes out gems once a day is very nice!|0|0|12000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|west_pack|`oWild West Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Cowboy Hat, 1 Cowboy Boots, 1 War Paint, 1 Face Bandana, 1 Sheriff Vest, 1 Layer Cake Dress,  1 Corset, 1 Kansas Curls, 10 Western Building 1 Saloon Doors, 5 Western Banners, 1 Buffalo, 10 Rustic Fences, 1 Campfire and 1 Parasol.<CR><CR>`5Description:`` Yippee-kai-yay! This pack includes everything you need to have wild time in the wild west! The Campfire plays cowboy music, and the `#Parasol`` lets you drift down slowly. Special bonus: A `#Rare`` `2Six Shooter`` to blast criminals with!|0|2|8000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|astro_pack|`oAstro Pack``|interface/large/store_buttons/store_buttons6.rttex|`2You Get:`` 1 Astronaut Helmet, 1 Space Suit, 1 Space Pants, 1 Moon Boots, 1 Rocket Thruster, 1 Solar Panel, 6 Space Connectors, 1 Porthole, 1 Compu Panel, 1 Forcefield and 1 `#Rare`` `2Zorbnik DNA``.<CR><CR>`5Description:`` Boldly go where no Growtopian has gone before with an entire Astronaut outfit. As a special bonus, you can have this `#Rare`` `2Zorbnik DNA`` we found on a distant planet. It doesn't do anything by itself, but by trading with your friends, you can collect 10 of them, and then... well, who knows?|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|prehistoric_pack|`oPrehistoric Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 1 Caveman Club, 1 Cave Woman Hair, 1 Caveman Hair, 1 Sabertooth Toga, 1 Fuzzy Bikini Top, 1 Fuzzy Bikni Bottom, 1 Cavewoman Outfit, 10 Cliffside, 5 Rock Platforms, 1 Cave Entrance, 3 Prehistoric Palms and 1 `#Rare Sabertooth Growtopian``.<CR><CR>`5Description:`` Travel way back in time with this pack, including full Caveman and Cavewoman outfits and `#Rare Sabertooth Growtopian`` (that's a mask of sorts). Unleash your inner monster!|0|0|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|shop_pack|`oShop Pack``|interface/large/store_buttons/store_buttons8.rttex|`2You Get:`` 4 Display Boxes, 1 For Sale Sign, 1 Gem Sign, 1 Exclamation Sign, 1 Shop Sign, 1 Open Sign, 1 Cash Register, 1 Mannequin and 1 Security Camera.<CR><CR>`5Description:`` Run a fancy shop with these new items! Advertise your wares with an Open/Closed Sign you can switch with a punch, a Cash Register, a Mannequin you can dress up to show off clothing, and a `#Rare`` Security Camera, which reports when people enter and take items!|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|home_pack|`oHome Pack``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Television, 4 Couches, 2 Curtains, 1 Wall Clock, 1 Microwave, 1 Meaty Apron, 1 Ducky Pants, 1 Ducky top and 1 Eggs Benedict.<CR><CR>`5Description:`` Welcome home to Growtopia! Decorate with a Television, Window Curtains, Couches, a `#Rare`` Wall Clock that actually tells time, and a Microwave to cook in. Then dress up in a Meaty Apron and Ducky Pajamas to sit down and eat Eggs Benedict, which increases the amount of XP you earn!|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cinema_pack|`oCinema Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Clapboard, 1 Black Beret, 1 3D Glasses, 6 Theater Curtains, 6 Marquee Blocks, 1 Director's Chair, 4 Theater Seats, 6 Movie Screens, 1 Movie Camera and 1 `#Rare GHX Speaker``.<CR><CR>`5Description:`` It's movie time! Everything you need for the big screen experience including a `#Rare GHX Speaker`` that plays the score from Growtopia: The Movie.|0|2|6000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|adventure_pack|`oAdventure Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 4 Gateways to Adventure, 4 Path Markers, 1 Lazy Cobra, 1 Adventure Brazier, 4 Adventure Barriers, 1 Rope, 1 Torch, 1 Key, 1 Golden Idol, 1 `#Rare Adventuring Mustache``, 1 Explorer's Ponytail and 1 Sling Bag .<CR><CR>`5Description:`` Join Dr. Exploro and her father (also technically Dr. Exploro) as they seek out adventure! You can make your own adventure maps with the tools in this pack.|0|7|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rockin_pack|`oRockin' Pack``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 3 `#Rare Musical Instruments`` Including A Keytar, a Bass Guitar and Tambourine, 1 Starchild Make Up, 1 Rockin' Headband, 1 Leopard Leggings, 1 Shredded Ts-Shirt, 1 Drumkit, 6 Stage Supports, 6 Mega Rock Speakers and 6 Rock n' Roll Wallpaper.<CR><CR>`5Description:`` ROCK N' ROLL!!! Play live music in-game! We Formed a Band! Growtopia makes me want to rock out.|0|0|9999|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|game_pack|`oGame Pack``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 `#Rare Game Generator``,  4 Game Blocks, 4 Game Flags, 4 Game Graves and 4 Game Goals.<CR><CR>`5Description:`` Growtopia's not all trading and socializing! Create games for your friends with the Game Pack (and a lot of elbow grease).|0|6|50000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|superhero|`oSuperhero Pack``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Mask, 1 Shirt, 1 Boots, 1 Tights, 1 Cape, `#Rare Super Logos`` or `#Rare Utility Belt`` and 1 `2Phone Booth``.<CR><CR>`5Description:`` Battle the criminal element in Growtopia with a complete random superhero outfit including a cape that lets you double jump. Each of these items comes in one of six random colors. You also get one of 5 `#Rare`` Super Logos, which automatically match the color of any shirt you wear or a `#Rare`` Utility Belt... of course use the `2Phone Booth`` to change into your secret identity!|0|0|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|fashion_pack|`oFashion Pack``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 3 Random Clothing Items, 3 Jade Blocks and 1 `#Rare Spotlight``.<CR><CR>`5Description:`` The hottest new looks for the season are here now with 3 random Fashion Clothing (dress, shoes, or purse), Jade Blocks to pose on, and a `#Rare`` Spotlight to shine on your fabulousness.|0|0|6000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|sportsball_pack|`oSportsball Pack``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 2 Basketball Hoops, 2 Sporty Goals, 5 Stadiums, 5 Crowded Stadiums, 10 Field Grass, 1 Football Helmet, 1 Growies Cap, 1 Ref's Jersey, 1 World Cup Jersey, 1 `#Rare Sports Item`` or `#Rare Growmoji!``.<CR><CR>`5Description:`` We like sports and we don't care who knows! This pack includes everything you need to get sporty! Use the Sports Items to launch Sportsballs at each other.|0|1|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|firefighter|`oFirefighter Pack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Yellow Helmet, 1 Yellow Jacket, 1 Yellow Pants, 1 Firemans Boots, 1 Fire Hose, and 1 `#Rare Firehouse`` .<CR><CR>`5Description:`` Rescue Growtopians from the fire! Includes a full Yellow Firefighter Outfit, Fire Hose and a `#Rare Firehouse``, which will protect your own world from fires.|0|1|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|steampack|`oSteampack``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 10 Steam Tubes, 2 Steam Stompers, 2 Steam Organs, 2 Steam Vents, 2 Steam Valves and 1 `#Rare Steampunk Top Hat``.<CR><CR>`5Description:`` Steam! It's a wondrous new technology that lets you create paths of Steam Blocks, then jump on a Steam Stomper to launch a jet of steam through the path, triggering steam-powered devices. Build puzzles, songs, parkour challenges, and more!|0|6|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|paintbrush|`oPainter's Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Paintbrush``, 1 `#Rare Painting Easel`` and 20 Random Colored Paint Buckets.<CR><CR>`5Description:`` Want to paint your world? This pack includes 20 buckets of random paint colors (may include Varnish, to clean up your messes)! You can paint any block in your world different colors to personalize it.|0|1|20000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|paleo_kit|`oPaleontologist's Kit``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 5 Fossil Brushes, 1 Rock Hammer, 1 Rock Chisel, 1 Blue Hardhat and 1 `#Rare Fossil Prep Station``.<CR><CR>`5Description:`` If you want to dig up fossils, this is the kit for you! Includes everything you need! Use the prepstation to get your fossils ready for display.|0|0|20000|0|||-1|-1||-1|-1||1||||||0|0|"/*"\nadd_button|robot_starter_pack|`oCyBlocks Starter Pack``|interface/large/store_buttons/store_buttons18.rttex|`2You Get:`` 1 `5Rare ShockBot`` and 10 random movement commands.<CR><CR>`5Description:`` CyBlocks Starter Pack includes one `5Rare`` ShockBot and 10 random movement commands to use with it. `5ShockBot`` is a perma-item, is never lost when destroyed.|0|6|2500|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_command_pack|`oCyBlocks Command Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 10 Random CyBlock Commands.<CR><CR>`5Description:`` Grants 10 random CyBlock Commands to help control your CyBots!|0|2|1000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|robot_pack|`oCyBot Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 `5Rare CyBot``!<CR><CR>`5Description:`` Grants one random `5Rare`` CyBot! Use CyBlock Commands to send these mechanical monsters into action! `5Note: Each CyBot is a perma-item, and will never be lost when destroyed.``|0|3|7500|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|gang_pack|`oGangland Style``|interface/large/store_buttons/store_buttons2.rttex|`2You Get:`` 1 Fedora, 1 Dames Fedora, 1 Pinstripe Suit with Pants, 1 Flapper Headband with Dress, 1 Cigar, 1 Tommy Gun, 1 Victola and 10 Art Deco Blocks .<CR><CR>`5Description:`` Step into the 1920's with a Complete Outfit, a Tommygun, a Victrola that plays jazz music, and 10 Art Deco Blocks. It's the whole package!|0|6|5000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zombie_pack|`oZombie Defense Pack``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:`` 1 `#Rare Sawed-Off Shotgun``, 1 Combat Vest, 1 Zombie Stompin' Boots, 3 Traffic Barricades, 1 Military Radio, 1 Antidote, 3 Toxic Waste Barrels, 3 Biohazard Signs, 3 Tombstones and 1 `#Rare Deadly G-Virus``!.<CR><CR>`5Description:`` The zombie invasion has come! Protect yourself with all the esential zombie fighting gear and best of all, you get an Antidote to cure yourself! Also includes the deadly g-Virus itself to infect your friends with!|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|boo_pack|`oB.O.O. Training Pack``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 `#Rare Spectral Goggles``, 1 Neutron Gun, 1 Neutron Pack and 10 Ghost Jars <CR><CR>`5Description:`` It looks like Growtopia is under siege by ghosts! Well, the `9Battlers Of the Otherworldly`` are hiring! You'll have to earn your uniform, but this pack includes all the tools you need to actually capture ghosts! Including `#Rare`` Spectral Goggles (all the better to see them with!)and a Neutron Pack to corral the ghosts, of course 10 Ghost Jars to catch them in.|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ectojuicer|`oEctoJuicer``|interface/large/store_buttons/store_buttons20.rttex|`2You Get:`` 1 EctoJuicer.<CR><CR>`5Description:`` Infuse your muscles with the unearthly might of the Other Side! This spectral potion gives you the strength to wring every last drop of ectoplasm from a defeated Boss Ghost, granting you an EXTRA Boss Goo after a successful banishing!|0|0|30000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|ghost_hunting|`oGhost Hunter's Pack``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` At least 5 Ghost Jars and 1 Bonus Item.<CR><CR>`5Description:`` Essentials for Ghost Hunting! Guaranteed to have at least 5x Ghost Jars, plus one or more bonus items! Prizes can include: Neutron Focus Cores, Containment Field Power Nodes, EXTRA Ghost Jars, Ghost Traps, Spirit Boards, and maybe even a Dark Spirit Board!|0|7|10000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|chemsynth|`oChemsynth Pack``|interface/large/store_buttons/store_buttons16.rttex|`2You Get:`` 1 `#Rare Chemsynth Processor``, 10 Chemsynth Tanks and 1 Chemsynth Replicator, 1 Chemsynth Catalyst, 1 Chemsynth Solvent, 1 Chemsynth Centrifuge, 1 Chemsynth Stirrer.<CR><CR>`5Description:`` Tired of the lousy chemicals nature has to offer? Create new synthetic ones! With a `#Rare`` Chemsynth Processor, Chemsynth Tanks, and one each of the five Chemsynth tools, you can be whipping up Synthetic Chemicals in no time. `6Warning:`` Chemsynth solving is a pretty tricky puzzle, and it costs a whole bunch of the five basic chemicals (R, G, B, P, and Y) to complete.|0|4|10000|0|||-1|-1||-1|-1||1||||||0|0|" + (extra_tab.empty() ? "" : "\nselect_item|" + item_));
	}
	else if (tab == "tab5" + extra_tab) p.Insert("set_description_text|`2Custom Items!``  Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/gtps_shop_btn.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/gtps_shop_btn.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/gtps_shop_btn.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/gtps_shop_btn.rttex||1|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/gtps_shop_btn.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/gtps_shop_btn.rttex||0|2|0|0||||-1|-1|||0|0|\nadd_button|10938|`o" + items[10938].ori_name + "``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[10938].ori_name + ". <CR><CR>`5Description:`` " + items[10938].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.)|4|7|" + to_string(10000000 + _10938_) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|e_scepter|`oEclipsebane Scepter``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Eclipsebane Scepter. <CR><CR>`5Description:`` " + items[10936].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.)|4|6|" + to_string(1000000 + e_scepter) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dracula_set|`oDracula Set``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Dracula Hair & 1 Dracula Wings!<CR><CR>`5Description:`` " + items[10932].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.|4|1|" + to_string(500000 + dracula_set) + "|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10930|`oVapor Blade``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Vapor Blade!<CR><CR>`5Description:`` " + items[10930].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.|4|0|" + to_string(500000 + vapor_blade) + "|0|||-1|-1||-1|-1||1||||||0|\nadd_button|cursed_eyes|`oCursed Eyes``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Cursed Eyes. <CR><CR>`5Description:`` " + items[10928].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.)|3|13|" + to_string(1000000 + cursed_eyes) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|experience_rayman|`oExperience Rayman's Fist``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Experience Rayman's Fist!<CR><CR>`5Description:`` " + items[10362].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.|3|7|" + to_string(100000000 + experience_rayman) + "|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10364|`oZeus' Lightning Crown``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Zeus' Lightning Crown!<CR><CR>`5Description:`` " + items[10364].description + "<CR><CR> (Item price rises by `20,01%`` gems each purchase.|3|8|" + to_string(500000 + zeus_crown) + "|0|||-1|-1||-1|-1||1||||||0|\nadd_button|recycling_machine|`oRecycling Machine``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Recycling Machine.<CR><CR>`5Description:`` " + items[10374].description + " `5It's a perma-item, is never lost when destroyed.``.<CR><CR> (Item price rises by `20,01%`` gems each purchase.|3|9|" + to_string(1000000 + recycling_machine) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|boombox|Custom Music Boombox Pack|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Central Cee's Boombox, 1 Ice Spice's Boombox, 1 Drake's Boombox, 1 Phonk Boombox, 1 Marshmello's Boombox, 1 Pop Smoke's Boombox <CR><CR>`5Description:`` Receive a pack of custom music boomboxes!|2|4|50000|0|||-1|-1||-1|-1||1||||||0|"/*"\nadd_button|mythical|Mythical Infinity Rayman's Fist|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Mythical Infinity Rayman's Fist<CR><CR>`5Description:`` " + items[9908].description + "|2|0|100000000|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|9906|Legendary Infinity Rayman's Fist|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Legendary Infinity Rayman's Fist<CR><CR>`5Description:`` " + items[9906].description + "<CR><CR>`5Extra information:`` Rises by 3,000,000 on every purchase.``|0|12|" + to_string(role_price.lrayman_price) + "|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9814|`wIOTM Mystery Box``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 IOTM Mystery Box.<CR><CR>`5Description:`` This mysterious box contains one Item Of The Month. Place it in your world and break to see what's inside. It could contain `#Rare Rayman's Fist``, `#Rare MAGPLANT 5000``, `#Royal Lock`` or `#GrowScan 9000``.|2|6|200000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9910|" + items[9910].ori_name + "|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[9910].ori_name + "<CR><CR>`5Description:`` " + items[9910].description + "<CR><CR>`5Extra information:`` Farmable.``|2|1|6000|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9818|" + items[9818].ori_name + "|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[9818].ori_name + "<CR><CR>`5Description:`` " + items[9818].description + "|2|7|300000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|9824|" + items[9824].ori_name + "|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[9824].ori_name + "<CR><CR>`5Description:`` " + items[9824].description + "|2|8|300000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|9822|" + items[9822].ori_name + "|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 " + items[9822].ori_name + "<CR><CR>`5Description:`` " + items[9822].description + "|2|12|300000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|10016|Hide And Seek Ticket|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Hide And Seek Ticket <CR><CR>`5Description:`` " + items[10016].description + "|2|14|1000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|9946|Washing Machine|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Washing Machine<CR><CR>`5Description:`` " + items[9946].description + "|2|2|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|9582|Minecraft Blast|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Minecraft Blast, 25 Minecraft Dirt, 25 Minecraft Wood, 50 Minecraft Leaves, 10 Minecraft Portal, 10 Minecraft Obsidian<CR><CR>`5Description:`` Find awesome treasures in this Minecraft blasted world, first find a `2hidden password door`` in a world, enter the `2password`` and collect the dropped `2tnt`` and `2rock hammers``, `2tnt`` are used to explode the `2unbreakable`` stones, `2rock hammers`` are used to break `2gold`` and `2diamond`` ores.``|1|5|25000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|9788|Tech Fleece - Gray|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Tech Fleece Hoodie - Gray, 1 Tech Fleece Joggers - Gray, 1 Air Forces - White <CR><CR>`5Description:`` Awesome Gray - Tech Fleece Pack!``|1|11|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|9794|Tech Fleece - Black|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Tech Fleece Hoodie - Black, 1 Tech Fleece Joggers - Black, 1 Air Forces - Black <CR><CR>`5Description:`` Awesome Black - Tech Fleece Pack!``|1|12|50000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|7584|Sprite's Robe|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Sprite's Robe<CR><CR>`5Description:`` Don this beautiful robe to summon the power of a playful sprite! Every jump will transform you into a Sprite for a time and take you bounding above the world!``<CR><CR>`5Picture Credits:`` `#@keycards``, `#@JCLine``.|1|9|200000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|9540|Duct Taped|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Duct Taped<CR><CR>`5Description:`` You've been muted more than 100 times might as well have your own duct tape.``|0|14|600000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|pink_pack|Pink Pack|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Pink Focused Eyes and 1 Pink Pickaxe<CR><CR>`5Description:`` 2 Pink cool custom items.``|1|0|7500000|0|||-1|-1||-1|-1||1||||||0|\nadd_button|5190|`oNyan Hat``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` `#Rare`` `2Nyan Hat``.<CR><CR>`5Description:`` `#Rare`` `2Nyan Hat`` NYAN NYAN NYAN NYAN NYAN!|0|2|500000|0|||-1|-1||-1|-1||1||||||0|0|\n|0|0|" + (extra_tab.empty() ? "" : "\nselect_item|" + item_));
	else if (tab == "tab6" + extra_tab) p.Insert("set_description_text|`2Spend your Growtokens!`` (You have `50``) You earn Growtokens from Crazy Jim and Sales-Man. Select the item you'd like more info on, or BACK to go back.\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/gtps_shop_btn.rttex||0|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/gtps_shop_btn.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/gtps_shop_btn.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/gtps_shop_btn.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/gtps_shop_btn.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/gtps_shop_btn.rttex||1|2|0|0||||-1|-1|||0|0|"/*"\nadd_button|challenge_timer|`oChallenge Timer``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Challenge Timer.<CR><CR>`5Description:`` Get more people playing your parkours with this secure prize system. You'll need a `#Challenge Start Flag`` and `#Challenge End Flag`` as well (not included). Stock prizes into the Challenge Timer, set a time limit, and watch as players race from start to end. If they make it in time, they win a prize!|0|5|-2|0|||-1|-1||-1|-1||1||||||0|0|"*/"\nadd_button|megaphone|`oMegaphone``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Megaphone.<CR><CR>`5Description:`` You like broadcasting messages, but you're not so big on spending gems? Buy a Megaphone with Growtokens! Each Megaphone can be used once to send a super broadcast to all players in the game.|0|7|-5|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|xp_potion|`oExperience Potion``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Experience Potion.<CR><CR>`5Description:`` This `#Untradeable`` delicious fizzy drink will make you smarter! 10,000 XP smarter instantly, to be exact.|0|2|-10|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|i_love_dirt_shirt|`oI love Dirt Shirt``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 I love Dirt Shirt.<CR><CR>`5Description:`` Some people like things to be clean, you're not one of them are you? This item is `#Untradeable``.|4|0|-10|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|growmoji_pack|`oGrowmoji Mystery Box``|interface/large/store_buttons/store_buttons19.rttex|`2You Get:`` 1 Growmoji.<CR><CR>`5Description:`` Express yourself! This mysterious box contains one of five fun growmojis you can use to spice up your chat! Which will you get?|0|1|-15|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|rollback|`oRollback Pack``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Rollback Plaque, 1 Rollback Plaque II, 1 Rollback Plaque III.<CR><CR>`5Description:`` Get rollback blocks!|2|5|-20|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|mini_mod|`oMini-Mod``|interface/large/store_buttons/store_buttons17.rttex|`2You Get:`` 1 Mini-Mod.<CR><CR>`5Description:`` Oh no, it's a Mini-Mod! Punch him to activate (you'll want to punch him!). When activated, he won't allow anyone to drop items in your world.|0|0|-20|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|derpy_star|`oDerpy Star Block``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Derpy Star Block.<CR><CR>`5Description:`` DER IM A SUPERSTAR. This is a fairly ordinary block, except for the derpy star on it. Note: it is not permanent, and it doesn't drop seeds. So use it wisely!|0|3|-30|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|2218|`oMighty Snow Rod``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Mighty Snow Rod.<CR><CR>`5Description:`` Become the living embodiment of the winter with this deadly weapon! It blasts bricks with frost, smashing them more easily than a punch. Buy it today, before WinterFest ends and you can't get it for another year! Sponsored by iiStyloMilo, Bambam46, and MartinMan007's Subscribers.|0|4|-30|0|||-1|-1||-1|-1||1||||||0|0|rttex\nadd_button|saeedru_ghutra|`oSaeedRu's Ghutra``|interface/large/store_buttons/store_buttons39.rttex|`2You Get:`` 1 SaeedRu's Ghutra.<CR><CR>`5Description:`` A traditional headwear worn in the Middle East! Sponsored by SaeedRu for completing all epic quests!|4|2|-40|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|dirt_gun|`oBLYoshi's Free Dirt``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 BLYoshi's Free Dirt.<CR><CR>`5Description:`` \"Free\" might be stretching it, but hey, once you buy this deadly rifle, you can spew out all the dirt you want for free! Note: the dirt is launched at high velocity and explodes on impact. Sponsored by BLYoshi.|0|4|-40|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|nothingness|`oWeather Machine - Nothingness``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Weather Machine - Nothingness.<CR><CR>`5Description:`` Tired of all that fancy weather?  This machine will turn your world completely black. Yup, that's it. Not a single pixel in the background except pure blackness.|0|3|-50|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|spike_juice|`oSpike Juice``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Spike Juice.<CR><CR>`5Description:`` It's fresh squeezed, with little bits of spikes still in it! Drinking this `#Untradeable`` one-use potion will make you immune to Death Spikes and Lava for 5 seconds.|0|5|-60|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|doodad|`oDoodad``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Doodad.<CR><CR>`5Description:`` I have no idea what this thing does. It's something electronic? Maybe?|0|5|-75|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|crystal_cape|`oCrystal Cape``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Crystal Cape.<CR><CR>`5Description:`` This cape is woven of pure crystal, which makes it pretty uncomfortable. But it also makes it magical! It lets you double-jump off of an imaginary Crystal Block in mid-air. Sponsored by Edvoid20, HemeTems, and Aboge.|0|5|-90|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|focused_eyes|`oFocused Eyes``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Focused Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot electricity from your eyes! Wear them with pride, and creepiness.|0|4|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grip_tape|`oGrip Tape``|interface/large/store_buttons/store_buttons14.rttex|`2You Get:`` 1 Grip Tape.<CR><CR>`5Description:`` This is handy for wrapping around the handle of a weapon or tool. It can improve your grip, as well as protect you from cold metal handles. If you aren't planning to craft a weapon that requires Grip Tape, this does you no good at all!|0|5|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|cat_eyes|`oCat Eyes``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Cat Eyes.<CR><CR>`5Description:`` Wow, pawesome! These new eyes are the cat's meow, and the purrfect addition to any style.|0|5|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|riding_cloud|`oRiding Cloud``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Riding Cloud.<CR><CR>`5Description:`` Bringing the sky to the ground! This item is `#Untradeable``.|3|1|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|grow_boy|`oGrowBoy``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Growboy.<CR><CR>`5Description:`` Bask in the nostalgic green screened goodness of the Growboy! A portable gaming device that packs a punch. Now you're playing with GrowPower! Note: The Growboy is `#UNTRADEABLE``.|0|2|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|typewriter_hat|`oTypewriter Hat``|interface/large/store_buttons/store_buttons38.rttex|`2You Get:`` 1 Typewriter Hat.<CR><CR>`5Description:`` This hat is connected to your mind writing your story as you go about your day! Note: This hat is `#UNTRADEABLE``.|4|7|-100|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|night_vision|`oNight Vision Goggles``|interface/large/store_buttons/store_buttons15.rttex|`2You Get:`` 1 Night Vision Goggles.<CR><CR>`5Description:`` Scared of the dark? We have a solution. You can wear these goggles just to look cool, but if you also happen to have a D Battery (`4batteries not included``) on you, you will be able to see through darkness like it's not even there! Each D Battery can power your goggles for 1 minute. `2If you are in a world you own, the goggles will not require batteries!`` Note: you can't turn the goggles off without removing them, so you'll be wasting your battery if you wear them in daylight while carrying D Batteries.|0|3|-110|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|muddy_pants|`oMuddy Pants``|interface/large/store_buttons/store_buttons12.rttex|`2You Get:`` 1 Muddy Pants.<CR><CR>`5Description:`` Well, this is just a pair of muddy pants. But it does come with a super secret bonus surprise that is sure to blow your mind!|0|7|-125|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|piranha|`oCuddly Piranha``|interface/large/store_buttons/store_buttons10.rttex|`2You Get:`` 1 Cuddly Piranha.<CR><CR>`5Description:`` This friendly pet piranha won't stay in its bowl!  It just wants to snuggle with your face!|0|0|-150|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|tsed|`oTactical Stealth Espionage Device``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Tactical Stealth Espionage Device.<CR><CR>`5Description:`` This is Growtech's latest innovation on tactical espionage! Using the latest in scientific breakthroughs this device allows you to seamlessly disguise yourself as... a cardboard box! Note: The Tactical Stealth Espionage Device is `#UNTRADEABLE``.|0|1|-150|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|puddy_leash|`oPuddy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puddy Leash.<CR><CR>`5Description:`` Puddy is a friendly little kitten who will follow you around forever.|0|7|-180|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9950|`oCredit Card``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Credit Card.<CR><CR>`5Description:`` Get your own Credit Card! Deposit or withdraw your world lock currency or send abroad to anyone!|2|3|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|anime_action_hair|`oAnime Action Hair``|interface/large/store_buttons/store_buttons37.rttex|`2You Get:`` 1 Anime Action Hair.<CR><CR>`5Description:`` Lights, camera, ANIME ACTION HAIR! Feel the power from root to tip every time you punch! This item is `#Untradeable``.|4|1|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|golden_axe|`oGolden Pickaxe``|interface/large/store_buttons/store_buttons9.rttex|`2You Get:`` 1 Golden Pickaxe.<CR><CR>`5Description:`` Get your own sparkly pickaxe! This `#Untradeable`` item is a status symbol! Oh sure, it isn't any more effective than a normal pickaxe, but it sparkles!|0|1|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|puppy_leash|`oPuppy Leash``|interface/large/store_buttons/store_buttons11.rttex|`2You Get:`` 1 Puppy Leash.<CR><CR>`5Description:`` Get your own pet puppy! This little dog will follow you around forever, never wavering in her loyalty, thus making her `#Untradeable``.|0|4|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|diggers_spade|`oDigger's Spade``|interface/large/store_buttons/store_buttons13.rttex|`2You Get:`` 1 Digger's Spade.<CR><CR>`5Description:`` This may appear to be a humble shovel, but in fact it is enchanted with the greatest magic in Growtopia. It can smash Dirt or Cave Background in a single hit! Unfortunately, it's worthless at digging through anything else. Note: The spade is `#UNTRADEABLE``.|0|7|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|meow_ears|`oMeow Ears``|interface/large/store_buttons/store_buttons22.rttex|`2You Get:`` 1 Meow Ears.<CR><CR>`5Description:`` Meow's super special ears that everyone can now get! Note: These ears are `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|frosty_hair|`oFrosty Hair``|interface/large/store_buttons/store_buttons23.rttex|`2You Get:`` 1 Frosty Hair.<CR><CR>`5Description:`` Coldplay is cold, but you can be freezing! Note: The frosty hair is `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|zerkon_helmet|`oEvil Space Helmet``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Evil Space Helmet.<CR><CR>`5Description:`` Zerkon commands a starship too small to actually board - pah, time to rule the galaxy properly! Note: The evil space helmet is `#UNTRADEABLE``.|0|6|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|seils_magic_orb|`oSeil's Magic Orbs``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Seil's Magic Orbs.<CR><CR>`5Description:`` Seil is some kind of evil wizard, now you can be too! Note: These magic orbs are `#UNTRADEABLE``.|0|7|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|atomic_shadow_scythe|`oAtomic Shadow Scythe``|interface/large/store_buttons/store_buttons21.rttex|`2You Get:`` 1 Atomic Shadow Scythe.<CR><CR>`5Description:`` AtomicShadow might actually be evil, now you can try it out! Note: The shadow scythe is `#UNTRADEABLE``.|0|5|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|poseidon_diggers_trident|`oPoseidon's Digger's Trident``|interface/large/store_buttons/store_buttons25.rttex|`2You Get:`` 1 Poseidon's Digger's Trident.<CR><CR>`5Description:`` A gift from the gods. This may appear to be a humble trident, but in fact it has the power of Poseidon himself. It can smash `8Deep Sand`` or `8Ocean Rock`` in a single hit. Unfortunately, you don't get to wield the full might of Poseidon... the trident is worthless at smashing anything else. Note: The trident is `#UNTRADEABLE``.|0|6|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|really_dangerous_pet_llama|`oReally Dangerous Pet Llama``|interface/large/store_buttons/store_buttons32.rttex|`2You Get:`` 1 Really Dangerous Pet Llama.<CR><CR>`5Description:`` This Llama is ready for anything Growtopia throws at it! Armed with a silo of Growtech Missiles, experimental Growtech hardened steel armor and a rather snazzy helmet (Llama's own) this Llama is Dangerous with a capital D! Note: This Really Dangerous Pet Llama is `#UNTRADEABLE``.|0|0|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|leopard_shawl|`oSnow Leopard Shawl``|interface/large/store_buttons/store_buttons34.rttex|`2You Get:`` 1 Snow Leopard Shawl.<CR><CR>`5Description:`` Made of the finest Faux Snow Leopard Fur. This Shawl is infused with the spirit of a mighty Snow Leopard!|1|4|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9808|`oJinx Intergalactic Hair``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Jinx Intergalactic Hair.<CR><CR>`5Description:`` A manic and impulsive criminal from Zaun Crest, Jinx Jinx lives to wreak havoc without care for the consequences. With an arsenal of deadly weapons, she unleashes the loudest blasts and brightest explosions to leave a trail of mayhem and panic in her wake. Note: The intergalactic hair is `#UNTRADEABLE``.|3|5|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9804|`oNightmare Eyes``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Nightmare Eyes.<CR><CR>`5Description:`` This `#Untradeable`` item lets you shoot fire from your eyes! With these Nightmare Eyes, it'll burn everything in its sight.|3|3|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9802|`oHell Demonic Scythe``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Hell Demonic Scythe.<CR><CR>`5Description:`` This `#Untradeable`` scythe contains the fury of the hell!|3|4|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9806|`oDark Chimera Wings``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Dark Chimera Wings.<CR><CR>`5Description:`` Forged from bladed feathers of flame and fury, these wings will let you tear through the skies with the might of the chimera! Note: The dark chimera wings are `#UNTRADEABLE``.|3|6|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|9896|`oTrazer's Dark Scythe``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Trazer's Dark Scythe.<CR><CR>`5Description:`` This `#Untradeable`` " + items[9896].description + ".|1|14|-200|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|golden_frosty_hair|`oGolden Frosty Hair``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Golden Frosty Hair.<CR><CR>`5Description:`` Incredible Golden Frosty Hair!|3|10|-450|0|||-1|-1||-1|-1||1||||||0|0|\nadd_button|entry_booth|`oEntry Booth``|interface/large/store_buttons/store_gtps.rttex|`2You Get:`` 1 Entry Booth.<CR><CR>`5Description:`` Charge world locks per one entry from players!|3|2|-500|0|||-1|-1||-1|-1||1||||||0|0|" + (extra_tab.empty() ? "" : "\nselect_item|" + item_));
	else if (tab == "tab7" + extra_tab) {
		string gemsshop = "\nadd_banner|interface/large/gtps_store_overlays.rttex|0|1|\nadd_big_banner|interface/large/gui_store_iap_message.rttex|0|0|`0You can now purchase`` `2Premium GTPS World Locks`` `0we accept`` `2Real Growtopia`` `0payment, type`` `2/deposit`` `0to see more information or type`` `2/shop`` `0to spend premium wls``|" + a + (credit_payment ? "\nadd_button|9999wl|`o9,999 Premium World Locks``|interface/large/store_buttons/store_gtps.rttex|https://www.g2g.com/offer/Growtopia-Private-Server---9-999-Premium-World-Locks?service_id=lgc_service_16&brand_id=lgc_game_24121&username=edwin82&offer_id=56908504|0|13|0|0|$ USD 59.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#9,999 Premium World Locks``.<CR><CR>`5Description:`` Get 9,999 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|5000wl|`o5000 Premium World Locks``|interface/large/store_buttons/store_gtps.rttex|https://www.g2g.com/offer/Growtopia-Private-Server---5-000-Premium-World-Locks?service_id=lgc_service_16&brand_id=lgc_game_24121&username=edwin82&offer_id=56908727|0|6|0|0|$ USD 32.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#5000 Premium World Locks``.<CR><CR>`5Description:`` Get 5000 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|1500wl|`o1500 Premium World Locks``|interface/large/store_buttons/store_gtps.rttex|https://www.g2g.com/offer/Growtopia-Private-Server---1-500-Premium-World-Locks?service_id=lgc_service_16&brand_id=lgc_game_24121&username=edwin82&offer_id=56908799|0|5|0|0|$ USD 14.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#1500 Premium World Locks``.<CR><CR>`5Description:`` Get 1500 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|500wl|`o500 Premium World Locks``|interface/large/store_buttons/store_gtps.rttex|https://www.g2g.com/offer/Growtopia-Private-Server---500-Premium-World-Locks?service_id=lgc_service_16&brand_id=lgc_game_24121&username=edwin82&offer_id=56908881|0|4|0|0|$ USD 4.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#500 Premium World Locks``.<CR><CR>`5Description:`` Get 500 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|100wl|`o100 Premium World Locks``|interface/large/store_buttons/store_gtps.rttex|https://www.g2g.com/offer/Growtopia-Private-Server---100-Premium-World-Locks?service_id=lgc_service_16&brand_id=lgc_game_24121&seller=edwin82&offer_id=56908925|0|3|0|0|$ USD 1.99||-1|-1||0|0|`4We have automatic delivery, don't need to wait!``<CR><CR>`2You Get:`` `#100 Premium World Locks``.<CR><CR>`5Description:`` Get 100 Premium World Locks. These premium world locks can be spent in GTPS Shop type `9/shop`` to see more!|1||||||0|0|\nadd_button|grow_shop|`oGrowtopia Shop``|interface/large/store_buttons/store_buttons36.rttex|https://www.g2g.com/edwin82/|1|1|0|0|Open Shop||-1|-1|interface/large/gui_shop_buybanner.rttex|0|1|If you can purchase Gem Packs through your telecom provider, then open the Growtopia Shop website here.<CR><CR>Please note, this service is only available in the following countries: `9Brazil``, `9Cambodia``, `9Estonia``, `9Indonesia``, `9Latvia``, `9Lithuania``, `9Malaysia``, `9Philippines``, `9Qatar``, `9Romania``, `9Saudi Arabia``, `9Singapore``, `9Thailand``, `9Turkey``, and `9United Arab Emirates``|1||||||0|0|" : "");
		p.Insert("set_description_text|Welcome to the `2Growtopia Store``! Select the item you'd like more info on.`o `wWant to get `5Supporter`` status? Any Gem purchase (or `520000`` Gems earned with free `5Tapjoy`` offers) will make you one. You'll get new skin colors, the `5Recycle`` tool to convert unwanted items into Gems, and more bonuses!\nenable_tabs|1\nadd_tab_button|main_menu|Home|interface/large/gtps_shop_btn.rttex||1|0|0|0||||-1|-1|||0|0|\nadd_tab_button|locks_menu|Locks And Stuff|interface/large/gtps_shop_btn.rttex||0|1|0|0||||-1|-1|||0|0|\nadd_tab_button|itempack_menu|Item Packs|interface/large/gtps_shop_btn.rttex||0|3|0|0||||-1|-1|||0|0|\nadd_tab_button|bigitems_menu|Awesome Items|interface/large/gtps_shop_btn.rttex||0|4|0|0||||-1|-1|||0|0|\nadd_tab_button|weather_menu|Weather Machines|interface/large/gtps_shop_btn.rttex|Tired of the same sunny sky?  We offer alternatives within...|0|5|0|0||||-1|-1|||0|0|\nadd_tab_button|token_menu|Growtoken Items|interface/large/gtps_shop_btn.rttex||0|2|0|0||||-1|-1|||0|0|"""/*"\nadd_button|summer_pack|`oBeach Blast Bingo!``|interface/large/store_buttons/store_buttons4.rttex|`2You Get:``Beach Blast, Summer Surprise and 100 Fireworks. <CR><CR>`5Description:`` It's hot out there! Don't you want to go to the beach? Now you can make your own beach with a Beach Blast device and the 100 Fireworks needed to power it. The Beach Blast creates a brand new world set up as a beach, full of cool new Summer items. As a bonus, you'll get a Summer Surprise too! (Available during Summerfest week only)|0|7|5000|0|||-1|-1||-1|-1||1||||||0|0|"*/"" + (extra_tab.empty() ? "" : "\nselect_item|" + item_));

	}p.CreatePacket(peer);
}

void set_tab(ENetPeer* peer) {
	string sets = "";
	for (int i = 0; i < pInfo(peer)->set.size(); i++) {
		bool empty = pInfo(peer)->set[i].size() == 0 ? true : false;
		sets += "\nadd_cmmnty_wotd_bttn|set_save_"+to_string(i) + "|`w#" + to_string(i+1) + "`` save `#SET``"+(empty ? " (empty)" : "") + "|interface/large/set_banner.rttex||0|0||\nadd_cmmnty_wotd_bttn|" + (empty ? "" : "set_load_" + to_string(i) + "") + "|`w#" + to_string(i + 1) + "``" + (empty ? " `#<empty>``" : " load `#SET``") + "|interface/large/set_banner.rttex||0|0||";
	}
	sets += "\nadd_cmmnty_wotd_bttn|set_addslot|`w#("+to_string(pInfo(peer)->set.size()) + "/10)`` add `#SLOT``|interface/large/set_banner.rttex||0|1||\nadd_cmmnty_wotd_bttn|set_removeslot|`w#(" + to_string(pInfo(peer)->set.size()) + "/10)`` remove `#SLOT``|interface/large/set_banner.rttex||0|2||";
	gamepacket_t p;
	p.Insert("OnCommunityHubRequest");
	p.Insert("set_description_text|You can save and load your clothing saved sets!|\nset_default_color|`o"+ sets +"\nadd_tab_button|set|set|interface/large/set_list.rttex||0|0|0|0||\ncommunity_hub_type|set");
	p.CreatePacket(peer);
}
void world_menu(ENetPeer* peer, bool load_msg = true) {
	string recently_visited = "", c_active_worlds = "";
	for (uint8_t w_ = 0; w_ < (pInfo(peer)->worlds_owned.size() >= 10 ? 10 : pInfo(peer)->worlds_owned.size()); w_++) c_active_worlds += "\nadd_floater|" + pInfo(peer)->worlds_owned[w_] + "|0|0.5|2147418367";
	for (auto it = pInfo(peer)->last_visited_worlds.rbegin(); it != pInfo(peer)->last_visited_worlds.rend(); ++it) recently_visited += "\nadd_floater|" + *it + "|0|0.5|3417414143";
	gamepacket_t p;
	//\nadd_floater|Random World|0|0.402878|2915716095
	//\nadd_floater|LOCKETOWN|ā LOCKETOWN|0|0.5|-2016482305
	p.Insert("OnRequestWorldSelectMenu"), p.Insert("add_filter|\nadd_heading|Top Worlds ("+to_string(World_Stuff.top_active_worlds.size()) + ")<ROW2>|\nadd_floater|TRADE|ā TRADE|0|0.5|-2016482305|\nadd_floater|GROWGANOTH|`2GROWGANOTH|0|0.5|-2016482305|" + World_Stuff.active_world_list + (pInfo(peer)->worlds_owned.size() != 0 ? "\nadd_heading|My Worlds (" + to_string(pInfo(peer)->worlds_owned.size()) + ")<CR>|" + c_active_worlds : "\nadd_heading|Recommended Worlds<CR>|\nadd_floater|START|0|0.5|2147418367\nadd_floater|TRADE|0|0.5|2147418367\nadd_floater|ITEM|0|0.5|2147418367") + (not recently_visited.empty() ? "\nadd_heading|Recently Visited Worlds<CR>|" + recently_visited : "") + "\n"), p.CreatePacket(peer);
	if (load_msg) {
		int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
		get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
		console_msg(peer, "Where would you like to go? (`w" + setGems(s_c) + "`` online)");
	}
}


bool has_playmod(Player* p_, string name_, bool not_hand = false) {
	name_ = replace_str2(cleanup_(to_lower(name_)), " ", "_");
	vector<string> player_playmods{};
	player_playmods.push_back(items[p_->hair].playmod_total);
	player_playmods.push_back(items[p_->shirt].playmod_total);
	player_playmods.push_back(items[p_->pants].playmod_total);
	player_playmods.push_back(items[p_->feet].playmod_total);
	player_playmods.push_back(items[p_->face].playmod_total);
	if (not_hand == false) player_playmods.push_back(items[p_->hand].playmod_total);
	player_playmods.push_back(items[p_->back].playmod_total);
	player_playmods.push_back(items[p_->mask].playmod_total);
	player_playmods.push_back(items[p_->necklace].playmod_total);
	player_playmods.push_back(items[p_->ances].playmod_total);
	for (int i_ = 0; i_ < player_playmods.size(); i_++) {
		if (player_playmods[i_].empty()) continue;
		string playmod = replace_str2(cleanup_(to_lower(player_playmods[i_])), " ", "_");
		if (playmod.find(name_) != string::npos) return true;
	}
	return false;
}



bool has_playmod2(Player* p_, uint16_t id, int time_ = 0) {
	vector<PlayMods>::iterator p = find_if(p_->playmods.begin(), p_->playmods.end(), [&](const PlayMods& a) { return a.id == id; });
	if (p != p_->playmods.end()) {
		if (time_ != 0) p_->playmods[p - p_->playmods.begin()].time = time(nullptr) + time_;
		return true;
	}
	else return false;
}

bool remove_playmod(Player* p_, uint16_t id) {
	vector<PlayMods>::iterator p = find_if(p_->playmods.begin(), p_->playmods.end(), [&](const PlayMods& a) { return a.id == id; });
	if (p != p_->playmods.end()) {
		p_->playmods[p - p_->playmods.begin()].time = 1;
		return true;
	}
	else return false;
}

int form_flagmay(Player* p_, int force = false) {
	int state_ = 0;
//	state_ |= 1 << punched;
	state_ |= has_playmod2(p_, 38) << 0;
	state_ |= has_playmod2(p_, 99) << 1;
	if (p_->back == 1970 || p_->back == 8530 || p_->hand == 9906 || p_->hand == 9908 || p_->hair == 9838) state_ |= 1 << 5;
	if (p_->necklace == 10412) state_ |= 1 << 10;
	if (p_->back == 10426) state_ |= 1 << 11;
	if (items[p_->hand].flagmay != 256) state_ |= 1 << (p_->flagmay ? items[p_->hand].flagmay : items[p_->hand].flagmay - 1);
	if (items[p_->necklace].flagmay != 256) state_ |= 1 << (p_->flagmay ? items[p_->necklace].flagmay : items[p_->necklace].flagmay - 1);
	if (items[p_->feet].flagmay != 256) state_ |= 1 << (p_->flagmay ? items[p_->feet].flagmay : items[p_->feet].flagmay - 1);
	if (p_->mask_dragon && (p_->face == 11506 || p_->face == 11508)) state_ |= 1 << 19;
	if (p_->hair == 12872 || p_->hair == 12874)state_ |= 1 << (p_->panda_spirit == 0 ? 25 : 26);
	return p_->flag_may_form = state_;
}

int form_type_player(Player* p_, int force = false) {
	int state_ = 0;
	//state_ |= 1 << punched;
	state_ |= has_playmod2(p_, 101) << 0;
	state_ |= has_playmod2(p_, 102) << 1;
	state_ |= has_playmod2(p_, 103) << 2;
	state_ |= has_playmod2(p_, 104) << 3;
	if (p_->mask == 5712) state_ |= 1 << p_->wild;
	if (p_->feet == 10044) state_ |= 1 << p_->golem;
	if (p_->hand == 6028)state_ |= 1 << 10;
	if (p_->necklace == 6120) state_ |= 1 << 12;
	if (p_->hand == 6262)state_ |= 1 << 13;
	if (p_->feet == 7384 && p_->growformer) state_ |= 1 << 19;
	if (p_->shirt == 7584)state_ |= 1 << (21 + (p_->sprite == 0 ? 1 : p_->sprite));
	return p_->type_player = state_;
}

int form_state(Player* p_, bool force = false) {
	int state_ = 0;
	//state_ |= 1 << punched;
	state_ |= p_->ghost << 0;
	if (p_->invis) {
		state_ |= 1 << 2;
		state_ |= 1 << 3;
		state_ |= 1 << 5;
	}
	else {
		state_ |= p_->no_hands << 3;
		state_ |= p_->no_body << 5;
	}
	if (p_->xenonite & Gtps3::XENONITE_BLOCK_DOUBLE_JUMP) {

	}
	else if (p_->xenonite & Gtps3::XENONITE_FORCE_DOUBLE_JUMP)state_ |= 1 << 1;
	else {
		if ((p_->cheater_settings & Gtps3::SETTINGS_2 && p_->disable_cheater == 0) || has_playmod(p_, "double jump"))	state_ |= 1 << 1;
	}
	state_ |= has_playmod(p_, "The One Ring") << 2;
	state_ |= has_playmod(p_, "Mark of Growganoth") << 4;
	if ((p_->cheater_settings & Gtps3::SETTINGS_3 && p_->disable_cheater == 0)) state_ |= 1 << 10;
	if (p_->pants == 9782 || p_->hair == 9866 || p_->shirt == 9868 || p_->necklace == 12540 || p_->hand == 9906 || p_->hand == 9918 || p_->hand == 10290 || p_->hand == 9908 || p_->hair == 9838 || p_->back == 10684) state_ |= 1 << 15;
	if (p_->necklace == 6064) state_ |= 1 << 18;
	if (p_->spotlight) state_ |= 1 << 20;


	/*
	if (p_->stage_pineapple < 600) {
		state_ |= (p_->stage_pineapple >= 400 && p_->stage_pineapple < 600) << 21;
		state_ |= (p_->stage_pineapple >= 200 && p_->stage_pineapple < 400) << 22;
	}
	else {
		state_ |= 1 << 21;
		state_ |= 1 << 22;
	}*/
	state_ |= p_->hs << 24;
	bool antidote_ = false;
	if (has_playmod2(p_, 25)) antidote_ = true;
	for (int i_ = 0; i_ < p_->playmods.size(); i_++) {
		if (p_->playmods[i_].id == 90) p_->surgery_type = 28;
		else if (p_->playmods[i_].id == 91) p_->surgery_type = 25;
		else if (p_->playmods[i_].id == 92) p_->surgery_type = 24;
		else if (p_->playmods[i_].id == 93) p_->surgery_type = 27;
		else if (p_->playmods[i_].id == 94) p_->surgery_type = 26;
		else if (p_->playmods[i_].id == 95) p_->surgery_type = 23;
		if (not info_about_playmods[p_->playmods[i_].id - 1][7].empty()) state_ |= true << atoi(info_about_playmods[p_->playmods[i_].id - 1][7].c_str());
		if (antidote_)if (p_->playmods[i_].id == 28 || p_->playmods[i_].id == 27 || p_->playmods[i_].id == 41 || p_->playmods[i_].id == 49 || p_->playmods[i_].id == 48 || p_->playmods[i_].id == 71 || p_->playmods[i_].id == 72 || p_->playmods[i_].id == 73 || p_->playmods[i_].id == 4 || p_->playmods[i_].id == 16 || p_->playmods[i_].id == 17 || p_->playmods[i_].id == 19 || p_->playmods[i_].id == 27 || p_->playmods[i_].id == 42) p_->playmods[i_].time = 1;
	}
	return p_->state_player = state_;
}

void add_playmod(ENetPeer* peer, int playmod, int time_s = 0) {
	if (time_s == 0) time_s = atoi(info_about_playmods[playmod - 1][2].c_str());
	if (not has_playmod2(pInfo(peer), playmod, time_s)) {
		PlayMods new_playmod{};
		new_playmod.id = playmod, new_playmod.time = time(nullptr) + time_s;
		pInfo(peer)->playmods.push_back(new_playmod);
		console_msg(peer, info_about_playmods[playmod - 1][4] + " (`$" + info_about_playmods[playmod - 1][3] + "!`` mod added, `$" + to_playmod_time(new_playmod.time - time(nullptr)) + "`` left)");
	}
}

int get_skin_color(ENetPeer* peer) {
	vector<PlayMods>::iterator p = find_if(pInfo(peer)->playmods.begin(), pInfo(peer)->playmods.end(), [&](const PlayMods& a) { return not info_about_playmods[a.id - 1][9].empty(); });
	if (p != pInfo(peer)->playmods.end()) {
		char* endptr = NULL;
		string special_id = info_about_playmods[pInfo(peer)->playmods[p - pInfo(peer)->playmods.begin()].id - 1][9];
		return strtoll(special_id.c_str(), &endptr, 10);
	}
	else {
		if ((pInfo(peer)->ghost or pInfo(peer)->hair == 8496) && pInfo(peer)->skin_c == "0,0,0") return -2450;
		else {
			if (has_playmod(pInfo(peer), "ninja stealth")) return 1684300950;
			else if (pInfo(peer)->face == 10928) return -2139062017;
		}
		return pInfo(peer)->skin;
	}
}
void update_clothes(ENetPeer* peer, bool state = false, bool clothing = false) {
	if (pInfo(peer)->world.empty()) pInfo(peer)->update = true;
	bool hide_status = (pInfo(peer)->hider && pInfo(peer)->world == Hide_N_Seek.hidenseekworld) ? true : false;
	PlayerMoving data{ pInfo(peer)->netID, 0, 0x14, 0, (hide_status ? 16777236 : pInfo(peer)->state_player), 0, 0, 0, 1200, (pInfo(peer)->xenonite & Gtps3::XENONITE_FORCE_STRONG_PUNCH or (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_9 && pInfo(peer)->disable_cheater == 0) ? 500 : (pInfo(peer)->xenonite & Gtps3::XENONITE_BLOCK_STRONG_PUNCH ? 200 : pInfo(peer)->strong_punch)), (pInfo(peer)->xenonite & Gtps3::XENONITE_FORCE_SPEEDY ? 310 : (pInfo(peer)->xenonite & Gtps3::XENONITE_BLOCK_SPEEDY or hide_status ? 250 : pInfo(peer)->player_speed)), (pInfo(peer)->xenonite & Gtps3::XENONITE_FORCE_HIGH_JUMP or (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_7 && pInfo(peer)->disable_cheater == 0) ? 700 : (pInfo(peer)->xenonite & Gtps3::XENONITE_BLOCK_HIGH_JUMP ? 1000 : pInfo(peer)->high_jump)) };
	gamepacket_t p(0, pInfo(peer)->netID);
	if (state == false || clothing == true) {
		p.Insert("OnSetClothing");
		if (hide_status) {
			p.Insert(0, 0, 0); // hair shirt pants
			p.Insert(0, (float)pInfo(peer)->hiden_clothing, 0); // feet face hand 
			p.Insert(0, 0, 0); // back mask neck
		}
		else {
			p.Insert((float)pInfo(peer)->hair, (float)pInfo(peer)->shirt, (float)pInfo(peer)->pants); // hair shirt pants
			p.Insert((float)pInfo(peer)->feet, (float)pInfo(peer)->face, (float)pInfo(peer)->hand); // feet face hand 
			p.Insert((float)pInfo(peer)->back, (float)pInfo(peer)->mask, (float)pInfo(peer)->necklace); // back mask neck
		}
		p.Insert(get_skin_color(peer));
		if (hide_status) {
			p.Insert(0, 0, 0); // tie kiti 2 tai nzn   
		}
		else {
			p.Insert((float)pInfo(peer)->ances, 0, 0); // tie kiti 2 tai nzn   
		}
	}
	BYTE* raw = packPlayerMoving(&data);
	int e_ = 8421376 + (pInfo(peer)->punched != 0 ? pInfo(peer)->punched : pInfo(peer)->punch_effect);
	memcpy(raw + 1, &e_, 3); //16777218
	*(uint8_t*)(raw + 2) = (pInfo(peer)->xenonite & Gtps3::XENONITE_FORCE_LONG_BUILD or (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_11 && pInfo(peer)->disable_cheater == 0) ? 129 : (pInfo(peer)->xenonite & Gtps3::XENONITE_BLOCK_LONG_BUILD ? 128 : pInfo(peer)->build_range));
	*(uint8_t*)(raw + 3) = (pInfo(peer)->xenonite & Gtps3::XENONITE_FORCE_LONG_PUNCH or (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_10 && pInfo(peer)->disable_cheater == 0) ? 129 : (pInfo(peer)->xenonite & Gtps3::XENONITE_BLOCK_LONG_PUNCH ? 128 : pInfo(peer)->punch_range));
	if (pInfo(peer)->eye_lenses != 0xFFFFFFFF) *(uint32_t*)(raw + 8) = pInfo(peer)->eye_lenses;
	*(int*)(raw + 12) = (hide_status ? 0 : pInfo(peer)->type_player);
	*(float*)(raw + 16) = pInfo(peer)->water_speed;
	if (pInfo(peer)->hair_color != 0xFFFFFFFF)	*(uint32_t*)(raw + 44) = pInfo(peer)->hair_color;
	if (pInfo(peer)->eye_drop != 0xFFFFFFFF)	*(uint32_t*)(raw + 48) = pInfo(peer)->eye_drop;
	gamepacket_t pf(0, pInfo(peer)->netID), p2c(0, pInfo(peer)->netID), p3(0, pInfo(peer)->netID)/*, p5(0, pInfo(peer)->netID)*/;
	if (state == false) {
		pf.Insert("OnFlagMay2019"), pf.Insert((hide_status ? 0 : pInfo(peer)->flag_may_form));
		p2c.Insert("OnCountryState"), p2c.Insert(pInfo(peer)->country + "|showGuild" + (pInfo(peer)->lvl125 ? "|maxLevel" : "") + (pInfo(peer)->donor == 1 ? "|donor" : "") + (pInfo(peer)->master ? "|master" : ""));
		p3.Insert("OnSetRoleSkinsAndIcons"), p3.Insert(pInfo(peer)->roleSkin), p3.Insert(pInfo(peer)->roleIcon), p3.Insert(0);
		//p5.Insert("OnFactionDataChanged"), p5.Insert(pInfo(peer)->balloon_faction), p5.Insert(pInfo(peer)->hit_by), p5.Insert(pInfo(peer)->hit_by), p5.Insert("bountyLevel|" + to_string(pInfo(peer)->balloon_hit >= 20 ? pInfo(peer)->balloon_hit / 20 : 0) + "\nbountyScore|" + to_string(pInfo(peer)->balloon_hit >= 20 ? pInfo(peer)->balloon_hit : 0) + "\n"), p5.Insert(1);
	}
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		if (state == false) {
			if (hide_status == false) {
				if (pInfo(peer)->b_bill.substr(0, 1) == "1" && pInfo(peer)->b_p != 0) {
					gamepacket_t p5(0, pInfo(peer)->netID);
					p5.Insert("OnBillboardChange"), p5.Insert(pInfo(peer)->netID), p5.Insert(pInfo(peer)->b_i), p5.Insert(pInfo(peer)->b_bill), p5.Insert(pInfo(peer)->b_p), p5.Insert(pInfo(peer)->b_w);
					p5.CreatePacket(currentPeer);
				}
				if (pInfo(peer)->necklace == 11818) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnScarfOfSeasons"), p.Insert(pInfo(peer)->i_11818_1), p.Insert(pInfo(peer)->i_11818_2), p.CreatePacket(currentPeer);
				}
				else if (pInfo(peer)->necklace == 11748) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnBannerBandolier"), p.Insert(pInfo(peer)->Banner_Item);
					p.Insert(pInfo(peer)->Banner_Flag);
					p.CreatePacket(currentPeer);
				}
				else if (pInfo(peer)->necklace == 10246) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnDaylightDragon");
					p.Insert(DaylightDragon.param1);
					p.Insert(DaylightDragon.param2);
					p.Insert(DaylightDragon.param3);
					p.Insert(DaylightDragon.param4);
					p.Insert(DaylightDragon.param5);
					p.Insert(DaylightDragon.param6);
					p.CreatePacket(currentPeer);
				}

				if (pInfo(peer)->hair == 12958) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnInfinityCrown");
					p.Insert(pInfo(peer)->Crown_Value);
					p.Insert(pInfo(peer)->Crown_Cycle_Time);
					p.Insert(to_string(pInfo(peer)->Crown_Value_0_0) + "," + to_string(pInfo(peer)->Crown_Value_0_1) + "," + to_string(pInfo(peer)->Crown_Value_0_2));
					p.Insert(to_string(pInfo(peer)->Crown_Value_1_0) + "," + to_string(pInfo(peer)->Crown_Value_1_1) + "," + to_string(pInfo(peer)->Crown_Value_1_2));
					p.CreatePacket(currentPeer);
				}
				else if (pInfo(peer)->hair == 10674) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnCernuousMask");
					p.Insert(pInfo(peer)->Aura_Season);
					p.Insert(pInfo(peer)->Trail_Season);
					p.CreatePacket(currentPeer);
				}

				if (pInfo(peer)->back == 12640) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnMinokawaWings"), p.Insert(pInfo(peer)->minokawa_wings);
					p.CreatePacket(currentPeer);
				}
				else if (pInfo(peer)->back == 10424) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnRiftCape"), p.Insert(pInfo(peer)->flags), p.Insert(pInfo(peer)->cape_t), p.Insert(pInfo(peer)->cape_t2), p.Insert(pInfo(peer)->cape_c), p.Insert(pInfo(peer)->cape_c2), p.Insert(pInfo(peer)->TimeDilation), p.CreatePacket(currentPeer);
				}
				else if (pInfo(peer)->back == 11478) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnRiftWings"), p.Insert(pInfo(peer)->_flags), p.Insert(pInfo(peer)->wings_t), p.Insert(pInfo(peer)->wings_t2), p.Insert(pInfo(peer)->wings_c), p.Insert(pInfo(peer)->wings_c2), p.Insert(pInfo(peer)->_TimeDilation), p.CreatePacket(currentPeer);
				}
				else if (pInfo(peer)->back == 10182) {
					gamepacket_t p(0, pInfo(currentPeer)->netID);
					p.Insert("OnPianoWingsUpdate");
					p.Insert(pInfo(currentPeer)->musical_note);
					p.Insert(pInfo(currentPeer)->musical_volume);
					p.Insert(0);
					p.CreatePacket(peer);
				}

				if (pInfo(peer)->feet == 10666) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnChangeAirBalloonStyle"), p.Insert(pInfo(peer)->grow_air_ballon);
					p.CreatePacket(currentPeer);
				}
				if (pInfo(peer)->pants == 10914) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnChangePureBeingMode"), p.Insert(pInfo(peer)->pure_shadow);
					p.CreatePacket(currentPeer);
				}
				if (pInfo(peer)->ances == 12634) {
					gamepacket_t p(0, pInfo(peer)->netID);
					p.Insert("OnEqAura"), p.Insert(pInfo(peer)->eq_aura);
					p.CreatePacket(currentPeer);
				}
				if (not pInfo(peer)->transmuted.empty() or pInfo(peer)->temp_transmute) {
					gamepacket_t p5(0, pInfo(peer)->netID);
					p5.Insert("OnTransmutateLinkDataModified"), p5.Insert(pInfo(peer)->transmuted);
					p5.CreatePacket(currentPeer);
				}
			}
			pf.CreatePacket(currentPeer), p2c.CreatePacket(currentPeer), p3.CreatePacket(currentPeer);
			if (pInfo(peer)->guild_role != -1) {
				gamepacket_t p4(0, pInfo(peer)->netID);
				p4.Insert("OnGuildDataChanged"), p4.Insert(50478), p4.Insert(79289404);
				if (pInfo(peer)->guild_fg == 0 && pInfo(peer)->guild_bg == 0) p4.Insert(0);
				else p4.Insert((65536 * pInfo(peer)->guild_bg) + pInfo(peer)->guild_fg);
				p4.Insert(pInfo(peer)->guild_role);
				p4.CreatePacket(currentPeer);
			}

			//p5.CreatePacket(currentPeer);
		}
		if (state == false || clothing == true) p.CreatePacket(currentPeer);
		send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		if (pInfo(peer)->netID != pInfo(currentPeer)->netID) {
			bool hide_p2 = (pInfo(currentPeer)->hider && pInfo(currentPeer)->world == Hide_N_Seek.hidenseekworld) ? true : false;
			if (state == false || clothing == true) {
				if (hide_p2 == false) {
					if (pInfo(currentPeer)->b_bill.substr(0, 1) == "1" && pInfo(currentPeer)->b_p != 0) {
						gamepacket_t p5(0, pInfo(currentPeer)->netID);
						p5.Insert("OnBillboardChange"), p5.Insert(pInfo(currentPeer)->netID), p5.Insert(pInfo(currentPeer)->b_i), p5.Insert(pInfo(currentPeer)->b_bill), p5.Insert(pInfo(currentPeer)->b_p), p5.Insert(pInfo(currentPeer)->b_w);
						p5.CreatePacket(peer);
					}
					if (pInfo(peer)->updated_clothes) {
						if (pInfo(currentPeer)->fishing_used != 0) {
							PlayerMoving data_{};
							data_.packet_3 = 0, data_.netID = pInfo(currentPeer)->netID, data_.x = pInfo(currentPeer)->f_x, data_.y = pInfo(currentPeer)->f_y;
							BYTE* raw = packFishMoving(&data_);
							send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
						}
					}
					{
						gamepacket_t p3(0, pInfo(currentPeer)->netID);
						p3.Insert("OnSetRoleSkinsAndIcons"), p3.Insert(pInfo(currentPeer)->roleSkin), p3.Insert(pInfo(currentPeer)->roleIcon), p3.Insert(0), p3.CreatePacket(peer);
					}
					{
						gamepacket_t p2(0, pInfo(currentPeer)->netID);
						p2.Insert("OnCountryState"), p2.Insert(pInfo(currentPeer)->country + "|showGuild" + (pInfo(currentPeer)->lvl125 ? "|maxLevel" : "") + (pInfo(currentPeer)->donor == 1 ? "|donor" : "") + (pInfo(currentPeer)->master ? "|master" : "")), p2.CreatePacket(peer);
					}
					if (pInfo(currentPeer)->guild_role != -1) {
						gamepacket_t p4(0, pInfo(currentPeer)->netID);
						p4.Insert("OnGuildDataChanged"), p4.Insert(50478), p4.Insert(79289404);

						if (pInfo(currentPeer)->guild_fg == 0 && pInfo(currentPeer)->guild_bg == 0) 	p4.Insert(0);
						else p4.Insert((65536 * pInfo(currentPeer)->guild_bg) + pInfo(currentPeer)->guild_fg);
						p4.Insert(pInfo(currentPeer)->guild_role), p4.CreatePacket(peer);
					}
					if (pInfo(currentPeer)->feet == 10666) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnChangeAirBalloonStyle"), p.Insert(pInfo(currentPeer)->grow_air_ballon);
						p.CreatePacket(peer);
					}
					if (pInfo(currentPeer)->hair == 12958) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnInfinityCrown");
						p.Insert(pInfo(currentPeer)->Crown_Value);
						p.Insert(pInfo(currentPeer)->Crown_Cycle_Time);
						p.Insert(to_string(pInfo(currentPeer)->Crown_Value_0_0) + "," + to_string(pInfo(currentPeer)->Crown_Value_0_1) + "," + to_string(pInfo(currentPeer)->Crown_Value_0_2));
						p.Insert(to_string(pInfo(currentPeer)->Crown_Value_1_0) + "," + to_string(pInfo(currentPeer)->Crown_Value_1_1) + "," + to_string(pInfo(currentPeer)->Crown_Value_1_2));
						p.CreatePacket(peer);
					}
					else if (pInfo(currentPeer)->hair == 10674) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnCernuousMask");
						p.Insert(pInfo(currentPeer)->Aura_Season);
						p.Insert(pInfo(currentPeer)->Trail_Season);
						p.CreatePacket(peer);
					}

					if (pInfo(currentPeer)->necklace == 11748) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnBannerBandolier"), p.Insert(pInfo(currentPeer)->Banner_Item);
						p.Insert(pInfo(currentPeer)->Banner_Flag);
						p.CreatePacket(peer);
					}
					else if (pInfo(currentPeer)->necklace == 11818) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnScarfOfSeasons"), p.Insert(pInfo(currentPeer)->i_11818_1), p.Insert(pInfo(currentPeer)->i_11818_2), p.CreatePacket(peer);
					}
					else if (pInfo(currentPeer)->necklace == 10246) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnDaylightDragon");
						p.Insert(DaylightDragon.param1);
						p.Insert(DaylightDragon.param2);
						p.Insert(DaylightDragon.param3);
						p.Insert(DaylightDragon.param4);
						p.Insert(DaylightDragon.param5);
						p.Insert(DaylightDragon.param6);
						p.CreatePacket(peer);
					}
					if (not pInfo(currentPeer)->transmuted.empty() or pInfo(currentPeer)->temp_transmute) {
						gamepacket_t p5(0, pInfo(currentPeer)->netID);
						p5.Insert("OnTransmutateLinkDataModified"), p5.Insert(pInfo(currentPeer)->transmuted);
						p5.CreatePacket(peer);
					}
					if (pInfo(currentPeer)->pants == 10914) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnChangePureBeingMode"), p.Insert(pInfo(currentPeer)->pure_shadow);
						p.CreatePacket(peer);
					}
					if (pInfo(currentPeer)->ances == 12634) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnEqAura"), p.Insert(pInfo(currentPeer)->eq_aura);
						p.CreatePacket(peer);
					}
					{
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnFlagMay2019"), p.Insert((hide_p2 ? 0 : pInfo(currentPeer)->flag_may_form)), p.CreatePacket(peer);
					}

					if (pInfo(currentPeer)->back == 12640) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnMinokawaWings"), p.Insert(pInfo(currentPeer)->minokawa_wings);
						p.CreatePacket(peer);
					}
					else if (pInfo(currentPeer)->back == 10424) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnRiftCape"), p.Insert(pInfo(currentPeer)->flags), p.Insert(pInfo(currentPeer)->cape_t), p.Insert(pInfo(currentPeer)->cape_t2), p.Insert(pInfo(currentPeer)->cape_c), p.Insert(pInfo(currentPeer)->cape_c2), p.Insert(pInfo(currentPeer)->TimeDilation), p.CreatePacket(peer);
					}
					else if (pInfo(currentPeer)->back == 11478) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnRiftWings"), p.Insert(pInfo(currentPeer)->_flags), p.Insert(pInfo(currentPeer)->wings_t), p.Insert(pInfo(currentPeer)->wings_t2), p.Insert(pInfo(currentPeer)->wings_c), p.Insert(pInfo(currentPeer)->wings_c2), p.Insert(pInfo(currentPeer)->_TimeDilation), p.CreatePacket(peer);
					}
					else if (pInfo(currentPeer)->back == 10182) {
						gamepacket_t p(0, pInfo(currentPeer)->netID);
						p.Insert("OnPianoWingsUpdate");
						p.Insert(pInfo(currentPeer)->musical_note);
						p.Insert(pInfo(currentPeer)->musical_volume);
						p.Insert(0);
						p.CreatePacket(peer);
					}
				}
				/*
				{
					gamepacket_t p(0, pInfo(currentPeer)->netID);
					p.Insert("OnFactionDataChanged"), p.Insert(pInfo(currentPeer)->balloon_faction), p.Insert(pInfo(currentPeer)->hit_by), p.Insert(pInfo(currentPeer)->hit_by), p.Insert("bountyLevel|" + to_string(pInfo(currentPeer)->balloon_hit >= 20 ? pInfo(currentPeer)->balloon_hit / 20 : 0) + "\nbountyScore|" + to_string(pInfo(currentPeer)->balloon_hit >= 20 ? pInfo(currentPeer)->balloon_hit : 0) + "\n"), p.Insert(1), p.CreatePacket(peer);
				}*/
			}
			if (state == false || clothing == true) {
				gamepacket_t p(0, pInfo(currentPeer)->netID);
				p.Insert("OnSetClothing");
				if (hide_p2) {
					p.Insert(0, 0, 0); // hair shirt pants
					p.Insert(0, (float)pInfo(currentPeer)->hiden_clothing, 0); // feet face hand 
					p.Insert(0, 0, 0); // back mask neck
				}
				else {
					p.Insert((float)pInfo(currentPeer)->hair, (float)pInfo(currentPeer)->shirt, (float)pInfo(currentPeer)->pants); // hair shirt pants
					p.Insert((float)pInfo(currentPeer)->feet, (float)pInfo(currentPeer)->face, (float)pInfo(currentPeer)->hand); // feet face hand 
					p.Insert((float)pInfo(currentPeer)->back, (float)pInfo(currentPeer)->mask, (float)pInfo(currentPeer)->necklace); // back mask neck
				}
				p.Insert(get_skin_color(currentPeer));
				if (hide_p2) {
					p.Insert(0, 0, 0); // tie kiti 2 tai nzn   
				}
				else {
					p.Insert((float)pInfo(currentPeer)->ances, 0, 0); // tie kiti 2 tai nzn   
				}
				p.CreatePacket(peer); // kiti tau
			}
			PlayerMoving data2{ pInfo(currentPeer)->netID, 0, 0x14, 0, (hide_p2 ? 16777236 : pInfo(currentPeer)->state_player), 0, 0, 0, 1200, (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_FORCE_STRONG_PUNCH or (pInfo(currentPeer)->cheater_settings & Gtps3::SETTINGS_9 && pInfo(currentPeer)->disable_cheater == 0) ? 500 : (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_BLOCK_STRONG_PUNCH ? 200 : pInfo(currentPeer)->strong_punch)), (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_FORCE_SPEEDY ? 310 : (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_BLOCK_SPEEDY or hide_p2 ? 250 : pInfo(currentPeer)->player_speed)), (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_FORCE_HIGH_JUMP or (pInfo(currentPeer)->cheater_settings & Gtps3::SETTINGS_7 && pInfo(currentPeer)->disable_cheater == 0) ? 700 : (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_BLOCK_HIGH_JUMP ? 1000 : pInfo(currentPeer)->high_jump)) };
			BYTE* raw_ = packPlayerMoving(&data2);
			int e_ = 8421376 + (pInfo(currentPeer)->punched != 0 ? pInfo(currentPeer)->punched : pInfo(currentPeer)->punch_effect);
			memcpy(raw_ + 1, &e_, 3); //16777218
			*(uint8_t*)(raw_ + 2) = (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_FORCE_LONG_BUILD or (pInfo(currentPeer)->cheater_settings & Gtps3::SETTINGS_11 && pInfo(currentPeer)->disable_cheater == 0) ? 129 : (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_BLOCK_LONG_BUILD ? 128 : pInfo(currentPeer)->build_range));
			*(uint8_t*)(raw_ + 3) = (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_FORCE_LONG_PUNCH or (pInfo(currentPeer)->cheater_settings & Gtps3::SETTINGS_10 && pInfo(currentPeer)->disable_cheater == 0) ? 129 : (pInfo(currentPeer)->xenonite & Gtps3::XENONITE_BLOCK_LONG_PUNCH ? 128 : pInfo(currentPeer)->punch_range));
			*(int*)(raw_ + 12) = (hide_p2 ? 0 : pInfo(currentPeer)->type_player);
			*(float*)(raw_ + 16) = pInfo(currentPeer)->water_speed;
			if (pInfo(currentPeer)->hair_color != 0xFFFFFFFF)*(uint32_t*)(raw_ + 44) = pInfo(currentPeer)->hair_color;
			if (pInfo(currentPeer)->eye_drop != 0xFFFFFFFF)*(uint32_t*)(raw_ + 48) = pInfo(currentPeer)->eye_drop;
			if (pInfo(currentPeer)->eye_lenses != 0xFFFFFFFF) *(uint32_t*)(raw_ + 8) = pInfo(currentPeer)->eye_lenses;
			send_raw(peer, 4, raw_, 56, ENET_PACKET_FLAG_RELIABLE);
			delete[]raw_;
		}
	}
	delete[]raw;
	pInfo(peer)->updated_clothes = false;
}

void update_clothes_value(ENetPeer* peer, bool guild = false) {
	if (guild == false) {
		form_state(pInfo(peer));
		form_type_player(pInfo(peer));
		form_flagmay(pInfo(peer));
		pInfo(peer)->strong_punch = has_playmod(pInfo(peer), "punch range-") ? float(-300) : (has_playmod(pInfo(peer), "fists o' fury") || pInfo(peer)->hand == 9908 ? 500 : (has_playmod(pInfo(peer), "Dragonborn") ? 500 : (has_playmod(pInfo(peer), "devouring souls") ? -300 : 200)));
		pInfo(peer)->high_jump = (has_playmod2(pInfo(peer), 18) || has_playmod2(pInfo(peer), 72) ? -30 : (has_playmod(pInfo(peer), "high jump") || has_playmod(pInfo(peer), "slowfall") ? 700 : 1000));
		if ((pInfo(peer)->cheater_settings & Gtps3::SETTINGS_4 && pInfo(peer)->disable_cheater == 0)) pInfo(peer)->player_speed = 800;
		else {
			pInfo(peer)->player_speed = 250;
			if (has_playmod(pInfo(peer), "Speedy")) pInfo(peer)->player_speed = 320;
			if (has_playmod2(pInfo(peer), 47) || has_playmod2(pInfo(peer), 116)) pInfo(peer)->player_speed = 420;
			if (has_playmod2(pInfo(peer), 141) || has_playmod2(pInfo(peer), 28) || has_playmod2(pInfo(peer), 114) || has_playmod(pInfo(peer), "Black Magic"))  pInfo(peer)->player_speed = (pInfo(peer)->player_speed == 420 || pInfo(peer)->player_speed == 310 ? 190 : 150);
		}
		pInfo(peer)->water_speed = has_playmod(pInfo(peer), "water") || pInfo(peer)->hand == 2970 ? 170 : 125;
		if (pInfo(peer)->hand == 11094) {
			pInfo(peer)->build_range = (pInfo(peer)->mod || pInfo(peer)->dev || pInfo(peer)->superdev || pInfo(peer)->name_color == "`2" ? 131 : 129);
			pInfo(peer)->punch_range = (pInfo(peer)->mod || pInfo(peer)->dev || pInfo(peer)->superdev || pInfo(peer)->name_color == "`2" ? 131 : 129);
		}
		else {
			if (pInfo(peer)->hand == 9908) pInfo(peer)->build_range = 133, pInfo(peer)->punch_range = 136;
			else if (pInfo(peer)->hand == 9906) pInfo(peer)->build_range = 130, pInfo(peer)->punch_range = 132;
			else {
				pInfo(peer)->build_range = (has_playmod(pInfo(peer), "build range") ? 129 : 128);
				if (has_playmod(pInfo(peer), "punch range")) {
					if (has_playmod(pInfo(peer), "punch range+"))  pInfo(peer)->punch_range = 130;
					else pInfo(peer)->punch_range = 129;
				}
				else  pInfo(peer)->punch_range = 128;
			}
		}
		if (pInfo(peer)->transmute.size() != 0 or pInfo(peer)->temp_transmute) {
			pInfo(peer)->transmuted.clear();
			for (int i = 0; i < pInfo(peer)->transmute.size(); i++) {
				if (items[pInfo(peer)->transmute[i].first].clothType == items[pInfo(peer)->transmute[i].second].clothType) {
					pInfo(peer)->transmuted += "," + to_string(pInfo(peer)->transmute[i].first) + ":" + to_string(pInfo(peer)->transmute[i].second);
				}
			}
			if (not pInfo(peer)->transmuted.empty()) pInfo(peer)->transmuted.erase(0, 1);
		}

		pInfo(peer)->punch_modifier = 0;
		pInfo(peer)->punch_decrease = false;
		if (has_playmod(pInfo(peer), "Enhanced Digging")) pInfo(peer)->punch_modifier++;
		if (has_playmod(pInfo(peer), "punch damage", (pInfo(peer)->punch_modifier == 0 ? false : true))) pInfo(peer)->punch_modifier++;
		if (has_playmod(pInfo(peer), "Dragoscarf")) pInfo(peer)->punch_modifier++;
		if (has_playmod(pInfo(peer), "punch range-")) pInfo(peer)->punch_decrease = true;
		pInfo(peer)->punch_effect = items[pInfo(peer)->hand].effect != 0 ? items[pInfo(peer)->hand].effect : items[pInfo(peer)->necklace].effect != 0 ? items[pInfo(peer)->necklace].effect : items[pInfo(peer)->back].effect != 0 ? items[pInfo(peer)->back].effect : items[pInfo(peer)->face].effect != 0 ? items[pInfo(peer)->face].effect : items[pInfo(peer)->mask].effect != 0 ? items[pInfo(peer)->mask].effect : items[pInfo(peer)->hair].effect != 0 ? items[pInfo(peer)->hair].effect : items[pInfo(peer)->feet].effect != 0 ? items[pInfo(peer)->feet].effect : items[pInfo(peer)->shirt].effect != 0 ? items[pInfo(peer)->shirt].effect : items[pInfo(peer)->pants].effect != 0 ? items[pInfo(peer)->pants].effect : items[pInfo(peer)->ances].effect != 0 ? items[pInfo(peer)->ances].effect : 0;

	}
	else {
		bool guild_role = false;
		if (pInfo(peer)->guild_id != 0) {
			uint32_t guild_id = pInfo(peer)->guild_id;
			vector<Guild>::iterator find_guild = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (find_guild != guilds.end()) {
				Guild* guild_information = &guilds[find_guild - guilds.begin()];
				for (GuildMember member_search : guild_information->guild_members) {
					if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
						pInfo(peer)->guild_role = member_search.role_id;
						if (guild_information->guild_mascot[0] + guild_information->guild_mascot[1] != 0) {
							pInfo(peer)->guild_fg = guild_information->guild_mascot[0];
							pInfo(peer)->guild_bg = guild_information->guild_mascot[1];
						}
						guild_role = true;
						break;
					}
				}
			}
			if (guild_role == false) pInfo(peer)->guild_role = 0;
		}
		else {
			if (guild_role == false) pInfo(peer)->guild_role = -1;
		}
	}
}


void add_pineapple(ENetPeer* peer, int give) {
	bool bc_all = false;
	total_pineapple_eaten += give;
	pInfo(peer)->stage_pineapple += give;
	pInfo(peer)->total_pineapple += give;
	uint16_t stage = pInfo(peer)->stage_pineapple;
	if (stage >= 200) stage -= (stage / 200) * 200;
	stage /= 2;
	if (stage == 0 && (pInfo(peer)->stage_pineapple == 200 || pInfo(peer)->stage_pineapple == 400 || pInfo(peer)->stage_pineapple == 600)) stage = 100;
	uint8_t stage_level = (pInfo(peer)->stage_pineapple <= 200 ? 1 : (pInfo(peer)->stage_pineapple <= 400 ? 2 : 3));
	vector<string> pineapple_text{ "Full of Pineapples", "Almost a Pineapple", "Pineapple Form" }, random_scream{ ":P `9No more!!``", ":P `9URP!``", ":P `9Bluhhhh...``", ":P `9I can't eat another bite!``", ":P `9Please stop, I'm going to explode!``", ":P `9Seriously, I AM GOING TO `4EXXPPPPLLLOOOODEEE``!!!``" };
	gamepacket_t p;
	p.Insert("OnTalkBubble");
	p.Insert(pInfo(peer)->netID);
	if (stage == 100) {
		update_clothes_value(peer);
		update_clothes(peer);
		p.Insert("`9You have reached Stage " + to_string(stage_level) + "``\n`2" + pineapple_text[stage_level - 1] + "``");
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = pInfo(peer)->x + 16, data_.plantingTree = 300, data_.y = pInfo(peer)->y + 16;
		BYTE* raw = packPlayerMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
	}
	else {
		if (pInfo(peer)->stage_pineapple <= 617) p.Insert((pInfo(peer)->stage_pineapple <= 599 ? "You are `5" + to_string(stage) + "%`` towards becoming Stage " + to_string(stage_level) + " `5" + pineapple_text[stage_level - 1] + "``" : random_scream[rand() % random_scream.size()]));
		else {
			update_clothes_value(peer);
			update_clothes(peer);
			bc_all = true;
			p.Insert(":P `9I exploded.``");
			pInfo(peer)->stage_pineapple = 0;
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.x = pInfo(peer)->x + 16, data_.plantingTree = 300, data_.y = pInfo(peer)->y + 16, data_.XSpeed = 2734;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			if (has_playmod(pInfo(peer), "Ultimate Super Pineapple Magic") == false) {
				PlayMods new_playmod{};
				new_playmod.id = 98, new_playmod.time = time(nullptr) + 1200, pInfo(peer)->playmods.push_back(new_playmod);
				{
					packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("You shmimer with ULTIMATE Super Pineapple Magic (`$Ultimate Super Pineapple Magic`` mod added, `$20 mins`` left)"), p.CreatePacket(peer);
				}
			}
		}
		p.Insert(0);
		p.Insert((pInfo(peer)->stage_pineapple <= 599 ? 1 : 0));
		if (pInfo(peer)->stage_pineapple > 599 or bc_all) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				p.CreatePacket(currentPeer);
			}
		}
	}
	p.CreatePacket(peer);
}

void unequip_(ENetPeer* p_, const int id_) {
	if (pInfo(p_)->hider && pInfo(p_)->world == Hide_N_Seek.hidenseekworld) return;
	if (items[id_].flagmay != 0) pInfo(p_)->flagmay = 0, update_clothes(p_);
	if (id_ == 7584) {
		pInfo(p_)->sprite++;
		if (pInfo(p_)->sprite > 3) pInfo(p_)->sprite = 1;
	}
	else if (id_ == 5712) {
		pInfo(p_)->wild++;
		if (pInfo(p_)->wild > 8) pInfo(p_)->wild = 6;
	}
	else if (id_ == 10666) {
		pInfo(p_)->grow_air_ballon++;
		if (pInfo(p_)->grow_air_ballon > 3) pInfo(p_)->grow_air_ballon = 0;
	}
	else if (id_ == 10044) {
		pInfo(p_)->golem++;
		if (pInfo(p_)->golem > 8) pInfo(p_)->golem = 6;
	}
	else if (id_ == 7384) pInfo(p_)->growformer = (pInfo(p_)->growformer ? 0 : 1);
	else if (id_ == 11506 || id_ == 11508) pInfo(p_)->mask_dragon = (pInfo(p_)->mask_dragon ? 0 : 1);
	else if (id_ == 10914) pInfo(p_)->pure_shadow = (pInfo(p_)->pure_shadow == 1 ? 0 : 1);
	bool stat_ = 0;
	ItemDB item_ = items[id_];
	switch (items[id_].clothType) {
	case ClothTypes::ANCES:
		if (pInfo(p_)->ances == id_)
			pInfo(p_)->ances = 0, stat_ = 1;
		break;
	case ClothTypes::BACK:
		if (pInfo(p_)->back == id_)
			pInfo(p_)->back = 0, stat_ = 1;
		break;
	case ClothTypes::FACE:
		if (pInfo(p_)->face == id_)
			pInfo(p_)->face = 0, stat_ = 1;
		break;
	case ClothTypes::FEET:
		if (pInfo(p_)->feet == id_)
			pInfo(p_)->feet = 0, stat_ = 1;
		break;
	case ClothTypes::HAIR:
		if (pInfo(p_)->hair == id_)
			pInfo(p_)->hair = 0, stat_ = 1;
		break;
	case ClothTypes::HAND:
		if (pInfo(p_)->hand == id_)
			pInfo(p_)->hand = 0, stat_ = 1;
		break;
	case ClothTypes::MASK:
		if (pInfo(p_)->mask == id_)
			pInfo(p_)->mask = 0, stat_ = 1;
		break;
	case ClothTypes::NECKLACE:
		if (pInfo(p_)->necklace == id_)
			pInfo(p_)->necklace = 0, stat_ = 1;
		break;
	case ClothTypes::PANTS:
		if (pInfo(p_)->pants == id_)
			pInfo(p_)->pants = 0, stat_ = 1;
		break;
	case ClothTypes::SHIRT:
		if (pInfo(p_)->shirt == id_)
			pInfo(p_)->shirt = 0, stat_ = 1;
		break;
	default:
		break;
	}
	if (stat_) {
		update_clothes_value(p_);
		update_clothes(p_);
		packet_(p_, "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0");
	}
	if (stat_ and item_.on_remove != "" or id_ == 2286 and pInfo(p_)->hand == 2286 or id_ == 2204 and pInfo(p_)->hand == 2204 or id_ == 2558 and pInfo(p_)->hand == 2560 or id_ == 2560 and pInfo(p_)->hand == 2558) {
		packet_(p_, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		if (id_ == 2204 || id_ == 2558) console_msg(p_, "" + items[id_].ori_name + " removed. (`$" + items[id_].ori_name + "`` mod removed)");
		else if (id_ == 2286 or id_ == 2560 and pInfo(p_)->geiger_ < 100) {
			console_msg(p_, "" + items[id_].ori_name + " is no longer charging! (`$Charging " + items[id_].ori_name + "`` mod removed)");
			pInfo(p_)->geiger_ = 0;
		}
		else console_msg(p_, item_.on_remove + (item_.playmod != "" ? " (`$" + item_.playmod + "`` mod removed)" : ""));
	}
}
void cancel_trade(ENetPeer* p_, bool confirm_cancel = false, bool busy_ = false) {
	bool found = false;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(p_)->world) {
			if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
				found = true;
				pInfo(currentPeer)->block_trade = false, pInfo(currentPeer)->accept_the_offer = false, pInfo(currentPeer)->trading_with = -1, pInfo(currentPeer)->trade_items.clear();
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					if (not confirm_cancel) {
						World* world_ = &worlds[p - worlds.begin()];
						{
							if (busy_) {
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(get_player_nick(p_) + " is too busy to trade!");
									p.CreatePacket(currentPeer), p.CreatePacket(p_);
								}
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert(get_player_nick(p_) + " is too busy to trade!");
								p.CreatePacket(currentPeer), p.CreatePacket(p_);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert(get_player_nick(p_) + " has canceled the trade");
								p.CreatePacket(currentPeer);
							}
						}
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("`6[```4Trade canceled by " + get_player_nick(p_) + "!```6]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("`6[```4Trade canceled by " + get_player_nick(p_) + "!```6]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`6[```4Trade canceled by " + get_player_nick(p_) + "!```6]``");
							p.CreatePacket(p_), p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTextOverlay");
							p.Insert("`6[```4Trade canceled by " + get_player_nick(p_) + "!```6]``");
							p.CreatePacket(p_), p.CreatePacket(currentPeer);
						}
					}
					gamepacket_t p;
					p.Insert("OnForceTradeEnd");
					p.CreatePacket(currentPeer);
					if (busy_) {
						p.CreatePacket(p_);
					}
				}
				pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
				return;
			}
		}
	}
	if (busy_) {
		{
			console_msg(p_, (not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->tankIDName) + " is too busy to trade!");
		}
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert((not pInfo(p_)->d_name.empty() ? pInfo(p_)->d_name : pInfo(p_)->tankIDName) + " is too busy to trade!");
		p.CreatePacket(p_);
	}
	else if (pInfo(p_)->trade_accept) {
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert("The other person left the trade!");
		p.CreatePacket(p_);
	}
	if (not found) {
		gamepacket_t p;
		p.Insert("OnForceTradeEnd");
		p.CreatePacket(p_);
	}
	pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
}


void send_logs(string log, string logs_name) {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	log = "`0" + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : to_string(newtime.tm_hour)) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : to_string(newtime.tm_min)) + " " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + ": `o" + log + "``\n";
	vector<pair<string, string>>::iterator p2 = find_if(Server_Security.logs.begin(), Server_Security.logs.end(), [&](const pair < string, string>& element) { return element.first == logs_name; });
	if (p2 != Server_Security.logs.end()) Server_Security.logs[p2 - Server_Security.logs.begin()].second += log;
	else Server_Security.logs.push_back(make_pair(logs_name, log));
}


void send_logs_page(ENetPeer* peer, string button, string search = "") {
	string log_text = "";
	int found = 0;
	vector<string> text_decode;
	for (int i = 0; i < Server_Security.logs.size(); i++) {
		if (Server_Security.logs[i].first == button) {
			vector <string> that_log = explode("\n", Server_Security.logs[i].second);
			reverse(that_log.begin(), that_log.end());
			text_decode = that_log;
			break;
		}
	}
	if (not search.empty()) {
		for (int i = 0; i < text_decode.size(); i++) {
			if (to_lower(explode("\n", text_decode[i])[0].c_str()).find(to_lower(search)) != string::npos) {
				log_text += "\nadd_smalltext|" + a + explode("\n", text_decode[i])[0].c_str() + "|left|";
				found++;
			}
		}
	}
	else {
		if (text_decode.size() > 1) {
			if (pInfo(peer)->search_page >= text_decode.size()) {
				pInfo(peer)->search_page = text_decode.size() - 20;
			}
			for (int i = (pInfo(peer)->search_page > text_decode.size() ? 0 : pInfo(peer)->search_page - 20); i < (pInfo(peer)->search_page > text_decode.size() ? text_decode.size() : pInfo(peer)->search_page); i++) log_text += "\nadd_smalltext|" + a + explode("\n", text_decode[i])[0].c_str() + "|left|";
		}
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + button + "``|left|3732|\nembed_data|logs_title|" + button + "" + (log_text.empty() ? "\nadd_smalltext|No logs yet|left|\nend_dialog|logs|OK||" : "\nadd_spacer|small|\nadd_text_input|search|Search: "+(not search.empty() ? "(" + to_string(found) + ")" : "") + ":||30|\nadd_spacer|small|" + log_text + "\nadd_spacer|small|"+(not search.empty() ? "" : "" +a + (pInfo(peer)->search_page != 20 ? "\nadd_button|Previous page|`#<Previous 20>``|noflags|0|0|" : "") + "\nadd_button|Next page|`#<Next 20>``|noflags|0|0|") + "\nend_dialog|logs_search|OK|Search|") + "");
	p.CreatePacket(peer);
}

void save_player(Player* p_, bool on_exit) {
	if (p_->growid == false or p_->tankIDName.empty() or p_->tankIDPass.empty()) return;
	if (p_->auth_) return;
	//saveall
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	json save_;
	if (p_->temp_password != p_->tankIDPass) p_->temp_password.clear();
	save_["name"] = p_->tankIDName;
	save_["temp_pass"] = p_->temp_password;
	save_["n"] = p_->n;
	save_["mod2"] = p_->moderator;
	save_["vips"] = p_->vip_p;
	save_["dev"] = p_->dev;
	save_["superdev"] = p_->superdev;
	save_["m_h"] = p_->m_h;
	save_["cc"] = p_->cc;
	save_["opc"] = p_->opc;
	save_["7bans"] = p_->bans;
	save_["w_w"] = p_->w_w;
	save_["mer"] = p_->mercy;
	save_["meta"] = p_->meta;
	save_["rtg"] = p_->real_growtopia_name;
	save_["drtt"] = p_->drtitle;
	save_["drll"] = p_->drlegend;
	save_["new_pass"] = p_->new_pass;
	save_["_drt"] = p_->drt;
	save_["dnr"] = p_->donor;
	save_["mst"] = p_->master;
	save_["wls_participated"] = p_->wls_participated;
	save_["/whitelist"] = p_->whitelist_role;
	save_["al"] = p_->all_in;
	save_["mlb"] = p_->mailbox;
	save_["ccd"] = p_->total_credit_card;
	save_["ccd2"] = p_->credit_card;
	save_["radio2"] = p_->radio2;
	save_["owner"] = p_->ownership_role;
	save_["/buy"] = p_->buy_role;
	save_["/ghost"] = p_->ghost_role;
	save_["/nick"] = p_->nick_role;
	save_["/give"] = p_->give_role;
	save_["/edit"] = p_->give_editor;
	save_["/csn"] = p_->csn_role;
	save_["/custom_name_color"] = p_->custom_name_color;
	save_["cry"] = p_->crypto;
	save_["participated"] = p_->participated;
	save_["ig"] = p_->ignored;
	save_["wipe"] = p_->wiped_invalid_worlds;
	save_[recycle_event_name] = p_->received_recycle_prize;

	save_["lr"] = p_->last_rated;
	save_["sc"] = p_->skin_c;
	save_["as"] = p_->autofarm_slot;
	save_["playtime_items"] = p_->playtime_items;
	save_["tmod"] = p_->tmod;
	save_["bc"] = p_->black_color;
	save_["gg4e"] = p_->grow4good_email;
	//save_["blabo"] = p_->black_box_consumed;
	save_["on"] = p_->p_status;
	save_["rubble"] = p_->rubble;
		// Crown of Season
	save_["a_s"] = p_->Aura_Season;
	save_["t_s"] = p_->Trail_Season;

	// Banner Bandolier
	save_["ba_i"] = p_->Banner_Item;
	save_["ba_f"] = p_->Banner_Flag;


	save_["p_d1"] = p_->pinata_day;
	save_["p_d2"] = p_->pinata_prize;
	save_["p_d3"] = p_->pinata_claimed;

	save_["g" + to_string(grow_pass_item)] = p_->growpass_points;
	save_["gp" + to_string(grow_pass_item)] = p_->growpass_prizes;
	save_["gq" + to_string(grow_pass_item)] = p_->growpass_quests;
	// Infinity Crown
	save_["sm1"] = p_->summer_surprise;
	save_["sm2"] = p_->summer_total;
	save_["sm3"] = p_->summer_milestone;

	//
	save_["c_t_c"] = p_->Crown_Time_Change;
	save_["c_c_t"] = p_->Crown_Cycle_Time;
	save_["br0"] = p_->Base_R_0;
	save_["bg0"] = p_->Base_G_0;
	save_["bb0"] = p_->Base_B_0;
	save_["gr0"] = p_->Gem_R_0;
	save_["gg0"] = p_->Gem_G_0;
	save_["gb0"] = p_->Gem_B_0;
	save_["cr0"] = p_->Crystal_R_0;
	save_["cg0"] = p_->Crystal_G_0;
	save_["cb0"] = p_->Crystal_B_0;
	save_["cfe0"] = p_->Crown_Floating_Effect_0;
	save_["clb0"] = p_->Crown_Laser_Beam_0;
	save_["crc0"] = p_->Crown_Crystals_0;
	save_["c0rr"] = p_->Crown_Rays_0;
	save_["Base_R_1"] = p_->Base_R_1;
	save_["Base_G_1"] = p_->Base_G_1;
	save_["Base_B_1"] = p_->Base_B_1;
	save_["Gem_R_1"] = p_->Gem_R_1;
	save_["Gem_G_1"] = p_->Gem_G_1;
	save_["Gem_B_1"] = p_->Gem_B_1;
	save_["Crystal_R_1"] = p_->Crystal_R_1;
	save_["Crystal_G_1"] = p_->Crystal_G_1;
	save_["Crystal_B_1"] = p_->Crystal_B_1;
	save_["Crown_Floating_Effect_1"] = p_->Crown_Floating_Effect_1;
	save_["Crown_Laser_Beam_1"] = p_->Crown_Laser_Beam_1;
	save_["Crown_Crystals_1"] = p_->Crown_Crystals_1;
	save_["Crown_Rays_1"] = p_->Crown_Rays_1;
	save_["Crown_Value"] = p_->Crown_Value;
	save_["Crown_Value_0_0"] = p_->Crown_Value_0_0;
	save_["Crown_Value_0_1"] = p_->Crown_Value_0_1;
	save_["Crown_Value_0_2"] = p_->Crown_Value_0_2;
	save_["Crown_Value_1_0"] = p_->Crown_Value_1_0;
	save_["Crown_Value_1_1"] = p_->Crown_Value_1_1;
	save_["Crown_Value_1_2"] = p_->Crown_Value_1_2;
	// Crown of Season

	save_["cheater"] = p_->cheater_;
	save_["c_s"] = p_->cheater_settings;
	save_["support101"] = p_->support101_;
	save_["logger"] = p_->logger;

	save_["egg"] = p_->egg_carton;
	save_["egg2"] = p_->magic_egg;
	save_["h1"] = p_->won_hider;
	save_["h2"] = p_->won_seeker;

	// Magic Magnet
	save_["mg"] = p_->Magnet_Item;
	save_["g_a_b"] = p_->grow_air_ballon;
	// Carnival Quest
	save_["ca_c"] = p_->carnival_credit;
	save_["CQuest"] = p_->C_QuestActive;
	save_["CQItem"] = p_->C_DeliverID;
	save_["CQProg"] = p_->C_QuestProgress;
	save_["CQKind"] = p_->C_QuestKind;
	save_["CQNeed"] = p_->C_ProgressNeeded;
	save_["CQStep"] = p_->C_QuestStep;

	save_["balloon_prize"] = p_->received_balloon_warz;

	save_["ch_55"] = p_->chat_prefix;


	save_["grm"] = p_->growmoji;
	save_["12640"] = p_->minokawa_wings;
	save_["12872"] = p_->panda_spirit;
	save_["11506"] = p_->mask_dragon;
	save_["7384"] = p_->growformer;
	save_["12634"] = p_->eq_aura;

	save_["gender"] = p_->gender;

	save_["bb_1"] = p_->balloon_faction;
	save_["bb_2"] = p_->balloon_hit;
	save_["bb_3"] = p_->hit_by;
	save_["bb_4"] = p_->balloon_donated;
	save_["bb_5"] = p_->balloon_score;

	save_["lw_1"] = p_->lwiz_quest;
	save_["lw_2"] = p_->lwiz_step;
	save_["lw_3"] = p_->lwiz_notification;
	save_["lw_4"] = p_->legendary_quest;
	save_["set"] = p_->set;
	save_["is_legend"] = p_->is_legend;


	/*
	save_["w_t_d"] = p_->winterfest_task_day;
	save_["w_t_w"] = p_->winterfest_wishes;
	save_["w_t_q1"] = p_->winterfest_quest_1;
	save_["w_t_q2"] = p_->winterfest_quest_2;
	save_["w_t_q3"] = p_->winterfest_quest_3;

	save_["w_t_rq1"] = p_->reset_winterfest_quest_1;
	save_["w_t_rq2"] = p_->reset_winterfest_quest_2;
	save_["w_t_rq3"] = p_->reset_winterfest_quest_3;
	save_["w_t_rq4"] = p_->reset_winterfest_quest_4;
	save_["w_t_rq5"] = p_->reset_winterfest_quest_5;
	save_["w_t_rq6"] = p_->reset_winterfest_quest_6;
	save_["w_t_rq7"] = p_->reset_winterfest_quest_7;
	save_["w_t_rq8"] = p_->reset_winterfest_quest_8;
	save_["w_t_st"] = p_->winterfest_stuff4toys;
	save_["got_4292"] = p_->got_4292;
	save_["got_4286"] = p_->got_4286;
	save_["got_4288"] = p_->got_4288;
	save_["got_10500"] = p_->got_10500;*/

	save_["ri_1"] = p_->cape_t;
	save_["ri_2"] = p_->cape_c;
	save_["ri_3"] = p_->cape_t2;
	save_["ri_4"] = p_->cape_c2;
	save_["ri_5"] = p_->flags;
	save_["ri_6"] = p_->TimeDilation;
	save_["ri_7"] = p_->CapeStyleColor_1;
	save_["ri_8"] = p_->CapeStyleColor_2;
	save_["ri_9"] = p_->CapeCollarColor_1;
	save_["ri_10"] = p_->CapeCollarColor_2;

	save_["rw_1"] = p_->wings_t;
	save_["rw_2"] = p_->wings_c;
	save_["rw_3"] = p_->wings_t2;
	save_["rw_4"] = p_->wings_c2;
	save_["rw_5"] = p_->_flags;
	save_["rw_6"] = p_->_TimeDilation;
	save_["rw_7"] = p_->_CapeStyleColor_1;
	save_["rw_8"] = p_->_CapeStyleColor_2;
	save_["rw_9"] = p_->_CapeCollarColor_1;
	save_["rw_10"] = p_->_CapeCollarColor_2;

	/*
	save_["h_1"] = p_->halloween_task_1;
	save_["h_2"] = p_->halloween_task_2;
	save_["h_3"] = p_->halloween_task_3;
	save_["h_4"] = p_->halloween_task_4;

	save_[to_string(halloween_quest) + "1"] = p_->halloween_ptask_1;
	save_[to_string(halloween_quest) + "2"] = p_->halloween_ptask_2;
	save_[to_string(halloween_quest) + "3"] = p_->halloween_ptask_3;
	save_[to_string(halloween_quest) + "4"] = p_->halloween_ptask_4;
	save_[to_string(halloween_quest) + "5"] = p_->halloween_ptask_5;*/

	/*
	save_["p_d1"] = p_->pinata_day;
	save_["p_d2"] = p_->pinata_prize;
	save_["p_d3"] = p_->pinata_claimed;
	*/
	save_["p_7"] = p_->pure_shadow;
	save_["gr_w"] = p_->growtoken_worlds;
	save_["g4g_7"] = p_->grow4good_gems;
	save_["g4g_9"] = p_->grow4good_surgery;
	save_["g4g_10"] = p_->grow4good_fish;
	save_["g4g_11"] = p_->grow4good_points;
	save_["g4g_12"] = p_->grow4good_30mins;
	save_["g4g_14"] = p_->grow4good_break;
	save_["g4g_15"] = p_->grow4good_place;
	save_["g4g_16"] = p_->grow4good_trade;
	save_["g4g_17"] = p_->grow4good_sb;
	save_["g4g_18"] = p_->grow4good_enter;
	save_["g4g_19"] = p_->grow4good_provider;
	save_["g4g_20"] = p_->grow4good_provider2;
	save_["g4g_21"] = p_->grow4good_geiger;
	save_["g4g_22"] = p_->grow4good_geiger2;
	save_["g4g_24"] = p_->grow4good_seed;
	save_["g4g_25"] = p_->grow4good_seed2;
	save_["g4g_26"] = p_->grow4good_combine;
	save_["gd_"] = p_->grow_reset_day;
	save_["gw_"] = p_->grow_reset_week;
	save_["gm_"] = p_->grow_reset_month;
	save_["g4g_28"] = p_->grow4good_crystal;
	save_["g4g_29"] = p_->grow4good_honors;

	save_["2fa"] = p_->fa2;

	//save_["garuda"] = p_->garuda;


	save_["p_1"] = p_->display_age;
	save_["p_2"] = p_->display_home;

	save_["fire"] = p_->fires;

	//save_["cnv_1"] = p_->carnival_credit;

	save_["bea_1"] = p_->pearl;

	save_["spr"] = p_->sprite;

	save_["spr2"] = p_->wild;
	save_["spr3"] = p_->golem;

	save_["p1_1"] = p_->total_pineapple;
	save_["p1_2"] = p_->stage_pineapple;


	//save_["smp"] = p_->halloween_dark_king;


	save_["lvl125"] = p_->lvl125;
	save_["rad"] = p_->radio;
	save_["skl"] = p_->surgery_skill;
	save_["sgt"] = p_->surgery_type;
	save_["sd"] = p_->surgery_done;
	save_["su1"] = p_->su_8552_1;
	save_["su2"] = p_->su_8552_2;
	save_["su3"] = p_->su_8552_3;
	//save_["egg"] = p_->egg;
	save_["glo"] = p_->glo;
	save_["b_t"] = p_->b_t;
	save_["b_b"] = p_->b_b;
	save_["dd"] = p_->dd;
	save_["lo"] = to_string(newtime.tm_mon + 1) + "/" + to_string(today_day) + "/" + to_string(1900 + newtime.tm_year) + " " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec);
	save_["ip"] = p_->ip;
	save_["fa_ip"] = p_->fa_ip;
	save_["b_s"] = p_->b_s;
	save_["b_r"] = p_->b_r;
	save_["b_ra"] = p_->b_ra;
	save_["i_11818_1"] = p_->i_11818_1;
	save_["i_11818_2"] = p_->i_11818_2;
	save_["e_1"] = p_->hair_color;
	save_["e_2"] = p_->eye_drop;
	save_["e_3"] = p_->eye_lenses;
	save_["b_lvl"] = p_->b_lvl;
	save_["b_i"] = p_->b_i;
	save_["b_bill"] = p_->b_bill;
	save_["myou"] = p_->mini_you;
	save_["b_w"] = p_->b_w;
	save_["b_p"] = p_->b_p;
	save_["m_b"] = p_->m_b;
	save_["note"] = p_->note;
	save_["supp"] = p_->supp;
	save_["hs"] = p_->hs;
	save_["bb"] = p_->bb;
	save_["gtwl"] = p_->gtwl;
	save_["rb"] = p_->rb;
	save_["gp"] = p_->gp;
	save_["glo_p"] = p_->glo_p;
	save_["surg_p"] = p_->surg_p;
	save_["t_p"] = p_->t_p;
	save_["bb_p"] = p_->bb_p;
	save_["ff_p"] = p_->ff_p;
	save_["p_p"] = p_->p_p;
	save_["g_p"] = p_->g_p;
	save_["t_xp"] = p_->t_xp;
	save_["bb_xp"] = p_->bb_xp;
	save_["ff_xp"] = p_->ff_xp;
	save_["s_xp"] = p_->s_xp;
	save_["g_xp"] = p_->g_xp;
	save_["p_xp"] = p_->p_xp;
	save_["t_lvl"] = p_->t_lvl;
	save_["bb_lvl"] = p_->bb_lvl;
	save_["ff_lvl"] = p_->ff_lvl;
	save_["g_lvl"] = p_->g_lvl;
	save_["p_lvl"] = p_->p_lvl;
	save_["s_lvl"] = p_->s_lvl;
	save_["b_l"] = p_->b_l;
	save_["bp"] = p_->bp;
	save_["flagmay"] = p_->flagmay;
	save_["pass"] = p_->tankIDPass, save_["email"] = p_->email;
	save_["gems"] = p_->gems;
	save_["vou"] = p_->voucher;
	save_["punch"] = p_->punch_count;
	save_["home_world"] = p_->home_world;
	save_["show_location"] = p_->show_location_;
	save_["show_notifications"] = p_->show_friend_notifications_;
	save_["xp"] = p_->xp;
	save_["d_name"] = p_->d_name;
	save_["level"] = p_->level;
	save_["skin"] = p_->skin;
	save_["geiger"] = p_->geiger_;
	save_["ghost"] = p_->ghost;
	save_["invis"] = p_->invis;
	save_["date"] = p_->account_created;
	save_["booty_broken"] = p_->booty_broken;
	save_["playtime"] = p_->seconds + (time(NULL) - p_->playtime);
	save_[guild_name_player] = p_->guild_id;
	save_["legend"] = p_->is_legend;
	save_["roleSkin"] = p_->roleSkin;
	save_["roleIcon"] = p_->roleIcon;
	save_["mac"] = p_->mac;
	save_["rid"] = p_->rid;
	save_["vid"] = p_->vid;
	/*
	for (int i_ = 0; i_ < (p_->inv.size() > 496 ? 497 : p_->inv.size()); i_++) {
		json item_;
		item_["i"] = p_->inv[i_].id;
		item_["c"] = p_->inv[i_].count;
		inv_.push_back(item_);
	}*/
	/*
	for (it = p_->achievements.begin(); it != p_->achievements.end(); it++) {
		json achievement_;
		achievement_["title"] = it->first;
		achievement_["progress"] = it->second;
		achievements_.push_back(achievement_);
	} */
	/*
	json blarneys_ = json::array();
	for (int i_ = 0; i_ < p_->completed_blarneys.size(); i_++) {
		json blarney_;
		blarney_["world"] = p_->completed_blarneys[i_][0];
		blarney_["time"] = p_->completed_blarneys[i_][1];
		blarneys_.push_back(blarney_);
	}*/
	save_["blarney"] = json::array();
	save_["playmods"] = p_->playmods;
	save_["worlds_owned"] = p_->worlds_owned;
	save_["ch"] = p_->crypto_history;
	save_["la_wo"] = p_->last_visited_worlds;
	save_["t_h"] = p_->trade_history;
	save_["inventory"] = p_->inv;
	save_["trans"] = p_->transmute;
	save_["achievements"] = json::array();
	save_["friends"] = p_->friends;
	save_["favitem"] = p_->Fav_Items;
	save_["load_item2"] = p_->load_item2;
	save_["hair"] = p_->hair, save_["shirt"] = p_->shirt, save_["pants"] = p_->pants, save_["feet"] = p_->feet, save_["face"] = p_->face, save_["hand"] = p_->hand, save_["back"] = p_->back, save_["mask"] = p_->mask, save_["necklace"] = p_->necklace, save_["ances"] = p_->ances;
	ofstream w_("players/" + p_->tankIDName + "_.json");
	if (w_.fail()) {
		cout << "failed to save player " << p_->tankIDName << endl;
		return;
	}
	w_ << save_ << endl;
	w_.close();
	{
		if (on_exit) {
			uint32_t guild_id = p_->guild_id;
			if (p_->guild_id != 0) {
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* edit_member = &guild_information->guild_members[i_];
						if (to_lower(edit_member->member_name) == to_lower(p_->tankIDName)) {
							edit_member->last_online = time(NULL);
							break;
						}
					}
				}
			}
			{
				vector<string> friends_;
				gamepacket_t p, p_g;
				p.Insert("OnConsoleMessage"), p.Insert("`3FRIEND ALERT:`` " + p_->tankIDName + " has `4logged off``.");
				p_g.Insert("OnConsoleMessage"), p_g.Insert("`5[GUILD ALERT]`` " + p_->tankIDName + " has `4logged off``.");
				string t_ = "action|play_sfx\nfile|audio/friend_logoff.wav\ndelayMS|0";
				BYTE* const d_ = new BYTE[5 + t_.length()];
				*(__int8*)(d_) = 3;
				memcpy(d_ + 4, t_.c_str(), t_.length());
				*(__int8*)(d_ + 4 + t_.length()) = 0;
				ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
				for (int c_ = 0; c_ < p_->friends.size(); c_++) friends_.push_back(to_lower(p_->friends[c_].name));
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->temp_radio) continue;
					if (p_->guild_id != 0) {
						if (p_->guild_id == pInfo(currentPeer)->guild_id) p_g.CreatePacket(currentPeer);
					}
					if (find(friends_.begin(), friends_.end(), to_lower(pInfo(currentPeer)->tankIDName)) != friends_.end()) {
						for (int d_ = 0; d_ < pInfo(currentPeer)->friends.size(); d_++) {
							if (to_lower(pInfo(currentPeer)->friends[d_].name) == to_lower(p_->tankIDName)) {
								pInfo(currentPeer)->friends[d_].last_seen = time(NULL);
								break;
							}
						}
						if (not p_->invis and not p_->m_h) {
							if (pInfo(currentPeer)->show_friend_notifications_) {
								enet_peer_send(currentPeer, 0, p_m);
								 p.CreatePacket(currentPeer);
							}
						}
					}
				}
				delete[]d_;
			}
		}
	}
}

void leave_guild(ENetPeer* peer) {
	uint32_t guild_id = pInfo(peer)->guild_id;
	if (guild_id == 0) return;
	vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
	if (p != guilds.end()) {
		__int64 id_ = p - guilds.begin();
		Guild* guild_information = &guilds[p - guilds.begin()];
		for (GuildMember member_search : guild_information->guild_members) {
			if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
				if (member_search.role_id == 3) {
					if (guild_information->guild_members.size() != 1) return;
					break;
				}
			}
		}
		{
			console_msg(peer, "`5[GUILD ALERT]`` You left the guild!");
		}
		gamepacket_t p_leave;
		p_leave.Insert("OnConsoleMessage");
		p_leave.Insert("`5[GUILD ALERT]`` " + pInfo(peer)->tankIDName + " left the guild!");
		if (pInfo(peer)->world == guild_information->guild_world and guild_access(peer, guild_information->guild_id)) {
			nick_update_2(peer, NULL);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					if (pInfo(currentPeer)->netID != pInfo(peer)->netID and pInfo(currentPeer)->guild_id == guild_id) {
						p_leave.CreatePacket(currentPeer);
					}
				}
			}
		}
		else {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->netID != pInfo(peer)->netID and pInfo(currentPeer)->guild_id == guild_id) {
					p_leave.CreatePacket(currentPeer);
				}
			}
		}
		pInfo(peer)->guild_id = 0;
		update_clothes_value(peer);
		update_clothes(peer);
		save_player(pInfo(peer), false);
		for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
			GuildMember* member_search = &guild_information->guild_members[i_];
			if (to_lower(member_search->member_name) == to_lower(pInfo(peer)->tankIDName)) {
				if (member_search->role_id == 3) {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							if (pInfo(currentPeer)->guild_id == guild_information->guild_id) {
								if (guild_access(currentPeer, guild_information->guild_id)) {
									nick_update_2(currentPeer, NULL);
								}
							}
						}
					}
					/*
					string path_ = "guilds/" + to_string(guild_information->guild_id) + ".json";
					if (_access_s(path_.c_str(), 0) == 0) {
						remove(path_.c_str());
					}
					guilds.erase(guilds.begin() + id_);*/
					break;
				}
				guild_information->guild_members.erase(guild_information->guild_members.begin() + i_);
				create_guild_log(guild_information, "`$" + pInfo(peer)->tankIDName + "`` `wleft the guild", 5948);
			}
		}

	}
}


int modify_inventory(ENetPeer* p_, const int i_, int& c_, bool upd_inv_visuals = true, bool force_return = false) {
	if (c_ > 200 or i_ <= 0 or i_ == 112) return -1;

	if (c_ == 0) upd_inv_visuals = false;
	int ori_ = c_;
	Player* k_ = pInfo(p_);
	int last_free_ = -1;
	for (int a_ = 0; a_ < k_->inv.size(); a_++) {
		if (k_->inv[a_].first == i_) {
			if (k_->inv[a_].second + c_ <= 200) {
				if (c_ < 0 and k_->inv[a_].second + c_ < 0) return -1;
				if (k_->inv[a_].second + c_ == 0) {
					if (pInfo(p_)->b_i == k_->inv[a_].first) {
						if (pInfo(p_)->b_bill.size() < 3) pInfo(p_)->b_bill = "0,0";
						gamepacket_t p5(0, pInfo(p_)->netID);
						p5.Insert("OnBillboardChange"), p5.Insert(pInfo(p_)->netID), p5.Insert(pInfo(p_)->b_i = 0), p5.Insert(pInfo(p_)->b_bill = "0," + pInfo(p_)->b_bill.substr(2, 3)), p5.Insert(pInfo(p_)->b_p), p5.Insert(pInfo(p_)->b_w);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(p_)->world != pInfo(currentPeer)->world) continue;
							p5.CreatePacket(currentPeer);
						}
					}
					if (items[k_->inv[a_].first].blockType == BlockTypes::CLOTHING)
						unequip_(p_, k_->inv[a_].first);
					k_->inv[a_].first = 0, k_->inv[a_].second = 0;
					goto s_;
				}
				k_->inv[a_].second += c_;
				if (c_ == 0) {
					c_ = k_->inv[a_].second;
					return -1;
				}
				c_ = k_->inv[a_].second;
			}
			else {
				if (force_return)
					c_ = k_->inv[a_].second;
				return -1;
			}
			goto s_;
		}
		else if (k_->inv[a_].first == 0 and last_free_ == -1) {
			last_free_ = a_;
		}
		if (a_ + 1 == k_->inv.size()) {
			if (last_free_ != -1 and c_ > 0) {
				k_->inv[last_free_].first = i_, k_->inv[last_free_].second = c_;
				goto s_;
			}
			return -1;

		}
	}
s_:
	if (i_ == 7188) {
		send_logs(pInfo(p_)->tankIDName + " lvl: " + to_string(pInfo(p_)->level) + ", " + std::to_string(c_) + "x " + " in World: [" + pInfo(p_)->world + "]", "BGL Modified");
	}
	if (i_ == 8470) {
		send_logs(pInfo(p_)->tankIDName + " lvl: " + to_string(pInfo(p_)->level) + ", " + std::to_string(c_) + "x " + " in World: [" + pInfo(p_)->world + "]", "Black Gem Lock Modified");
	}
	if (i_ == 1796 && abs(c_) >= 50) {
		send_logs(pInfo(p_)->tankIDName + " lvl: " + to_string(pInfo(p_)->level) + ", " + std::to_string(c_) + "x " + " in World: [" + pInfo(p_)->world + "]", "Diamond Lock Modified");
	}
	if (pInfo(p_)->give_role || pInfo(p_)->buy_role) {
		send_logs(pInfo(p_)->tankIDName + " lvl: " + to_string(pInfo(p_)->level) + ", " +items[i_].ori_name + " " + std::to_string(c_) + "x " + " in World: [" + pInfo(p_)->world + "]", "inventory move logs (give role)");
	}
	if (upd_inv_visuals and c_ != 0) {
		PlayerMoving data_{};
		data_.packetType = 13, data_.plantingTree = i_;
		BYTE* raw = packPlayerMoving(&data_);
		raw[(ori_ < 0 ? 2 : 3)] = ori_ < 0 ? (ori_ * -1) : ori_;
		send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		delete[]raw;
	}
	return 0;
}


void janeway(ENetPeer* peer) {
	string availableItem = "\nadd_spacer|small|\nadd_textbox|Press item icon, you want to sell:|left|", items_ = "";
	bool add_ = false;
	for (int i = 0; i < janeway_.janeway_item.size(); i++) {
		int got = 0;
		modify_inventory(peer, janeway_.janeway_item[i].first, got);
		if (janeway_.janeway_item[i].first % 2 == 0) items_ += "\nadd_label_with_icon|small|" + items[janeway_.janeway_item[i].first].ori_name + "|left|" + to_string(janeway_.janeway_item[i].first) + "|";
		else items_ += "\nadd_smalltext|" + items[janeway_.janeway_item[i].first].ori_name + "|\nadd_seed_color_icons|" + to_string(janeway_.janeway_item[i].first) + "|";
		if (got == 200) {
			availableItem += "\nadd_button_with_icon|sell_" + to_string(janeway_.janeway_item[i].first) + "||staticBlueFrame|" + to_string(janeway_.janeway_item[i].first) + "|" + to_string(got) + "|";
			add_ = true;
		}
	}
	if (add_ == false) availableItem = "\nadd_textbox|It seems you don't have any items that i'm intrested to, come back later when you have thoose items.|left|";
	else availableItem += "\nadd_button_with_icon||END_LIST|noflags|0|0|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|\nadd_label_with_icon|big|`wOffer Something to Janeway``|left|12158|\nadd_spacer|small|\nadd_smalltext|`wHello there I am `9Janeway``<CR>Would you like to make a deal with me? if so please choose down below which item that you want to sell to me``|\nadd_spacer|small|\nadd_label_with_icon|small|My exchanging reward would be `2" + items[janeway_.janeway_payout].ori_name + "`` for now..|left|" + to_string(janeway_.janeway_payout) + "|\nadd_spacer|small|\nadd_textbox|I'm currently interested on buying 200 of|left|" + items_ + "\nadd_spacer|small|" + availableItem + "\nend_dialog|sellstuff|Cancel||\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}
void RandomizeCQuest(ENetPeer* p_) {
	if (pInfo(p_)->C_QuestKind != 0) return;
	if (pInfo(p_)->CQ) pInfo(p_)->CQ = false;
	int RandomQuest = rand() % 15 + 1;
	if (RandomQuest == 1) {
		pInfo(p_)->C_QuestKind = 1;
	GenerateAgain:
		int RandomItem = rand() % items.size() + 34;
		if (items[RandomItem].r_1 == 2035 || items[RandomItem].r_2 == 2035 || items[RandomItem].r_1 == 2037 || items[RandomItem].r_2 == 2037 || items[RandomItem].blockType == BlockTypes::LOCK || items[RandomItem].blockType == BlockTypes::SEED || items[RandomItem].r_1 == 0 || items[RandomItem].r_2 == 0 || items[RandomItem].properties & Property_Untradable || items[RandomItem].properties & Property_Mod || items[RandomItem].rarity == 999 || items[RandomItem].rarity >= 150) goto GenerateAgain;
		else {
			pInfo(p_)->C_DeliverID = RandomItem;
			pInfo(p_)->C_ProgressNeeded = rand() % 300 + 1;
		}
	}
	if (RandomQuest == 2) {
		int RandomProg = rand() % 20000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 2;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 3) {
		int RandomProg = rand() % 20000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 3;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 4) {
		int RandomProg = rand() % 2500;
		if (RandomProg <= 500) RandomProg += 500;
		pInfo(p_)->C_QuestKind = 4;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 5) {
		int RandomProg = rand() % 20000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 5;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 6) {
		int RandomProg = rand() % 10000;
		if (RandomProg <= 1000) RandomProg += 1000;
		pInfo(p_)->C_QuestKind = 6;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 7) {
		int RandomProg = rand() % 100000;
		if (RandomProg <= 20000) RandomProg += 20000;
		pInfo(p_)->C_QuestKind = 7;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 8) {
		int RandomProg = rand() % 200 + 1;
		pInfo(p_)->C_DeliverID = 242;
		pInfo(p_)->C_QuestKind = 8;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 9) {
		int RandomProg = rand() % 25 + 1;
		if (RandomProg <= 3) RandomProg += 5;
		pInfo(p_)->C_QuestKind = 9;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 10) {
		int RandomProg = rand() % 1000 + 1;
		pInfo(p_)->C_QuestKind = 10;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 11) {
		int RandomProg = rand() % 5 + 1;
		pInfo(p_)->C_QuestKind = 11;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 12) {
		int RandomProg = rand() % 15 + 1;
		if (RandomProg <= 3) RandomProg += 5;
		pInfo(p_)->C_QuestKind = 12;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 13) {
		int RandomProg = rand() % 25 + 1;
		if (RandomProg <= 3) RandomProg += 5;
		pInfo(p_)->C_QuestKind = 13;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 14) {
		int RandomProg = rand() % 3000 + 1;
		if (RandomProg <= 200) RandomProg += 400;
		pInfo(p_)->C_QuestKind = 14;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
	if (RandomQuest == 15) {
		int RandomProg = rand() % 10 + 1;
		pInfo(p_)->C_QuestKind = 15;
		pInfo(p_)->C_ProgressNeeded = RandomProg;
	}
}

void SendCarnivalQuest(ENetPeer* p_, int delay) {
	if (!pInfo(p_)->C_QuestActive) return;
	if (pInfo(p_)->CQ) pInfo(p_)->CQ = false;
	try {
		string step = to_string(pInfo(p_)->C_QuestStep);
		string quest_info = "", current_progress = "", deliver = "", extra = "";
		int QuestKind = pInfo(p_)->C_QuestKind, ProgressNeeded = pInfo(p_)->C_ProgressNeeded, item = pInfo(p_)->C_DeliverID;
		// QuestKind 1 = Deliver
		// QuestKind 2 = Harvest
		// QuestKind 3 = Plant Rarity
		// QuestKind 4 = Break Block
		// QuestKind 5 = Break Rarity Block
		// QuestKind 6 = Earn XP
		// QuestKind 7 = Deliver Gems
		// QuestKind 8 = Deliver World Lock
		// QuestKind 9 = Perform Surgery
		// QuestKind 10 = Harvest Provider
		// QuestKind 11 = Earn Growtoken
		// QuestKind 12 = Shatter Crystal
		// QuestKind 13 = Geiger Counter
		// QuestKind 14 = Fishing lb fish
		// QuestKind 15 = DNA Splicing
		if (QuestKind == 0) {
			RandomizeCQuest(p_);
			return;
		}
		switch (QuestKind) {
		case 1: {
			quest_info = "Your task is to bring me " + fixint(ProgressNeeded) + " of them " + items[item].ori_name + " things!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You have none to deliver!";
			int adaBrp = 0;
			modify_inventory(p_, item, adaBrp);
			if (adaBrp != 0) {
				if (pInfo(p_)->C_QuestProgress + adaBrp > ProgressNeeded) adaBrp = ProgressNeeded - pInfo(p_)->C_QuestProgress;
				deliver = "Deliver " + fixint(adaBrp) + " " + items[item].ori_name + "";
			}
			break;
		}
		case 2: {
			quest_info = "You must pluck " + fixint(ProgressNeeded) + " rarity worth of delicious fruit from any tree! I don't want the fruit, I'm just mad that it's up there!";
			extra = "\nadd_smalltext|`o(For example, if you smash a rarity-50 tree and get 3 fruit from it, you get 150 points)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will go pick fruit!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "The fruit is no more!";
			}
			break;
		}
		case 3: {
			quest_info = "You must plant " + fixint(ProgressNeeded) + " rarity worth of trees!";
			extra = "\nadd_smalltext|`o(For example, if you plant a tree of rarity 50, you get 50 points. A Dirt Tree is 1 point because it is rarity 1)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will go plant more!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I have planted them all!";
			}
			break;
		}
		case 4: {
			quest_info = "You must crush " + fixint(ProgressNeeded) + " blocks for me! I don't care what kind!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "Keep on smashing!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I bashed 'em good!";
			}
			break;
		}
		case 5: {
			quest_info = "You must pummel " + fixint(ProgressNeeded) + " rarity worth of blocks! Destroy!";
			extra = "\nadd_smalltext|(For example, if you smash a block of rarity 50, you get 50 points. A Dirt block is 1 point because it is rarity 1)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will go smash more!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "No block can beat me!";
			}
			break;
		}
		case 6: {
			quest_info = "Here's a freeform quest for you - I don't care what you do, just earn " + fixint(ProgressNeeded) + " XP doing it!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I have learned!";
			}
			break;
		}
		case 7: {
			quest_info = "It's traditional to grease the palm of an old carnie such as myself if you want to loosen up one of these rings in the hopes of it falling into your pocket... What I mean by that is, give me " + fixint(ProgressNeeded) + " Gems. Now.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You have none to deliver!";
			int adaBrp = pInfo(p_)->gems;
			if (adaBrp != 0) {
				if (pInfo(p_)->C_QuestProgress + adaBrp > ProgressNeeded) adaBrp = ProgressNeeded - pInfo(p_)->C_QuestProgress;
				deliver = "Deliver " + fixint(adaBrp) + " Gems";
			}
			break;
		}
		case 8: {
			quest_info = "Your task is to bring me " + fixint(ProgressNeeded) + " of them World Lock things!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You have none to deliver!";
			int adaBrp = 0;
			modify_inventory(p_, 242, adaBrp);
			if (adaBrp != 0) {
				if (pInfo(p_)->C_QuestProgress + adaBrp > ProgressNeeded) adaBrp = ProgressNeeded - pInfo(p_)->C_QuestProgress;
				deliver = "Deliver " + fixint(ProgressNeeded) + " " + items[242].ori_name + "";
			}
			break;
		}
		case 9: {
			quest_info = "Do some good for the world. Save " + fixint(ProgressNeeded) + " ailing Growtopians by performing surgery!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "You haven't helped enough!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "Saving lives is what I do";
			}
			break;
		}
		case 10: {
			quest_info = "I need you to go pick up some groceries for me. Collect " + fixint(ProgressNeeded) + " items from Providers.";
			extra = "\nadd_smalltext|(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I'm a cow-puncher!";
			}
			break;
		}
		case 11: {
			quest_info = "Prove your skill! Earn " + fixint(ProgressNeeded) + " Growtokens! You can keep the Growtokens, I'm more popular than you can imagine!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I will quest onward!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I am talented!";
			}
			break;
		}
		case 12: {
			quest_info = "I want you to achieve inner peace. Shatter " + fixint(ProgressNeeded) + " crystals that are in harmonic resonance.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "Does your hand hurt?";
			}
			break;
		}
		case 13: {
			quest_info = "Let's see how good you are at finding stuff. Go collect " + fixint(ProgressNeeded) + " radioactive items with a Geiger Counter. You can keep them!";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "I'm on my way!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "These feel warm!";
			}
			break;
		}
		case 14: {
			quest_info = "I hate fish. Could you go catch " + fixint(ProgressNeeded) + "lbs of fish? You can keep them, I just wanna know they suffered.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "Get them no-good fish!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I caught em!";
			}
			break;
		}
		case 15: {
			quest_info = "Splice DNA into " + fixint(ProgressNeeded) + " prehistoric thing for me! You can keep them, I just want to see them brought back to life.";
			current_progress = "(Current progress " + fixint(pInfo(p_)->C_QuestProgress) + "/" + fixint(ProgressNeeded) + ")";
			deliver = "Go make life from rocks!";
			if (pInfo(p_)->C_QuestProgress >= ProgressNeeded) {
				current_progress = "(Current progress " + fixint(ProgressNeeded) + "/" + fixint(ProgressNeeded) + ")";
				deliver = "I made em!";
			}
			break;
		}
		}
		gamepacket_t p(delay);
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Ring``|left|1900|\nadd_smalltext|`o(Step " + step + "/10)``|\nadd_spacer|small|\nadd_textbox|`o" + quest_info + "``|" + extra + "\nadd_spacer|small|\nadd_smalltext|`o" + current_progress + "``|\nadd_button|deliver|`o" + deliver + "|noflags|0|0|\nadd_button|give_up|`oGive up this quest|noflags|0|0|\nadd_spacer|small|\nadd_textbox|If you had 5 rings of the same type maybe we could have made a deal...|\nadd_spacer|small|\nend_dialog|carnival|Goodbye!||");
		p.CreatePacket(p_);
	}
	catch (out_of_range& e) {
		return;
	}
}


int get_wls(ENetPeer* peer, bool bgl = false, bool erase = false, int amount = 0) {
	int my_wls = 0, c_ = 0, remove_ = 0;
	modify_inventory(peer, 242, c_);
	my_wls += c_;
	if (erase) {
		remove_ = -1 * c_;
		modify_inventory(peer, 242, remove_);
	}
	c_ = 0;
	modify_inventory(peer, 1796, c_);
	my_wls += c_ * 100;
	if (erase) {
		remove_ = -1 * c_;
		modify_inventory(peer, 1796, remove_);
	}
	if (bgl) {
		c_ = 0;
		modify_inventory(peer, 7188, c_);
		my_wls += c_ * 10000;
		if (erase) {
			remove_ = -1 * c_;
			modify_inventory(peer, 7188, remove_);
		}
	}
	if (erase && amount) {
		int total_wl = my_wls - amount, c_ = 0;
		bool returned = false;
		if (total_wl >= 10000) {
			if (total_wl > 2000000) c_ = 200;
			else c_ = total_wl / 10000;
			total_wl -= c_ * 10000;
			if (modify_inventory(peer, 7188, c_) == 0) {
			}
			else pInfo(peer)->bp.push_back(make_pair(7188, c_)), returned = true;
			c_ = 0;
		}
		if (total_wl >= 100) {
			if (total_wl > 20000) c_ = 200;
			else c_ = total_wl / 100;
			total_wl -= c_ * 100;
			if (modify_inventory(peer, 1796, c_) == 0) {
			}
			else pInfo(peer)->bp.push_back(make_pair(1796, c_)), returned = true;
			c_ = 0;
		}
		if (total_wl >= 1) {
			if (total_wl > 200) c_ = 200;
			else c_ = total_wl;
			total_wl -= c_;
			if (modify_inventory(peer, 242, c_) == 0) {
			}
			else pInfo(peer)->bp.push_back(make_pair(242, c_)), returned = true;
			c_ = 0;
		}
		if (returned) {
			gamepacket_t p, p2(1500);
			p.Insert("OnTextOverlay"), p.Insert("Some of the World Locks could not fit in your inventory!"), p.CreatePacket(peer);
			p2.Insert("OnTextOverlay"), p2.Insert("We have placed them in your Personal Backpack."), p2.CreatePacket(peer);
		}
	}
	return my_wls;
}

void get_wl_value(ENetPeer* peer, string& hold) {
	uint16_t wl = 0, dl = 0, bgl = 0;
	for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
		if (pInfo(peer)->inv[i_].first == 242) wl = pInfo(peer)->inv[i_].second;
		if (pInfo(peer)->inv[i_].first == 1796) dl = pInfo(peer)->inv[i_].second;
		if (pInfo(peer)->inv[i_].first == 7188) bgl = pInfo(peer)->inv[i_].second;
		if (wl && dl && bgl) break;
	}
	hold = "\nadd_smalltext|`9(Hmm, smells like you don't carry any world locks)``|left|";
	if (wl != 0 || dl != 0) hold = "\nadd_smalltext|`9(Hmm, smells like you care carrying";
	if (wl) hold += " " + to_string(wl) + " World Locks" + (dl != 0 ? " and" : ")``|left|") + "";
	if (dl) hold += " " + to_string(dl) + " Diamond Locks)``|left|";
	if (bgl && wl == 0 && dl == 0) hold = "\nadd_smalltext|`9(Hmm, smells like you care carrying " + to_string(bgl) + " Blue Gem Locks)``|left|";
	else if (bgl) hold += "\nadd_smalltext|`9(You are also holding additional " + to_string(bgl) + " Blue Gem Locks)``|left|";
}


void convert_wls(ENetPeer* peer, bool withdraw = false) {
	packet_(peer, "action|play_sfx\nfile|audio/deposit.wav\ndelayMS|0");
	//2020200
	int have_ = 0;
	for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
		if (pInfo(peer)->inv[i_].first == 242 || pInfo(peer)->inv[i_].first == 1796 || pInfo(peer)->inv[i_].first == 7188) {
			if (pInfo(peer)->inv[i_].first == 242) have_ += pInfo(peer)->inv[i_].second;
			if (pInfo(peer)->inv[i_].first == 1796) have_ += pInfo(peer)->inv[i_].second * 100;
			if (pInfo(peer)->inv[i_].first == 7188) have_ += pInfo(peer)->inv[i_].second * 10000;
			int remove = pInfo(peer)->inv[i_].second * -1;
			modify_inventory(peer, pInfo(peer)->inv[i_].first, remove);
		}
	}
	if (withdraw) {
		int give_back = 0, c_ = 0;
		give_back = pInfo(peer)->total_credit_card + have_;
		if (give_back >= 10000) {
			if (give_back > 2000000) c_ = 200;
			else c_ = give_back / 10000;
			if (modify_inventory(peer, 7188, c_) == 0) {
				give_back -= c_ * 10000;
			}
			c_ = 0;
		}
		if (give_back >= 100) {
			if (give_back > 20000) c_ = 200;
			else c_ = give_back / 100;
			if (modify_inventory(peer, 1796, c_) == 0) {
				give_back -= c_ * 100;
			}
			c_ = 0;
		}
		if (give_back >= 1) {
			if (give_back > 200) c_ = 200;
			else c_ = give_back;
			if (modify_inventory(peer, 242, c_) == 0) {
				give_back -= c_;
			}
			c_ = 0;
		}
		pInfo(peer)->total_credit_card = give_back;
	}
	else pInfo(peer)->total_credit_card += have_;
}

/*
void carnival_end(ENetPeer* peer, uint8_t game, bool prize = false) {
	long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
	long long last_carnival_time = 0;
	uint16_t remove_sec = 0;
	uint8_t points = pInfo(peer)->carnival_punch;
	vector<pair<int, string>>::iterator p23 = find_if(carnival_game_playing.begin(), carnival_game_playing.end(), [&](const pair < int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
	if (p23 != carnival_game_playing.end()) {
		if (game == 1 || game == 3)last_carnival_time = (game == 1 ? last_carnival_time_1 : last_carnival_time_3), remove_sec = 400;
		else if (game == 2) last_carnival_time = last_carnival_time_2, remove_sec = 600;
		else if (game == 4 || game == 5) {
			last_carnival_time = (game == 4 ?last_carnival_time_4 : last_carnival_time_5);
			remove_sec = 600;
			PlayerMoving data_{ pInfo(peer)->netID, 0, 0, 0, 0, 0, 0 };
			BYTE* raw = packPlayerMoving(&data_);
			*(__int8*)(raw + 0) = 28;
			*(__int8*)(raw + 44) = 7;
			*(__int8*)(raw + 48) = pInfo(peer)->carnival_punch = 0;
			send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			delete[]raw;
		}
	}
	{
		gamepacket_t p(250, pInfo(peer)->netID), p3(250), p4(250, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
		p3.Insert("OnZoomCamera"), p3.Insert((float)10000.000000), p3.Insert(1000), p3.CreatePacket(peer);
		p4.Insert("OnSetFreezeState"), p4.Insert(0), p4.CreatePacket(peer);
	}
	gamepacket_t p, p2(0, pInfo(peer)->netID), p3(0, pInfo(peer)->netID), p4(0, pInfo(peer)->netID);
	p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
	if (prize) {
		vector<uint16_t> list;
		if (game == 1) list = { 1936 , 1880 , 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884, 1884 };
		else if (game == 2)list = { 2216 , 2220 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 , 2238 };
		else if (game == 3) list = { 1940 , 1930 ,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878,1878 };
		else if (game == 4) list = { 1892 , 1894 ,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890,1890 };
		else if (game == 5) list = { 1934 , 1896 ,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886,1886 };
		uint16_t prize_item = list[rand() % list.size()];
		int got = 1;
		modify_inventory(peer, prize_item, got);
		if (game == 4 || game == 5) p.Insert("`8You scored "+to_string(points) + " points!`` You win a `2" + items[prize_item].ori_name + "``!");
		else p.Insert("`8You finished with " + to_string(abs((last_carnival_time - time) / 1000 )) + "." + to_string(abs((last_carnival_time - time) / 100 - remove_sec)) + " seconds left. You win a `2" + items[prize_item].ori_name + "``!");
	}
	else p.Insert("`8" + (game == 4 || game == 5 ? "You only scored " + to_string(points) + " points" : "You didn't make it in time") + "!`` No prize for you!");
	p.CreatePacket(peer);
	p2.Insert("OnSetPos"), p2.Insert(pInfo(peer)->x = (game == 1 ? 288 : (game == 2 ? 1186 : (game == 3 ? 2892 : (game == 4 ? 1120 : 2528)))), pInfo(peer)->y = (game == 1 ? 1248 : (game == 2 ? 514 : (game == 3 ? 1250 : (game == 4 ? 1632 : 1632))))), p2.CreatePacket(peer);
	p3.Insert("OnCountdownEnd"), p3.CreatePacket(peer);
	p4.Insert("OnPlayPositioned"), p4.Insert("audio/race_end.wav");
	pInfo(peer)->c_x = 0, pInfo(peer)->c_y = 0;
	pInfo(peer)->pulled = true;
}
*/



/*
void add_halloween_point(ENetPeer* peer, int id, bool permament = false) {
	gamepacket_t p;
	p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
	if (permament) {
		if (id == 1) p.Insert("Trick or Treat task: Complete Daily Quest wearing a "+items[halloween_quest].ori_name + " `2completed``."), pInfo(peer)->halloween_ptask_1++;
		else if (id == 2)  p.Insert("Trick or Treat task: Complete Tomb of Growganoth parkour wearing a " + items[halloween_quest].ori_name + " `2completed``."), pInfo(peer)->halloween_ptask_2++;
		else if (id == 3)  p.Insert("Trick or Treat task: Complete Halloween Dark King's Offering quest wearing a " + items[halloween_quest].ori_name + " `2completed``."), pInfo(peer)->halloween_ptask_3++;
		else if (id == 4)  p.Insert("Trick or Treat task: Sacrifice Dark King's Offering wearing a " + items[halloween_quest].ori_name + " `2completed``."), pInfo(peer)->halloween_ptask_4++;
		else if (id == 5)  p.Insert("Trick or Treat task: Get Boney Block from Growganoth wearing a " + items[halloween_quest].ori_name + " `2completed``."), pInfo(peer)->halloween_ptask_5++;
	}
	else {
		if (id == 1) p.Insert("Trick or Treat task: Sacrifice Dark King's Offering `2completed``."), pInfo(peer)->halloween_task_1++;
		else if (id == 2) p.Insert("Trick or Treat task: Purchase a Dark Ticket `2completed``."), pInfo(peer)->halloween_task_2++;
		else if (id == 3) p.Insert("Trick or Treat task: Purchase a Gift of Growganoth `2completed``."), pInfo(peer)->halloween_task_3++;
		else if (id == 4) p.Insert("Trick or Treat task: Purchase Weather Machine - Dark Mountains `2completed``."), pInfo(peer)->halloween_task_4++;
	}
	p.Insert(0), p.Insert(1), p.CreatePacket(peer);
}*/


/*
void add_gift(int add = 1) {
	winterfest_gift += add;
	if (winterfest_gift % 50 == 0) {
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`2Winter Growch:`` `3Growtopians have collectively feeded " + to_string(winterfest_gift) + "`` `2Winter Gift's`` `3and reached " + to_string(winterfest_gift) + "/500, for every 500`` `2Growch`` `3gives random prizes for everyone!``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
	}
	if (winterfest_gift >= 500) {
		winterfest_gift = 0;
		vector<int>noob_item = { 3566,12,56,16,380,1138,20,100,378,116,370,26,22,580,194,104,190,376,1306,696,880,166,184,1322,164,3578,3782,368,24,170,372,374,52,102,178,42,68,40,28,248,176,130,270,1324,236,142,336,694,10034,140,76,48,188,44,34,168,54,222,174,884,118,3572,198,548,36,680,654,122,238,106,66,38,90,208,162,30,272,670,888,144,886,192,126,1432,2938,172,7630,412,3570,3568,2808,354,138,9392,214,11202,224,342,1846,110,108,210,234,200,58,11202 };
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			int c_ = 1, i_ = noob_item[rand() % noob_item.size()];
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (modify_inventory(currentPeer, i_, c_) == -1) p.Insert("Failed to add inventory item");
			else p.Insert("`2Growch:`` `wYou received: " + items[i_].ori_name + "``.");
			p.CreatePacket(currentPeer);
		}
	}
}*/

void add_balloon(ENetPeer* peer, int faction, int point) {
	{
		pInfo(peer)->balloon_score += point;
		vector<pair<int, string>>::iterator p = find_if(Balloon_Warz.top_balloon.begin(), Balloon_Warz.top_balloon.end(), [&](const pair < int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
		if (p != Balloon_Warz.top_balloon.end()) Balloon_Warz.top_balloon[p - Balloon_Warz.top_balloon.begin()].first += point;
		else Balloon_Warz.top_balloon.push_back(make_pair(point, pInfo(peer)->tankIDName));
	}
	vector<pair<int, int>>::iterator p = find_if(Balloon_Warz.balloon_warz.begin(), Balloon_Warz.balloon_warz.end(), [&](const pair < int, int>& element) { return element.second == faction; });
	if (p != Balloon_Warz.balloon_warz.end()) Balloon_Warz.balloon_warz[p - Balloon_Warz.balloon_warz.begin()].first += point;
	else Balloon_Warz.balloon_warz.push_back(make_pair(point, faction));
}

void add_points(ENetPeer* peer, int id) {
	if (can_event) return;
	//block basher 	uint16_t point = (id == 6238 ? 50 : id == 6240 ? 1200 : id == 6926 ? 170 : 10);
	//harvesting heroes 	uint16_t point = (id == 6244 ? 80 : id == 6246 ? 1200 : id == 6928 ? 220 : 20);
	//fishing fanatics int point = (id == 6256 ? 15700 : id == 6932 ? 42800 : id == 6258 ? 340000 : 3400);
	//surgery stars 	int point = (id == 9592 ? 1000000 : id == 6252 ? 150000 : id == 6930 ? 20000 : id == 6250 ? 6200 : 1500);
	//speedy splicers 	int point = (id == 6836 ? 2100 : id == 6936 ? 220 : id == 6834 ? 80 : 20);
	// block builders 	uint16_t point = (id == 6828 ? 80 : id == 6830 ? 2100 : id == 6934 ? 220 : 20);
	int point = (id == 6836 ? 2100 : id == 6936 ? 220 : id == 6834 ? 80 : 20);
	if (event_item == 6238) point = (id == 6240 ? 1800 : id == 6926 ? 170 : id == 6238 ? 50 : id == 6236 ? 8 : 0);
	else if (event_item == 6828) point = (id == 6830 ? 2100 : id == 6934 ? 220 : id == 6828 ? 80 : id == 6826 ? 20 : 0);
	else if (event_item == 6256) point = (id == 6258 ? 350000 : id == 6932 ? 42800 : id == 6256 ? 15700 : id == 6254 ? 3400 : 0);
	else if (event_item == 6244) point = (id == 6244 ? 80 : id == 6246 ? 1200 : id == 6928 ? 220 : id == 6242 ? 20 : 0);
	else if (event_item == 6834)point = (id == 6836 ? 2100 : id == 6936 ? 220 : id == 6834 ? 80 : id == 6832 ? 20 : 0);
	else if (event_item == 6250)point = (id == 6252 ? 150000 : id == 6930 ? 20000 : id == 6250 ? 6200 : id == 6248 ? 1500 : 0);
	if (point == 0) return;
	//block basher 	if (id == 6238 || id == 6240 || id == 6926) {
	//harvest heroes 	if (id == 6244 || id == 6246 || id == 6928) {
	//	fishing fanatics		if (id == 6256 || id == 6932 || id == 6258) {
	// surgery stars if (id == 9592 || id == 6252 || id == 6930 || id == 6250) {
	// speedy splicers 	if (id == 6936 || id == 6834 || id == 6836) {
	// block builders 	if (id == 6828 || id == 6830 || id == 6934) {
	if (point != 10 && point != 20 && point != 3400 && point != 1500) {
		int most_give = 0, most_second = 0, most_last = 0;
		if (event_item == 6238) most_give = 6240, most_second = 6238, most_last = 6236;
		else if (event_item == 6828)  most_give = 6830, most_second = 6828, most_last = 6826;
		else if (event_item == 6256) most_give = 6258, most_second = 6256, most_last = 6254;
		else if (event_item == 6244)  most_give = 6246, most_second = 6244, most_last = 6242;
		else if (event_item == 6834)  most_give = 6836, most_second = 6834, most_last = 6832;
		else if (event_item == 6250) most_give = 6252, most_second = 6250, most_last = 6248;
		int got = 0;
		uint8_t chance = (id == most_give ? 3 : 4);
		if (rand() % 50 < chance) {
			console_msg(peer, "Your " + items[id].name + " has fractured!");
			modify_inventory(peer, id, got = -1);
			modify_inventory(peer, (id == most_give ? most_second : most_last), got = 1);
		}
	}
	vector<pair<long long int, string>>::iterator p = find_if(top_basher.begin(), top_basher.end(), [&](const pair < long long int, string>& element) { return element.second == pInfo(peer)->tankIDName; });
	if (p != top_basher.end()) {
		if (top_basher[p - top_basher.begin()].first < 0) top_basher[p - top_basher.begin()].first = 0;
		top_basher[p - top_basher.begin()].first += point;
	}
	else top_basher.push_back(make_pair(point, pInfo(peer)->tankIDName));
	if (pInfo(peer)->guild_id != 0) {
		pInfo(peer)->participated = event_item;
		vector<pair<long long int, string>>::iterator pz = find_if(top_guild.begin(), top_guild.end(), [&](const pair < long long int, string>& element) { return element.second == to_string(pInfo(peer)->guild_id); });
		if (pz != top_guild.end()) {
			if (top_guild[pz - top_guild.begin()].first < 0) top_guild[pz - top_guild.begin()].first = 0;
			top_guild[pz - top_guild.begin()].first += point;
		}
		else top_guild.push_back(make_pair(point, to_string(pInfo(peer)->guild_id)));
	}
}

void add_wls(ENetPeer* peer, int points) {
	pInfo(peer)->wls_participated = true;
	total_wls_recycled += points;
	vector<pair<long long int, string>>::iterator pz = find_if(top_wls.begin(), top_wls.end(), [&](const pair < long long int, string>& element) { return  to_lower(element.second) == to_lower(pInfo(peer)->tankIDName); });
	if (pz != top_wls.end()) top_wls[pz - top_wls.begin()].first += points;
	else top_wls.push_back(make_pair(points, pInfo(peer)->tankIDName));
}

void dropas_(World* world_, WorldDrop drop_, int net_id = -1, bool Flag = false) {
	world_->fresh_world = true;
	//if (drop_.y < 0 || drop_.x < 0 || drop_.id == 0) return;
	if (drop_.id == 745 || drop_.id == 747 || drop_.id == 749) drop_.id = 743;
	if (drop_.id == 629 || drop_.id == 631 || drop_.id == 633 || drop_.id == 635 || drop_.id == 637 || drop_.id == 639 || drop_.id == 641 || drop_.id == 643 || drop_.id == 645 || drop_.id == 647 || drop_.id == 649) drop_.id = 627;
	if (drop_.id == 112) {
		// gemu merging   
		int c_ = 0;
		for (int i_ = 0; i_ < world_->drop_new.size(); i_++) if (abs(world_->drop_new[i_][4] - drop_.y) <= 17 and abs(world_->drop_new[i_][3] - drop_.x) <= 17 and world_->drop_new[i_][0] == 112) c_ += world_->drop_new[i_][1];
		if (c_ != 0) {
			int b_thousand_ = c_ >= 1000 ? c_ / 1000 : 0, b_purple_ = c_ - (b_thousand_ * 1000) >= 100 ? (c_ - (b_thousand_ * 1000)) / 100 : 0, b_green_ = c_ - ((b_thousand_ * 1000) + (b_purple_ * 100)) >= 50 ? (c_ - ((b_thousand_ * 1000) + (b_purple_ * 100))) / 50 : 0, b_red_ = c_ - ((b_thousand_ * 1000) + (b_purple_ * 100)) - (b_green_ * 50) >= 10 ? (c_ - ((b_thousand_ * 1000) + (b_purple_ * 100)) - (b_green_ * 50)) / 10 : 0, b_blue_ = c_ - (b_green_ * 50) - ((b_thousand_ * 1000) + (b_purple_ * 100)) - (b_red_ * 10) >= 5 ? (c_ - (b_green_ * 50) - ((b_thousand_ * 1000) + (b_purple_ * 100)) - (b_red_ * 10)) / 5 : 0, b_yellow_ = c_ - (b_red_ * 10) - (b_green_ * 50) - ((b_thousand_ * 1000) + (b_purple_ * 100)) - (b_blue_ * 5) > 0 ? (c_ - (b_red_ * 10) - (b_green_ * 50) - ((b_thousand_ * 1000) + (b_purple_ * 100)) - (b_blue_ * 5)) / 1 : 0;
			c_ += drop_.count;
			int thousand_ = c_ >= 1000 ? c_ / 1000 : 0, purple_ = c_ - (thousand_ * 1000) >= 100 ? (c_ - (thousand_ * 1000)) / 100 : 0, green_ = c_ - ((thousand_ * 1000) + (purple_ * 100)) >= 50 ? (c_ - ((thousand_ * 1000) + (purple_ * 100))) / 50 : 0, red_ = c_ - ((thousand_ * 1000) + (purple_ * 100)) - (green_ * 50) >= 10 ? (c_ - ((thousand_ * 1000) + (purple_ * 100)) - (green_ * 50)) / 10 : 0, blue_ = c_ - (green_ * 50) - ((thousand_ * 1000) + (purple_ * 100)) - (red_ * 10) >= 5 ? (c_ - (green_ * 50) - ((thousand_ * 1000) + (purple_ * 100)) - (red_ * 10)) / 5 : 0, yellow_ = c_ - (red_ * 10) - (green_ * 50) - ((thousand_ * 1000) + (purple_ * 100)) - (blue_ * 5) > 0 ? (c_ - (red_ * 10) - (green_ * 50) - ((thousand_ * 1000) + (purple_ * 100)) - (blue_ * 5)) / 1 : 0;
			vector<uint8_t> update_gem;
			if (blue_ > b_blue_ or blue_ == 0 and b_blue_ != 0) {
				drop_.count = 5;
				update_gem.push_back(1);
			}
			if (red_ > b_red_ or red_ == 0 and b_red_ != 0) {
				drop_.count = 10;
				update_gem.push_back(5);
			}
			if (green_ > b_green_ or green_ == 0 and b_green_ != 0) {
				drop_.count = 50;
				update_gem.push_back(10);
			}
			if (purple_ > b_purple_) {
				drop_.count = 100;
				update_gem.push_back(50);
			}
			if (thousand_ > b_thousand_) {
				drop_.id = 4490;
				drop_.count = 1;
				update_gem.push_back(100);
			}
			vector<BYTE*>blocks;
			for (int i = 0; i < update_gem.size(); i++) {
				for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
					if ((abs(world_->drop_new[i_][4] - drop_.y) <= 17 and abs(world_->drop_new[i_][3] - drop_.x) <= 17) and world_->drop_new[i_][0] == 112) {
						if (world_->drop_new[i_][1] == update_gem[i]) {
							PlayerMoving data_{};
							data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop_new[i_][2];
							blocks.push_back(packPlayerMoving(&data_));
							world_->drop_new.erase(world_->drop_new.begin() + i_);
						}
					}
				}
			}
			if (update_gem.size() != 0) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
					for (auto& b : blocks) send_raw(currentPeer, 4, b, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				for (auto& b : blocks) free(b);
				blocks.clear();
			}
		}
	}
	if (drop_.id != 112 && items[drop_.id].blockType != BlockTypes::FISH) {
		for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
			if (world_->drop_new[i_][0] == 0) continue;
			if (abs(world_->drop_new[i_][4] - drop_.y) <= 16 and abs(world_->drop_new[i_][3] - drop_.x) <= 16 and world_->drop_new[i_][0] == drop_.id and world_->drop_new[i_][1] < 200) {
				int truksta_iki_200 = 200 - world_->drop_new[i_][1];
				if (drop_.count > truksta_iki_200 or world_->drop_new[i_][1] + drop_.count <= 200) {
					int drop_atskirai = drop_.count - truksta_iki_200;
					if (world_->drop_new[i_][1] + drop_.count <= 200) {
						world_->drop_new[i_][1] += drop_.count;
						drop_.count = 0;
						goto update;
					}
					drop_.count = drop_atskirai;
					world_->drop_new[i_][1] = 200;
				update:
					PlayerMoving data_{};
					data_.packetType = 14, data_.netID = -3, data_.plantingTree = world_->drop_new[i_][0];
					data_.x = world_->drop_new[i_][3], data_.y = world_->drop_new[i_][4];
					int32_t item = world_->drop_new[i_][2];
					float val = world_->drop_new[i_][1];
					BYTE* raw = packPlayerMoving(&data_);
					memcpy(raw + 8, &item, 4);
					memcpy(raw + 16, &val, 4);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[]raw;
					break;
				}
			}
		}
	}
	if (drop_.count != 0) {
		world_->drop_new.push_back({ {drop_.id}, {drop_.count}, {world_->total_drop_uid += 1}, {drop_.x}, {drop_.y} });
		PlayerMoving data_{};
		data_.packetType = 14, data_.x = drop_.x, data_.y = drop_.y, data_.netID = -1, data_.plantingTree = drop_.id;
		BYTE* raw = packPlayerMoving(&data_);
		*(int*)(raw + 8) = net_id;
		*(float*)(raw + 16) = (float)(Flag ? drop_.flag : drop_.count);
		*(__int8*)(raw + 1) = 0;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name) {
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[]raw;
	}
}



void wipe_darkticket(ENetPeer* peer, bool prize = false) {
	string name_ = pInfo(peer)->world;
	if (has_playmod2(pInfo(peer), 127), 30) {
		if (name_ == "TOMBOFGROWGANOTH1" || name_ == "TOMBOFGROWGANOTH2" || name_ == "TOMBOFGROWGANOTH3") {
			if (prize) {
				if (pInfo(peer)->halloween_prize_receive == false) {
					pInfo(peer)->halloween_prize_receive = true;
					vector<int> list{ 10328 , 12794  , 12770 , 12402 };
					int item_ = list[rand() % list.size()], give_count = 1, given_ = 0;
					if (item_ == 12794) give_count = 5;
					given_ = give_count;
					if (modify_inventory(peer, item_, given_) == 0) {
					}
					else {
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							WorldDrop drop_block_{};
							drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = item_, drop_block_.count = give_count, drop_block_.uid = uint16_t(world_->drop_new.size()) + 1;
							dropas_(world_, drop_block_);
						}
					}
					/*
					if (pInfo(peer)->halloween_ptask_2 == 0) {
						if (pInfo(peer)->hand == halloween_quest || pInfo(peer)->necklace == halloween_quest || pInfo(peer)->back == halloween_quest || pInfo(peer)->face == halloween_quest || pInfo(peer)->mask == halloween_quest || pInfo(peer)->hair == halloween_quest || pInfo(peer)->feet == halloween_quest || pInfo(peer)->shirt == halloween_quest || pInfo(peer)->pants == halloween_quest) {
							add_halloween_point(peer, 2, true);
						}
					}*/
					gamepacket_t p_t, p_t2;
					p_t.Insert("OnParticleEffectV2"), p_t.Insert(13), p_t.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
					p_t2.Insert("OnParticleEffectV2"), p_t2.Insert(22), p_t2.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
						p_t.CreatePacket(currentPeer);
						p_t2.CreatePacket(currentPeer);
					}
					gamepacket_t p, p2, p3;
					p.Insert("OnEndMission"), p.CreatePacket(peer);
					p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Thanks for completing the `2Growganoth Parkour``! As a reward I'm giving you `2" + items[item_].ori_name + "``!"), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
					p3.Insert("OnConsoleMessage");
					p3.Insert("You will be kicked out of the world in `$30 seconds``.");
					p3.CreatePacket(peer);
				}
			}
		}
	}
}

void wipe_whistle(ENetPeer* peer) {
	string name_ = pInfo(peer)->world;
	if (has_playmod2(pInfo(peer), 128, 10)) {
		if (name_ == "WW1" || name_ == "WW2" || name_ == "WW3" || name_ == "WW4" || name_ == "WW5" || name_ == "WW6" || name_ == "WW7") {
			if (not pInfo(peer)->wolf_world.empty()) {
				pInfo(peer)->wolf_world.clear();
				int give_times = 1;
				if (pInfo(peer)->gp) {
					if (complete_gpass_task(peer, "Wolf")) give_times++;
				}
				int item_ = 4354;
				for (int i = 0; i < give_times; i++) {
					int give_count = 1;
					vector<int> list{ 13076, 11650, 13042, 12782 ,4354,122,124,1188,4346,8544,2996,4342,3136,10082,12486,4352,8262,8264,8266,8268,2998,3538,2986,2984,2992,4348,4350,6842,3774,4344,3176,7146,11338 };
					item_ = list[rand() % list.size()];

					if (modify_inventory(peer, item_, give_count) == 0) {
					}
					else {
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							WorldDrop drop_block_{};
							drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = item_, drop_block_.count = 1;
							dropas_(world_, drop_block_);
						}
					}
				}

				{
					int w_ticket = 1;
					if (modify_inventory(peer, 4354, w_ticket) == 0) {
					}
					else {
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							WorldDrop drop_block_{};
							drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = 4354, drop_block_.count = 1;
							dropas_(world_, drop_block_);
						}
					}
				}
				gamepacket_t p_t, p_t2;
				p_t.Insert("OnParticleEffectV2"), p_t.Insert(13), p_t.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
				p_t2.Insert("OnParticleEffectV2"), p_t2.Insert(22), p_t2.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
					p_t.CreatePacket(currentPeer);
					p_t2.CreatePacket(currentPeer);
				}
				gamepacket_t p, p2, p3;
				p.Insert("OnEndMission"), p.CreatePacket(peer);
				p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Thanks for completing the `2Wolf Parkour``! As a reward I'm giving you `2" + items[item_].ori_name + "``!"), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
				p3.Insert("OnConsoleMessage");
				p3.Insert("Thanks for completing the `2Wolf Parkour``! As a reward I'm giving you `2" + items[item_].ori_name + "``!");
				p3.CreatePacket(peer);
			}
		}
	}
}

void add_peer_xp(ENetPeer* peer, int amount, bool bonus = false) {
	if (pInfo(peer)->gp) amount++;
	if (has_playmod2(pInfo(peer), 53) || has_playmod2(pInfo(peer), 134) || has_playmod2(pInfo(peer), 97) || has_playmod2(pInfo(peer), 106) || has_playmod(pInfo(peer), "Extra XP")) {
		if ((rand() % 25) + 1 == pInfo(peer)->ances != 0 ? items[pInfo(peer)->ances].chance : 7) {
			bonus = true;
			amount *= 2;
		}
	}
	if (pInfo(peer)->hand == 10362 || pInfo(peer)->hand == 10384) amount *= 5, bonus = true;
	else if (pInfo(peer)->hand == 9906 or pInfo(peer)->hand == 9918 or pInfo(peer)->hand == 9914 or pInfo(peer)->hand == 10290 or pInfo(peer)->hand == 9908 or pInfo(peer)->necklace == 10176 && bonus == false) amount *= 2, bonus = true;
	if (bonus) {
		gamepacket_t p;
		p.Insert("OnParticleEffect"), p.Insert(49), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer);
		}
	}
	if (pInfo(peer)->guild_id != 0) {
		uint32_t guild_id = pInfo(peer)->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
			guild_information->guild_settings |= Gtps3::SETTINGS_0;
			if (guild_information->guild_level < guild_lvl.size()) {
				uint32_t max_xp = guild_lvl[guild_information->guild_level - 1][0];
				if (guild_information->guild_xp < max_xp) {
					guild_information->guild_xp += amount;
					if (guild_information->guild_xp > max_xp) guild_information->guild_xp = max_xp;
				}
			}
		}
	}
	int required = 50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2);
	if (pInfo(peer)->lwiz_step == 8) add_lwiz_points(peer, amount);
	if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 6 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
		pInfo(peer)->C_QuestProgress += amount;
		if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
			pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
	if (pInfo(peer)->level <= 500) {
		pInfo(peer)->xp += amount;
		int add_more = 0, timer = 0;
		for (add_more = 0; add_more < 1; add_more++) {
			if (pInfo(peer)->xp >= 50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2)) {
				pInfo(peer)->level++;
				pInfo(peer)->xp -= required;
				if (pInfo(peer)->level == 5) form_emoji(peer, true);
				{
					if (pInfo(peer)->level >= 50) {
						if (pInfo(peer)->mini_you == false) {
							int give = 0;
							modify_inventory(peer, 2278, give);
							if (give != 0)pInfo(peer)->mini_you = true;
							if (pInfo(peer)->mini_you == false) {
								if (modify_inventory(peer, 2278, give) == -1) {}
								else {
									pInfo(peer)->mini_you = true;
									gamepacket_t p, p2;
									p.Insert("OnAddNotification"), p.Insert("interface/large/friend_button.rttex"), p.Insert("You've unlocked `$Mini-You``!"), p.Insert("audio/hub_open.wav"), p.Insert(0), p.CreatePacket(peer);
									p2.Insert("OnConsoleMessage"), p2.Insert("You've unlocked `$Mini-You``!"), p2.CreatePacket(peer);
								}
							}
						}
					}
				}
				gamepacket_t p(timer), p2(timer), p3;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(get_player_nick(peer) + " is now level " + to_string(pInfo(peer)->level) + "!"), p.Insert(0), p.Insert(0);
				p2.Insert("OnConsoleMessage"), p2.Insert(get_player_nick(peer) + " is now level " + to_string(pInfo(peer)->level) + "!");
				p3.Insert("OnParticleEffect"), p3.Insert(46), p3.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16), p3.Insert(timer);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					p.CreatePacket(currentPeer);
					p2.CreatePacket(currentPeer);
					p3.CreatePacket(currentPeer);
				}
			}
			if (pInfo(peer)->xp >= 50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2)) add_more -= 1, timer += 500;
		}
	}
}


void stop_fishing(ENetPeer* peer, bool fail, string error) {
	if (pInfo(peer)->fishing_used != 0) {
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
		p2.Insert("OnConsoleMessage");
		if (error .empty()) {
			if (pInfo(peer)->last_fish_catch + pInfo(peer)->fish_seconds < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) p.Insert("There was nothing on the line!"), p2.Insert("There was nothing on the line!");
			else {
				int give_times = 1;
				if (pInfo(peer)->gp) {
					if (complete_gpass_task(peer, "Fish")) give_times++;
				}
				int giveitem = 0, c_ = 0;
				bool fish = false, fullinv = false;
				for (int i = 0; i < give_times; i++) {
					fish = false;
					giveitem = items[pInfo(peer)->fishing_used].randomitem[rand() % items[pInfo(peer)->fishing_used].randomitem.size()], c_ = 1;
					vector<int> list;
					//list.push_back(13158);
					if (pInfo(peer)->hand == 10262) {
						for (int i__ = 0; i__ < items[pInfo(peer)->fishing_used].randomitem.size(); i__++) if (items[items[pInfo(peer)->fishing_used].randomitem[i__]].blockType == BlockTypes::FISH) list.push_back(items[pInfo(peer)->fishing_used].randomitem[i__]);
						giveitem = list[rand() % list.size()];
					}
					if (items[giveitem].blockType == BlockTypes::FISH) {
						fish = true, c_ = rand() % items[giveitem].fish_max_lb + 1;
						if (event_item == 6256)add_points(peer, pInfo(peer)->hand);
					}
					if (pInfo(peer)->hand == 3040 or thedaytoday == 0 and fish) {
						c_ *= 1.25;
						if (c_ > items[giveitem].fish_max_lb) c_ = items[giveitem].fish_max_lb;
					}
					if (giveitem == 1486) if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, 1);

					//	list.push_back(13158);
					if (rand() % 50 < 1) list.push_back(1486);
					if (rand() % 100 < 1) list.push_back(12566);
					if (rand() % 200 < 1) list.push_back(12568);
					if (fish) for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].first == giveitem) fullinv = true;
					int give = 1;
					/*
					if (giveitem == 13158) {
						give = 5;
						ubi_sold_3 += 5;
					}*/
					if (fullinv == false && fish == false && modify_inventory(peer, giveitem, give) == 0) {
					}
					else fullinv = true;
					if (fullinv || fish) {
						if (has_playmod2(pInfo(peer), 145)) OnSetGems(peer, 125);
						string name_ = pInfo(peer)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							WorldDrop drop_block_{};
							drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = giveitem, drop_block_.count = c_;
							dropas_(world_, drop_block_);
						}
					}
				}
				PlayerMoving data_{};
				data_.x = pInfo(peer)->f_x * 32, data_.y = pInfo(peer)->f_y * 32, data_.packetType = 19, data_.plantingTree = 500, data_.punchX = giveitem, data_.punchY = pInfo(peer)->netID;
				int32_t to_netid = pInfo(peer)->netID;
				BYTE* raw = packPlayerMoving(&data_);
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
				if (fish && pInfo(peer)->grow4good_fish < 450 && pInfo(peer)->grow4good_fish != -1) daily_quest(peer, false, "fish", c_);
				add_peer_xp(peer, items[pInfo(peer)->fishing_used].rarity + (pInfo(peer)->necklace == 7746 ? 6 : 0), (pInfo(peer)->necklace == 7746 ? true : false));
				add_event_xp(peer, 1, "fishing");
				p.Insert("You caught a ```2" + (fish ? to_string(c_) + " lb. " : "") + "" + items[giveitem].name + "!``"), p2.Insert("You caught a ```2" + (fish ? to_string(c_) + " lb. " : "") + "" + items[giveitem].name + "!``");
				if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 14 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
					pInfo(peer)->C_QuestProgress += c_;
					if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
			}
		}
		else p.Insert(error), p2.Insert(error);
		pInfo(peer)->fishing_used = 0, pInfo(peer)->last_fish_catch = 0;
		PlayerMoving data_{};
		data_.packet_3 = 2, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
		BYTE* raw = packFishMoving(&data_);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw;
		p.Insert(0), p.Insert(0);
		p.CreatePacket(peer), p2.CreatePacket(peer);
	}
}


void equip_clothes(ENetPeer* p_, int item) {
	if (pInfo(p_)->hider && pInfo(p_)->world == Hide_N_Seek.hidenseekworld) return;
	int c_ = 0;
	modify_inventory(p_, item, c_);
	if (c_ == 0) return;
	if (pInfo(p_)->ances == item or pInfo(p_)->back == item
		or pInfo(p_)->feet == item or pInfo(p_)->face == item
		or pInfo(p_)->hair == item or pInfo(p_)->hand == item
		or pInfo(p_)->mask == item or pInfo(p_)->necklace == item
		or pInfo(p_)->pants == item or pInfo(p_)->shirt == item) {
		unequip_(p_, item);
	}
	else {
		if (item == 8304) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMagic Magnet``|left|8304|\nadd_spacer|small|" + (string(pInfo(p_)->Magnet_Item != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(p_)->Magnet_Item].name + "``|left|" + to_string(pInfo(p_)->Magnet_Item) + "|" : "")) + "\nadd_item_picker|magic_compass_item|`wSelect Item``|Choose an item to pickup!|\nadd_button|clear_item|Clear|noflags|0|0|\nadd_spacer|small|\nend_dialog|magic_compass|Close||");
			p.CreatePacket(p_);
		}
		else if (item == 4746 or item == 4748 or item == 4750) {
			int remove_ = c_ * -1, give_back = abs(remove_);

			if (item == 4746) {
				modify_inventory(p_, item, remove_);
				item = 4748;
				modify_inventory(p_, item, give_back);
			}
			else if (item == 4748) {
				modify_inventory(p_, item, remove_);
				item = 4750;
				modify_inventory(p_, item, give_back);
			}
			else if (item == 4750) {
				modify_inventory(p_, item, remove_);
				item = 4746;
				modify_inventory(p_, item, give_back);
			}
		}
		ClothTypes type_ = items[item].clothType;
		if (type_ == ClothTypes::ANCES)
			pInfo(p_)->ances = item;
		else if (type_ == ClothTypes::BACK)
			pInfo(p_)->back = item;
		else if (type_ == ClothTypes::FEET)
			pInfo(p_)->feet = item;
		else if (type_ == ClothTypes::FACE)
			pInfo(p_)->face = item;
		else if (type_ == ClothTypes::HAIR)
			pInfo(p_)->hair = item;
		else if (type_ == ClothTypes::HAND)
			pInfo(p_)->hand = item;
		else if (type_ == ClothTypes::MASK)
			pInfo(p_)->mask = item;
		else if (type_ == ClothTypes::NECKLACE)
			pInfo(p_)->necklace = item;
		else if (type_ == ClothTypes::PANTS)
			pInfo(p_)->pants = item;
		else if (type_ == ClothTypes::SHIRT)
			pInfo(p_)->shirt = item;
		if (items[item].on_equip != "") {
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert(items[item].on_equip + (items[item].playmod != "" ? " (`$" + items[item].playmod + "`` mod added)" : "")), p.CreatePacket(p_);
		}
		update_clothes_value(p_);
		packet_(p_, "action|play_sfx\nfile|audio/change_clothes.wav\ndelayMS|0");
		update_clothes(p_);
		if (pInfo(p_)->fishing_used != 0)stop_fishing(p_, true, "Sit still if you wanna fish!");
		if (item == 3172) {
			if (has_playmod2(pInfo(p_), 86, 1)) {
				gamepacket_t p, p2;
				p.Insert("OnConsoleMessage"), p.Insert("`2Your briefs have stunned the judge!``"), p.CreatePacket(p_);
				p2.Insert("OnTalkBubble"), p2.Insert(pInfo(p_)->netID), p2.Insert("`2Your briefs have stunned the judge!``"), p2.Insert(0), p2.Insert(0), p2.CreatePacket(p_);
				int remove = -1;
				modify_inventory(p_, 3172, remove);
			}
		}
	}
}

int alloc_(World* world_, WorldBlock* block_) {
	if (items[block_->fg].blockType == SEED) return 0;
	if (items[block_->fg].blockType == BlockTypes::VIP_ENTRANCE) {
		return (block_->admins.size() * 4) + 99;
	}
	else if (items[block_->fg].blockType == BlockTypes::LOCK) {
		if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
			return (block_->admins.size() * 4) + 99;
		}
		return (world_->admins.size() * 4) + 99;
	}
	return 99;
}
int form_visual(BYTE*& blc, WorldBlock block_, World world_, ENetPeer* peer, bool case_ = true, bool show = false, int x1 = -1, int y1 = -1) {
	if (not case_) {
		*(__int16*)(blc) = block_.fg;
		*(__int16*)(blc + 2) = block_.bg;
		*(__int32*)(blc + 4) = block_.flags;
	}
	if (items[block_.fg].audio_rack) {
		*(__int8*)(blc + 8) = 56;
		*(__int16*)(blc + 9) = block_.txt.size();
		memcpy(blc + 11, block_.txt.c_str(), block_.txt.size());
		*(__int16*)(blc + 11 + block_.txt.size()) = block_.pr;
		if (case_) {
			blc += 7 + block_.txt.size();
			return 7 + block_.txt.size();
		}
	}
	else if (items[block_.fg].simple_load) {
		*(__int8*)(blc + 8) = 6;
		if (case_) {
			blc += 8;
			return 8;
		}
	}
	else if (block_.fg == 6954) {
		*(__int8*)(blc + 8) = 71;
		*(__int8*)(blc + 9) = block_.pr > 0 ? 1 : 0;
		*(__int16*)(blc + 13) = block_.pr;
		*(__int16*)(blc + 17) = block_.id + (block_.build_only ? 0 : -1);
		*(__int16*)(blc + 25) = block_.id + (block_.invert ? 0 : -1);
		*(__int8*)(blc + 31) = block_.enabled ? 0 : 1;
		if (case_) {
			blc += 13;
			return 13;
		}
	}
	else {
		switch (items[block_.fg].blockType) {
		case BlockTypes::GAME_BLOCK:
		{
			
		}
		case BlockTypes::GAME_GENERATOR:
		{
			
		}
		case BlockTypes::WEATHER:
		{
			switch (block_.fg) {
			case 3694: case 5000:
			{
				*(__int8*)(blc + 8) = 40;
				*(__int32*)(blc + 9) = (block_.fg == 3694 ? (block_.b << 24) | (block_.g << 16) | (block_.r << 8) : block_.id != 0 ? block_.id : 14);
				if (case_) {
					blc += 5;
					return 5;
				}
				break;
			}
			case 3832:	case 5958:
			{
				*(__int8*)(blc + 8) = 49;
				if (block_.fg != 5958) {
					*(__int16*)(blc + 9) = (block_.id != 0 ? block_.id : 2);
					*(__int16*)(blc + 13) = block_.gravity;
					*(__int16*)(blc + 17) = (int)block_.spin | ((int)block_.invert << 1);
				}
				if (case_) {
					blc += 10;
					return 10;
				}
				break;
			}
			default:
			{
				*(__int8*)(blc + 8) = 5;
				if (case_) {
					blc += 1;
					return 1;
				}
				break;
			}
			}
			break;
		}
		case BlockTypes::AUTO_BLOCK: {
			*(__int8*)(blc + 8) = block_.fg == 6950 ? 70 : 69;
			*(__int8*)(blc + 9) = block_.pr > 0 ? 1 : 0;
			*(__int16*)(blc + 13) = block_.pr;
			*(__int16*)(blc + 17) = block_.id;
			*(__int8*)(blc + 21) = block_.enabled;
			if (case_) {
				blc += 13;
				return 13;
			}
			break;
		}
		case BlockTypes::FISH: {
			*(__int8*)(blc + 8) = 63;
			if (case_) {
				blc += 1 + 4 + 8;
				return 1 + 4 + 8;
			}
			break;
		}
		case BlockTypes::COUNTRY_FLAG: {
			*(__int8*)(blc + 8) = 0x21;
			*(__int16*)(blc + 9) = block_.heart_monitor.size();
			memcpy(blc + 11, block_.heart_monitor.data(), block_.heart_monitor.size());

			if (case_) {
				blc += 11 + block_.heart_monitor.size();
				return 11 + block_.heart_monitor.size();
			}
			break;
		}
		case BlockTypes::GEIGER_CHARGER: {
			*(int*)(blc + 4) = block_.flags;
			*(__int8*)(blc + 8) = 57;
			*(int*)(blc + 9) = (block_.planted - time(nullptr) <= 0 ? 3600 : 3600 - (block_.planted - time(nullptr)));
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::Spirit_Storage: {
			*(__int8*)(blc + 8) = 41;
			*(__int16*)(blc + 9) = block_.c_;
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::MAGIC_EGG: {
			*(__int8*)(blc + 8) = 15;
			*(__int16*)(blc + 9) = block_.shelf_1;
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::Painting_Easel: {
			*(__int8*)(blc + 8) = 35;
			*(__int16*)(blc + 9) = block_.id;
			*(__int16*)(blc + 13) = block_.txt.size();
			memcpy(blc + 15, block_.txt.c_str(), block_.txt.size());
			if (case_) {
				blc += 7 + block_.txt.size();
				return 7 + block_.txt.size();
			}
			break;
		}
		case BlockTypes::Fish_Mount: {
			*(__int8*)(blc + 8) = 47;
			*(__int8*)(blc + 9) = 0;
			if (case_) {
				blc += 8;
				return 8;
			}
			break;
		}
		case BlockTypes::PORTRAIT: {
			*(__int8*)(blc + 8) = 48;
			*(__int16*)(blc + 9) = block_.txt.size();
			memcpy(blc + 11, block_.txt.c_str(), block_.txt.size());
			*(__int16*)(blc + 17) = block_.shelf_3;
			*(__int16*)(blc + 21) = block_.shelf_4;

			if (block_.portrait.c_skin == 0 and block_.portrait.c_face == 0 and block_.portrait.c_head == 0 and block_.portrait.c_hair == 0) {

			}
			else {
				*(__int16*)(blc + 11 + block_.txt.size()) = block_.portrait.c_expression;
				*(__int16*)(blc + 19 + block_.txt.size()) = block_.portrait.c_hair_colour;
				*(__int16*)(blc + 23 + block_.txt.size()) = block_.portrait.c_skin;
				*(__int16*)(blc + 27 + block_.txt.size()) = block_.portrait.c_face;
				*(__int16*)(blc + 29 + block_.txt.size()) = block_.portrait.c_head;
				*(__int16*)(blc + 31 + block_.txt.size()) = block_.portrait.c_hair;
			}
			if (case_) {
				blc += 7 + 15 + 3 + block_.txt.size();
				return 7 + 15 + 3 + block_.txt.size();
			}
			break;
		}
		case BlockTypes::MANNEQUIN: {
			*(__int8*)(blc + 8) = 14;
			*(__int16*)(blc + 9) = block_.txt.size();
			memcpy(blc + 11, block_.txt.c_str(), block_.txt.size());
			*(__int16*)(blc + 16 + block_.txt.size()) = block_.mannequin.c_hair;
			*(__int16*)(blc + 18 + block_.txt.size()) = block_.mannequin.c_shirt;
			*(__int16*)(blc + 20 + block_.txt.size()) = block_.mannequin.c_pants;
			*(__int16*)(blc + 22 + block_.txt.size()) = block_.mannequin.c_feet;
			*(__int16*)(blc + 24 + block_.txt.size()) = block_.mannequin.c_head;
			*(__int16*)(blc + 26 + block_.txt.size()) = block_.mannequin.c_hand;
			*(__int16*)(blc + 28 + block_.txt.size()) = block_.mannequin.c_back;
			*(__int16*)(blc + 30 + block_.txt.size()) = block_.mannequin.c_mask;
			*(__int16*)(blc + 32 + block_.txt.size()) = block_.mannequin.c_neck;
			if (case_) {
				blc += 26 + block_.txt.size();
				return 26 + block_.txt.size();
			}
			break;
		}
		case BlockTypes::KRANKEN: {
			int model_ = block_.kranken_pattern;
			int rgb = (block_.b << 24) | (block_.g << 16) | (block_.r << 8);
			int w_ = rgb + 255;
			BYTE btype = 0x50;
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 9, &model_, 4);
			memcpy(blc + 13, &w_, 4);
			if (case_) {
				blc += 9;
				return 9;
			}
			break;
		}
		case BlockTypes::SUCKER: {
			*(__int8*)(blc + 8) = 62;
			*(__int16*)(blc + 9) = block_.id;
			*(__int16*)(blc + 13) = block_.pr;
			*(__int8*)(blc + 17) = block_.enabled;
			if (block_.fg == 6948 or block_.fg == 6946) {
				*(__int16*)(blc + 21) = 1500;
			}
			else {
				*(__int8*)(blc + 18) = block_.spin;
				*(__int16*)(blc + 20) = 5000;
			}
			if (case_) {
				blc += 15;
				return 15;
			}
			break;
		}
		case BlockTypes::Heart_Monitor: {
			*(__int8*)(blc + 8) = 11;
			{
				uint32_t ijungtas = -1;
				*(__int16*)(blc + 9) = ijungtas;
				if (ijungtas) *(int*)(blc + 4) = block_.flags | 0x00400000;
			}
			*(__int16*)(blc + 13) = block_.heart_monitor.size();
			memcpy(blc + 15, block_.heart_monitor.c_str(), block_.heart_monitor.size());
			if (case_) {
				blc += 7 + block_.heart_monitor.size();
				return 7 + block_.heart_monitor.size();
			}
			break;
		}
		case BlockTypes::TRICKSTER: {
			*(__int8*)(blc + 8) = 52;
			if (case_) {
				blc += 1;
				return 1;
			}
			break;
		}
		case BlockTypes::VIP_ENTRANCE: {
			*(__int8*)(blc + 8) = 44;
			vector<int> vip_members;
			if (block_.limit_admins) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_.name) vip_members.push_back(name_to_number(to_lower(pInfo(currentPeer)->tankIDName)));
				}
			}
			else {
				if (peer != NULL && to_lower(pInfo(peer)->tankIDName) == to_lower(world_.owner_name)) vip_members.push_back(name_to_number(to_lower(pInfo(peer)->tankIDName)));
				for (int i = 0; i < block_.admins.size(); i++) vip_members.push_back(name_to_number(to_lower(block_.admins[i])));
			}
			*(__int16*)(blc + 14) = vip_members.size();
			for (int i = 0; i < vip_members.size(); i++) *(__int32*)(blc + 18 + (i * 4)) = vip_members[i];
			if (case_) {
				blc += 10 + (vip_members.size() * 4);
				return 10 + (vip_members.size() * 4);
			}
			break;
		}
		case BlockTypes::TIMER:
		{
			*(__int8*)(blc + 8) = 45;
			if (case_) {
				blc += 1;
				return 1;
			}
			break;
		}
		case BlockTypes::Display_Shelf:
		{
			*(__int8*)(blc + 8) = 43;
			*(__int16*)(blc + 9) = block_.shelf_1;
			*(__int16*)(blc + 13) = block_.shelf_2;
			*(__int16*)(blc + 17) = block_.shelf_3;
			*(__int16*)(blc + 21) = block_.shelf_4;
			if (case_) {
				blc += 17;
				return 17;
			}
			break;
		}
		case BlockTypes::CRYSTAL:
		{
			*(__int8*)(blc + 8) = 20;
			*(__int8*)(blc + 9) = 0;
			memcpy(blc + 11, "", 0);
			*(__int16*)(blc + 17) = block_.id;
			*(__int8*)(blc + 21) = block_.enabled;
			if (case_) {
				blc += 3 + 0;
				return 3 + 0;
			}
			break;
		}
		case BlockTypes::GIVING_TREE:
		{
			BYTE btype = 0x1C;
			int count = block_.shelf_1, zero = 0;
			uint16_t times = uint16_t(block_.planted - time(nullptr) <= 0 ? 14400 : 14400 - (block_.planted - time(nullptr)));
			memset(blc + 8, 0, 7);
			memcpy(blc, &block_.fg, 2);
			memcpy(blc + 4, &block_.flags, 4);
			memcpy(blc + 8, &btype, 1);
			memcpy(blc + 8 + 1, &zero, 1);
			memcpy(blc + 8 + 2, &times, 4);
			memcpy(blc + 8 + 6, &count, 1);
			if (case_) {
				blc += 7;
				return 7;
			}
			break;
		}
		case BlockTypes::VENDING:
		{
			*(int*)(blc + 9) = (block_.pr < 0 and block_.id != 0 && block_.c_ < (block_.pr * -1) ? 0 : block_.id);
			*(__int8*)(blc + 8) = 24;
			*(int*)(blc + 4) = (block_.pr < 0 and block_.id != 0 && block_.c_ < (block_.pr * -1) ? block_.flags | ((block_.c_ < (block_.pr * -1)) ? (block_.wl != 0 ? 0x02410000 : 0x00410000) : (block_.wl != 0 ? 0x02410000 : 0x00410000)) : block_.flags | (block_.id == 0 ? (block_.wl != 0 ? 0x02000000 : 0x00000000) : (block_.wl != 0 ? 0x02410000 : 0x00410000)));
			*(int*)(blc + 13) = (block_.pr < 0 and block_.id != 0 && block_.c_ < (block_.pr * -1) ? 0 : block_.pr);
			if (case_) {
				blc += 9;
				return 9;
			}
			break;
		}
		case BlockTypes::DISPLAY:
		{
			*(__int8*)(blc + 8) = 23;
			*(__int16*)(blc + 9) = block_.id;
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::PROVIDER:
		{
			*(__int8*)(blc + 8) = 9;
			*(int*)(blc + 9) = time(nullptr) - block_.planted <= items[block_.fg].growTime ? time(nullptr) - block_.planted : items[block_.fg].growTime;
			if (case_) {
				blc += 5;
				return 5;
			}
			break;
		}
		case BlockTypes::RANDOM_BLOCK:
		{
			*(__int8*)(blc + 8) = 8;
			*(__int16*)(blc + 9) = block_.roll;
			if (case_) {
				blc += 2;
				return 2;
			}
			break;
		}
		case BlockTypes::LOCK:
		{
			if (block_.spin) *(int*)(blc + 4) = 0x00800000;
			*(__int8*)(blc + 8) = 3;
			uint32_t world_owner_id = -1;
			{
				if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994 or block_.fg == 10000) {
					world_owner_id = name_to_number(to_lower(block_.owner_name));
				}
				else {
					world_owner_id = name_to_number(to_lower(world_.owner_name));
				}
			}
			uint8_t world_settings = world_.world_settings & Gtps3::SETTINGS_5 ? (world_.world_settings & Gtps3::SETTINGS_6 ? 12345 : 1234) : (world_.world_settings & Gtps3::SETTINGS_6 ? 100 : 0);
			if (world_.world_settings & Gtps3::SETTINGS_7 and block_.fg == 4802) world_settings += 128;
			*(__int8*)(blc + 9) = world_settings;
			*(int*)(blc + 10) = world_owner_id;
			*(int*)(blc + 18) = world_.music_bpm * -1;
			uint32_t count_of_admins = 1;
			{
				if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994 or block_.fg == 10000) {
					for (int i = 0; i < block_.admins.size(); i++) {
						if (count_of_admins == 1) {
							*(int*)(blc + 22) = name_to_number(to_lower(block_.admins[i]));
						}
						else {
							*(int*)(blc + 22 + (count_of_admins * 4)) = name_to_number(to_lower(block_.admins[i]));
						}
						count_of_admins++;
					}
				}
				else {
					for (int i = 0; i < world_.admins.size(); i++) {
						if (count_of_admins == 1) {
							*(int*)(blc + 22) = name_to_number(to_lower(world_.admins[i]));
						}
						else {
							*(int*)(blc + 22 + (count_of_admins * 4)) = name_to_number(to_lower(world_.admins[i]));
						}
						count_of_admins++;
					}
				}
				*(int*)(blc + 14) = count_of_admins;
			}
			if (block_.fg == 5814 and world_.guild_id != 0) {
			}
			else {
				if (case_) {
					blc += 10 + (count_of_admins * 4);
					return 10 + (count_of_admins * 4);
				}
			}
			break;
		}
		case BlockTypes::MAIN_DOOR:
		{
			*(__int8*)(blc + 8) = 1;
			*(__int16*)(blc + 9) = 4;
			memcpy(blc + 11, "EXIT", 4);
			if (case_) {
				blc += 4 + 4;
				return 4 + 4;
			}
			break;
		}
		case BlockTypes::SEED:
		{
			*(int*)(blc + 4) = block_.flags | 0x100000;
			*(__int8*)(blc + 8) = 4;
			*(int*)(blc + 9) = (time(nullptr) - block_.planted <= items[block_.fg].growTime ? time(nullptr) - block_.planted : items[block_.fg].growTime);
			*(__int16*)(blc + 13) = block_.fruit;
			if (case_) {
				blc += 6;
				return 6;
			}
			break;
		}
		case BlockTypes::DONATION:case BlockTypes::MAILBOX:case BlockTypes::FOSSIL: {
			*(int*)(blc + 4) = block_.flags;
			*(__int8*)(blc + 8) = 12;
			if (case_ && items[block_.fg].blockType != BlockTypes::FOSSIL) {
				blc += 8;
				return 8;
			}
			break;
		}
		case BlockTypes::DOOR: case BlockTypes::PORTAL:
		{
			string duru_tekstas = (block_.txt.empty() ? (block_.door_destination.empty() ? "" : (block_.door_destination.find(":") != string::npos ? explode(":", block_.door_destination)[0] + "..." : block_.door_destination)) : block_.txt);
			*(__int8*)(blc + 8) = 1;
			*(__int16*)(blc + 9) = duru_tekstas.size();
			memcpy(blc + 11, duru_tekstas.c_str(), duru_tekstas.size());
			*(__int8*)(blc + 11 + duru_tekstas.size()) = (block_.open ? 0 : 0x08);
			if (case_) {
				blc += 4 + duru_tekstas.size();
				return 4 + duru_tekstas.size();
			}
			break;
		}
		case BlockTypes::SIGN:
		{
			*(__int8*)(blc + 8) = 2;
			*(int*)(blc + 9) = block_.txt.size();
			memcpy(blc + 11, block_.txt.c_str(), block_.txt.size());
			*(__int16*)(blc + 11 + block_.txt.size()) = 0;
			if (case_) {
				blc += 7 + block_.txt.size();
				return 7 + block_.txt.size();
			}
			break;
		}
		}
	}
	return 0;
}
void upd_lock(WorldBlock block_2, World world_, ENetPeer* peer) {
	int l_x = block_2.lock_origin % 100, l_y = block_2.lock_origin / 100;
	WorldBlock block_ = world_.blocks[l_x + (l_y * 100)];
	if (items[block_.fg].blockType != BlockTypes::LOCK) return;
	vector<vector<int>> locked_tiles_around_lock;
	vector<int> new_tiles;
	new_tiles.push_back(l_x + (l_y * 100));
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
		if (s_x_ < (world_.max_x - 1) and world_.blocks[s_x_ + 1 + (s_y_ * 100)].locked and world_.blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin == (l_x + (l_y * 100))) {
			if (not world_.blocks[s_x_ + 1 + (s_y_ * 100)].scanned) {
				world_.blocks[s_x_ + 1 + (s_y_ * 100)].scanned = true;
				new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
				locked_tiles_around_lock.push_back({ s_x_ + 1, s_y_ });
			}
		} if (s_x_ > 0 and world_.blocks[s_x_ - 1 + (s_y_ * 100)].locked and world_.blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin == (l_x + (l_y * 100))) {
			if (not world_.blocks[s_x_ - 1 + (s_y_ * 100)].scanned) {
				world_.blocks[s_x_ - 1 + (s_y_ * 100)].scanned = true;
				new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
				locked_tiles_around_lock.push_back({ s_x_ - 1, s_y_ });
			}
		} if (s_y_ < (world_.max_y - 1) and world_.blocks[s_x_ + ((s_y_ + 1) * 100)].locked and world_.blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin == (l_x + (l_y * 100))) {
			if (not world_.blocks[s_x_ + ((s_y_ + 1) * 100)].scanned) {
				world_.blocks[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
				new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
				locked_tiles_around_lock.push_back({ s_x_, s_y_ + 1 });
			}
		} if (s_y_ > 0 and world_.blocks[s_x_ + ((s_y_ - 1) * 100)].locked and world_.blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin == (l_x + (l_y * 100))) {
			if (not world_.blocks[s_x_ + ((s_y_ - 1) * 100)].scanned) {
				world_.blocks[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
				new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
				locked_tiles_around_lock.push_back({ s_x_, s_y_ - 1 });
			}
		}
	}
	if (locked_tiles_around_lock.size() != 0) {
		PlayerMoving data_{};
		data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
		data_.netID = name_to_number(to_lower(block_.owner_name));
		data_.plantingTree = block_.fg;
		BYTE* raw;
		raw = packPlayerMoving(&data_, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_));
		int lalala = 8, lock_size = locked_tiles_around_lock.size();
		memcpy(raw + 8, &lock_size, 2);
		memcpy(raw + 12, &lalala, 2);
		BYTE* blc = raw + 56;
		for (int i_ = 0; i_ < locked_tiles_around_lock.size(); i_++) {
			int x = locked_tiles_around_lock[i_][0];
			int y = locked_tiles_around_lock[i_][1];
			int sq_ = x + (y * 100);
			memcpy(blc + (i_ * 2), &sq_, 2);
			world_.blocks[x + (y * 100)].scanned = false;
		}
		PlayerMoving data_2{};
		data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
		BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(&world_, &block_));
		BYTE* blc2 = raw2 + 56;
		form_visual(blc2, block_, world_, peer, false);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) { //fix
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or world_.name != pInfo(currentPeer)->world) continue;
			send_raw(currentPeer, 4, raw, 112 + (locked_tiles_around_lock.size() * 2) + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
			send_raw(currentPeer, 4, raw2, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw, blc;
		delete[] raw2, blc2;
	}
	else {
		PlayerMoving data_{};
		data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
		data_.netID = name_to_number(to_lower(block_.owner_name));
		data_.plantingTree = block_.fg;
		BYTE* raw = packPlayerMoving(&data_, 56);
		PlayerMoving data_2{};
		data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
		BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(&world_, &block_));
		BYTE* blc2 = raw2 + 56;
		form_visual(blc2, block_, world_, NULL, false);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or world_.name != pInfo(currentPeer)->world) continue;
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			send_raw(currentPeer, 4, raw2, 112 + alloc_(&world_, &block_), ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw2, blc2;
		delete[] raw;
	}
}


void tile_update(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	PlayerMoving data_{};
	data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
	int alloc = alloc_(world_, block_);
	BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
	BYTE* blc = raw + 56;
	form_visual(blc, *block_, *world_, peer, false);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
		send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
	}
	delete[] raw, blc;
	if (block_->locked) upd_lock(*block_, *world_, peer);
}


void drop_from_magic_egg(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	WorldDrop drop_block_{};
	uint32_t percentage = block_->shelf_1 / 10;
	if (percentage <= 9) {
		{
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 42, data_.YSpeed = 42, data_.x = pInfo(peer)->x + rand() % 17, data_.y = pInfo(peer)->y + rand() % 22;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_->name) {
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
			}
			delete[] raw;
		}
		add_playmod(peer, 4);
		update_clothes(peer);
	}
	else if (percentage <= 19) {
		vector<int> pastel_blocks{
			510,
			512,
			514,
			516,
			518,
			520,
			522
		};
		drop_block_.id = pastel_blocks[rand() % pastel_blocks.size()], drop_block_.count = 5;
	}
	else if (percentage <= 24) 	drop_block_.id = 10760, drop_block_.count = 5;
	else if (percentage <= 29) drop_block_.id = 4624, drop_block_.count = 7;
	else if (percentage >= 30 && percentage <= 34) drop_block_.id = 13388, drop_block_.count = 1;
	else if (percentage <= 39) drop_block_.id = ((rand() % 100) < 50 ? 616 : 618), drop_block_.count = 1;
	else if (percentage <= 49) drop_block_.id = ((rand() % 100) < 50 ? 1548 : 8044), drop_block_.count = 1;
	else if (percentage <= 59) {
		vector<int> easter_set{
			502,
			500,
			498,
			508,
		};
		drop_block_.id = easter_set[rand() % easter_set.size()], drop_block_.count = 1;
	}
	else if (percentage <= 69) {
		vector<int> bunny_set{
			504,
			506,
			524
		};
		drop_block_.id = bunny_set[rand() % bunny_set.size()], drop_block_.count = 1;
	}
	else if (percentage <= 79) drop_block_.id = 8038, drop_block_.count = 1;
	else if (percentage <= 89) drop_block_.id = 2558, drop_block_.count = 1;
	else if (percentage <= 99) drop_block_.id = 1550, drop_block_.count = 1;
	else if (percentage == 100) drop_block_.id = 1552, drop_block_.count = 1;
	else if (percentage >= 100 && percentage <= 104) drop_block_.id = 13374, drop_block_.count = 1;
	else if (percentage <= 119) drop_block_.id = 9452, drop_block_.count = 1;
	else if (percentage <= 159) drop_block_.id = 9468, drop_block_.count = 1;
	else if (percentage <= 179) drop_block_.id = 9454, drop_block_.count = 1;
	else if (percentage <= 199) drop_block_.id = 9442, drop_block_.count = 1;
	else if (percentage == 200)drop_block_.id = 9446, drop_block_.count = 1;
	drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
	dropas_(world_, drop_block_);
}


void add_magic_egg(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_, int eggs = 1) {
	pInfo(peer)->magic_egg += eggs;
	PlayerMoving data_{};
	data_.packetType = 17, data_.netID = 66, data_.YSpeed = 66, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
	BYTE* raw_e = packPlayerMoving(&data_);
	if (block_->shelf_1 < 2001) {
		//pInfo(peer)->egg++;
		block_->shelf_1 += eggs;
	}
	if (block_->shelf_1 > 1000) {
		int burst_chance = 350;
		if (block_->shelf_1 > 1500) burst_chance = 125;
		gamepacket_t p;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
		bool not_crack = false;
		for (int i = 0; i < eggs; i++) {
			if (rand() % burst_chance < 1) {
				drop_from_magic_egg(peer, world_, block_, x_, y_);
				p.Insert("`6The egg has exploded!``");
				block_->fg = 0, block_->shelf_1 = 0;
				update_tile(peer, x_, y_, 0, false, true);
				not_crack = true;
				break;
			}
		}
		if (not_crack == false) p.Insert(block_->shelf_1 <= 1500 ? "This oversized egg has a fair chance to burst!" : "`6This over-sized egg has a good chance to burst!``");
		p.Insert(0), p.Insert(1), p.CreatePacket(peer);
	}
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			send_raw(currentPeer, 4, raw_e, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete[] raw_e;
	tile_update(peer, world_, block_, x_, y_);
}

void add_ridban(ENetPeer* peer) {
	Server_Security.ridbans.push_back(pInfo(peer)->rid);
	Server_Security.ridbans.push_back(pInfo(peer)->ip);
	if (not pInfo(peer)->meta.empty() && pInfo(peer)->meta != pInfo(peer)->ip) Server_Security.ridbans.push_back(pInfo(peer)->meta);
	pInfo(peer)->bans.push_back("\nadd_smalltext|`6ON:`` `#" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` `0(" + pInfo(peer)->requestedName + ") #" + to_string(pInfo(peer)->netID) + "`` IP BAN: " + pInfo(peer)->ip + "|left|");
}

void add_modlogs(ENetPeer* peer, string bywho, string text, string timed) {
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `r>> [MOD-LOGS] from (``" + bywho + "```r) in [```$" + pInfo(peer)->world + "```r] > `r" + text + "" + (timed != "" ? " for " + timed + "``" : ""));
	string ban = "[MOD-LOGS] from(" + bywho + ") in [" + pInfo(peer)->world + "] > " + text + "" + (timed != "" ? " for " + timed + "" : "");
	send_logs(fixchar2(ban), "Bans");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->mod + pInfo(currentPeer)->dev == 0) continue;
		p.CreatePacket(currentPeer);
	}
}

void SendRespawn(ENetPeer* peer, bool kickall, int instant, bool kill = false) {
	if (pInfo(peer)->hider) {
		gamepacket_t p((instant == 0 ? 2000 : 100), pInfo(peer)->netID);
		p.Insert("OnSetFreezeState");
		p.Insert(0);
		p.CreatePacket(peer);
		return;
	}
	if (pInfo(peer)->trading_with != -1) cancel_trade(peer, false, true);
	if (pInfo(peer)->respawn_time + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() || kickall) {
		pInfo(peer)->respawn_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			bool skip_ = false;
			if (pInfo(peer)->c_x < 0 || pInfo(peer)->c_y < 0 || pInfo(peer)->c_x >= world_->max_x || pInfo(peer)->c_y >= world_->max_y) skip_ = true;
			if (skip_ == false && (items[world_->blocks[pInfo(peer)->c_x + (pInfo(peer)->c_y * 100)].fg].blockType == BlockTypes::CHECKPOINT or items[world_->blocks[pInfo(peer)->c_x + (pInfo(peer)->c_y * 100)].fg].blockType == BlockTypes::MAIN_DOOR or world_->blocks[pInfo(peer)->c_x + (pInfo(peer)->c_y * 100)].fg == 1912)) {
			}
			else {
				int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize, square = (int)world_->blocks.size();
				for (int i_ = 0; i_ < square; i_++) {
					if (items[world_->blocks[i_].fg].blockType == BlockTypes::MAIN_DOOR) {
						pInfo(peer)->c_x = (i_ % xSize);
						pInfo(peer)->c_y = (i_ / xSize);
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("SetRespawnPos");
						p.Insert(i_);
						p.CreatePacket(peer);
						break;
					}
				}
			}
		}
		{
			gamepacket_t p(0, pInfo(peer)->netID);
			p.Insert("OnSetFreezeState");
			p.Insert(2);
			p.CreatePacket(peer);
		}
		{
			gamepacket_t p(0, pInfo(peer)->netID);
			p.Insert("SetRespawnPos");
			p.Insert(pInfo(peer)->c_x + (pInfo(peer)->c_y * 100));
			p.CreatePacket(peer);
		}
		{
			if (kill) {
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnKilled");
				p.CreatePacket(peer);
			}
		}
		{
			OnSetPos(peer, pInfo(peer)->c_x * 32, pInfo(peer)->c_y * 32, (instant == 0 ? 2000 : 100));
		}
		{
			gamepacket_t p((instant == 0 ? 2020 : 100), pInfo(peer)->netID);
			p.Insert("OnPlayPositioned");
			p.Insert("audio/teleport.wav");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					p.CreatePacket(currentPeer);
				}
			}
		}
		{
			gamepacket_t p((instant == 0 ? 2000 : 100), pInfo(peer)->netID);
			p.Insert("OnSetFreezeState");
			p.Insert(0);
			p.CreatePacket(peer);
		}
	}
}


void end_surgery(ENetPeer* peer) {
	if (pInfo(peer)->surgery_started) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			if (pInfo(peer)->surged_person != "" && pInfo(peer)->surged_person == pInfo(currentPeer)->tankIDName) SendRespawn(currentPeer, true, 0, 1), add_peer_xp(currentPeer, 700);
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("`7[``" + get_player_nick(peer) + " `4failed to save`` " + pInfo(peer)->surged_display + " from " + pInfo(peer)->surgery_name + "!`7]``"), p.CreatePacket(currentPeer);
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("`4The patient has succumbed to infection.`` `4YOUR MEDICAL LICENSE IS REVOKED!``"), p.CreatePacket(peer);
		if (pInfo(peer)->started_type != 30) {
			if (pInfo(peer)->pants == 3172) {
				gamepacket_t p, p2;
				p.Insert("OnConsoleMessage"), p.Insert("`2Your briefs have stunned the judge!``"), p.CreatePacket(peer);
				p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("`2Your briefs have stunned the judge!``"), p2.Insert(0), p2.Insert(0), p2.CreatePacket(peer);
				int remove = -1;
				modify_inventory(peer, 3172, remove);
			}
			else {
				int seconds = 3600;
				if (thedaytoday == 6) seconds = 900;
				if (pInfo(peer)->pants == 3172) seconds = 0;
				if (pInfo(peer)->necklace == 8954) seconds *= 0.75;
				add_playmod(peer, 86, seconds);
			}
		}
		pInfo(peer)->surged_person = "";
		pInfo(peer)->surgery_started = false;
	}
}

void wipe_hidenseek(ENetPeer* peer) {
	if (pInfo(peer)->hider) Hide_N_Seek.total_players--;
	Hide_N_Seek.hide_players.erase(remove(Hide_N_Seek.hide_players.begin(), Hide_N_Seek.hide_players.end(), pInfo(peer)->tankIDName), Hide_N_Seek.hide_players.end());
	Hide_N_Seek.seeker.erase(remove(Hide_N_Seek.seeker.begin(), Hide_N_Seek.seeker.end(), to_lower(pInfo(peer)->tankIDName)), Hide_N_Seek.seeker.end());
	pInfo(peer)->hider = false;
	pInfo(peer)->seeker = false;
	Hide_N_Seek.seeker_start = false;
	Hide_N_Seek.hider_start = false;
}

struct temp_locked_worlds {
	string name = "";
	long long int time = 0;
};
vector<temp_locked_worlds>t_l_worlds;

void add_temp_locked_world(string name) {
	temp_locked_worlds tmp;
	tmp.name = to_lower(name);
	tmp.time = time(nullptr) + 1;
	t_l_worlds.push_back(tmp);
}

bool check_and_remove_temp_locked_world(string name) {
	for (int i = 0; i < t_l_worlds.size(); i++) {
		if (t_l_worlds.at(i).name == name) {
			if (t_l_worlds.at(i).time > time(nullptr)) {
				return true;
			}
			else {
				t_l_worlds.erase(t_l_worlds.begin() + i);
				return false;
			}
			break;
		}
	}
	return false;
}

void memory_clean_world(const string world_name) {
	if (get_players_world(world_name) < 1) save_world(world_name, true);
}

void exit_(ENetPeer* peer, bool reset_ = false, bool del = true, bool force = false) {
	string name_ = pInfo(peer)->world;
	
	/*vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		bool gamefound = false;
		int gamex = 0, gamey = 0;
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg == 1660 and world_->blocks[i_].enabled) {
				gamex = i_ % 100; gamey = i_ / 100;
				gamefound = true;
				break;
			}
		}
		if (gamefound and pInfo(peer)->ONGame) {
			WorldBlock* block_ = &world_->blocks.at(gamex + (gamey * 100));
			Send_Add_PVP_Point(world_, block_, peer, peer, -1, true, world_->Game_Score.size());
			for (int i = 0; i < world_->Game_Score.size(); i++) {
				if (pInfo(peer)->Game_Team == "") {
					if (world_->Game_Score[i].first == pInfo(peer)->tankIDName) {
						world_->Game_Score.erase(world_->Game_Score.begin() + i);
						break;
					}
				}
			}
		}
	}
	*/
	pInfo(peer)->rr_used = 0;
	pInfo(peer)->random_geiger_time = 0;
	pInfo(peer)->World_Timed = 0;
	pInfo(peer)->WorldTimed = false;
	if (pInfo(peer)->spotlight) {
		pInfo(peer)->spotlight = false;
		form_state(pInfo(peer));
	}
	if (pInfo(peer)->hider && Hide_N_Seek.hider_start) wipe_hidenseek(peer);
	pInfo(peer)->temp_transmute = false;
	if (force == false) autofarm_status(peer);
	if (not Server_Security.log_player.empty() && Server_Security.log_player == to_lower(pInfo(peer)->tankIDName)) {
		cout << "LOGGING: " << pInfo(peer)->tankIDName << " | " << " LEFT WORLD " << "|" << endl;
	}
	end_surgery(peer);
	if (pInfo(peer)->invis == false) {
		add_cctv(peer, "left", "");
		packet_(peer, "action|play_sfx\nfile|audio/door_shut.wav\ndelayMS|0");
	}
	
	const string world_name = pInfo(peer)->world;
	pInfo(peer)->world = "", pInfo(peer)->world_owner = "";
	pInfo(peer)->access_offers.clear();
	int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
	get_players(world_name, w_c, s_c, net_, r_c);
	if (w_c == 0) { //Something Todo
		add_temp_locked_world(world_name);
		save_world(world_name, true);
	}
	else {
		gamepacket_t p;
		p.Insert("OnRemove"), p.Insert("netID|" + to_string(pInfo(peer)->netID) + "\n");
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage");
		p2.Insert("`5<`0" + get_player_nick(peer) + "`` left, `w" + to_string(w_c) + " `5others here>``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_name) {
				p.CreatePacket(currentPeer);
				if (w_c <= 14 and not pInfo(peer)->invis) {
					if (world_name != Hide_N_Seek.hidenseekworld && force == false) {
						packet_(currentPeer, "action|play_sfx\nfile|audio/door_shut.wav\ndelayMS|0");
						p2.CreatePacket(currentPeer);
					}
				}
			}
		}
	}
	if (not reset_) world_menu(peer);
}


void finish_hide() {
	string name_ = Hide_N_Seek.hidenseekworld;
	gamepacket_t p, p2, p3;
	p.Insert("OnEndMission");
	p2.Insert("OnConsoleMessage");
	p3.Insert("OnConsoleMessage"), p3.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: Hide And Seek is over.." + a + (Hide_N_Seek.hide_players.size() == Hide_N_Seek.seeker.size() ? "Seekers" : "  " + to_string(Hide_N_Seek.hide_players.size()) + " Hiders") + " won!");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == Hide_N_Seek.hidenseekworld) {
			int amount = 5000;
			if (Hide_N_Seek.hide_players.size() > Hide_N_Seek.seeker.size()) {
				if (pInfo(currentPeer)->hider) {
					OnSetGems(currentPeer, amount);
					p2.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: The game is over! You won " + setGems(amount) + " gems!");
					pInfo(currentPeer)->won_hider++;
					if (pInfo(currentPeer)->lwiz_step == 2) add_lwiz_points(currentPeer, 1);
				}
				else if (pInfo(currentPeer)->seeker) p2.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: You lost! " + to_string(Hide_N_Seek.hide_players.size() - Hide_N_Seek.seeker.size()) + " hiders left..");
			}
			else {
				add_peer_xp(currentPeer, 1500);
				OnSetGems(currentPeer, amount);
				p2.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: You found everyone, you received " + setGems(amount) + " gems and 1,500 XP!");
				pInfo(currentPeer)->won_seeker++;
			}
			exit_(currentPeer);
			p2.CreatePacket(currentPeer), p.CreatePacket(currentPeer);
		}
		if (pInfo(currentPeer)->hider or pInfo(currentPeer)->seeker) {
			pInfo(currentPeer)->hider = false;
			pInfo(currentPeer)->seeker = false;
		}
		p3.CreatePacket(currentPeer);
	}
	Hide_N_Seek.hide_players.clear();
	Hide_N_Seek.seeker.clear();
	Hide_N_Seek.last_hide_event = 0;
	Hide_N_Seek.wait_players_time = 0;
	Hide_N_Seek.hide_time = 0;
	Hide_N_Seek.total_players = 0;
	Hide_N_Seek.seeker_start = false;
	Hide_N_Seek.hider_start = false;
}


/*
void send_fix_world(World* world_) {
	for (int i_ = 0, add_up = -1; i_ < world_->drop_new.size(); i_++) {
		if (world_->drop_new[i_][0] == 0) {
			world_->drop_new.erase(world_->drop_new.begin() + i_);
			i_--;
		}
		else world_->drop_new[i_][2] = add_up += 1;
	}
	int lock_ = 0, first_ = -1;
	for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
		if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
			if (world_->blocks[i_].fg != 202 and world_->blocks[i_].fg != 204 and world_->blocks[i_].fg != 206 and world_->blocks[i_].fg != 4994 and world_->blocks[i_].fg != 10000) {
				lock_++;
			}
		}
	}
	if (lock_ > 1) {
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
				if (world_->blocks[i_].fg != 202 and world_->blocks[i_].fg != 204 and world_->blocks[i_].fg != 206 and world_->blocks[i_].fg != 4994 and world_->blocks[i_].fg != 10000) {
					if (first_ == -1) first_ = i_;
					world_->blocks[i_].fg = 0;
				}
			}
		}
		if (first_ != -1) world_->blocks[first_].fg = 242;
	}
	world_->total_drop_uid = world_->drop_new.size();
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
		exit_(currentPeer);
	}
}*/

void create_address_world(ENetPeer* peer, string name_, string currentworld_) {
	int rm = -1;
	name_ = to_upper(name_);
	currentworld_ = to_upper(currentworld_);
	get_world(name_);
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World world_ = worlds[p - worlds.begin()];
		vector<World>::iterator p2 = find_if(worlds.begin(), worlds.end(), [currentworld_](const World& b) { return b.name == currentworld_; });
		if (p2 != worlds.end()) {
			World c_world_ = worlds[p2 - worlds.begin()];
			c_world_.fresh_world = true;
			if (pInfo(peer)->superdev) {

			}
			else {
				if (to_lower(world_.owner_name) != to_lower(pInfo(peer)->tankIDName) || to_lower(c_world_.owner_name) != to_lower(pInfo(peer)->tankIDName)) return;
			}
			if (modify_inventory(peer, 2580, rm) == 0) {
				{
					{
						gamepacket_t p, p2, p3;
						p.Insert("OnAddNotification"), p.Insert("interface/large/jump_icon.rttex"), p.Insert("This world has just been renamed to `5" + name_ + "`` by the owner! (Please join it again)"), p.Insert("audio/gate_close.wav");
						p2.Insert("OnConsoleMessage"), p2.Insert("Ok, " + currentworld_ + " and " + name_ + " have swapped names!");
						p3.Insert("OnConsoleMessage"), p3.Insert("This world has just been renamed to `5" + name_ + "`` by the owner! (Please join it again)");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_.name or pInfo(currentPeer)->world == c_world_.name) {
								p.CreatePacket(currentPeer);
								p2.CreatePacket(currentPeer);
								p3.CreatePacket(currentPeer);
								exit_(currentPeer, false);
							}
						}
					}
					for (int i = 0; i < worlds.size(); i++) {
						if (worlds[i].name == currentworld_ or worlds[i].name == name_) {
							save_world(worlds[i].name, false);
							worlds.erase(worlds.begin() + i);
							i--;
						}
					}
					string path_ = "worlds/" + world_.name + "_.json";
					string path_2 = "worlds/" + c_world_.name + "_.json";
					string path_4 = "worlds/t_" + world_.name + "_.json";
					string path_3 = "worlds/t_" + c_world_.name + "_.json";
					rename(path_2.c_str(), path_3.c_str()); // dabartini worlda i temp
					rename(path_.c_str(), path_4.c_str()); // i kuri keicia worlda i temp
					rename(path_3.c_str(), path_.c_str()); // temp i kuri keicia
					rename(path_4.c_str(), path_2.c_str()); // temp i dabartini
				}
			}
		}
	}
}

string get_balloon_team(int team) {
	if (team == 1) return "4Punch";
	else if (team == 2) return "2Grow";
	else return "1Build";
}

void load_surgery(ENetPeer* peer, uint16_t tool) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (tool != 0 && tool != 1296) {
			int got = 0;
			if (inventory_contains(peer, tool) == 0) {
				end_surgery(peer);
				return;
			}
			if (pInfo(peer)->hand == 9068 && rand() % 100 < 10) {
			}
			else modify_inventory(peer, tool, got = -1);
		}
		bool has_tool = false;
		if (tool != 0) for (int i = 0; i < pInfo(peer)->available_surg_items.size(); i++) if (pInfo(peer)->available_surg_items[i] == tool) has_tool = true;
		if (tool == 0) has_tool = true;

		uint8_t skill = pInfo(peer)->surgery_skill;
		if (skill <= 10)	skill += 10;
		string surgery_fail_text = "", cured = "";
		if (has_playmod(pInfo(peer), "Calm Nerves") || has_playmod2(pInfo(peer),84)) skill *= 2;
		else {
			if (pInfo(peer)->hand == 6252) skill += 5;
			else if (pInfo(peer)->hand == 9068) skill += 5; // chance of not using surigcal tool
			if (pInfo(peer)->hair == 9592) skill += 5;
			if (pInfo(peer)->necklace == 3130) skill *= 2;
		}
		if (skill >= 100) skill = 100;
		if (rand() % skill < 3) {
			pInfo(peer)->s = false;
		}
		if (pInfo(peer)->started_type == 30) pInfo(peer)->gems += 500;
		if (pInfo(peer)->hand == 8536 && (pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25)) pInfo(peer)->s = true;
		if (tool == 999) pInfo(peer)->endtext = "giveup";
		if (tool != 0) {
			if (tool == 1258) {
				pInfo(peer)->spongUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->dirt = 0;
					cured = "mopped up the operating site.";
					pInfo(peer)->tooltext = "You mopped up the operating site.";
				}
				else
					pInfo(peer)->tooltext = "You somehow managed to eat the sponge.";
			}
			if (tool == 1260) {
				pInfo(peer)->scalpUsed += 1;
				if (pInfo(peer)->sleep == 0)
					pInfo(peer)->endtext = "You have cut the awake patient!";
				if (pInfo(peer)->incisions == pInfo(peer)->incneeded && pInfo(peer)->shattered == 0) {
					pInfo(peer)->tooltext = "You stabbed the patient in a vital organ!";
					pInfo(peer)->bleeding += 1;
					pInfo(peer)->s = false;
				}
				else {
					pInfo(peer)->incisions += 1;
					if (pInfo(peer)->s)
						pInfo(peer)->tooltext = "You've made a neat incision.";
					else
						pInfo(peer)->tooltext = "This will leave a nasty scar, but you managed to cut the right place.";
				}
			}
			if (tool == 1270) {
				pInfo(peer)->stitcUsed += 1;
				if (pInfo(peer)->s) {
					if (pInfo(peer)->incisions > 0) {
						cured = "stitched up an incision.";
						pInfo(peer)->tooltext = "You stitched up an incision.";
					}
					else if (pInfo(peer)->bleeding > 0) {
						cured = "bandaged some injuries.";
						pInfo(peer)->tooltext = "You bandaged some injuries.";
					}
					else
						pInfo(peer)->tooltext = "You tried to stitch your patient's mouth shut!.";
					if (pInfo(peer)->bleeding > 0)
						pInfo(peer)->bleeding -= 1;
					if (pInfo(peer)->incisions > 0)
						pInfo(peer)->incisions -= 1;
				}
				else
					pInfo(peer)->tooltext = "You somehow tied yourself up in stitches!";
			}
			if (tool == 1264) {
				pInfo(peer)->antisUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->site = min(pInfo(peer)->site + 20, 20);
					cured = "disinfected the operating site.";
				}
				else
					pInfo(peer)->tooltext = "You spilled antiseptic on your shoes. They are very clean now.";
			}
			if (tool == 1266) {
				pInfo(peer)->antibUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->fever -= 3;
					pInfo(peer)->tooltext = "You used antibiotics to reduce the patient's infection.";
					cured = "cured you with antibiotics.";
					if (pInfo(peer)->fever > -3)
						pInfo(peer)->antibs = true;
				}
				else {
					pInfo(peer)->fever += 1;
					pInfo(peer)->tooltext = "This is the wrong medication! The bacteria like it.";
				}
			}
			if (tool == 1268) {
				pInfo(peer)->splinUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->broken -= 1;
					cured = "splinted a broken bone.";
					pInfo(peer)->tooltext = "You splinted a broken bone.";
				}
				else
					pInfo(peer)->tooltext = "You ate a splint, good job!";
			}
			if (tool == 1262) {
				pInfo(peer)->anestUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->sleep += 10;
					cured = "falls into a deep sleep.";
					pInfo(peer)->tooltext = "The patient falls into a deep sleep.";
				}
				else
					pInfo(peer)->tooltext = "You end up inhaling all the anesthetic yourself. You feel woozy.";
			}
			if (tool == 4318) {
				pInfo(peer)->labkiUsed += 1;
				if (pInfo(peer)->s) {
					cured = "used a lab kit to discover you are suffering from " + pInfo(peer)->scantext;
					pInfo(peer)->labworked = true;
					if (pInfo(peer)->flu)
						pInfo(peer)->tooltext = "You performed lab work on the patient, and discovered they are suffering from " + pInfo(peer)->scantext;
					else
						pInfo(peer)->tooltext = "You performed lab work on the patient, and have antibiotics at the ready.";
				}
				else
					pInfo(peer)->tooltext = "You contaminated the sample.";
			}
			if (tool == 4316) {
				pInfo(peer)->ultraUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->sounded = true;
					if (pInfo(peer)->flu)
						pInfo(peer)->tooltext = "You scanned the patient , but didn't find any abnormal masses.";
					else {
						cured = "used a ultrasound to discover you are suffering from " + pInfo(peer)->scantext;
						pInfo(peer)->tooltext = "You scanned the patient with ultrasound, discovering they are suffering from " + pInfo(peer)->scantext;
					}
				}
				else
					pInfo(peer)->tooltext = "You scanned the nurse with your ultrasound!";
			}
			if (tool == 4308) {
				pInfo(peer)->pinsUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->shattered -= 1;
					pInfo(peer)->broken += 1;
					cured = "pinned a shattered bone together.";
					pInfo(peer)->tooltext = "You pinned a shattered bone together. Don't forget to splint it!";
				}
				else {
					pInfo(peer)->bleeding += 1;
					pInfo(peer)->tooltext = "You jabbed the pin through the artery!";
				}
			}
			if (tool == 4312) {
				pInfo(peer)->defibUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->heart = 0;
					cured = "used a defibrillator and shocken your life back!";
					pInfo(peer)->tooltext = "You shocked the patient back to life!";
				}
				else
					pInfo(peer)->tooltext = "You electrocuted yourself!";
			}
			if (tool == 4310) {
				pInfo(peer)->transUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->pulse = min(pInfo(peer)->pulse + 15, 40);
					cured = "tranfused several pints of blood into patient.";
					pInfo(peer)->tooltext = "You transfused several pints of blood into your patient.";
				}
				else
					pInfo(peer)->tooltext = "You spilled all of it! Kind of gross.";
			}
			if (tool == 4314) {
				pInfo(peer)->clampUsed += 1;
				if (pInfo(peer)->s) {
					pInfo(peer)->bleeding -= 1;
					cured = "clamped up some blood vessels.";
					pInfo(peer)->tooltext = "You clamped up some blood vessels.";
				}
				else
					pInfo(peer)->tooltext = "The clamp fell out of your hand, oh well.";
			}
			if (tool == 1296) {
				if (pInfo(peer)->s) {
					pInfo(peer)->fixed = true;
					cured = pInfo(peer)->postext;
					pInfo(peer)->tooltext = pInfo(peer)->postext;
				}
				else
					pInfo(peer)->tooltext = "You screwed it up! Try again.";
			}
			if (cured != "") {
				if (pInfo(peer)->surged_person != "") {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(peer)->surged_person != pInfo(currentPeer)->tankIDName) continue;
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert(get_player_nick(peer) + " " + cured), p2.CreatePacket(currentPeer);
					}
				}
				gamepacket_t p2;
				p2.Insert("OnConsoleMessage"), p2.Insert(cured), p2.CreatePacket(peer);
			}
			surgery_fail_text = pInfo(peer)->tooltext;
			// Making Glove available
			if (!pInfo(peer)->fixable && (pInfo(peer)->incisions == pInfo(peer)->incneeded) && pInfo(peer)->sounded) {
				pInfo(peer)->fixable = true;
				pInfo(peer)->tooltext += "\nadd_smalltext|`3" + pInfo(peer)->fixtext + "``|left|";
			}
			// Managing bleeding, site, dirt
			pInfo(peer)->dirt += pInfo(peer)->bleeding + pInfo(peer)->incisions;
			if (pInfo(peer)->dirt > 10)
				pInfo(peer)->dirt = 10;
			pInfo(peer)->site -= floor(pInfo(peer)->dirt / 3);
			if (pInfo(peer)->site < -25)
				pInfo(peer)->site = -25;
			if (pInfo(peer)->sleep == 0 && pInfo(peer)->incisions > 0)
				pInfo(peer)->bleeding += 1;
			if (pInfo(peer)->bleeding > 4)
				pInfo(peer)->bleeding = 4;

			// Managing temp, fever
			if (pInfo(peer)->fever < 0) {
				if (pInfo(peer)->fever > -0.06)
					pInfo(peer)->fever = 0;
				else if (!pInfo(peer)->antibs)
					pInfo(peer)->fever = (pInfo(peer)->fever - 3) / 2;
			}
			else if ((pInfo(peer)->site <= 2) && (pInfo(peer)->bleeding > 0) || (pInfo(peer)->site <= 4) && (pInfo(peer)->incisions > 0))
				pInfo(peer)->fever += 0.06;
			pInfo(peer)->temp += pInfo(peer)->fever;
			pInfo(peer)->temp = round(pInfo(peer)->temp * 100) / 100;
			if (pInfo(peer)->temp < 98.6)
				pInfo(peer)->temp = 98.6;
			pInfo(peer)->antibs = false;
			// Managing status, heart stopping
			if (((pInfo(peer)->sleep > 0) && (rand() % 100 < 5)) || (pInfo(peer)->heart > 0)) {
				pInfo(peer)->heart += 1;
			}
			else pInfo(peer)->sleep = max(pInfo(peer)->sleep - 1, 0);
			// Managing pulse
			pInfo(peer)->pulse -= pInfo(peer)->bleeding + min(pInfo(peer)->incisions, 1);
			// Checking for fail
			if (pInfo(peer)->pulse < 1 && pInfo(peer)->endtext .empty())
				pInfo(peer)->endtext = "Your patient bled out!";
			else if (pInfo(peer)->temp >= 111)
				pInfo(peer)->endtext = "Your patient succumbed to infection!";
			else if (pInfo(peer)->heart == 3)
				pInfo(peer)->endtext = "You failed to resucicate your patient in time!";
			else if (pInfo(peer)->sleep > 15)
				pInfo(peer)->endtext = "You put your patient to sleep. Permanently!";
			else if ((pInfo(peer)->incisions == 0) && (pInfo(peer)->broken == 0) && (pInfo(peer)->shattered == 0) && pInfo(peer)->fixed && (pInfo(peer)->bleeding == 0) && (pInfo(peer)->temp < 101))
				pInfo(peer)->endtext = "success";

			// Tool text
			if (pInfo(peer)->s)
				pInfo(peer)->tooltext = "`3" + pInfo(peer)->tooltext + "``";
			else {
				pInfo(peer)->tooltext = "`3[```4Skill Fail (" + to_string(30 - pInfo(peer)->surgery_skill / 4) + "%)```3] `6" + pInfo(peer)->tooltext + "``";
				if (pInfo(peer)->surged_person != "") {
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(peer)->surged_person != pInfo(currentPeer)->tankIDName) continue;
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage"), p2.Insert("[`4Skill Fail (" + to_string(30 - skill / 4) + "%)``] `6" + surgery_fail_text + "``"), p2.CreatePacket(currentPeer);
					}
				}
			}
		}

		// Diagnosed
		string diagnosed = "";
		if (!pInfo(peer)->sounded && !pInfo(peer)->flu || !pInfo(peer)->labworked && pInfo(peer)->flu)
			diagnosed += "`4The patient has not been diagnosed.``";
		else if (!pInfo(peer)->fixable || pInfo(peer)->flu || pInfo(peer)->incneeded == 0)
			diagnosed += (pInfo(peer)->pretext);
		else if (!pInfo(peer)->fixed) {
			diagnosed += (pInfo(peer)->fixtext);
		}
		else
			diagnosed += (pInfo(peer)->postext);
		// Pulse
		string pulse = "Pulse: ";
		if (pInfo(peer)->pulse < 11)
			pulse += "`4Extremely Weak``";
		else if (pInfo(peer)->pulse < 21)
			pulse += "`6Weak``";
		else if (pInfo(peer)->pulse < 31)
			pulse += "`3Steady``";
		else
			pulse += "`2Strong``";
		// Status
		string status = "Status: ";
		if (pInfo(peer)->heart > 0)
			status += "`4Heart `4stopped!``";
		else if (pInfo(peer)->sleep == 0)
			status += (pInfo(peer)->fixed ? "`3" : "`4") + a + "Awake``";
		else if (pInfo(peer)->sleep < 3)
			status += "`6Coming to``";
		else
			status += "`2Unconcsious``";
		// Temp
		string temp = "Temp: ";
		stringstream stream;
		stream << std::fixed << std::setprecision(1) << pInfo(peer)->temp;
		if (pInfo(peer)->temp < 100)
			temp += "`2" + stream.str() + "``";
		else if (pInfo(peer)->temp < 104)
			temp += "`3" + stream.str() + "``";
		else if (pInfo(peer)->temp < 106)
			temp += "`6" + stream.str() + "``";
		else
			temp += "`4" + stream.str() + "``";
		// Operation site
		string operation = "Operation site: ";
		if (pInfo(peer)->site < -3)
			operation += "`4Uns`4anitary``";
		else if (pInfo(peer)->site < -1)
			operation += "`6Unc`6lean``";
		else if (pInfo(peer)->site < 1)
			operation += "`3Not `3sanitized``";
		else operation += "`2Cl`2ean``";
		// Dirt
		string dirt = "";
		if (pInfo(peer)->dirt == 10)
			dirt += "`4You can't see what you `4are doing!";
		else if (pInfo(peer)->dirt > 4)
			dirt += "`6It is becoming hard to see your work.";
		// Incisions
		string incisions = "Incisions: ";
		if (pInfo(peer)->incisions == 0)
			incisions += "`2" + to_string(pInfo(peer)->incisions) + "``";
		else
			incisions += "`3" + to_string(pInfo(peer)->incisions) + "``";
		// Bones
		string bones = "";
		if (pInfo(peer)->broken + pInfo(peer)->shattered > 0 && pInfo(peer)->sounded) {
			bones += "Bones: ";
			if (pInfo(peer)->broken > 0) {
				if (pInfo(peer)->broken > 2)
					bones += "`4" + to_string(pInfo(peer)->broken) + " broken``";
				else
					bones += "`6" + to_string(pInfo(peer)->broken) + " broken``";
			}
			if (pInfo(peer)->broken > 0 && pInfo(peer)->shattered > 0)
				bones += ", ";
			if (pInfo(peer)->shattered > 0) {
				if (pInfo(peer)->shattered > 2)
					bones += "`4" + to_string(pInfo(peer)->shattered) + " shattered``";
				else
					bones += "`6" + to_string(pInfo(peer)->shattered) + " shattered``";
			}
		}
		// Bleeding
		string bleeding = "";
		if (pInfo(peer)->bleeding > 0) {
			bleeding += "Patient is ";
			if (pInfo(peer)->bleeding == 1)
				bleeding += "losing blood `3slow`3ly.``";
			else if (pInfo(peer)->bleeding == 4)
				bleeding += "losing blood `4Extremely `4Fast!``";
			else {
				bleeding += "`6losing `6blood!``";
			}
		}
		// Fever
		string fever = "";
		if (pInfo(peer)->fever > 0 && pInfo(peer)->temp > 100) {
			fever += "Patient's fever is ";
			if (pInfo(peer)->fever < 0.5)
				fever += "`3slowly `3rising.``";
			else if (pInfo(peer)->fever > 2)
				fever += "`4climbing `4fast!``";
			else {
				fever += "`6clim`6bing!``";
			}
		}
		// Special: heart stop and cut awake
		string heart_stopped = "";
		if (pInfo(peer)->heart == 1)
			heart_stopped += "`4The patient's `4heart `4has stopped!``";
		else if (pInfo(peer)->incisions > 0 && pInfo(peer)->sleep == 0)
			heart_stopped += "`4The patient `4screams and flails!``";


		string tools_available = "";
		pInfo(peer)->available_surg_items.clear();
		vector <int> tools{ 1258 , 1260 ,1270,1266, 1264 , 1296 ,4316, 4318 , 1262, 1268, 4312, 4308, 4314, 4310 };
		for (int i = 0, have_tools = 0; i < tools.size(); i++) {
			if (toolavailable(peer, tools[i], have_tools)) {
				if (tools[i] == 1296) have_tools = 1;
				string name = items[tools[i]].ori_name;
				replaceAll(name, "Surgical ", "");
				tools_available += "\nadd_button_with_icon|tool"+to_string(tools[i]) + "|`$"+name + "``|noflags|" + to_string(tools[i]) + "|" + to_string(have_tools) + "|";
				pInfo(peer)->available_surg_items.push_back(tools[i]);
			}
			else tools_available += "\nadd_button_with_icon|tool0||noflags|4320||";
		}
		if (pInfo(peer)->endtext .empty()) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + (pInfo(peer)->surged_person .empty() ? "Surg-E" : pInfo(peer)->surged_display) + "``|left|18|\nadd_smalltext|" + diagnosed + "|left|\nadd_smalltext|" + pulse + "    " + status + "|left|\nadd_smalltext|" + temp + "    " + operation + "|left|" + (dirt != "" ? "\nadd_smalltext|" + dirt + "|left|" : "") + "\nadd_smalltext|" + incisions + "    " + (bones != "" ? bones : "") + "|left|" + (fever != "" ? "\nadd_smalltext|" + fever + "|left|" : "") + "" + (bleeding != "" ? "\nadd_smalltext|" + bleeding + "|left|" : "") + "\nadd_spacer|small|" + (pInfo(peer)->tooltext != "" ? "\nadd_smalltext|" + pInfo(peer)->tooltext + "|left|" : "") + "" + (heart_stopped != "" ? "\nadd_spacer|small|\nadd_smalltext|" + heart_stopped + "|left|" : "") + "\ntext_scaling_string|Defibrillator|" + tools_available + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|tool999|Give up!|noflags|0|0|\nend_dialog|surgery|||");
			p.CreatePacket(peer);
			pInfo(peer)->s = true;
		}
		else
		{
			if (pInfo(peer)->hand == 8536 && pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) {
				int remove = -1;
				modify_inventory(peer, 8536, remove);
			}
			if (pInfo(peer)->endtext == "success") {
				if (pInfo(peer)->lwiz_step == 12) add_lwiz_points(peer, 1);
				if (event_item == 6250)add_points(peer, pInfo(peer)->hand);
				if (has_playmod2(pInfo(peer), 142)) OnSetGems(peer, 250);
				if (pInfo(peer)->grow4good_surgery < 5 && pInfo(peer)->grow4good_surgery != -1) daily_quest(peer, false, "surgery", 1);
				pInfo(peer)->surgery_started = false;
				if (pInfo(peer)->surgery_skill < 100) pInfo(peer)->surgery_skill++;
				add_event_xp(peer, 1, "surgeon");
				pInfo(peer)->surgery_done++;
				if (has_playmod2(pInfo(peer), 107)) add_peer_xp(peer, (pInfo(peer)->hand == 7754 ? 450 * 1.3 : 150 * 1.3), (pInfo(peer)->hand == 7754 ? true : false));
				else add_peer_xp(peer, (pInfo(peer)->hand == 7754 ? 450 : 150), (pInfo(peer)->hand == 7754 ? true : false));
				if (pInfo(peer)->su_8552_2 >= 3000 && pInfo(peer)->hair == 9488) pInfo(peer)->su_8552_3++;
				if (pInfo(peer)->shirt == 8448 && pInfo(peer)->feet == 8550 && pInfo(peer)->hair == 8444 && pInfo(peer)->necklace == 8442 && pInfo(peer)->face == 8446 && pInfo(peer)->pants == 8450) pInfo(peer)->su_8552_1++;
				if (pInfo(peer)->su_8552_1 >= 2000 && pInfo(peer)->back == 8552) pInfo(peer)->su_8552_2++;
				if (pInfo(peer)->su_8552_1 >= 2000 && pInfo(peer)->mercy == false) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					int c_ = 1;
					if (modify_inventory(peer, 8552, c_) == 0) {
						pInfo(peer)->mercy = true;
						packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
						p.Insert("You received `2Angel of Mercy's Wings`` for completing 2,000 Surgeries while wearing Blinking Set!");
						gamepacket_t p3;
						p3.Insert("OnParticleEffect"), p3.Insert(46), p3.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y +16);
						p.CreatePacket(peer);
					}
					else p.Insert("You have finished Angel of Mercy quest, but your inventory is full! Clear inventory and complete another surgery.");
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
				}
				if (pInfo(peer)->su_8552_2 >= 3000 && pInfo(peer)->drtitle == false) {
					pInfo(peer)->drtitle = true;
					packet_(peer, "action|play_sfx\nfile|audio/piano_nice.wav\ndelayMS|0");
					gamepacket_t p, p2, p3;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!"), p.Insert(0), p.Insert(1);
					p2.Insert("OnConsoleMessage"), p2.Insert("You received `2Dr.Title`` for completing 3,000 Surgeries while wearing Angel Of Mercy Wings!");
					p3.Insert("OnParticleEffect"), p3.Insert(46), p3.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y +16);
					p3.CreatePacket(peer);
					p.CreatePacket(peer), p2.CreatePacket(peer);
				}
				int give_times = 1;
				if (pInfo(peer)->gp) {
					if (complete_gpass_task(peer, "Surg")) give_times++;
				}
				vector<int> list{ 9902,7960, 13138, 2992, 12466, 12468, 12470, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 2586, 782, 3536, 764, 4176, 13138, 2992, 12466, 12468, 12470, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 2586, 782, 3536, 764, 4176, 13138, 2992, 12466, 12468, 12470, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 2586, 782, 3536, 764, 4176, 13138, 2992, 12466, 12468, 12470, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 1258, 1268, 1264, 1266, 1262, 1260, 1270, 4318, 4314, 4308, 4310, 4316, 4312, 1242, 1244, 1246, 1248, 1282, 1284, 1286, 1290, 1292, 1288, 1294, 1256, 2586, 782, 3536, 764, 4176 };
				int prize_to_pacient = list[rand() % list.size()];
				if (pInfo(peer)->started_type == 27 || pInfo(peer)->started_type == 21 || pInfo(peer)->started_type == 22 || pInfo(peer)->started_type == 19 || pInfo(peer)->started_type == 18 || pInfo(peer)->started_type == 28 || pInfo(peer)->started_type == 23 || pInfo(peer)->started_type == 26 || pInfo(peer)->started_type == 24 || pInfo(peer)->started_type == 25) list.push_back(8534);
				if (thedaytoday == 6 && rand() % 250 < 1) list = { 4334, 4330, 4326, 4328, 4324, 10570, 12224, 4334, 4330, 4326, 4328, 4324, 10570, 12224, 4334, 4330, 4326, 4328, 4324, 10570, 12224, 4334, 4330, 4326, 4328, 4324, 10570, 12224, 9488 };
				if (rand() % 200 < 1) list.insert(list.end(), { 13034, 3172,4322,10774,11770 });
				if (rand() % 450 < 1) list = { 12224, 4322 ,2976, 4080,11872, 3790, 4990, 8954, 1506, 1274, 1252, 2992, 3172, 10092, 11224, 9000, 10112, 10094 };
				if (rand() % 450 < 1) list = { 12292, 12294, 12342, 12372, 12444 };
				if (rand() % 2 < 1) {
					if (pInfo(peer)->started_type == 27) list.push_back(8442);
					if (pInfo(peer)->started_type == 21) list.push_back(8482);
					if (pInfo(peer)->started_type == 22) list.push_back(8486);
					if (pInfo(peer)->started_type == 19) list.push_back(8480);
					if (pInfo(peer)->started_type == 18) {
						list.push_back(8478);
						if (rand() % 3 < 1) list.insert(list.end(), { 8488,8452,8454 });
					}
					if (pInfo(peer)->started_type == 28 && rand() % 10 < 1)  list.insert(list.end(), { 8466,8468,8494 });
					if (pInfo(peer)->started_type == 23) {
						list.push_back(8444);
						if (rand() % 3 < 1) list.push_back(8492);
					}
					if (pInfo(peer)->started_type == 26) {
						list.push_back(8448);
						if (rand() % 3 < 1) list.insert(list.end(), { 8474,8476,8498 });
					}
					if (pInfo(peer)->started_type == 24) {
						list.push_back(8450);
						if (rand() % 3 < 1) list.insert(list.end(), { 8472,8496 });
					}
					if (pInfo(peer)->started_type == 25) {
						list.push_back(8550);
						if (rand() % 3 < 1) list.insert(list.end(), { 8458,8456,8490 });
					}
				}
				if (rand() % 3500 < 1) list = { 8284, 1614 };
				if (pInfo(peer)->started_type == 31) list.push_back(2900);
				if (rand() % 100 < 1) list.push_back(12566);
				if (rand() % 200 < 1) list.push_back(12568);
				int item = 0, got = 1;
				for (int i = 0; i < give_times; i++) {
					item = list[rand() % list.size()], got = 1;
					if (item == 1290) got = 10;
					/*
					if (item == 13158) {
						got = 12;
						ubi_sold_3 += 12;
					}*/
					if (item == 1294 || item == 1288 || item == 1292 || item == 1258 || item == 1268 || item == 1264 || item == 1266 || item == 1262 || item == 1260 || item == 1270 || item == 4318 || item == 4314 || item == 4308 || item == 4310 || item == 4316 || item == 4312) got = 5;
					int give_prize = 1;
					int give_rn = got;
					if (modify_inventory(peer, item, give_prize = got) != 0) {
						string name_ = pInfo(peer)->world;
						vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p != worlds.end()) {
							World* world_ = &worlds[p - worlds.begin()];
							world_->fresh_world = true;
							WorldDrop drop_block_{};
							drop_block_.id = item, drop_block_.count = give_rn, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
							dropas_(world_, drop_block_);
						}
					}
					give_prize = 1;
					if (modify_inventory(peer, 4298, give_prize = 1) == 0) {
					}
					else {
						int has_caduc = 0;
						modify_inventory(peer, 4298, has_caduc);
						if (modify_inventory(peer, 4300, give_prize = 2) == 0 and has_caduc >= 200) modify_inventory(peer, 4298, has_caduc = -199);
					}
				}
				gamepacket_t p, p2, p3;
				p.Insert("OnConsoleMessage");
				if (pInfo(peer)->surged_person .empty()) p.Insert("Hey, somebody left " + to_string(got) + " " + items[item].ori_name + " in this patient last time they operated!");
				else p.Insert("`w" + pInfo(peer)->surged_display + "``'s parents are so glad you saved their child that they give you " + to_string(got) + " " + items[item].ori_name + "!");
				p.CreatePacket(peer);
				p3.Insert("OnConsoleMessage"), p3.Insert("`2YOU `2SAVED YOUR `2PATIENT!`"), p3.CreatePacket(peer);
				p2.Insert("OnConsoleMessage"), p2.Insert("You got " + to_string(got) + " `2" + items[item].ori_name + "`` and a `3Caduceus``!"), p2.CreatePacket(peer);
				if (pInfo(peer)->surged_person != "") {
					gamepacket_t p, p2;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[``" + get_player_nick(peer) + " `2cured`` `0" + pInfo(peer)->surged_display + "`` of " + pInfo(peer)->surgery_name + "`7]``"), p.Insert(0), p.Insert(0);
					p2.Insert("OnConsoleMessage"), p2.Insert("`7[``" + get_player_nick(peer) + " `2cured`` `0" + pInfo(peer)->surged_display + "`` of " + pInfo(peer)->surgery_name + "`7]``");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
						if (pInfo(peer)->surged_person == pInfo(currentPeer)->tankIDName) {
							add_peer_xp(currentPeer, 500);
							int give_prize = got;
							if (modify_inventory(currentPeer, prize_to_pacient, give_prize) == 0) {
							}
							gamepacket_t p3;
							p3.Insert("OnConsoleMessage"), p3.Insert("You are healed! Celebrate your good health with 500 Gems and 1 " + items[prize_to_pacient].ori_name + "!"), p3.CreatePacket(currentPeer);
							OnSetGems(currentPeer, 500);
						}
						p.CreatePacket(currentPeer);
						p2.CreatePacket(currentPeer);
					}
				}
				pInfo(peer)->surged_person = "", pInfo(peer)->surged_display = "";
			}
			else end_surgery(peer);
		}
	}
}


bool block_access(ENetPeer* peer, World* world_, WorldBlock* block_, bool vend = false, bool admin_access = false, bool lock_access = false, bool public_world = false) {
	if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) || pInfo(peer)->superdev) return true;
	if (vend) {
		if (world_->world_settings & Gtps3::SETTINGS_3 && public_world == false) {
			if (not block_->locked && find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_->admins.end()) return true;
		}
		if (block_->locked) {
			WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
			if (to_lower(block2_->owner_name) == to_lower(pInfo(peer)->tankIDName)) return true;
		}
		else if (world_->owner_name .empty() && public_world == false) return true;
	}
	else {
		if (block_->locked) {
			WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
			if (lock_access == false) if (find(block2_->admins.begin(), block2_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != block2_->admins.end()) return true;
			if (to_lower(block2_->owner_name) == to_lower(pInfo(peer)->tankIDName)) return true;
			if (public_world == false && block2_->spin) return true;
		}
		else {
			if (public_world == false && (world_->owner_name .empty() || world_->world_settings & Gtps3::SETTINGS_4)) return true;
			if (admin_access == false) if (find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_->admins.end()) return true;
		}
	}
	return false;
}

string get_lwiz_quest_name(ENetPeer* peer) {
	string deliver_text = "You have none to deliver!";
	if ((pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1].size() == 3 && inventory_contains(peer, pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][2]) != 0) or (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] >= pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1])) deliver_text = "Deliver!";
	return "set_default_color|`o\nadd_label_with_icon|big|`9" + get_quest_item("", pInfo(peer)->lwiz_quest) + "``|left|1790|\nadd_smalltext|(Step " + to_string(pInfo(peer)->lwiz_step) + "/20)|left|\nadd_spacer|small|\nadd_textbox|" + get_quest_name(peer, pInfo(peer)->lwiz_quest, pInfo(peer)->lwiz_step) + "|left|" + (pInfo(peer)->lwiz_step == 15 ? "\nadd_smalltext|(For example, if you smash a rarity-50 tree and get 3 fruit from it, you get 150 points)|left|" : "") + "" + (pInfo(peer)->lwiz_step == 5 || pInfo(peer)->lwiz_step == 11 ? "\nadd_smalltext|(For example, if you " + a + (pInfo(peer)->lwiz_step == 5 ? "plant a tree" : "smash a block") + " of rarity 50, you get 50 points. A Dirt " + (pInfo(peer)->lwiz_step == 5 ? "Tree" : "block") + " is 1 point because it is rarity 1)|left|" : (pInfo(peer)->lwiz_step == 13 ? "\nadd_smalltext|(Providers are items like Science Stations and Cows, that give you an item on a regular basis)|" : "")) + "\nadd_spacer|small|\nadd_smalltext|(Current progress: " + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0]) + "/" + setGems(pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) + ")|left|\nadd_button|deliver|`oDeliver!``|noflags|0|0|\nadd_button|give_up|`oGive up this quest``|noflags|0|0|\nend_dialog|wizard_quests|Goodbye!||";
}
void lwiz_quest(ENetPeer* peer, string type) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
		if (not block_access(peer, world_, block_)) return;
			if (block_->fg == 1790) {
				gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (pInfo(peer)->level >= 40) {
						if (pInfo(peer)->lwiz_quest == 0) {
							if (type == "open") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`#Legendary Wizard``|left|1790|\nadd_label|small|Greetings, traveler! I am the Legendary Wizard.  Should you wish to embark on a Legendary Quest, simply choose one blow.|left|\nadd_spacer|small|\nadd_button|Quest For Honor|`9Quest For Honor``|noflags|0|0|\nadd_button|Quest For Fire|`9Quest For Fire``|noflags|0|0|\nadd_button|Quest Of Steel|`9Quest Of Steel``|noflags|0|0|\nadd_button|Quest Of The Heavens|`9Quest Of The Heavens``|noflags|0|0|\nadd_button|Quest For The Blade|`9Quest For The Blade``|noflags|0|0|\nadd_button|Quest For Candour|`9Quest For Candour``|noflags|0|0|\nadd_button|Quest For The Sky|`9Quest For The Sky``|noflags|0|0|\nadd_button|Quest Of The Owl|`9Quest Of The Owl``|noflags|0|0|\nadd_button|Quest Of The Mech|`9Quest Of The Mech``|noflags|0|0|\nadd_button|Quest Of The Dark|`9Quest Of The Dark``|noflags|0|0|\nend_dialog|wizard|No Thanks||");
							else if (type == "open_Quest Of The Dark" || type == "open_Quest Of The Mech" || type == "open_Quest Of The Owl" || type == "open_Quest For The Sky" || type == "open_Quest For Honor" || type == "open_Quest For Fire" || type == "open_Quest Of Steel" || type == "open_Quest Of The Heavens" || type == "open_Quest For The Blade" || type == "open_Quest For Candour") {
								string vardas = type;
									replaceAll(vardas, "open_", "");
									p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9" + vardas + "``|left|1790|\nadd_smalltext|This quest will challenge every fiber of your Growtopian being. It will cost you thousands of gems, weeks or months of time, and possibly your friends and family.|left|\nadd_smalltext|Every quest has 20 steps to complete, and each step alone is probably more than most Growtopians could manage.|left|\nadd_smalltext|But the rewards are also vast. If you complete this quest, you will earn the `9" + get_quest_item(type) + "``! These quest rewards are `5Untradeable``, and you will truly be a Legendary Growtopian if you complete a quest.|left|\nadd_smalltext|You may turn in your quests at any Legendary Wizard you have access to (we're in a union), but I will vanish permamently if somebody turns in their final quest step to me, so don't let other people have access to me!|left|\nadd_smalltext|There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all progress on this quest. So choose your quest wisely and see it through to the end!|left|\nadd_spacer|small|\nadd_textbox|So... now that you've received the official disclaimer, are you truly prepared to embark on the " + vardas + "?|left|\nend_dialog|wizard_start_" + type + "|No!|Yes!|");

							}
							else if (type == "start_open_Quest Of The Dark" || type == "start_open_Quest Of The Mech" || type == "start_open_Quest Of The Owl" || type == "start_open_Quest For The Sky" || type == "start_open_Quest For Honor" || type == "start_open_Quest For Fire" || type == "start_open_Quest Of Steel" || type == "start_open_Quest Of The Heavens" || type == "start_open_Quest For The Blade" || type == "start_open_Quest For Candour") {
								if (type == "start_open_Quest For Honor") pInfo(peer)->legendary_quest = legendary_quests[0], pInfo(peer)->lwiz_quest = 1;
								else if (type == "start_open_Quest For Fire") pInfo(peer)->legendary_quest = legendary_quests[1], pInfo(peer)->lwiz_quest = 2;
								else if (type == "start_open_Quest Of Steel") pInfo(peer)->legendary_quest = legendary_quests[2], pInfo(peer)->lwiz_quest = 3;
								else if (type == "start_open_Quest Of The Heavens") pInfo(peer)->legendary_quest = legendary_quests[3], pInfo(peer)->lwiz_quest = 4;
								else if (type == "start_open_Quest For The Blade") pInfo(peer)->legendary_quest = legendary_quests[4], pInfo(peer)->lwiz_quest = 5;
								else if (type == "start_open_Quest For Candour") pInfo(peer)->legendary_quest = legendary_quests[5], pInfo(peer)->lwiz_quest = 6;
								else if (type == "start_open_Quest For The Sky") pInfo(peer)->legendary_quest = legendary_quests[6], pInfo(peer)->lwiz_quest = 7;
								else if (type == "start_open_Quest Of The Owl") pInfo(peer)->legendary_quest = legendary_quests[7], pInfo(peer)->lwiz_quest = 8;
								else if (type == "start_open_Quest Of The Mech") pInfo(peer)->legendary_quest = legendary_quests[8], pInfo(peer)->lwiz_quest = 9;
								else if (type == "start_open_Quest Of The Dark") pInfo(peer)->legendary_quest = legendary_quests[9], pInfo(peer)->lwiz_quest = 10;
								p.Insert(get_lwiz_quest_name(peer));
							}
						}
						else p.Insert(get_lwiz_quest_name(peer));
					}
					else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`#Legendary Wizard``|left|1790|\nadd_label|small|Greetings, traveler! I am the Legendary Wizard.  Should you wish to embark on a Legendary Quest, simply choose one blow.|left|\nadd_spacer|small|\nadd_label|small|Oh wait, sorry... looks like you aren't yet legendary enough for Legendary Quests. You must be at least Level 40 to begin your journey!|left|\nend_dialog|wizard|Darn It||");
				p.CreatePacket(peer);
			}
	}
}

void offering_table(ENetPeer* peer, WorldBlock* block_ = NULL, string button = "", int item = 0, int count = 0, int slot = 0) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (block_ == NULL) block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
		if (block_ != NULL) {
			if (block_access(peer, world_, block_)) {
				if (block_->fg == 12598) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (button .empty()) {
						if (item != 0) {
							if (block_->donates.size() < 10) {
								Donate donate_{};
								donate_.item = item, donate_.count = count, donate_.name = pInfo(peer)->tankIDName, donate_.text = "";
								block_->donates.push_back(donate_);
								modify_inventory(peer, item, count *= -1);
							}
						}
						int count = 0, all_ = 0;
						string list = "";
						for (int i_ = 0; i_ < block_->donates.size(); i_++, all_++) {
							count += block_->donates[i_].count;
							list += "\nadd_button_with_icon|slot_btn_" + to_string(i_) + "||frame|" + to_string(block_->donates[i_].item) + "|" + to_string(block_->donates[i_].count) + "|\nadd_custom_margin|x:-15;y:0|" + (i_ == 4 || i_ == 9 ? "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:-15|" : "");
						}
						for (int i_ = all_; i_ < 10; i_++, all_++) list += "\nadd_button_with_icon|slot_btn_" + to_string(i_) + "||frame|982||\nadd_custom_margin|x:-15;y:0|" + (i_ == 4 || i_ == 9 ? "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_custom_margin|x:0;y:-15|" : "");
						p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wOffer Mooncakes to the Moon``|left|12598|\nadd_spacer|small|\nadd_textbox|Fill the table with 10 Mooncakes and offer them to the Moon to receive 1 random reward.|left|\nadd_textbox|Select a Mooncake to place on the table.|left|" + list + "\nadd_textbox|Total Mooncakes on table: `5" + to_string(count) + "``|left|\nadd_smalltext|You get 1 reroll for every 100 Mooncakes offered.| left |\nadd_smalltext|The current offering will get `5" + to_string(count / 100) + " rerolls``.| left |\nadd_spacer|small|\nadd_button|offer_btn|Offer Mooncakes|noflags|0|0|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Depending on the types of Mooncakes offered the rewards may vary. You can check the possible rewards that can be received from your current offering here:|left|\nadd_spacer|small|\nadd_button|reward_list_btn|Reward List|noflags|0|0|\nend_dialog|mooncake_altar_dialog|Close||");
					}
					else if (button == "reward") {
						string epic = "", rare = "", uncommon = "";
						vector<int> already_added, already_added2;
						if (block_->donates.size() > 0) {
							for (int i_ = 0; i_ < block_->donates.size(); i_++) {
								if (find(already_added.begin(), already_added.end(), block_->donates[i_].item) == already_added.end()) {
									already_added.push_back(block_->donates[i_].item);

									for (int i = 0; i < items[block_->donates[i_].item].rare.size(); i++) {
										if (find(already_added2.begin(), already_added2.end(), items[block_->donates[i_].item].rare[i]) == already_added2.end()) {
											already_added2.push_back(items[block_->donates[i_].item].rare[i]);
											rare += "\nadd_label_with_icon|small|`w" + items[items[block_->donates[i_].item].rare[i]].ori_name + "``|left|" + to_string(items[block_->donates[i_].item].rare[i]) + "|";
										}
									}
									for (int i = 0; i < items[block_->donates[i_].item].epic.size(); i++) {
										if (find(already_added2.begin(), already_added2.end(), items[block_->donates[i_].item].epic[i]) == already_added2.end()) {
											already_added2.push_back(items[block_->donates[i_].item].epic[i]);
											epic += "\nadd_label_with_icon|small|`w" + items[items[block_->donates[i_].item].epic[i]].ori_name + "``|left|" + to_string(items[block_->donates[i_].item].epic[i]) + "|";
										}
									}
									for (int i = 0; i < items[block_->donates[i_].item].uncommon.size(); i++) {
										if (find(already_added2.begin(), already_added2.end(), items[block_->donates[i_].item].uncommon[i]) == already_added2.end()) {
											already_added2.push_back(items[block_->donates[i_].item].uncommon[i]);
											uncommon += "\nadd_label_with_icon|small|`w" + items[items[block_->donates[i_].item].uncommon[i]].ori_name + "``|left|" + to_string(items[block_->donates[i_].item].uncommon[i]) + "|";
										}
									}
								}
							}
						}
						p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wRewards table!``|left|12598|\nadd_spacer|small|\nadd_textbox|The following items my be received for the current offering:|left|" + a + (epic.empty() ? "" : "\nadd_spacer|small|\nadd_textbox|Epic|left|" + epic) + (rare.empty() ? "" : "\nadd_spacer|small|\nadd_textbox|Rare|left|" + rare) + "\nadd_spacer|small|\nadd_textbox|Uncommon|left|" + uncommon + "\nadd_label_with_icon|small|`wSunflower Pinwheel``|left|11270|\nadd_label_with_icon|small|`wTraditional Harvest Hat``|left|12622|\nadd_label_with_icon|small|`wTraditional Harvest Shirt``|left|12624|\nadd_label_with_icon|small|`wTraditional Harvest Dress``|left|12626|\nadd_spacer|small|\nadd_textbox|Common|left|\nadd_label_with_icon|small|`wChinese Lantern``|left|1054|\nadd_label_with_icon|small|`wScarecrow``|left|1064|\nadd_label_with_icon|small|`wSky Lantern``|left|1066|\nadd_label_with_icon|small|`wYellow Hanbok Top``|left|1070|\nadd_label_with_icon|small|`wPurple Hanbok Top``|left|1072|\nadd_label_with_icon|small|`wGreen Hanbok Top``|left|1074|\nadd_label_with_icon|small|`wPink Hanbok Skirt``|left|1076|\nadd_label_with_icon|small|`wBlue Hanbok Skirt``|left|1078|\nadd_label_with_icon|small|`wOrange Hanbok Skirt``|left|1080|\nadd_label_with_icon|small|`wYellow Hanbok Pants``|left|1082|\nadd_label_with_icon|small|`wPurple Hanbok Pants``|left|1084|\nadd_label_with_icon|small|`wGreen Hanbok Pants``|left|1086|\nadd_label_with_icon|small|`wMoon Block``|left|1834|\nadd_label_with_icon|small|`wHarvest Horn``|left|3868|\nadd_label_with_icon|small|`wBlue Hanbok Top``|left|3872|\nadd_label_with_icon|small|`wOrange Hanbok Top``|left|3874|\nadd_label_with_icon|small|`wBlue Hanbok Pants``|left|3876|\nadd_label_with_icon|small|`wOrange Hanbok Pants``|left|3878|\nadd_label_with_icon|small|`wGreen Hanbok Skirt``|left|3880|\nadd_label_with_icon|small|`wYellow Hanbok Skirt``|left|3882|\nadd_label_with_icon|small|`wSunflower Hair Pin``|left|3884|\nadd_label_with_icon|small|`wSheep``|left|3888|\nadd_label_with_icon|small|`wDragon Scales``|left|5098|\nadd_label_with_icon|small|`wLeaves``|left|5102|\nadd_label_with_icon|small|`wScarecrow Mask``|left|5118|\nadd_label_with_icon|small|`wZen Garden``|left|5198|\nadd_label_with_icon|small|`wMoon Palace``|left|12604|\nadd_label_with_icon|small|`wMoon Palace Roof``|left|12606|\nadd_label_with_icon|small|`wBuddy To He``|left|12608|\nadd_label_with_icon|small|`wMoon Palace Door``|left|12652|\nadd_spacer|small|\nadd_button|goto_maindialog|Thanks for the info|0|0|\nend_dialog|mooncake_reward_list_dialog|||");
					}
					else if (button == "reroll") {
						if (block_->offering_items.size() == 0) block_->offering_items = { 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,1834, 1834, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1834, 3868, 3872, 3874, 3876, 3878, 3880, 3882, 3884, 3888, 5098, 5102, 1062, 12604, 12604, 12604 };
						if (block_->shelf_1 > 100) {
							block_->shelf_1 -= 100;
							if (block_->offering_items.size() == 0) block_->shelf_1 = 5118;
							else block_->shelf_1 = block_->offering_items[rand() % block_->offering_items.size()];
						}
						p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wReward!``|left|12598|\nadd_spacer|small|\nadd_textbox|You received:|left|\nadd_label_with_icon|small|`w1 x " + items[block_->shelf_1].name + "``|left|" + to_string(block_->shelf_1) + "|\nadd_spacer|small|" + (block_->shelf_1 > 100 ? "\nadd_textbox|You have " + to_string(block_->shelf_1 / 100) + " rerolls remaining.|left|\nadd_button|reroll|Reroll|0|0|" : "") + "\nadd_button|take_reward|Claim Reward|0|0|" + (block_->shelf_1 > 100 ? "\nadd_smalltext|`6Claiming the reward will forfeit any remaining rerolls.``|left|" : "") + "\nend_dialog|mooncake_reward_dialog|||");
					}
					else if (button == "offer") {
						int start_offer = 0;
						for (int i_ = 0; i_ < block_->donates.size(); i_++) start_offer += block_->donates[i_].count;
						if (start_offer > 100 && block_->donates.size() >= 10) {
							block_->offering_items = { 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,1834, 1834, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1834,  5098, 5102, 5118, 5198, 12604, 12606, 12652, 1054 ,1064, 1066, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1834, 3868, 3872, 3874, 3876, 3878, 3880, 3882, 3884, 3888, 5098, 5102, 1062, 12604, 12604, 12604 };
							block_->shelf_1 = start_offer;
							vector<Donate>::iterator p3 = find_if(block_->donates.begin(), block_->donates.end(), [&](const Donate& a) { return a.item == 1096 || a.item == 7058 || a.item == 1828 || a.item == 11286; });
							if (p3 != block_->donates.end()) {
								Donate* found = &block_->donates[p3 - block_->donates.begin()];
								if (found->item == 1096) {
									vector<Donate>::iterator p2 = find_if(block_->donates.begin(), block_->donates.end(), [&](const Donate& a) { return a.item == 1828 || a.item == 11286 || a.item == 7058; });
									if (p2 != block_->donates.end()) {
										Donate* found2 = &block_->donates[p2 - block_->donates.begin()];
										if (found2->item == 1828)block_->offering_items.insert(block_->offering_items.end(), { 12380 });
										if (found2->item == 11286)block_->offering_items.insert(block_->offering_items.end(), { 12388 });
										if (found2->item == 7058)block_->offering_items.insert(block_->offering_items.end(), { 12390 });
									}
									if (rand() % 20 < 1)  block_->offering_items.insert(block_->offering_items.end(), { 12604, 12652, 12606, 12608, 12622, 12624, 12626 });
								}
							}
							for (int i_ = 0; i_ < block_->donates.size(); i_++) {
								int chance = 0;

								for (int i = 0; i < items[block_->donates[i_].item].epic.size(); i++) {
									if (rand() % 6500 - block_->donates[i_].count + items[block_->donates[i_].item].grindable_count < 1) {
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].epic[i]);
									}
								}
								for (int i = 0; i < items[block_->donates[i_].item].rare.size(); i++) {
									if (rand() % 4000 - block_->donates[i_].count + items[block_->donates[i_].item].grindable_count < 1) {
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].rare[i]);
									}
								}
								for (int i = 0; i < items[block_->donates[i_].item].uncommon.size(); i++) {
									if (rand() % 700 - block_->donates[i_].count + items[block_->donates[i_].item].grindable_count < 1) {
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].uncommon[i]);
										block_->offering_items.insert(block_->offering_items.end(), items[block_->donates[i_].item].uncommon[i]);
									}
								}
							}
							block_->donates.clear();
							block_->shelf_1 = block_->offering_items[rand() % block_->offering_items.size()];
							p.Insert("set_default_color|`w\nadd_label_with_icon|big|`wReward!``|left|12598|\nadd_spacer|small|\nadd_textbox|You received:|left|\nadd_label_with_icon|small|`w1 x " + items[block_->shelf_1].name + "``|left|" + to_string(block_->shelf_1) + "|\nadd_spacer|small|" + (block_->shelf_1 > 100 ? "\nadd_textbox|You have " + to_string(block_->shelf_1 / 100) + " rerolls remaining.|left|\nadd_button|reroll|Reroll|0|0|" : "") + "\nadd_button|take_reward|Claim Reward|0|0|" + (block_->shelf_1 > 100 ? "\nadd_smalltext|`6Claiming the reward will forfeit any remaining rerolls.``|left|" : "") + "\nend_dialog|mooncake_reward_dialog|||");
						}
						else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wNot Enough Mooncakes``|left|1432|\nadd_textbox|You must fill the table before you can offer the Mooncakes.|left|\nadd_spacer|small|\nadd_button|goto_maindialog|OK|0|0|\nadd_spacer|small|\nend_dialog|altar_warning_dialog|||");
					}
					p.CreatePacket(peer);
				}
			}
		}
	}
}

bool setstats(ENetPeer* peer, int i, string surged, string surged_display) {
	if (pInfo(peer)->surgery_started) {
		end_surgery(peer);
		return false;
	}
	if (has_playmod2(pInfo(peer), 86)) {
		gamepacket_t p;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(surged .empty() ? "I know it's just a robot, but the authorities don't even trust you operating on that with your malpractice issues." : "You can't perform surgery right now."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
		return false;
	}
	if (i < 0 || i > 31) i = rand() % 31;
	pInfo(peer)->started_type = i;
	pInfo(peer)->surged_person = surged;
	pInfo(peer)->surged_display = surged_display;
	pInfo(peer)->surgery_world = pInfo(peer)->world;
	pInfo(peer)->surgery_started = true;
	pInfo(peer)->sounded = false;
	pInfo(peer)->labworked = false;
	pInfo(peer)->fixed = false;
	pInfo(peer)->fixable = false;
	pInfo(peer)->flu = false;
	pInfo(peer)->pulse = 40;
	pInfo(peer)->site = 0;
	pInfo(peer)->sleep = 0;
	pInfo(peer)->dirt = 0;
	pInfo(peer)->broken = 0;
	pInfo(peer)->shattered = 0;
	pInfo(peer)->incisions = 0;
	pInfo(peer)->bleeding = 0;
	pInfo(peer)->incneeded = 0;
	pInfo(peer)->heart = 0;
	pInfo(peer)->temp = 98.6;
	pInfo(peer)->fever = 0;
	pInfo(peer)->pretext = "";
	pInfo(peer)->fixtext = "";
	pInfo(peer)->postext = "";
	pInfo(peer)->scantext = "";
	pInfo(peer)->tooltext = "Patient is prepped for surgery.";
	pInfo(peer)->endtext = "";
	pInfo(peer)->s = true;

	pInfo(peer)->spongUsed = 0;
	pInfo(peer)->scalpUsed = 0;
	pInfo(peer)->stitcUsed = 0;
	pInfo(peer)->antibUsed = 0;
	pInfo(peer)->antisUsed = 0;
	pInfo(peer)->ultraUsed = 0;
	pInfo(peer)->labkiUsed = 0;
	pInfo(peer)->anestUsed = 0;
	pInfo(peer)->defibUsed = 0;
	pInfo(peer)->splinUsed = 0;
	pInfo(peer)->pinsUsed = 0;
	pInfo(peer)->clampUsed = 0;
	pInfo(peer)->transUsed = 0;
	pInfo(peer)->surgery_name = "";

	if (pInfo(peer)->surged_person .empty()) {
		string name_ = pInfo(peer)->surgery_world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
			if (block_->fg == 4296 || block_->fg == 8558) {
				block_->fg = 0;
				update_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 0, false, true);
			}
			else return false;
		}
	}

	switch (i) {
	case 0:
		pInfo(peer)->fixed = true;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->broken = 1;
		pInfo(peer)->pretext = "Patient broke his arm.";
		pInfo(peer)->scantext = "a broken arm! You found 1 broken bone.";
		pInfo(peer)->surgery_name = "a broken arm.";
		break;
	case 1:
		pInfo(peer)->fixed = true;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->broken = 1;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->pretext = "Patient broke his leg.";
		pInfo(peer)->scantext = "a broken leg! You found 1 broken bone and 1 shattered bone.";
		pInfo(peer)->surgery_name = "a broken leg.";
		break;
	case 2:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 2.5;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the bird flu.";
		pInfo(peer)->scantext = "bird flu!";
		pInfo(peer)->surgery_name = "a bird flu!";
		break;
	case 3:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 3.6;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the turtle flu.";
		pInfo(peer)->scantext = "turtle flu!";
		pInfo(peer)->surgery_name = "a turtle flu!";
		break;
	case 4:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 2.4;
		pInfo(peer)->pretext = "Patient is showing signs of the monkey flu.";
		pInfo(peer)->scantext = "monkey flu!";
		pInfo(peer)->surgery_name = "a monkey flu!";
		break;
	case 5:
		pInfo(peer)->sounded = true;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->pretext = "Patient wants a nose job.";
		pInfo(peer)->fixtext = "You have cut into nasal area.";
		pInfo(peer)->postext = "You rearranged their face!";
		pInfo(peer)->surgery_name = "a nose job.";
		break;
	case 6:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->scantext = "a lung tumor!";
		pInfo(peer)->pretext = "Patient has a tumor in their lung.";
		pInfo(peer)->fixtext = "The lungs are now exposed.";
		pInfo(peer)->postext = "You excised the tumor!";
		pInfo(peer)->surgery_name = "a lung tumor!";
		break;
	case 7:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->scantext = "a heart attack!";
		pInfo(peer)->pretext = "Patient had a heart attack.";
		pInfo(peer)->fixtext = "The heart is now exposed for operating.";
		pInfo(peer)->postext = "You grafted in some nice new arteries!";
		pInfo(peer)->surgery_name = "a heart attack!";
		break;
	case 8:
		pInfo(peer)->incneeded = 5;
		pInfo(peer)->scantext = "a brain tumor!";
		pInfo(peer)->pretext = "Patient has a brain tumor, deep inside.";
		pInfo(peer)->fixtext = "You've finally found the tumor!";
		pInfo(peer)->postext = "You excised the tumor!";
		pInfo(peer)->surgery_name = "a brain tumor!";
		break;
	case 9:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 0.6;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->scantext = "a liver infection!";
		pInfo(peer)->pretext = "Patient has a liver infection.";
		pInfo(peer)->fixtext = "You've accessed the liver.";
		pInfo(peer)->postext = "You treated the source of the infection!";
		pInfo(peer)->surgery_name = "a liver infection!";
		break;
	case 10:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->scantext = "kidney failure!";
		pInfo(peer)->pretext = "Patient suffers from kidney failure.";
		pInfo(peer)->fixtext = "You now have access to the bad kidney.";
		pInfo(peer)->postext = "You popped in a fresh new kidney!";
		pInfo(peer)->surgery_name = "kidney failure!";
		break;
	case 11:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->scantext = "appendicitis!";
		pInfo(peer)->pretext = "Patient suffers from appendicitis.";
		pInfo(peer)->fixtext = "You now have access to the appendix.";
		pInfo(peer)->postext = "You yanked out the appendix!";
		pInfo(peer)->surgery_name = "appendicitis!";
		break;
	case 12:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->scantext = "swallowed World Lock!";
		pInfo(peer)->pretext = "Patient has swallowed a world lock.";
		pInfo(peer)->fixtext = "You've opened the stomach.";
		pInfo(peer)->postext = "You got the lock out!";
		pInfo(peer)->surgery_name = "a swallowed World Lock!";
		break;
	case 13:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 100.4;
		pInfo(peer)->scantext = "a herniated disc!";
		pInfo(peer)->pretext = "Patient's spine is damaged.";
		pInfo(peer)->fixtext = "You've opened up the vertebrae.";
		pInfo(peer)->postext = "You repaired the disc!";
		pInfo(peer)->surgery_name = "a herniated disc!";
		break;
	case 14:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 100.58;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->shattered = 4;
		pInfo(peer)->scantext = "broken everything! You found 4 shattered bones.";
		pInfo(peer)->pretext = "Patient was run over by a truck.";
		pInfo(peer)->fixtext = "You've found gravel in the knees.";
		pInfo(peer)->postext = "You removed the gravel!";
		pInfo(peer)->surgery_name = "a broken everything!";
		break;
	case 15:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->bleeding = 4;
		pInfo(peer)->scantext = "a serious head injury!";
		pInfo(peer)->pretext = "Patient has a serious head injury.";
		pInfo(peer)->fixtext = "You've opened the skull.";
		pInfo(peer)->postext = "You reduced the swelling!";
		pInfo(peer)->surgery_name = "a serious head injury!";
		break;
	case 16:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->broken = 2;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->scantext = "serious trauma! You found 2 broken bones and 1 shattered bone.";
		pInfo(peer)->pretext = "Patient suffered serious trauma with a punctured lung.";
		pInfo(peer)->fixtext = "You found the lung puncture.";
		pInfo(peer)->postext = "You repaired it.";
		pInfo(peer)->surgery_name = "a serious trauma!";
		break;
	case 17:
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->pulse = 30;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 4;
		pInfo(peer)->broken = 2;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->scantext = "massive trauma! You found 2 broken bones and 2 shattered bones.";
		pInfo(peer)->pretext = "Patient suffered massive trauma with internal bleeding.";
		pInfo(peer)->fixtext = "You found the internal bleed.";
		pInfo(peer)->postext = "You cauterized it.";
		pInfo(peer)->surgery_name = "a massive trauma!";
		break;
	case 18:
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->dirt = 15;
		pInfo(peer)->scantext = "torn punching muscle!";
		pInfo(peer)->pretext = "Patient has a torn punching muscle.";
		pInfo(peer)->fixtext = "You've accessed the arm muscles. ";
		pInfo(peer)->postext = "You patched the torn punching muscle! They should be back to punching in no time.";
		pInfo(peer)->surgery_name = "a torn punching muscle!";
		break;
	case 19:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->dirt = 0;
		pInfo(peer)->fever = 0;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->scantext = "gem cuts!";
		pInfo(peer)->pretext = "Patient is bleeding from multiple gem-induced cuts.";
		pInfo(peer)->fixtext = "You've examined the wounds.";
		pInfo(peer)->postext = "You've stitches the gem cuts closed and stopped the bleeding.";
		pInfo(peer)->surgery_name = "gem cuts!";
		break;
	case 20:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->dirt = 5;
		pInfo(peer)->scantext = "Grumbleteeth! You found 1 shattered bones.";
		pInfo(peer)->pretext = "Patient's teeth are chattering They sound angry.";
		pInfo(peer)->fixtext = "You removed grumbleteeth";
		pInfo(peer)->postext = "You've replaced the patient's angriest teeth and quited";
		pInfo(peer)->surgery_name = "Grumbleteeth!";
		break;
	case 21:
		pInfo(peer)->fixable = false;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->heart = 0;
		pInfo(peer)->fever = 1.56;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->scantext = "chicken feet! You found 2 shattered bones.";
		pInfo(peer)->pretext = "Patient feet have turned into chicken toes.";
		pInfo(peer)->fixtext = "You've insvestigated the feet.";
		pInfo(peer)->postext = "You fixed the patient feet. They look like normal blocky toes again!";
		pInfo(peer)->surgery_name = "chicken feet!";
		break;
	case 22:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 1;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 1.2;
		pInfo(peer)->dirt = 2;
		pInfo(peer)->scantext = "Broken Heart! You found 2 shattered bones.";
		pInfo(peer)->pretext = "Patient suffered from a Broken Heart.";
		pInfo(peer)->fixtext = "You've revealed the heart.";
		pInfo(peer)->postext = "You've repaired the fractured in the patient's heart";
		pInfo(peer)->surgery_name = "Broken heart!";
		break;
	case 23:
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->temp = 100.58;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->fever = 0.8;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 5;
		pInfo(peer)->scantext = "brain worms! You found 1 Shattered bone.";
		pInfo(peer)->pretext = "You've exposed the brain.";
		pInfo(peer)->fixtext = "You made a neat incision.";
		pInfo(peer)->postext = "You've shut down the worm party in the patient brain and cleared away their trash.";
		pInfo(peer)->surgery_name = "brain worms!";
		break;
	case 24:
		pInfo(peer)->incneeded = 0;
		pInfo(peer)->fixable = false;
		pInfo(peer)->temp = 98.6;
		pInfo(peer)->dirt = 0;
		pInfo(peer)->broken = 6;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->bleeding = 1;
		pInfo(peer)->scantext = "ecto bones! You found 6 Broken bones and 2 Shattered bones.";
		pInfo(peer)->pretext = "You've exposed the ribs";
		pInfo(peer)->fixtext = "You made an incision";
		pInfo(peer)->postext = "You pinned down all patient major bones and dyed them back to their normal color.";
		pInfo(peer)->surgery_name = "ecto bones!";
		break;
	case 25:
		pInfo(peer)->fixable = false;
		pInfo(peer)->pulse = 20;
		pInfo(peer)->temp = 104.6;
		pInfo(peer)->fever = 1.98;
		pInfo(peer)->shattered = 1;
		pInfo(peer)->incneeded = 2;
		pInfo(peer)->scantext = "Moldy Guts! You found 1 shattered bone.";
		pInfo(peer)->pretext = "Patient suffers from Moldy Guts.";
		pInfo(peer)->fixtext = "You've openned the abdomen.";
		pInfo(peer)->postext = "You'e cleaned out the patient's internal organs and applied a light air freshener";
		pInfo(peer)->surgery_name = "Moldy Guts!";
		break;
	case 26:
		pInfo(peer)->fixable = false;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 101.6;
		pInfo(peer)->fever = 2.0;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "fatty liver!";
		pInfo(peer)->pretext = "Patient suffered fatty liver.";
		pInfo(peer)->fixtext = "Patient poor diet has led to a high degree of fat build-up in their liver";
		pInfo(peer)->postext = "You pickup it.";
		pInfo(peer)->surgery_name = "fatty liver!";
		break;
	case 27:
		pInfo(peer)->fixed = false;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->temp = 105.6;
		pInfo(peer)->broken = 2;
		pInfo(peer)->fever = 2.6;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "Chaos Infection! You found 2 Broken bones.";
		pInfo(peer)->pretext = "Patient suffered chaos infection.";
		pInfo(peer)->fixtext = "Patient poor diet has led to a high degree of fat build-up in their liver";
		pInfo(peer)->postext = "You removed it.";
		pInfo(peer)->surgery_name = "Chaos Infection!";
		break;
	case 28:
		pInfo(peer)->fixed = false;
		pInfo(peer)->incneeded = 4;
		pInfo(peer)->temp = 100.1;
		pInfo(peer)->broken = 2;
		pInfo(peer)->fever = 3.1;
		pInfo(peer)->sleep = 3;
		pInfo(peer)->shattered = 2;
		pInfo(peer)->dirt = 10;
		pInfo(peer)->incneeded = 3;
		pInfo(peer)->bleeding = 3;
		pInfo(peer)->scantext = "Lupus! You found 2 Broken bones.";
		pInfo(peer)->pretext = "Patient suffered lupus.";
		pInfo(peer)->fixtext = "Chance of patient tearing skin, adding one extra incision";
		pInfo(peer)->postext = "You removed it.";
		pInfo(peer)->surgery_name = "Lupus!";
		break;
	case 29:
		pInfo(peer)->fixed = true;
		pInfo(peer)->flu = true;
		pInfo(peer)->temp = 107.6;
		pInfo(peer)->fever = 2.5;
		pInfo(peer)->dirt = 6;
		pInfo(peer)->pretext = "Patient is showing signs of the COVID-19.";
		pInfo(peer)->scantext = "COVID-19!";
		pInfo(peer)->surgery_name = "a COVID-19!";
		break;
	case 30:
		pInfo(peer)->incneeded = 7;
		pInfo(peer)->temp = 102.6;
		pInfo(peer)->fever = 0.6;
		pInfo(peer)->scantext = "a Ebola! Patient is having seizure.";
		pInfo(peer)->pretext = "Patient has Ebola.";
		pInfo(peer)->fixtext = "You've finally cured the seizure!";
		pInfo(peer)->postext = "You made the patient experience a seizure!";
		pInfo(peer)->surgery_name = "a Ebola!";
		break;
	case 31:
		pInfo(peer)->incneeded = 6;
		pInfo(peer)->temp = 103.6;
		pInfo(peer)->fever = 1.5;
		pInfo(peer)->scantext = "a Monkeypox! Patient is having pimples.";
		pInfo(peer)->pretext = "Patient has Monkeypox.";
		pInfo(peer)->fixtext = "You've finally cured the pimples!";
		pInfo(peer)->postext = "You made the patient experience a exhaustion!";
		pInfo(peer)->surgery_name = "a Monkeypox!";
		break;
	}
	gamepacket_t p;
	p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[``" + get_player_nick(peer) + " is performing surgery on " + pInfo(peer)->surged_display + "!`7]``"), p.Insert(0), p.Insert(0);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		p.CreatePacket(currentPeer);
	}
	load_surgery(peer, 0);
	return true;
}


void send_growscan_floating(ENetPeer* peer, string search, string type) {
	int total_floating = 0, total_rarity = 0, total_super_item = 0, total_gems = 0;
	vector<pair<int, int>> founditems;
	string name_ = pInfo(peer)->world;
	string found_list = "";
	vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (px != worlds.end()) {
		World* world_ = &worlds[px - worlds.begin()];
		for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
			if (world_->drop_new[i_][0] == 0) continue;
			if (world_->drop_new[i_][0] != 0 || world_->drop_new[i_][3] > 0 || world_->drop_new[i_][4] > 0) {
				if (search == "start") {
					total_floating++;
					if (items[world_->drop_new[i_][0]].rarity < 363) total_rarity += items[world_->drop_new[i_][0]].rarity * world_->drop_new[i_][1];
					else if (items[world_->drop_new[i_][0]].rarity == 999)total_super_item += world_->drop_new[i_][1];
					if (world_->drop_new[i_][0] == 112 || world_->drop_new[i_][0] == 4490) total_gems += (world_->drop_new[i_][0] == 4490 ? 1000 * world_->drop_new[i_][1] : world_->drop_new[i_][1]);
				}
				else if (type == "1" or type == "2" and items[world_->drop_new[i_][0]].blockType == BlockTypes::CLOTHING or type == "3" and items[world_->drop_new[i_][0]].blockType == BlockTypes::CONSUMABLE or type == "4" and items[world_->drop_new[i_][0]].blockType == BlockTypes::FOREGROUND or type == "5" and items[world_->drop_new[i_][0]].blockType == BlockTypes::SEED or type == "6" and items[world_->drop_new[i_][0]].blockType == BlockTypes::LOCK) {
					if (to_lower(items[world_->drop_new[i_][0]].name).find(to_lower(search)) != string::npos) {
						bool copy = true;
						for (int i = 0; i < founditems.size(); i++) {
							if (founditems[i].first == world_->drop_new[i_][0]) {
								founditems[i].second += world_->drop_new[i_][1];
								copy = false;
							}
						}
						if (copy) founditems.push_back(make_pair(world_->drop_new[i_][0], world_->drop_new[i_][1]));
					}
				}
			}
		}
		for (int i = 0; i < founditems.size(); i++) found_list += to_string(founditems[i].first) + "," + to_string(founditems[i].second) + ",";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (search == "start") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|`wTotal number in world: " + to_string(total_floating) + "|left\nadd_textbox|`wTotal floating item rarity: " + to_string(total_rarity) + "|left|\nadd_textbox|`wTotal super rare items: " + to_string(total_super_item) + "|left|\nadd_textbox|`wTotal gems: " + to_string(total_gems) + "|left|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|search_1|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|search_2|Search Clothing|noflags|0|0|\nadd_button|search_3|Search Consumables|noflags|0|0|\nadd_button|search_4|Search Blocks and Backgrounds|noflags|0|0|\nadd_button|search_5|Search Seeds|noflags|0|0|\nadd_button|search_6|Search Locks|noflags|0|0|\nadd_button|search_1|Search Others|noflags|0|0|\nadd_spacer|small|\nadd_button|back_to_gscan|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
	else {
		if (found_list .empty()) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|No items found.|left|\nadd_spacer|small|\nadd_button|floatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
		else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFloating Items``|left|6016|\nadd_spacer|small|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findObject_|itemID_itemAmount|" + found_list + "\nadd_spacer|small|\nadd_button|floatingItems|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
	}
	p.CreatePacket(peer);
}

void send_growscan_worldblocks(ENetPeer* peer, string search, string type) {
	int total_block = 0, total_background = 0, total_untradeable = 0, total_super_rare_item = 0, total_rarity = 0, total_fire = 0, total_water = 0, total_earth = 0, total_air = 0;
	string name_ = pInfo(peer)->world;
	string found_list = "";
	vector<pair<int, int>> founditems;
	vector<World>::iterator px = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (px != worlds.end()) {
		World* world_ = &worlds[px - worlds.begin()];
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg != 8 && world_->blocks[i_].fg != 6) {
				if (search == "start") {
					if (world_->blocks[i_].fg != 0) total_block++;
					if (world_->blocks[i_].bg != 0) total_background++;
					if (world_->blocks[i_].fg != 0 && items[world_->blocks[i_].fg].untradeable == 1 or world_->blocks[i_].bg != 0 && items[world_->blocks[i_].bg].untradeable == 1) total_untradeable++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].rarity >= 999 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].rarity >= 999) total_super_rare_item++;
					if (items[world_->blocks[i_].fg].rarity < 363 and items[world_->blocks[i_].fg].rarity != 999) if (world_->blocks[i_].fg != 0) total_rarity += items[world_->blocks[i_].fg].rarity;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 0 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 0) total_earth++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 1 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 1) total_fire++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 2 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 2) total_air++;
					if (world_->blocks[i_].fg != 0 and items[world_->blocks[i_].fg].chi == 3 or world_->blocks[i_].bg != 0 and items[world_->blocks[i_].bg].chi == 3) total_water++;
				}
				else if (type == "1" or type == "2") {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || (type == "1" && to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos)) {
						if (world_->blocks[i_].fg != 0) {
							bool copy_fg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].fg) {
									founditems[i].second++;
									copy_fg = false;
								}
							}
							if (copy_fg) founditems.push_back(make_pair(world_->blocks[i_].fg, 1));
						}
						if (type == "1" && world_->blocks[i_].bg != 0) {
							bool copy_bg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].bg) {
									founditems[i].second++;
									copy_bg = false;
								}
							}
							if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
						}
					}
				}
				else if (type == "3") {
					if (to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].bg != 0) {
							bool copy_bg = true;
							for (int i = 0; i < founditems.size(); i++) {
								if (founditems[i].first == world_->blocks[i_].bg) {
									founditems[i].second++;
									copy_bg = false;
								}
							}
							if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
						}
					}
				}
				else if (type == "5") {
					if (world_->blocks[i_].fg == 2946 && world_->blocks[i_].id != 0) {
						founditems.push_back(make_pair(world_->blocks[i_].id, 1));
					}
				}
				else if (type == "4") {
					if (to_lower(items[world_->blocks[i_].fg].name).find(to_lower(search)) != string::npos || to_lower(items[world_->blocks[i_].bg].name).find(to_lower(search)) != string::npos) {
						if (world_->blocks[i_].fg != 0 && items[world_->blocks[i_].fg].untradeable == 1 or world_->blocks[i_].bg != 0 && items[world_->blocks[i_].bg].untradeable == 1) {
							if (world_->blocks[i_].fg != 0) {
								bool copy_fg = true;
								for (int i = 0; i < founditems.size(); i++) {
									if (founditems[i].first == world_->blocks[i_].fg) {
										founditems[i].second++;
										copy_fg = false;
									}
								}
								if (copy_fg) founditems.push_back(make_pair(world_->blocks[i_].fg, 1));
							}

							if (world_->blocks[i_].bg != 0) {
								bool copy_bg = true;
								for (int i = 0; i < founditems.size(); i++) {
									if (founditems[i].first == world_->blocks[i_].bg) {
										founditems[i].second++;
										copy_bg = false;
									}
								}
								if (copy_bg) founditems.push_back(make_pair(world_->blocks[i_].bg, 1));
							}
						}
					}
				}
			}
		}
		for (int i = 0; i < founditems.size(); i++) found_list += to_string(founditems[i].first) + "," + to_string(founditems[i].second) + ",";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (search == "start") p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_label|small|`wThis world contains|left\nadd_textbox|`wBlocks: " + to_string(total_block) + "``|\nadd_textbox|`wBackgrounds: " + to_string(total_background) + "``|\nadd_textbox|`wUntradeable blocks: " + to_string(total_untradeable) + "``|left|\nadd_textbox|`wSuper rare items: " + to_string(total_super_rare_item) + "|left|\nadd_textbox|`wTotal block rarity: " + to_string(total_rarity) + "``|left|\nadd_label_with_icon|small|`wFire: " + to_string(total_fire) + "|left|6020|\nadd_label_with_icon|small|`wWater: " + to_string(total_water) + "|left|6024|\nadd_label_with_icon|small|`wEarth: " + to_string(total_earth) + "|left|6018|\nadd_label_with_icon|small|`wAir: " + to_string(total_air) + "|left|6022|\nadd_spacer|small|\nadd_text_input|searchName|Search by Name||100|\nadd_button|search_1|Search All|noflags|0|0|\nadd_smalltext|`5Or filter search by type``|left|\nadd_button|search_2|Search Blocks|noflags|0|0|\nadd_button|search_3|Search Backgrounds|noflags|0|0|\nadd_button|search_4|Search Untradeable|noflags|0|0|\nadd_button|search_5|Search Display Block|noflags|0|0|\nadd_spacer|small|\nadd_button|back_to_gscan|Back|noflags|0|0|\nend_dialog|statsblockworld|||\n");
	else {
		if (found_list .empty()) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_textbox|No results found.|left|\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nend_dialog|statsblock|||\n");
		else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWorld Blocks``|left|6016|\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nadd_spacer|small|\nadd_quick_exit|\nadd_textbox|Press on the icon to be directed to the location of the item.|left|\nadd_spacer|small|\nadd_label_with_icon_button_list|small|`w%s : %s|left|findTile_|itemIDseed2tree_itemAmount|" + found_list + "\nadd_spacer|small|\nadd_button|worldBlocks|Back|noflags|0|0|\nend_dialog|statsblockworld|||\n");
	}
	p.CreatePacket(peer);
}

void cant_enter(ENetPeer* peer, string text, bool door, int delay, string world_name = "") {
	gamepacket_t p2(delay);
	if (door) {
		gamepacket_t p(delay, pInfo(peer)->netID), p3(delay), p4(delay, pInfo(peer)->netID);
		p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
		p3.Insert("OnZoomCamera"), p3.Insert((float)10000.000000), p3.Insert(1000), p3.CreatePacket(peer);
		p4.Insert("OnSetFreezeState"), p4.Insert(0), p4.CreatePacket(peer);
	}
	else {
		gamepacket_t p2;
		p2.Insert("OnFailedToEnterWorld"), p2.CreatePacket(peer);
	}
	p2.Insert("OnConsoleMessage"), p2.Insert(text), p2.CreatePacket(peer);
	if (not world_name.empty()) memory_clean_world(world_name);
	return;
}


void add_pearl(ENetPeer* peer, int remove = 0) {
	gamepacket_t pb2;
	pb2.Insert("OnSetPearl"), pb2.Insert(pInfo(peer)->pearl += remove), pb2.Insert(0);
	pb2.CreatePacket(peer);
}

void join_world(ENetPeer* peer, string& name_, int spawnas_x = 0, int spawnas_y = 0, int delay = 0, bool locked = false, bool door = false, bool not_found = false) {
	if (check_and_remove_temp_locked_world(name_)) {
		return cant_enter(peer, "The system is currently experiencing high loads and is not allowing server moves, please try again later.", door, delay);
	}
	if (!Carnival and name_ == "CARNIVAL") {
		return cant_enter(peer, "We are now taking a break, goodbye see you next time.", door, delay);
	}
	if (!Growganoth and name_ == "GROWGANOTH") {
		return cant_enter(peer, "`4They are in an unreachable dimension.", door, delay);
	}
	pInfo(peer)->x = -1, pInfo(peer)->y = -1;
	pInfo(peer)->onetimecollect = true;
	pInfo(peer)->collect_allowed = false;
	pInfo(peer)->collect_total = 0;
	if (not door) {
		if (pInfo(peer)->spotlight) {
			pInfo(peer)->spotlight = false;
			form_state(pInfo(peer));
		}
		pInfo(peer)->cheater_settings &= ~Gtps3::SETTINGS_0;
		if (pInfo(peer)->world_time + 1500 > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			if (pInfo(peer)->world.empty()) {
				gamepacket_t p;
				p.Insert("OnFailedToEnterWorld"), p.CreatePacket(peer);
			}
			return;
		}
		pInfo(peer)->world_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		if (Server_Security.world_enter_time + 4000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			Server_Security.enter_world_count = 0;
			Server_Security.world_enter_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		}
		else Server_Security.enter_world_count++;
		if (Server_Security.enter_world_count > 20) {
			if (pInfo(peer)->world.empty()) {
				return cant_enter(peer, "The system is currently experiencing high loads and is not allowing server moves, please try again later.", door, delay);
			}
			return;
		}
	}
	if (has_playmod2(pInfo(peer), 139)) {
		name_ = "HELL";
		//pInfo(peer)->world = "HELL";
	}
	if (not check_name(name_)) {
		return cant_enter(peer, name_, door, delay);
	}
	bool dont_add = false;
	if (name_ == "MOD" && !pInfo(peer)->mod) return cant_enter(peer, "Only Mod able to enter this world.", door, delay);
	else if (name_ == "VIP" && !pInfo(peer)->vip) return cant_enter(peer, "Only Vip able to enter this world.", door, delay);
	else if (name_ == "HIDENSEEK" or name_ == "HIDENSEEK2" or name_ == "HIDENSEEK3" or name_ == "HIDENSEEK4") {
		if (name_ == Hide_N_Seek.hidenseekworld && Hide_N_Seek.seeker_start or pInfo(peer)->hider) {

		}
		else {
			if (pInfo(peer)->give_role or pInfo(peer)->Staff);
			else return cant_enter(peer, "You must consume a hide and seek ticket!", door, delay);
		}
	}
	else if (name_ == "WW1" || name_ == "WW2" || name_ == "WW3" || name_ == "WW4" || name_ == "WW5" || name_ == "WW6" || name_ == "WW7") {
		if (pInfo(peer)->wolf_world == name_) {
			for (int i_ = 0; i_ < pInfo(peer)->playmods.size(); i_++) {
				if (pInfo(peer)->playmods[i_].id == 128) {
					int times_ = pInfo(peer)->playmods[i_].time - time(nullptr);
					gamepacket_t p3(400);
					p3.Insert("OnSetMissionTimer"), p3.Insert(times_);
					p3.CreatePacket(peer);
					gamepacket_t p2(400);
					p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Welcome to `2Wolf World!``. I will give you `210`` minutes to finish this world.."), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
					dont_add = true;
					break;
				}
			}
		}
		else if (not pInfo(peer)->wolf_world.empty()) return cant_enter(peer, "Your must enter Wolf World `2" + pInfo(peer)->wolf_world + "``!", door, delay);
		if (dont_add == false) {
			if (pInfo(peer)->give_role or pInfo(peer)->Staff);
			else return cant_enter(peer, "You must consume Wolf Whistle to ENTER!", door, delay);
		}
	}
	if (door == false) {
		wipe_beach(peer);
	}
	World world_ = get_world(name_);
	string owner_name = to_lower(world_.owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
	int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
	if (world_.world_settings & Gtps3::SETTINGS_12 && owner_name != user_name) {
		pInfo(peer)->disable_cheater = 1;
		update_clothes_value(peer);
	}
	else pInfo(peer)->disable_cheater = 0;
	if (world_.name != pInfo(peer)->world) {
		if (world_.world_settings & Gtps3::SETTINGS_11 && not pInfo(peer)->superdev && pInfo(peer)->level > 10) return cant_enter(peer, "Your level is too big to join the world!", door, delay, world_.name);
		if (world_.drop_new.size() > 160000) {
			//send_fix_world(&world_);
			return cant_enter(peer, "Sub-server 7 is currently experiencing high load. Please try again in 30 seconds, hopefully loading balancing will fix it.", door, delay, world_.name);
		}
		/*
		if (name_ == "TOMBOFGROWGANOTH1" || name_ == "TOMBOFGROWGANOTH2" || name_ == "TOMBOFGROWGANOTH3") {
			for (int i_ = 0; i_ < pInfo(peer)->playmods.size(); i_++) {
				if (pInfo(peer)->playmods[i_].id == 127) {
					int times_ = pInfo(peer)->playmods[i_].time - time(nullptr);
					gamepacket_t p3(400);
					p3.Insert("OnSetMissionTimer"), p3.Insert(times_);
					p3.CreatePacket(peer);
					gamepacket_t p2(400);
					p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Welcome to `2Growganoth Parkour``. I will give you `210`` minutes to finish this world.."), p2.Insert(0), p2.Insert(1), p2.CreatePacket(peer);
					dont_add = true;
					break;
				}
			}
			if (dont_add == false) return cant_enter(peer, "You must consume Dark Ticket to ENTER!", door, delay);
		}*/
		if (world_.whitelist.size() != 0 && find(world_.whitelist.begin(), world_.whitelist.end(), user_name) == world_.whitelist.end() && pInfo(peer)->ownership_role == false) return cant_enter(peer, "That world is inaccessible.", door, delay, world_.name);
		if (not world_.nuked_by.empty() && pInfo(peer)->mod == 0) return cant_enter(peer, "That world is inaccessible.", door, delay, world_.name);
		if (pInfo(peer)->level < world_.entry_level and (to_lower(world_.owner_name) != to_lower(pInfo(peer)->tankIDName) and not pInfo(peer)->mod)) {
			if (!guild_access(peer, world_.guild_id) and find(world_.admins.begin(), world_.admins.end(), user_name) == world_.admins.end()) return cant_enter(peer, "Players lower than level " + to_string(world_.entry_level) + " can't enter " + world_.name + ".", door, delay, world_.name);
		}
		for (pair<string, long long int> p : world_.bannedPlayers) {
			if (p.first == to_lower(pInfo(peer)->tankIDName)) if (p.second + (3600 * 1000) > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) return cant_enter(peer, "`4Oh no!`` You've been banned from that world by its owner! Try again later after the world ban wears off.", door, delay, world_.name);
		}
		get_players(world_.name, w_c, s_c, net_, r_c);
		if (name_ != "HELL" && w_c >= 50 and not pInfo(peer)->dev and not pInfo(peer)->mod) return cant_enter(peer, "Oops, `5" + world_.name + "`` already has `450`` people in it. Try again later.", door, delay, world_.name);
		if (not pInfo(peer)->world.empty()) exit_(peer, true);
		pInfo(peer)->update = true;
		pInfo(peer)->updated_clothes = true;
	}
	else {
		if (door) {
			gamepacket_t p(delay, pInfo(peer)->netID), p2(delay), p3(delay, pInfo(peer)->netID);
			p.Insert("OnSetFreezeState"), p.Insert(1), p.CreatePacket(peer);
			if (not_found) {
				int found_door = 0;
				vector<WorldBlock>::iterator p = find_if(world_.blocks.begin(), world_.blocks.end(), [&](const WorldBlock& a) { return a.fg == 6; });
				if (p != world_.blocks.end()) {
					found_door = p - world_.blocks.begin();
					OnSetPos(peer, found_door % 100 * 32, found_door / 100 * 32, delay);
				}
			}
			else {
				if (not locked) {
					OnSetPos(peer, spawnas_x * 32, spawnas_y * 32, delay);
					if (not pInfo(peer)->invis) {
						gamepacket_t p(delay, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned"), p.Insert("audio/door_open.wav"), p.CreatePacket(peer);
					}
				}
				else if (locked) {
					gamepacket_t p(delay);
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("The door is locked."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
				}
			}
			p2.Insert("OnZoomCamera"), p2.Insert((float)10000.000000), p2.Insert(1000), p2.CreatePacket(peer);
			p3.Insert("OnSetFreezeState"), p3.Insert(0), p3.CreatePacket(peer);
		}
		else {
			if (spawnas_x != 0 && spawnas_y != 0) OnSetPos(peer, spawnas_x * 32, spawnas_y * 32, delay);
			else OnSetPos(peer, pInfo(peer)->c_x * 32, pInfo(peer)->c_y * 32, delay);
		}
		return;
	}
	uint32_t ySize = world_.blocks.size()/100, xSize = world_.blocks.size() / ySize;
	pInfo(peer)->lock = 0;
	pInfo(peer)->world_owner = world_.owner_name;
	pInfo(peer)->world = world_.name;
	pInfo(peer)->xenonite = world_.xenonite;
	int total = 78 + world_.name.length() + world_.blocks.size() + 24 + ((8 * world_.blocks.size()) + (world_.drop_new.size() * 16)), spawn_x = 0, spawn_y = 0;
	BYTE* data = (BYTE*)malloc(world_.blocks.size() * sizeof(WorldBlock) + sizeof(World) + world_.drop_new.size());
	memset(data, 0, total);
	*(__int8*)(data) = 4;
	*(__int8*)(data + 4) = 4;
	*(__int8*)(data + 16) = 8;
	*(__int8*)(data + 66) = world_.name.length();
	memcpy(data + 68, world_.name.c_str(), world_.name.length());
	*(__int8*)(data + 68 + world_.name.length()) = xSize;
	*(__int8*)(data + 72 + world_.name.length()) = ySize;
	*(__int16*)(data + 76 + world_.name.length()) = world_.blocks.size();
	BYTE* blc = data + 80 + world_.name.length();
	if (pInfo(peer)->new_version) blc += 5;
	vector<vector<unsigned int>> world_locks;
	world_.active_jammers.clear();
	vector<string> world_mods;
	if (not world_.category.empty()) {
		vector<string>::iterator pz = find_if(world_rate_types[world_category_id(world_.category)].begin(), world_rate_types[world_category_id(world_.category)].end(), [&](const string& element) { return element.substr(0, element.find("|")) == world_.name; });
		if (pz != world_rate_types[world_category_id(world_.category)].end()) {
			int spot = int(pz - world_rate_types[world_category_id(world_.category)].begin());
			world_mods.push_back("`9#" + to_string(spot + 1) + " " + world_.category + "``");
		}
		else world_mods.push_back("`9" + world_.category + "``");
	}
	//	vector<int> blocks;
	//auto start = high_resolution_clock::now();
	for (int i_ = 0; i_ < world_.blocks.size(); i_++) {
		/*
		if (find(blocks.begin(), blocks.end(), world_.blocks[i_].fg) == blocks.end()) {
			blocks.push_back(world_.blocks[i_].fg);
				cout << items[world_.blocks[i_].fg].ori_name << "|" << world_.blocks[i_].fg << " block type: " << items[world_.blocks[i_].fg].blockType << endl;
		}*/
		//	if (world_.blocks[i_].fg == 6950 || world_.blocks[i_].fg == 6952 || world_.blocks[i_].fg == 6954)  world_.blocks[i_].fg = 2;
		*(__int16*)(blc) = world_.blocks[i_].fg;
		*(__int16*)(blc + 2) = world_.blocks[i_].bg;
		*(__int32*)(blc + 4) = world_.blocks[i_].flags;
		if (world_.blocks[i_].fg) {
			if (world_.blocks[i_].flags & 0x00400000 && (world_.blocks[i_].fg == 226 || world_.blocks[i_].fg == 1276 || world_.blocks[i_].fg == 1278 || world_.blocks[i_].fg == 4884 || world_.blocks[i_].fg == 4992)) world_mods.push_back("`" + a + (world_.blocks[i_].fg == 226 ? "4JAMMED" : (world_.blocks[i_].fg == 1276 ? "2NOPUNCH" : (world_.blocks[i_].fg == 1278 ? "2IMMUNE" : (world_.blocks[i_].fg == 4884 ? "2NOWAR" : "2ANTIGRAVITY")))) + "``"), world_.active_jammers.push_back(world_.blocks[i_].fg);
			if (items[world_.blocks[i_].fg].audio_rack) {
				*(__int8*)(blc + 8) = 56;
				*(__int16*)(blc + 9) = world_.blocks[i_].txt.size();
				memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
				*(__int16*)(blc + 11 + world_.blocks[i_].txt.size()) = world_.blocks[i_].pr;
				blc += 7 + world_.blocks[i_].txt.size();
				total += 7 + world_.blocks[i_].txt.size();
			}
			else if (items[world_.blocks[i_].fg].simple_load) {
				*(__int8*)(blc + 8) = 6;
				blc += 8;
				total += 8;
				// CRASHABLE ITEMS
			}
			else {
				switch (items[world_.blocks[i_].fg].blockType) {
				case BlockTypes::GAME_BLOCK:
				{
					
				}
				case BlockTypes::GAME_GENERATOR:
				{
					
				}
				case BlockTypes::WEATHER: {
					switch (world_.blocks[i_].fg) {
					case 10058: {
						*(__int8*)(blc + 8) = 19;
						blc += 19;
						total += 19;
						break;
					}
					case 3694: case 5000:
					{
						*(__int8*)(blc + 8) = 40;
						*(__int32*)(blc + 9) = (world_.blocks[i_].fg == 3694 ? (world_.blocks[i_].b << 24) | (world_.blocks[i_].g << 16) | (world_.blocks[i_].r << 8) : world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 14);
						blc += 5;
						total += 5;
						break;
					}
					case 3832:	case 5958:
					{
						*(__int8*)(blc + 8) = 49;
						if (world_.blocks[i_].fg != 5958) {
							*(__int16*)(blc + 9) = (world_.blocks[i_].id != 0 ? world_.blocks[i_].id : 2);
							*(__int16*)(blc + 13) = world_.blocks[i_].gravity;
							*(__int16*)(blc + 17) = (int)world_.blocks[i_].spin | ((int)world_.blocks[i_].invert << 1);
						}
						blc += 10;
						total += 10;
						break;
					}
					default:
					{
						if (items[world_.blocks[i_].fg].actionType == 81) {
							*(__int8*)(blc + 8) = 5;
							blc += 1;
							total += 1;
						}
						break;
					}
					}
					break;
				}
				case BlockTypes::AUTO_BLOCK: {
					switch (world_.blocks[i_].fg) {
					case 10058: {
						*(__int8*)(blc + 8) = 62;
						*(__int16*)(blc + 9) = world_.blocks[i_].id;
						*(__int16*)(blc + 13) = world_.blocks[i_].pr;
						*(__int8*)(blc + 17) = world_.blocks[i_].enabled;
						*(__int16*)(blc + 21) = 1500;
						*(__int16*)(blc + 21) = 1500;
						blc += 15;
						total += 15;
						break;
					}
					default:
					{
						*(__int8*)(blc + 8) = world_.blocks[i_].fg == 6950 ? 70 : 69;
						*(__int8*)(blc + 9) = world_.blocks[i_].pr > 0 ? 1 : 0;
						*(__int16*)(blc + 13) = world_.blocks[i_].pr;
						*(__int16*)(blc + 17) = world_.blocks[i_].id;
						*(__int8*)(blc + 21) = world_.blocks[i_].enabled;
						blc += 13;
						total += 13;
						break;
					}
					}
					break;
				}
				case BlockTypes::FISH: {
					*(__int8*)(blc + 8) = 63;
					blc += 1 + 4 + 8;
					total += 1 + 4 + 8;
					break;
				}
				case BlockTypes::COUNTRY_FLAG: {
					*(__int8*)(blc + 8) = 0x21;
					*(__int16*)(blc + 9) = world_.blocks[i_].heart_monitor.size();
					memcpy(blc + 11, world_.blocks[i_].heart_monitor.data(), world_.blocks[i_].heart_monitor.size());
					blc += 3 + world_.blocks[i_].heart_monitor.size();
					total += 3 + world_.blocks[i_].heart_monitor.size();
					break;
				}
				case BlockTypes::GEIGER_CHARGER: {
					*(int*)(blc + 4) = world_.blocks[i_].flags;
					*(__int8*)(blc + 8) = 57;
					*(__int16*)(blc + 9) = (world_.blocks[i_].planted - time(nullptr) <= 0 ? 3600 : 3600 - (world_.blocks[i_].planted - time(nullptr)));
					blc += 5;
					total += 5;
					break;
				}
				case BlockTypes::Spirit_Storage: {
					*(__int8*)(blc + 8) = 41;
					*(__int16*)(blc + 9) = world_.blocks[i_].c_;
					blc += 5;
					total += 5;
					break;
				}
				case BlockTypes::MAGIC_EGG: {
					*(__int8*)(blc + 8) = 15;
					*(__int16*)(blc + 9) = world_.blocks[i_].shelf_1;
					blc += 5;
					total += 5;
					break;
				}
				case BlockTypes::Painting_Easel: {
					*(__int8*)(blc + 8) = 35;
					*(__int16*)(blc + 9) = world_.blocks[i_].id;
					*(__int16*)(blc + 13) = world_.blocks[i_].txt.size();
					memcpy(blc + 15, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
					blc += 7 + world_.blocks[i_].txt.size();
					total += 7 + world_.blocks[i_].txt.size();
					break;
				}
				case BlockTypes::Fish_Mount: {
					*(__int8*)(blc + 8) = 47;
					*(__int8*)(blc + 9) = 0;
					blc += 8;
					total += 8;
					break;
				}
				case BlockTypes::PORTRAIT: {
					*(__int8*)(blc + 8) = 48;
					*(__int16*)(blc + 9) = world_.blocks[i_].txt.size();
					memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
					if (world_.blocks[i_].portrait.c_skin == 0 and world_.blocks[i_].portrait.c_face == 0 and world_.blocks[i_].portrait.c_head == 0 and world_.blocks[i_].portrait.c_hair == 0) {

					}
					else {
						*(int*)(blc + 11 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_expression;
						*(int*)(blc + 19 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_hair_colour;
						*(int*)(blc + 23 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_skin;
						*(int*)(blc + 27 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_face;
						*(int*)(blc + 29 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_head;
						*(int*)(blc + 31 + world_.blocks[i_].txt.size()) = world_.blocks[i_].portrait.c_hair;
					}
					blc += 7 + 15 + 3 + world_.blocks[i_].txt.size();
					total += 7 + 15 + 3 + world_.blocks[i_].txt.size();
					break;
				}
				case BlockTypes::MANNEQUIN: {
					*(__int8*)(blc + 8) = 14;
					*(__int16*)(blc + 9) = world_.blocks[i_].txt.size();
					memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
					*(__int16*)(blc + 16 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_hair;
					*(__int16*)(blc + 18 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_shirt;
					*(__int16*)(blc + 20 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_pants;
					*(__int16*)(blc + 22 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_feet;
					*(__int16*)(blc + 24 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_head;
					*(__int16*)(blc + 26 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_hand;
					*(__int16*)(blc + 28 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_back;
					*(__int16*)(blc + 30 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_mask;
					*(__int16*)(blc + 32 + world_.blocks[i_].txt.size()) = world_.blocks[i_].mannequin.c_neck;
					blc += 26 + world_.blocks[i_].txt.size();
					total += 26 + world_.blocks[i_].txt.size();
					break;
				}
				case BlockTypes::KRANKEN: {
					int model_ = world_.blocks[i_].kranken_pattern;
					int rgb = (world_.blocks[i_].b << 24) | (world_.blocks[i_].g << 16) | (world_.blocks[i_].r << 8);
					int w_ = rgb + 255;
					BYTE btype = 0x50;
					memcpy(blc + 8, &btype, 1);
					memcpy(blc + 9, &model_, 4);
					memcpy(blc + 13, &w_, 4);
					blc += 9;
					total += 9;
					break;
				}
				case BlockTypes::SUCKER:{
					*(__int8*)(blc + 8) = 62;
					*(__int16*)(blc + 9) = world_.blocks[i_].id;
					*(__int16*)(blc + 13) = world_.blocks[i_].pr;
					*(__int8*)(blc + 17) = world_.blocks[i_].enabled;
					if (world_.blocks[i_].fg == 5638 || world_.blocks[i_].fg == 9850 || world_.blocks[i_].fg == 10266) {
						*(__int16*)(blc + 18) = world_.blocks[i_].spin;
						*(__int16*)(blc + 20) = 5000;
					}
					else {
						*(__int16*)(blc + 21) = 1500;
					}
					*(__int16*)(blc + 21) = 1500;
					blc += 15;
					total += 15;
					break;
				}
				case BlockTypes::Heart_Monitor:	{

					*(__int8*)(blc + 8) = 11;
					{
						bool ijungtas = false;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (fixchar(pInfo(currentPeer)->tankIDName) == fixchar(world_.blocks[i_].heart_monitor)) {
								ijungtas = 1;
								break;
							}
						}
						if (ijungtas)*(int*)(blc + 4) = world_.blocks[i_].flags | 0x00400000;
						*(int*)(blc + 9) = ijungtas;
					}
					*(int*)(blc + 13) = world_.blocks[i_].heart_monitor.size();
					memcpy(blc + 15, world_.blocks[i_].heart_monitor.c_str(), world_.blocks[i_].heart_monitor.size());
					blc += 7 + world_.blocks[i_].heart_monitor.size();
					total += 7 + world_.blocks[i_].heart_monitor.size();
					break;
				}
				case BlockTypes::TRICKSTER:
				{
					*(__int8*)(blc + 8) = 52;
					blc += 1;
					total += 1;
					break;
				}
				case BlockTypes::TIMER:
				{
					*(__int8*)(blc + 8) = 45;
					blc += 1;
					total += 1;
					break;
				}
				case BlockTypes::Display_Shelf:
				{
					*(__int8*)(blc + 8) = 43;
					*(__int16*)(blc + 9) = world_.blocks[i_].shelf_1;
					*(__int16*)(blc + 13) = world_.blocks[i_].shelf_2;
					*(__int16*)(blc + 17) = world_.blocks[i_].shelf_3;
					*(__int16*)(blc + 21) = world_.blocks[i_].shelf_4;
					blc += 17;
					total += 17;
					break;
				}
				case BlockTypes::VIP_ENTRANCE:
				{
					*(__int8*)(blc + 8) = 44;
					vector<int> vip_members;
					if (world_.blocks[i_].limit_admins or find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), user_name) != world_.blocks[i_].admins.end() or to_lower(pInfo(peer)->tankIDName) == to_lower(world_.owner_name) or world_.owner_name.empty()) vip_members.push_back(name_to_number(to_lower(pInfo(peer)->tankIDName)));
					*(__int16*)(blc + 14) = vip_members.size();
					for (int i = 0; i < vip_members.size(); i++) *(__int32*)(blc + 18 + (i * 4)) = vip_members[i];
					blc += 10 + (vip_members.size() * 4);
					total += 10 + (vip_members.size() * 4);
					break;
				}
				case BlockTypes::VENDING:
				{
					*(int*)(blc + 9) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? 0 : world_.blocks[i_].id);
					*(__int8*)(blc + 8) = 24;
					*(int*)(blc + 4) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? world_.blocks[i_].flags | ((world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1)) ? (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000) : (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000)) : world_.blocks[i_].flags | (world_.blocks[i_].id == 0 ? (world_.blocks[i_].wl != 0 ? 0x02000000 : 0x00000000) : (world_.blocks[i_].wl != 0 ? 0x02410000 : 0x00410000)));
					*(int*)(blc + 13) = (world_.blocks[i_].pr < 0 and world_.blocks[i_].id != 0 && world_.blocks[i_].c_ < (world_.blocks[i_].pr * -1) ? 0 : world_.blocks[i_].pr);
					blc += 9;
					total += 9;
					break;
				}
				case BlockTypes::GIVING_TREE:
				{
					BYTE btype = 0x1C;
					int count = world_.blocks[i_].shelf_1, zero = 0;
					uint16_t times = uint16_t(world_.blocks[i_].planted - time(nullptr) <= 0 ? 14400 : 14400 - (world_.blocks[i_].planted - time(nullptr)));
					memset(blc + 8, 0, 7);
					memcpy(blc, &world_.blocks[i_].fg, 2);
					memcpy(blc + 4, &world_.blocks[i_].flags, 4);
					memcpy(blc + 8, &btype, 1);
					memcpy(blc + 8 + 1, &zero, 1);
					memcpy(blc + 8 + 2, &times, 4);
					memcpy(blc + 8 + 6, &count, 1);
					blc += 7;
					total += 7;
					break;
				}
				case BlockTypes::DISPLAY:
				{
					*(__int8*)(blc + 8) = 23;
					*(__int16*)(blc + 9) = world_.blocks[i_].id;
					blc += 5;
					total += 5;
					break;
				}
				case BlockTypes::PROVIDER:
				{

					*(__int8*)(blc + 8) = 9;
					*(__int32*)(blc + 9) = (time(nullptr) - world_.blocks[i_].planted <= items[world_.blocks[i_].fg].growTime ? time(nullptr) - world_.blocks[i_].planted : items[world_.blocks[i_].fg].growTime);
					blc += 5;
					total += 5;
					break;
				}
				case BlockTypes::RANDOM_BLOCK:
				{
					*(__int8*)(blc + 8) = 8;
					*(__int32*)(blc + 9) = world_.blocks[i_].roll;
					blc += 2;
					total += 2;
					break;
				}
				case BlockTypes::LOCK:
				{
					if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994 or world_.blocks[i_].fg == 10000) world_locks.push_back({ i_ % xSize, i_ / xSize });
					else pInfo(peer)->lock = world_.blocks[i_].fg;
					if (world_.blocks[i_].spin) *(int*)(blc + 4) = 0x00800000;
					*(__int8*)(blc + 8) = 3;
					uint8_t world_settings = world_.world_settings & Gtps3::SETTINGS_5 ? (world_.world_settings & Gtps3::SETTINGS_6 ? 12345 : 1234) : (world_.world_settings & Gtps3::SETTINGS_6 ? 100 : 0);
					if (world_.world_settings & Gtps3::SETTINGS_7 and world_.blocks[i_].fg == 4802) world_settings += 128;
					*(__int16*)(blc + 9) = world_settings;
					*(int*)(blc + 10) = (to_lower(world_.blocks[i_].owner_name) == to_lower(pInfo(peer)->tankIDName) || to_lower(world_.owner_name) == to_lower(pInfo(peer)->tankIDName) ? name_to_number(to_lower(pInfo(peer)->tankIDName)) : -1);
					*(int*)(blc + 18) = world_.music_bpm * -1;
					bool access = false;
					uint16_t count_of_admins = 1;
					{
						if (world_.blocks[i_].fg == 202 or world_.blocks[i_].fg == 204 or world_.blocks[i_].fg == 206 or world_.blocks[i_].fg == 4994 or world_.blocks[i_].fg == 10000) if (find(world_.blocks[i_].admins.begin(), world_.blocks[i_].admins.end(), user_name) != world_.blocks[i_].admins.end())access = true;
						if (access or (world_.owner_name != "" && find(world_.admins.begin(), world_.admins.end(), user_name) != world_.admins.end())) *(int*)(blc + 22) = name_to_number(to_lower(pInfo(peer)->tankIDName)), count_of_admins++;
					}
					*(__int8*)(blc + 14) = count_of_admins;
					blc += 10 + (count_of_admins * 4);
					total += 10 + (count_of_admins * 4);
					break;
				}
				case BlockTypes::MAIN_DOOR:
				{
					spawn_x = (i_ % xSize) * 32, spawn_y = (i_ / xSize) * 32;
					pInfo(peer)->c_x = spawn_x / 32;
					pInfo(peer)->c_y = spawn_y / 32;
					*(__int8*)(blc + 8) = 1;
					*(__int16*)(blc + 9) = 4;
					memcpy(blc + 11, "EXIT", 4);
					blc += 8;
					total += 8;
					break;
				}
				case BlockTypes::SEED:
				{
					*(int*)(blc + 4) = 0 | 0x100000;
					*(__int8*)(blc + 8) = 4;
					*(int*)(blc + 9) = (time(nullptr) - world_.blocks[i_].planted <= items[world_.blocks[i_].fg].growTime ? time(nullptr) - world_.blocks[i_].planted : items[world_.blocks[i_].fg].growTime);
					*(__int16*)(blc + 13) = world_.blocks[i_].fruit;
					blc += 6;
					total += 6;
					break;
				}
				case BlockTypes::DONATION:case BlockTypes::MAILBOX: case BlockTypes::FOSSIL:
				{
					*(__int8*)(blc + 8) = 12;
					if (items[world_.blocks[i_].fg].blockType != BlockTypes::FOSSIL) {
						blc += 8;
						total += 8;
					}
					break;
				}
				case BlockTypes::DOOR: case BlockTypes::PORTAL:
				{
					string duru_tekstas = (world_.blocks[i_].txt.empty() ? (world_.blocks[i_].door_destination.empty() ? "" : (world_.blocks[i_].door_destination.find(":") != string::npos ? explode(":", world_.blocks[i_].door_destination)[0] + "..." : world_.blocks[i_].door_destination)) : world_.blocks[i_].txt);
					*(__int8*)(blc + 8) = 1;
					*(__int16*)(blc + 9) = duru_tekstas.size();
					memcpy(blc + 11, duru_tekstas.c_str(), duru_tekstas.size());
					*(__int8*)(blc + 11 + duru_tekstas.size()) = (world_.blocks[i_].open ? 0 : 0x08);
					blc += 4 + duru_tekstas.size();
					total += 4 + duru_tekstas.size();
					break;
				}
				case BlockTypes::SIGN:
				{
					*(__int8*)(blc + 8) = 2;
					*(int*)(blc + 9) = world_.blocks[i_].txt.size();
					memcpy(blc + 11, world_.blocks[i_].txt.c_str(), world_.blocks[i_].txt.size());
					*(__int16*)(blc + 11 + world_.blocks[i_].txt.size()) = 0;
					blc += 7 + world_.blocks[i_].txt.size();
					total += 7 + world_.blocks[i_].txt.size();
					break;
				}
				}
			}
		}
		blc += 8;
	}
	if (pInfo(peer)->new_version) 	blc += 12;
	*(int*)(blc) = world_.drop_new.size();
	*(int*)(blc + 4) = world_.total_drop_uid;
	blc += 8;
	for (int i_ = 0; i_ < world_.drop_new.size(); i_++) {
		*(__int16*)(blc) = world_.drop_new[i_][0];
		*(float*)(blc + 2) = world_.drop_new[i_][3];
		*(float*)(blc + 6) = world_.drop_new[i_][4];
		*(__int8*)(blc + 10) = world_.drop_new[i_][1];
		*(int*)(blc + 12) = world_.drop_new[i_][2];
		blc += 16;
	}
	enet_peer_send(peer, 0, enet_packet_create(data, total, ENET_PACKET_FLAG_RELIABLE));
	delete[] data;
	if (not pInfo(peer)->spectate_person.empty()) {
		bool found_ = false;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(peer)->spectate_person == pInfo(currentPeer)->tankIDName) {
				join_world(currentPeer, world_.name), found_ = true;
				break;
			}
		}
		if (found_ == false) pInfo(peer)->spectate_person = "";
	}
	if (world_locks.size() > 0) {
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_pointer_ = &worlds[p - worlds.begin()];
			for (vector<unsigned int> sk_ : world_locks) {
				int l_x = sk_[0];
				int l_y = sk_[1];
				WorldBlock block_ = world_.blocks[l_x + (l_y * 100)];
				block_.owner_named = block_.owner_name;
				world_pointer_->blocks[l_x + (l_y * 100)].owner_named = block_.owner_named;
				world_.blocks[l_x + (l_y * 100)].owner_named = block_.owner_name;
				vector<vector<int>> locked_tiles_around_lock{};
				vector<int> new_tiles{};
				new_tiles.push_back(l_x + (l_y * 100));
				for (int i2 = 0; i2 < new_tiles.size(); i2++) {
					int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
					if (s_x_ < (world_.max_x - 1) and world_.blocks[s_x_ + 1 + (s_y_ * 100)].locked and world_.blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not world_.blocks[s_x_ + 1 + (s_y_ * 100)].scanned) {
							world_.blocks[s_x_ + 1 + (s_y_ * 100)].scanned = true;
							new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
							locked_tiles_around_lock.push_back({ s_x_ + 1, s_y_ });
						}
					} if (s_x_ > 0 and world_.blocks[s_x_ - 1 + (s_y_ * 100)].locked and world_.blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not world_.blocks[s_x_ - 1 + (s_y_ * 100)].scanned) {
							world_.blocks[s_x_ - 1 + (s_y_ * 100)].scanned = true;
							new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
							locked_tiles_around_lock.push_back({ s_x_ - 1, s_y_ });
						}
					} if (s_y_ < (world_.max_y - 1) and world_.blocks[s_x_ + ((s_y_ + 1) * 100)].locked and world_.blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not world_.blocks[s_x_ + ((s_y_ + 1) * 100)].scanned) {
							world_.blocks[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ + 1 });
						}
					} if (s_y_ > 0 and world_.blocks[s_x_ + ((s_y_ - 1) * 100)].locked and world_.blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin == (l_x + (l_y * 100))) {
						if (not world_.blocks[s_x_ + ((s_y_ - 1) * 100)].scanned) {
							world_.blocks[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
							new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
							locked_tiles_around_lock.push_back({ s_x_, s_y_ - 1 });
						}
					}
				}
				if (locked_tiles_around_lock.size() != 0) {
					PlayerMoving data_{};
					data_.packetType = 15, data_.punchX = l_x, data_.punchY = l_y, data_.characterState = 0x8;
					data_.netID = name_to_number(to_lower(block_.owner_name));
					data_.plantingTree = block_.fg;
					BYTE* raw;
					int alloc = alloc_(&world_, &block_);
					raw = packPlayerMoving(&data_, 112 + (locked_tiles_around_lock.size() * 2) + alloc);
					*(int*)(raw + 8) = locked_tiles_around_lock.size();
					*(__int8*)(raw + 12) = 8;
					BYTE* blc = raw + 56;
					for (int i_ = 0; i_ < locked_tiles_around_lock.size(); i_++) {
						vector<int> update_tiles = locked_tiles_around_lock[i_];
						int x = update_tiles[0];
						int y = update_tiles[1];
						int sq_ = x + (y * 100);
						*(int*)(blc + (i_ * 2)) = sq_;
						world_.blocks[x + (y * 100)].scanned = false;
					}
					send_raw(peer, 4, raw, 112 + (locked_tiles_around_lock.size() * 2) + alloc, ENET_PACKET_FLAG_RELIABLE);
					PlayerMoving data_2{};
					data_2.packetType = 5, data_2.punchX = l_x, data_2.punchY = l_y, data_2.characterState = 0x8;
					BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc);
					BYTE* blc2 = raw2 + 56;
					form_visual(blc2, block_, world_, peer, false);
					send_raw(peer, 4, raw2, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
					delete[] raw, blc, raw2, blc2;
				}
			}
		}
	}
	bool wipe = false;
	for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
		if (pInfo(peer)->inv[i_].first == 1424 || pInfo(peer)->inv[i_].first == 5816 || pInfo(peer)->inv[i_].first == 5640 || pInfo(peer)->inv[i_].first == 5814 || pInfo(peer)->inv[i_].first == 8430) {
			wipe = true;
			if (pInfo(peer)->inv[i_].first == 5640) pInfo(peer)->magnetron_id = 0, pInfo(peer)->magnetron_x = 0, pInfo(peer)->magnetron_y = 0;
			pInfo(peer)->inv[i_].first = 0;
			pInfo(peer)->inv[i_].second = 0;
		}
	}
	if (wipe) send_inventory(peer);
	pInfo(peer)->netID = net_;
	if (spawnas_x != 0 or spawnas_y != 0) spawn_x = spawnas_x * 32, spawn_y = spawnas_y * 32;
	pInfo(peer)->name_color = (pInfo(peer)->give_role ? "`8@" : pInfo(peer)->Staff ? "`4@" : pInfo(peer)->superdev ? "`8@" : pInfo(peer)->dev ? "`6@" : (pInfo(peer)->mod) ? "`#@" : (to_lower(pInfo(peer)->tankIDName)) == to_lower(world_.owner_name) ? "`2" : find(world_.admins.begin(), world_.admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_.admins.end() ? "`^" : "`0");
	{
		gamepacket_t pb;
		pb.Insert((world_.name == "BEACHPARTYGAME" ? "ShowPearlCurrency" : "HidePearlCurrency"));
		pb.CreatePacket(peer);
		add_pearl(peer);
	}
	vector<pair<string, string>>::iterator paa = find_if(Honors_Update.world_honors.begin(), Honors_Update.world_honors.end(), [&](const pair<string, string>& a) { return a.first == world_.name; });
	if (paa != Honors_Update.world_honors.end()) {
		world_.honors = Honors_Update.world_honors[paa - Honors_Update.world_honors.begin()].second;
		/*
		if (to_lower(world_.owner_name) == to_lower(pInfo(peer)->tankIDName)) {
			if (pInfo(peer)->grow4good_honors == 0) daily_quest(peer, false, "honors", 1);
		}*/
	}
	if (world_.world_settings & Gtps3::SETTINGS_1) {
		world_.honors += a + (world_.honors.empty() ? "" : ", ") + "`$WOTW Winner";
	}
	if (pInfo(peer)->xenonite != 0) {
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage"), p2.Insert(xenonite_text(pInfo(peer)->xenonite)), p2.CreatePacket(peer);
	}
	if (world_.name == "GROWGANOTH") {
		packet_(peer, "action|play_music\nfile|audio/mp3/ykoops.mp3\ndelayMS|0");
		world_.weather = 9;
	}
	gamepacket_t p2, p3;
	p2.Insert("OnConsoleMessage"), p2.Insert("" + (pInfo(peer)->mod + pInfo(peer)->dev > 0 ? (not world_.nuked_by.empty() ? "`0[NUKED: " + world_.nuked_by + "]`` " : "") : "") + "World `w" + world_.name + "`` " + (world_mods.size() != 0 ? "`0[``" + join(world_mods, ", ") + "`0]`` " : "") + "" + (world_.honors.empty() ? "" : "(`3Honors:`` " + world_.honors + ") ") + "entered.  There are `w" + to_string(w_c) + "`` other people here, `w" + setGems(s_c) + "`` online."), p2.CreatePacket(peer);
	p3.Insert("OnSetCurrentWeather");
	if (world_.name != "GROWGANOTH" && comet_dust) p3.Insert(16);
	else p3.Insert((world_.weather == 0 || world_.weather == 80 && world_.d_weather != 0 ? world_.d_weather : (world_.weather == 0 ? 80 : world_.weather)));
	p3.CreatePacket(peer);
	{
		//pInfo(peer)->x = spawn_x, pInfo(peer)->y = spawn_y;
		string nickas = get_player_nick_main(peer);
		if (pInfo(peer)->hider && world_.name == Hide_N_Seek.hidenseekworld) nickas = "";
		string s_ = "spawn|avatar\nnetID|" + to_string(net_) + "\nuserID|" + to_string(name_to_number(to_lower(pInfo(peer)->tankIDName))) + "\ncolrect|0|0|20|30\nposXY|" + to_string(spawn_x) + "|" + to_string(spawn_y) + "\nname|" + nickas + "``\ncountry|" + pInfo(peer)->country + "\ninvis|" + (pInfo(peer)->invis && pInfo(peer)->hider == false && pInfo(peer)->seeker == false ? "1" : "0") + "\nmstate|" + (pInfo(peer)->mod or pInfo(peer)->dev && pInfo(peer)->seeker == false ? "1" : "0") + "\nsmstate|" + (pInfo(peer)->dev && pInfo(peer)->seeker == false ? "1" : "0") + "\nonlineID|";
		gamepacket_t p;
		p.Insert("OnSpawn"), p.Insert(s_);
		{
			gamepacket_t p;
			p.Insert("OnSpawn"), p.Insert(s_ + "\ntype|local"), p.CreatePacket(peer);
		}
		gamepacket_t p57, p58;
		p57.Insert("OnTalkBubble"), p57.Insert(pInfo(peer)->netID), p57.Insert("`5<`0" + get_player_nick(peer) + "`` entered, `w" + to_string(w_c) + " `5others here>``"), p57.Insert(0), p57.Insert(1);
		p58.Insert("OnConsoleMessage"), p58.Insert("`5<`0" + get_player_nick(peer) + "`` entered, `w" + to_string(w_c) + " `5others here>``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_ or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName) continue;
			p.CreatePacket(currentPeer);
			string nickass = get_player_nick_main(currentPeer);
			if (pInfo(currentPeer)->hider && world_.name == Hide_N_Seek.hidenseekworld) {
				nickass = "";
			}
			if (w_c <= 14 && w_c >= 1 && pInfo(peer)->invis == false && world_.name != Hide_N_Seek.hidenseekworld) {
				packet_(currentPeer, "action|play_sfx\nfile|audio/door_open.wav\ndelayMS|0");
				p57.CreatePacket(currentPeer), p58.CreatePacket(currentPeer);
			}
			gamepacket_t p;
			p.Insert("OnSpawn"), p.Insert("spawn|avatar\nnetID|" + to_string(pInfo(currentPeer)->netID) + "\nuserID|" + to_string(name_to_number(to_lower(pInfo(peer)->tankIDName))) + "\ncolrect|0|0|20|30\nposXY|" + to_string(pInfo(currentPeer)->x) + "|" + to_string(pInfo(currentPeer)->y) + "\nname|" + nickass + "``\ncountry|" + pInfo(currentPeer)->country + "\ninvis|" + (pInfo(currentPeer)->invis && pInfo(currentPeer)->hider == false && pInfo(currentPeer)->seeker == false ? "1" : "0") + "\nmstate|" + (pInfo(currentPeer)->mod or pInfo(currentPeer)->dev && pInfo(currentPeer)->seeker == false ? "1" : "0") + "\nsmstate|" + (pInfo(currentPeer)->dev && pInfo(currentPeer)->seeker == false ? "1" : "0") + "\nonlineID|"), p.CreatePacket(peer);
		}
	}
	if (not world_.owner_name.empty()) {
		if (to_lower(pInfo(peer)->tankIDName) == to_lower(world_.owner_name)) {
			if ((pInfo(peer)->name_color != "`0" or pInfo(peer)->mod || pInfo(peer)->dev || pInfo(peer)->superdev) && pInfo(peer)->name_color != "`2") world_.owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
			else world_.owner_named = pInfo(peer)->tankIDName;
		}
		else pInfo(peer)->worlds_owned.erase(remove(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end(), world_.name), pInfo(peer)->worlds_owned.end());
		if (world_.owner_named.substr(0, 2) == "`2" || world_.owner_named.substr(0, 2) == "`o") world_.owner_named = world_.owner_name;
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`5[```w" + world_.name + "`` `$World Locked`` by " + (world_.owner_named.empty() ? world_.owner_name : world_.owner_named) + "``" + (to_lower(world_.owner_name) == to_lower(pInfo(peer)->tankIDName) or (guild_access(peer, world_.guild_id) or find(world_.admins.begin(), world_.admins.end(), user_name) != world_.admins.end()) ? " (`2ACCESS GRANTED``)" : (world_.world_settings & Gtps3::SETTINGS_4 ? " (`$PUBLIC``)" : "")) + "`5]``");
		p.CreatePacket(peer);
	}
	else {
		pInfo(peer)->worlds_owned.erase(remove(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end(), world_.name), pInfo(peer)->worlds_owned.end());
	}
	//balloon ignore
	/*
	if (not has_playmod2(pInfo(peer), 135)) {
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("Balloons can't hit you, but you can't throw them either. (`$Balloon Immunity`` mod added)"), p.CreatePacket(peer);
		PlayMods give_playmod{};
		give_playmod.id = 135, give_playmod.time = time(nullptr) + 3;
		pInfo(peer)->playmods.push_back(give_playmod);
	}*/
	if (world_.owner_name == pInfo(peer)->tankIDName && not world_.honors.empty()) {
		if (find(pInfo(peer)->growtoken_worlds.begin(), pInfo(peer)->growtoken_worlds.end(), world_.name) == pInfo(peer)->growtoken_worlds.end()) {
			vector<pair<int, string>>::iterator p2 = find_if(top_yesterday.begin(), top_yesterday.end(), [&](const pair < int, string>& element) { return element.second.substr(0, element.second.find("|")) == world_.name; });
			if (p2 != top_yesterday.end()) {
				int give_tokens = 1, given = 0;
				given = give_tokens;
				if (modify_inventory(peer, 1486, give_tokens) == 0) {
					pInfo(peer)->growtoken_worlds.push_back(world_.name);
					if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, 1);
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("You received `$" + to_string(given) + " Growtoken`` from the players visiting your world yesterday."), p.CreatePacket(peer);
				}
			}
		}
	}
	if (world_.special_event) {
		gamepacket_t p2;
		p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_.special_event_item].event_name + ":`` " + (items[world_.special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_.special_event_item].name + "```o.``" : "`#" + to_string(items[world_.special_event_item].event_total) + " " + items[world_.special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + ""), p2.CreatePacket(peer);
	}
	/*
	{
		gamepacket_t p;
		p.Insert("OnSpawn"), p.Insert("spawn|avatar\nnetID|" + to_string(rand() % 30 + 450) + "\nuserID|288286691\ncolrect|0|0|20|30\nposXY|-32|-32\nname|`6@chris``\ncountry|us\ninvis|1\nmstate|1\nsmstate|1\nonlineID|"), p.CreatePacket(peer);
	}*/
	//if (world_.name == "GROWGANOTH") update_growganoth_self(peer);
	if (pInfo(peer)->xenonite != 0) {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID), p.Insert(xenonite_text(pInfo(peer)->xenonite)), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
	}
	if (dont_add == false) {
		for (int i_ = 0; i_ < pInfo(peer)->last_visited_worlds.size(); i_++) {
			if (pInfo(peer)->last_visited_worlds[i_] == world_.name) {
				pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin() + i_);
				pInfo(peer)->last_visited_worlds.push_back(world_.name);
			}
			else if (i_ + 1 == pInfo(peer)->last_visited_worlds.size()) {
				if (pInfo(peer)->last_visited_worlds.size() + 1 > 11) {
					pInfo(peer)->last_visited_worlds.erase(pInfo(peer)->last_visited_worlds.begin());
				}
				pInfo(peer)->last_visited_worlds.push_back(world_.name);
			}
		}
		if (pInfo(peer)->last_visited_worlds.size() == 0) pInfo(peer)->last_visited_worlds.push_back(world_.name);
	}
	if (not pInfo(peer)->invis) packet_(peer, "action|play_sfx\nfile|audio/door_open.wav\ndelayMS|0");
	for (int i_ = 0; i_ < world_.machines.size(); i_++) {
		WorldMachines machine_ = world_.machines[i_];
		if (machine_.enabled) tile_update(peer, &world_, &world_.blocks[machine_.x + (machine_.y * 100)], machine_.x, machine_.y);
	}
	if (pInfo(peer)->grow4good_enter == false)daily_quest(peer, false, "enter", 1);
	add_cctv(peer, "entered", "");
	if (world_.World_Time != 0) {
		pInfo(peer)->World_Timed = time(nullptr) + (world_.World_Time * 60);
		pInfo(peer)->WorldTimed = true;
	}
	if (world_.category != "None" and not world_.category.empty()) {
		gamepacket_t rate(5000);
		rate.Insert("OnConsoleMessage");
		rate.Insert("`9Type /rate to give your opinion of this world!`` `4/rate 1`` if you hate it, `2/rate 5`` if you love it, or anywhere in between. Share your thoughts!");
		rate.CreatePacket(peer);
	}
	if (pInfo(peer)->world == "CARNIVAL") packet_(peer, "action|play_music\nfile|audio/mp3/funtime.mp3\ndelayMS|0");
	if (pInfo(peer)->hair == 7102 && door == false) {
		gamepacket_t p(0, pInfo(peer)->netID);
		p.Insert("OnAction"), p.Insert("/omg"), p.CreatePacket(peer);
	}
	if (!pInfo(peer)->give_role and pInfo(peer)->world == "CARNIVAL") pInfo(peer)->ghost = false;

}

void add_ban_or_mute(ENetPeer* peer, long long int seconds, string reason, string muttedby, int playmod_id) {
	if (not has_playmod2(pInfo(peer), playmod_id)) {
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`#**`` `$The Gods`` have " + to_lower(info_about_playmods[playmod_id - 1][3]) + (playmod_id != 76 ? "d" : "") + " " + (get_player_nick(peer)) + "`o" + (playmod_id == 11 ? "'s mouth" : "") + " `#**`` (`4/rules`` to see the rules!)");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert("`oWarning from `4System``: You've been `4" + info_about_playmods[playmod_id - 1][3] + (playmod_id != 76 ? "d" : "") + "`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
			p.CreatePacket(peer);
			{
				gamepacket_t p;
				p.Insert("OnAddNotification");
				p.Insert("interface/atomic_button.rttex");
				p.Insert("`wWarning from `4System``: You've been `4" + info_about_playmods[playmod_id - 1][3] + "`` for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds"));
				p.Insert("audio/hub_open.wav");
				p.Insert(0);
				p.CreatePacket(peer);
			}
		}
		if (playmod_id == 76) {
			if (reason != "Curse Wand Effect") pInfo(peer)->bans.push_back("\nadd_smalltext|`6ON:`` `#" + (not pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->tankIDName) + "`` `0(" + pInfo(peer)->requestedName + ") #" + to_string(pInfo(peer)->netID) + "`` Time: " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " IP: " + pInfo(peer)->ip + " (banned by: " + muttedby + ", reason: " + reason + ") |left|");
			pInfo(peer)->b_s = (seconds * 1000);
			pInfo(peer)->b_r = reason;
			pInfo(peer)->b_b = muttedby;
			pInfo(peer)->b_t = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		}
		else if (playmod_id == 139) {
			if (pInfo(peer)->world != "HELL") {
				string world_ = "HELL";
				join_world(peer, world_);
			}
		}
		add_playmod(peer, playmod_id, seconds);
		form_state(pInfo(peer));
		update_clothes(peer, true);
		pInfo(peer)->bans.push_back("\nadd_smalltext|`6" + info_about_playmods[playmod_id - 1][3] + (playmod_id != 76 ? "d" : "") + " by " + muttedby + " for " + ((seconds / 86400 > 0) ? to_string(seconds / 86400) + " days" : (seconds / 3600 > 0) ? to_string(seconds / 3600) + " hours" : (seconds / 60 > 0) ? to_string(seconds / 60) + " minutes" : to_string(seconds) + " seconds") + " (" + reason + ")	|left|");
	}
	if (playmod_id == 76) enet_peer_disconnect_later(peer, 0);
}


ENetPeer* get_clicked_on(World* world_, int x_, int y_) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name or pInfo(currentPeer)->ghost) continue;
		if (y_ == pInfo(currentPeer)->y / 32) {
			if (pInfo(currentPeer)->state == 0 and x_ * 32 < pInfo(currentPeer)->x and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state == 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state != 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 20) {
				return currentPeer;
			}
		}
	}
	return NULL;
}


void join_beach_party(ENetPeer* peer) {
	if (pInfo(peer)->world == "BEACHPARTYGAME") {
		int ticket = 0;
		modify_inventory(peer, 12266, ticket);
		if (ticket == 0 || last_beach_event != 0 || find(beach_players.begin(), beach_players.end(), pInfo(peer)->tankIDName) != beach_players.end()) {
			gamepacket_t p;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert((ticket == 0 ? "You need at least one `4Beach Party Ticket`` to be able to join the Beach Party." : (last_beach_event != 0 ? "The game has already `4started``, try again later." : "You already joined the game."))), p.Insert(1), p.Insert(1), p.CreatePacket(peer);
		}
		else {
			beach_players.push_back(pInfo(peer)->tankIDName);
			gamepacket_t p, p2;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You're entered into the game! Your Beach Party Ticket will be removed when next round starts. Minimum players required : " + to_string(beach) + ". Good luck!."), p.CreatePacket(peer);
			p2.Insert("OnConsoleMessage"), p2.Insert("You're entered into the game! Your Beach Party Ticket will be removed when next round starts. Minimum players required : " + to_string(beach) + ". Good luck!."), p2.CreatePacket(peer);
			string world = "BEACHPARTYGAME";
			pInfo(peer)->x = 55 * 32, pInfo(peer)->y = 32 * 32;
			join_world(peer, world, 55, 32, 250, false, true);
			pInfo(peer)->x = 55 * 32, pInfo(peer)->y = 32 * 32;
			if (beach_players.size() >= beach) {
				gamepacket_t p2c, p3;
				p2c.Insert("OnConsoleMessage"), p2c.Insert("The game has started and your ticket has been removed from your inventory! Go smash some sand!");
				p3.Insert("OnSetMissionTimer"), p3.Insert(120);
				last_beach_event = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count() + 120000;
				vector<BYTE*>blocks;
				for (int i_ = 0; i_ < change_id_beach.size(); i_++) blocks.push_back(packBlockType(3, 0, change_id_beach[i_] % 100, change_id_beach[i_] / 100));
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != "BEACHPARTYGAME") continue;
					for (auto& b : blocks)send_raw(currentPeer, 4, b, 56, ENET_PACKET_FLAG_RELIABLE);
					if (find(beach_players.begin(), beach_players.end(), pInfo(currentPeer)->tankIDName) != beach_players.end()) {
						int remove = -1;
						if (modify_inventory(currentPeer, 12266, remove) != 0) exit_(currentPeer);
						if (pInfo(currentPeer)->y <= 26) SendRespawn(currentPeer, true, 0, 1);
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(currentPeer)->netID), p.Insert("The game has started and your ticket has been removed from your inventory! Go smash some sand!"), p.Insert(0), p.Insert(1), p.CreatePacket(currentPeer);
						p2c.CreatePacket(currentPeer),  p3.CreatePacket(currentPeer);
						pInfo(currentPeer)->c_x = 81, pInfo(currentPeer)->c_y = 32;
					}
				}
				for (auto& b : blocks) free(b);
				blocks.clear();
			}
		}
	}
}

void join_hidenseek(ENetPeer* peer) {
	int ticket = 0;
	modify_inventory(peer, 10016, ticket);
	if (Hide_N_Seek.hide_players.size() > 20) {
		gamepacket_t p;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Already maximum players joined! (20)"), p.Insert(1), p.Insert(1), p.CreatePacket(peer);
	}
	else if (ticket == 0 || Hide_N_Seek.last_hide_event != 0 || find(Hide_N_Seek.hide_players.begin(), Hide_N_Seek.hide_players.end(), pInfo(peer)->tankIDName) != Hide_N_Seek.hide_players.end()) {
		gamepacket_t p;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert((ticket == 0 ? "You need at least one `4" + items[10016].ori_name + "`` to be able to join the Hide And Seek." : (Hide_N_Seek.last_hide_event != 0 ? "The game has already `4started``, try again later. ("+ to_string(Hide_N_Seek.hide_players.size())+" hiders and "+to_string(Hide_N_Seek.seeker.size()) + " seeker left)" : "You already joined the game."))), p.Insert(1), p.Insert(1), p.CreatePacket(peer);
	}
	else {
		Hide_N_Seek.hide_players.push_back(pInfo(peer)->tankIDName);
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You're entered into the game! Your " + items[10016].ori_name + " will be removed when next round starts. Good luck!."), p.CreatePacket(peer);
		p2.Insert("OnConsoleMessage"), p2.Insert("You're entered into the game! Your " + items[10016].ori_name + " will be removed when next round starts. Good luck!."), p2.CreatePacket(peer);
		if (Hide_N_Seek.hide_players.size() >= 3 && Hide_N_Seek.wait_players_time == 0) {
			int found_players = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (find(Hide_N_Seek.hide_players.begin(), Hide_N_Seek.hide_players.end(), pInfo(currentPeer)->tankIDName) != Hide_N_Seek.hide_players.end()) found_players++;
			}
			if (found_players >= 3) {
				Hide_N_Seek.wait_players_time = time(nullptr) + 15;
				gamepacket_t p2c;
				p2c.Insert("OnConsoleMessage");
				p2c.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: The game is starting in 15 seconds!");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (find(Hide_N_Seek.hide_players.begin(), Hide_N_Seek.hide_players.end(), pInfo(currentPeer)->tankIDName) != Hide_N_Seek.hide_players.end()) {
						gamepacket_t pt;
						pt.Insert("OnTalkBubble"), pt.Insert(pInfo(currentPeer)->netID);
						pt.Insert("The game is starting in 15 seconds!");
						pt.Insert(0), pt.Insert(0), pt.CreatePacket(currentPeer);
						p2c.CreatePacket(currentPeer);
					}
				}
			}
			else {
				gamepacket_t p2c;
				p2c.Insert("OnConsoleMessage");
				p2c.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: The game is canceled..");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (find(Hide_N_Seek.hide_players.begin(), Hide_N_Seek.hide_players.end(), pInfo(currentPeer)->tankIDName) != Hide_N_Seek.hide_players.end()) {
						found_players++;
						gamepacket_t pt;
						pt.Insert("OnTalkBubble"), pt.Insert(pInfo(currentPeer)->netID);
						pt.Insert("The game is canceled..");
						pt.Insert(0), pt.Insert(0), pt.CreatePacket(currentPeer);
						p2c.CreatePacket(currentPeer);
					}
				}
				Hide_N_Seek.hide_players.clear();
			}
		}
	}
}


void honors_reset() {
	struct tm newtime;
	time_t now = time(0);
	localtime_s(&newtime, &now);
	bool clean_up = false;
	if (today_day != -1) {
		if (today_day != newtime.tm_mday) {
			today_day = newtime.tm_mday;
			top_yesterday = top_points;
			Crypto_Update.crypto_sold = 0;
			Crypto_Update.crypto_bought = 0;

			/*
			Cinco_De_Mayo.volcanic_cape = 0;
			Cinco_De_Mayo.volcanic_wings = 0;
			Cinco_De_Mayo.volcanic_pauldrons = 0;*/
			top_points.clear();
			clean_up = true;
			vector<int8_t> random_xy{ -1, 0 };
			item1 = small_seeds[rand() % small_seeds.size()] + random_xy[rand() % random_xy.size()];
			item2 = small_seed_pack[rand() % small_seed_pack.size()] + random_xy[rand() % random_xy.size()];
			phoenix_items_all = all_phoenix_items;
			item1c = rand() % 200 + 1;
			item2c = rand() % 100 + 1;
			day_ = today_day;
			cout << "LOAD NEW DAILY" << endl;
			ofstream o("db/daily_quest.json");
			if (!o.is_open()) cout << "daily quest error " << GetLastError() << endl;
			json j;
			j["item1"] = item1;
			j["item2"] = item2;
			j["item1c"] = item1c;
			j["item2c"] = item2c;
			j["day"] = day_;
			o << j << endl;
		}
		else {
			cout << "LOAD SAME DAILY" << endl;
			ifstream ifs("db/daily_quest.json");
			if (ifs.is_open()) {
				json j;
				ifs >> j;
				item1 = j["item1"].get<uint16_t>();
				item2 = j["item2"].get<uint16_t>();
				item1c = j["item1c"].get<uint8_t>();
				item2c = j["item2c"].get<uint8_t>();
				day_ = j["day"].get<uint8_t>();
			}
		}
	}
	if (today_month != -1) {
		if (today_month != newtime.tm_mon + 1) {
			today_month = newtime.tm_mon + 1;
			world_rating.clear();
			top_overall.clear();
			mails.clear();
			top_player_points.clear();
		}
	}
	if (newtime.tm_mday == 29) {
		comet_dust = true;
		news_banner = "temporary/comet.rttex";
		news_title = "Night Of The Comet!";
	}
	else {
		news_banner = "gui_halloween_banner3.rttex";
		news_title = "Halloween";
		comet_dust = false;
		//beach party gui_event_beachparty.rttex 		news_title = "Beach Party";
		// voucher dayz gui_voucher_dayz_banner.rttex
	}
	today_day = newtime.tm_mday;
	today_month = newtime.tm_mon + 1;
	thedaytoday = newtime.tm_wday;
	if (thedaytoday == 1) theitemtoday = 5040;
	else if (thedaytoday == 2) theitemtoday = 5042;
	else if (thedaytoday == 3) theitemtoday = 5044;
	else if (thedaytoday == 4) theitemtoday = 5032;
	else if (thedaytoday == 5)theitemtoday = 5034;
	else if (thedaytoday == 6) theitemtoday = 5036;
	else if (thedaytoday == 0)theitemtoday = 5038;
	long long ms_time = duration_cast<milliseconds>(system_clock::now().time_since_epoch()).count();
	if (Honors_Update.last_old_honors - ms_time <= 0 or Honors_Update.last_old_honors == 0 or clean_up or top_yesterday_list.empty()) {
		best_quote = random_quotes[rand() % random_quotes.size()];
		vector<pair<int, string>> top_tier = top_points;
		top_list.clear(), World_Stuff.top_list_world_menu.clear(), top_basher_list.clear(), top_guild_list.clear(), top_basher_list_shop.clear(), top_guild_list_shop.clear();
		Honors_Update.world_honors.clear();
		sort(top_tier.begin(), top_tier.end());
		reverse(top_tier.begin(), top_tier.end());
		top_tier.resize((top_tier.size() >= 200 ? 200 : top_tier.size()));
		for (uint8_t i = 0; i < top_tier.size(); i++) {
			string world = top_tier[i].second.substr(0, top_tier[i].second.find("|")), owner = top_tier[i].second.substr(top_tier[i].second.find("|") + 1);
			Honors_Update.world_honors.push_back(make_pair(world, "`8#" + to_string(i + 1) + " today``"));
			if (i == 0) best_world = world;
			if (i < 50) World_Stuff.top_list_world_menu += "\nadd_floater|" + world + "|" + to_string((i + 1) * -1) + "|0.38|3417414143";
			top_list += "\nadd_button|warp_to_" + world + "|`w#" + to_string(i + 1) + "`` " + world + " by " + owner + "|noflags|0|0|";
		}
		if (top_list.empty()) top_list = "\nadd_smalltext|The list should update in few minutes.|\nadd_spacer|small|";
		if (best_world.empty()) best_world = "NOT UPDATED YET!";
		{
			world_rate_types = { {},	{},{},{},{},{},	{},{},{},{},{},	{},{},{},{},{} };
			for (int i = 0; i < world_rate_types.size(); i++) {
				vector<pair<int, string>> top_rating;
				for (int i_ = 0; i_ < world_rating.size(); i_++) {
					if (world_category_id(world_rating[i_].category) == i) {
						int rating = item_average2(world_rating[i_].rating);
						string rating2 = to_string(rating);
						top_rating.push_back(make_pair(rating, world_rating[i_].name + "|" + rating2.substr(0, 1) + "." + rating2.substr(1, 2)));
					}
				}
				top_tier = top_rating;
				sort(top_tier.begin(), top_tier.end());
				reverse(top_tier.begin(), top_tier.end());
				top_tier.resize((top_tier.size() >= 100 ? 100 : top_tier.size()));
				for (uint8_t is = 0; is < top_tier.size(); is++) world_rate_types[i].push_back(top_tier[is].second);
			}
		}
		{
			top_tier = top_player_points;
			sort(top_tier.begin(), top_tier.end());
			reverse(top_tier.begin(), top_tier.end());
			top_tier.resize((top_tier.size() >= 1 ? 1 : top_tier.size()));
			for (uint8_t i = 0; i < top_tier.size(); i++) {
				ofstream o("C:/laragon/www/stats/" + server_name + "/best_player.json");
				if (!o.is_open()) cout << "server events " << GetLastError() << endl;
				json j;
				best_player = top_tier[i].second;
				j["username"] = top_tier[i].second;
				j["minutes"] = top_tier[i].first;
				o << j << endl;
			}
		}
		if (Balloon_Warz.top_balloon.size() != 0) {
			top_tier = Balloon_Warz.top_balloon;
			sort(top_tier.begin(), top_tier.end());
			reverse(top_tier.begin(), top_tier.end());
			top_tier.resize((top_tier.size() >= 30 ? 30 : top_tier.size()));
			for (uint8_t i = 0; i < top_tier.size(); i++) Balloon_Warz.top_balloon_list += "#" + to_string(i + 1) + " " + top_tier[i].second + " with " + setGems(top_tier[i].first) + " hits<CR>";
			if (Balloon_Warz.top_balloon_list.empty())Balloon_Warz.top_balloon_list = "The list should update in few minutes..";
			Balloon_Warz.balloon_leaderboard = "", Balloon_Warz.balloon_leaderboard2 = "";
			sort(Balloon_Warz.balloon_warz.begin(), Balloon_Warz.balloon_warz.end());
			reverse(Balloon_Warz.balloon_warz.begin(), Balloon_Warz.balloon_warz.end());
			for (int i = 0; i < Balloon_Warz.balloon_warz.size(); i++) {
				Balloon_Warz.balloon_leaderboard += to_string(i + 1) + "st: Team `" + get_balloon_team(Balloon_Warz.balloon_warz[i].second) + "``, with " + setGems(Balloon_Warz.balloon_warz[i].first) + " points.<CR>";
				Balloon_Warz.balloon_leaderboard2 += +"\n" + to_string(i + 1) + "st: Team `" + get_balloon_team(Balloon_Warz.balloon_warz[i].second) + "``, " + (i == 0 ? "leading " : "") + "with " + setGems(Balloon_Warz.balloon_warz[i].first) + " points.";
			}
			Balloon_Warz.top_balloon_list = "";
			if (Balloon_Warz.balloon_leaderboard.empty()) Balloon_Warz.balloon_leaderboard = "\nThe list should update in few minutes..";
			if (Balloon_Warz.balloon_leaderboard2.empty()) Balloon_Warz.balloon_leaderboard2 = "\nThe list should update in few minutes..";
		}
		top_overall_list.clear(), top_yesterday_list.clear();
		top_tier = top_yesterday;
		sort(top_tier.begin(), top_tier.end());
		reverse(top_tier.begin(), top_tier.end());
		top_tier.resize((top_tier.size() >= 200 ? 200 : top_tier.size()));
		top_yesterday = top_tier;
		for (uint8_t i = 0; i < top_tier.size(); i++) {
			string world = top_tier[i].second.substr(0, top_tier[i].second.find("|")), owner = top_tier[i].second.substr(top_tier[i].second.find("|") + 1);
			vector<pair<string, string>>::iterator paa = find_if(Honors_Update.world_honors.begin(), Honors_Update.world_honors.end(), [&](const pair<string, string>& a) { return a.first == world; });
			if (paa != Honors_Update.world_honors.end()) Honors_Update.world_honors[paa - Honors_Update.world_honors.begin()].second += ", `5#" + to_string(i + 1) + " yesterday``";
			else Honors_Update.world_honors.push_back(make_pair(world, "`5#" + to_string(i + 1) + " yesterday``"));
			top_yesterday_list += "\nadd_button|warp_to_" + world + "|`w#" + to_string(i + 1) + "`` " + world + " by " + owner + "|noflags|0|0|";
		}
		top_tier = top_overall;
		sort(top_tier.begin(), top_tier.end());
		reverse(top_tier.begin(), top_tier.end());
		top_tier.resize((top_tier.size() >= 200 ? 200 : top_tier.size()));
		for (uint8_t i = 0; i < top_tier.size(); i++) {
			string world = top_tier[i].second.substr(0, top_tier[i].second.find("|")), owner = top_tier[i].second.substr(top_tier[i].second.find("|") + 1);
			vector<pair<string, string>>::iterator paa = find_if(Honors_Update.world_honors.begin(), Honors_Update.world_honors.end(), [&](const pair<string, string>& a) { return a.first == world; });
			if (paa != Honors_Update.world_honors.end()) Honors_Update.world_honors[paa - Honors_Update.world_honors.begin()].second += ", `0#" + to_string(i + 1) + " overall``";
			else Honors_Update.world_honors.push_back(make_pair(world, "`0#" + to_string(i + 1) + " overall``"));

			top_overall_list += "\nadd_button|warp_to_" + world + "|`w#" + to_string(i + 1) + "`` " + world + " by " + owner + "|noflags|0|0|";
		}
		if (top_yesterday_list.empty()) top_yesterday_list = "\nadd_smalltext|The list should update in few minutes.|\nadd_spacer|small|";
		if (top_overall_list.empty()) top_overall_list = "\nadd_smalltext|The list should update in few minutes.|\nadd_spacer|small|";
		if (top_basher.size() != 0 && can_event == false) {
			vector<pair<long long int, string>> top_tiers = top_basher;
			sort(top_tiers.begin(), top_tiers.end());
			reverse(top_tiers.begin(), top_tiers.end());
			top_tiers.resize((top_tiers.size() >= 10 ? 10 : top_tiers.size()));
			for (uint8_t i = 0; i < top_tiers.size(); i++) {
				top_basher_list += "\nadd_smalltext|" + to_string(i + 1) + " : " + top_tiers[i].second + ", Score: " + setGems_(top_tiers[i].first) + "|";
				if (i < 5) top_basher_list_shop += "<CR>" + to_string(i + 1) + " : " + top_tiers[i].second + ", Score: " + setGems_(top_tiers[i].first) + "";
			}
			if (top_basher_list.empty()) top_basher_list = "\nadd_smalltext|The list should update in few minutes..|";
			top_tiers = top_guild;
			sort(top_tiers.begin(), top_tiers.end());
			reverse(top_tiers.begin(), top_tiers.end());
			top_tiers.resize((top_tiers.size() >= 10 ? 10 : top_tiers.size()));
			for (uint8_t i = 0; i < top_tiers.size(); i++) {
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [&](const Guild& a) { return a.guild_id == atoi(top_tiers[i].second.c_str()); });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					top_guild_list += "\nadd_button|warp_to_" + guild_information->guild_world + "|`w" + to_string(i + 1) + ". " + guild_information->guild_name + "``|noflags|0|0|\nadd_smalltext|Score: " + setGems_(top_tiers[i].first) + "|left|";
					if (i == 0) best_guild = guild_information->guild_name + ", score: " + setGems_(top_tiers[i].first);
					if (i < 5) top_guild_list_shop += "<CR>" + to_string(i + 1) + " : " + guild_information->guild_name + ", Score: " + setGems_(top_tiers[i].first) + "";
				}
			}
			if (top_guild_list.empty()) top_guild_list = "\nadd_smalltext|The list should update in few minutes..|";
		}
		Honors_Update.last_old_honors = ms_time + 23200000;
	}
}

void loop_save(ENetPeer* peer, bool forced = false) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (world_->special_event == false && server_event_spawn + 300000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
			int event_item = 0;
			if (rand() % 200 < 1 && world_->last_special_event + 900000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() or forced) {
				//1056 songpyeon only on harvest festival
				//528 only st. patirck
				//, 1360, 1360 , 1360 winter fest

				//611 magic egg
				vector<int> list = { 263,942,942,1396,4774,4522, 4774, 5002, 121, 1636, 2798, 2704, 3786, 4354 , 4354, 2992, 2992, 10016, 10016, 1396 };
				world_->special_event_item = list[rand() % list.size()];
				event_item = world_->special_event_item;
				world_->special_event = true;
				gamepacket_t p, p2;
				p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_->special_event_item].name + "```o.``" : "`#" + to_string(items[world_->special_event_item].event_total) + " " + items[world_->special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + ""), p.Insert("audio/cumbia_horns.wav"), p.Insert(0);
				p2.Insert("OnConsoleMessage"), p2.Insert("`2" + items[world_->special_event_item].event_name + ":`` " + (items[world_->special_event_item].event_total == 1 ? "`oYou have`` `030`` `oseconds to find and grab the`` `#" + items[world_->special_event_item].name + "```o.``" : "`#" + to_string(items[world_->special_event_item].event_total) + " " + items[world_->special_event_item].name + "`` `ospawn in your world, you have`` `030`` `oseconds to collect them.``") + "");
				for (ENetPeer* currentPeer_event = server->peers; currentPeer_event < &server->peers[server->peerCount]; ++currentPeer_event) {
					if (currentPeer_event->state != ENET_PEER_STATE_CONNECTED or currentPeer_event->data == NULL or pInfo(currentPeer_event)->world != name_) continue;
					p.CreatePacket(currentPeer_event), p2.CreatePacket(currentPeer_event);
				}
				world_->last_special_event = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			else if (zombie_apocalypse && rand() % 3 < 1 && world_->last_special_event + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				gamepacket_t p, p2, p3(0);
				p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2Zombie Apocalypse:`` `oIt's the Return of the Growing Dead!``"), p.Insert("audio/owooooo.wav"), p.Insert(0);
				p2.Insert("OnConsoleMessage"), p2.Insert("`2Zombie Apocalypse:`` `oIt's the Return of the Growing Dead!``");
				p3.Insert("OnSetCurrentWeather"), p3.Insert(31);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
					p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer), p3.CreatePacket(currentPeer);
					if (not has_playmod2(pInfo(currentPeer), 28)) {
						if (rand() % 2 < 1) {
							add_playmod(currentPeer, 28);
							update_clothes_value(currentPeer);
							update_clothes(currentPeer, true);
						}
					}
				}
				world_->last_special_event = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			else if (comet_dust && rand() % 3 < 1 && world_->last_comet_spawn + 180000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				event_item = 2034;
				world_->last_comet_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}
			/*
			else if (rand() % 2 < 1 && world_->last_comet_spawn + 420000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count() && server_event_spawn + 60000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (world_->last_comet_spawn != 0) event_item = 611;
				world_->last_comet_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			}*/
			if (event_item != 0) {
				cout << "special event in world: " << name_ << endl;
				if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) World_Stuff.t_worlds.push_back(world_->name);
				server_event_spawn = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				WorldDrop drop_block_{};
				drop_block_.count = 1;
				for (int i_ = 0; i_ < items[event_item].event_total; i_++) {
					drop_block_.id = event_item == 2034 ? (rand() % 100 < 25 ? 2036 : 2034) : world_->special_event_item,  drop_block_.x = rand() % 99 * 32, drop_block_.y = rand() % 54 * 32;
					world_->world_event_items.push_back(drop_block_.id);
					dropas_(world_, drop_block_, true);
				}
			}
		}
	}
}

bool auto_save = false;
void trigger_save2() {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer) == NULL) continue;
		if (pInfo(currentPeer)->savedd) continue;
		save_player(pInfo(currentPeer), false);
	}
	auto_save = true;
	for (int i = 0; i < worlds.size(); i++) {
		save_world(worlds[i].name, false);
	}
	auto_save = false;
}

void trigger_save3() {
	save_server_events();
	cout << "Saving: [PLAYERS/WORLDS/HONORS]" << endl;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		//for (int i = 0; i < pInfo(currentPeer)->worlds_owned.size(); i++) if (get_world(pInfo(currentPeer)->worlds_owned[i]).owner_name != pInfo(currentPeer)->tankIDName) pInfo(currentPeer)->worlds_owned.erase(pInfo(currentPeer)->worlds_owned.begin() + i);
		save_player(pInfo(currentPeer), false);
	}
	f_saving_ = true;
	auto_save = true;
	for (int i = 0; i < worlds.size(); i++) {
		save_world(worlds[i].name, false);
	}
	save_guilds();
	cout << "Saved: [PLAYERS/WORLDS/HONORS]" << endl;
	auto_save = false;
	exit(0);
}

bool othersignalcalled = false, wascalled = false;
void crashLog_do(int e) {
	cout << "SIGNAL TRIGGERED: " << e << endl;
	if (e == SIGBREAK) {
		othersignalcalled = true;
		if (wascalled == true) return;
		trigger_save3();
	}
	else if (e == 22) {
		if (othersignalcalled == true) return;
		othersignalcalled = true;
		wascalled = true;
		doLog2(cchs); doLog2(cchs3);
		doLog2("SIGNAL TRIGGERED: " + to_string(e));
		trigger_save3();
	}
	else {
		othersignalcalled = true;
		if (wascalled == true) return;
		doLog2(cchs); doLog2(cchs3);
		doLog2("SIGNAL TRIGGERED: " + to_string(e));
		trigger_save3();
	}
}
void trigger_save_(bool restart_exe) {
	if (server_port == main_port) {
		save_server_events();
		cout << "Saving: [PLAYERS/WORLDS/HONORS]" << endl;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			//for (int i = 0; i < pInfo(currentPeer)->worlds_owned.size(); i++) if (get_world(pInfo(currentPeer)->worlds_owned[i]).owner_name != pInfo(currentPeer)->tankIDName) pInfo(currentPeer)->worlds_owned.erase(pInfo(currentPeer)->worlds_owned.begin() + i);
			save_player(pInfo(currentPeer), false);
		}
		f_saving_ = true;
		/*
		{
			ofstream o("db/volcanic_capes.json");
			if (!o.is_open()) cout << "volcanic cape error" << GetLastError() << endl;
			json j;
			j["v1"] = Cinco_De_Mayo.volcanic_cape;
			j["v2"] = Cinco_De_Mayo.volcanic_wings;
			j["v4"] = Cinco_De_Mayo.volcanic_pauldrons;
			j["v3"] = today_day;
			o << j << endl;
		}*/
		cout << "Saving WORLDS [" << worlds.size() << "]" << endl;
		for (int i = 0; i < worlds.size(); i++) {
			save_world(worlds[i].name, false);
			//Sleep(50);
		}
		vector<vector<int>> item_prices;
		for (int i_ = 0; i_ < items.size(); i_++) item_prices.push_back({ items[i_].price });
		ofstream o("db/item_prices.json");
		if (!o.is_open()) cout << "saving item prices " << GetLastError() << endl;
		json j;
		j["items"] = item_prices;
		o << j << endl;
		save_guilds();
		Sleep(2000);
		cout << "Saved: [PLAYERS/WORLDS/HONORS]" << endl;
		worlds.clear();
		if (restart_exe) {
			honors_reset();
			cout << "saved but did not restart" << endl;
			f_saving_ = false;
		}
		else {
			system("PAUSE");
			exit(EXIT_FAILURE);
		}
	}
}


int auth_(ENetPeer* peer) {
	bool return_shit = false;
	Player* p_ = pInfo(peer);
	if (p_->temporary_tankIDName.find_first_not_of("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890") != std::string::npos) return -1;
	string path_ = "players/" + p_->temporary_tankIDName + "_.json";
	if (_access_s(path_.c_str(), 0) == 0) {
		json r_;
		ifstream f_(path_, ifstream::binary);
		if (f_.fail()) 	return -1;
		f_ >> r_;
		f_.close();
		try {
			p_->temp_password = (!(r_.find("temp_pass") != r_.end()) ? p_->temp_password : r_["temp_pass"].get<string>());
			if (not p_->temp_password.empty() && p_->temp_password == p_->tankIDPass) {
			}
			else if (p_->tankIDPass != r_["pass"]) return -1;
			pInfo(peer)->auth_ = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(p_->temporary_tankIDName)) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("`4ALREADY ON?! `o: This account was already online, kicking it off so you can log on. (if you were just playing before, this is nothing to worry about)"), p.CreatePacket(peer), p.CreatePacket(currentPeer);
					peer->data = currentPeer->data;
					enet_peer_disconnect_later(currentPeer, 0);
					enet_peer_disconnect_later(peer, 0);
					return_shit = true;
				}
			}
			if (return_shit) return -2;
			p_->growid = true;
			//json c_ = r_["friends"].get<json>();
			p_->tankIDName = r_["name"].get<string>();
			p_->inv = r_["inventory"].get<vector<pair<int, int>>>();


			//json b_ = r_["achievements"].get<json>()
			/*for (int i_ = 0; i_ < b_.size(); i_++) {
				p_->achievements.insert({ b_[i_]["title"].get<string>(), b_[i_]["progress"].get<int>() });
			}*/
			p_->friends = r_["friends"].get<vector<Friends>>();
			p_->worlds_owned = r_["worlds_owned"].get<vector<string>>();
			p_->last_visited_worlds = r_["la_wo"].get<vector<string>>();
			p_->is_legend = r_["legend"].get<bool>();
			p_->bb = r_["bb"].get<bool>();

			p_->pinata_day = (!(r_.find("p_d1") != r_.end()) ? p_->pinata_day : r_["p_d1"].get<int>());
			p_->pinata_prize = (!(r_.find("p_d2") != r_.end()) ? p_->pinata_prize : r_["p_d2"].get<bool>());
			p_->pinata_claimed = (!(r_.find("p_d3") != r_.end()) ? p_->pinata_claimed : r_["p_d3"].get<bool>());

			p_->trade_history = r_["t_h"].get<vector<string>>();
			p_->total_pineapple = r_["p1_1"].get<uint32_t>();
			p_->stage_pineapple = (!(r_.find("p1_2") != r_.end()) ? 0 : r_["p1_2"].get<uint16_t>());
			p_->dd = r_["dd"].get<uint8_t>();
			p_->supp = r_["supp"].get<uint8_t>();
			p_->hs = r_["hs"].get<uint8_t>();
			p_->note = r_["note"].get<string>();
			p_->d_name = r_["d_name"].get<string>();
			p_->gtwl = r_["gtwl"].get<int>();
			p_->rb = r_["rb"].get<uint8_t>();
			p_->gp = r_["gp"].get<uint8_t>();
			p_->glo = r_["glo"].get<uint8_t>();
			p_->glo_p = r_["glo_p"].get<vector<int>>();
			p_->tankIDPass = r_["pass"].get<string>();
			p_->last_online = r_["lo"].get<string>();
			p_->surg_p = r_["surg_p"].get<vector<uint8_t>>();
			p_->t_p = r_["t_p"].get<vector<uint8_t>>();
			p_->bb_p = r_["bb_p"].get<vector<uint8_t>>();
			p_->ff_p = r_["ff_p"].get<vector<uint8_t>>();
			p_->p_p = r_["p_p"].get<vector<uint8_t>>();
			p_->g_p = r_["g_p"].get<vector<uint8_t>>();
			p_->t_xp = r_["t_xp"].get<int>();
			p_->bb_xp = r_["bb_xp"].get<int>();
			p_->ff_xp = r_["ff_xp"].get<int>();
			p_->s_xp = r_["s_xp"].get<int>();
			p_->g_xp = r_["g_xp"].get<int>();
			p_->p_xp = r_["p_xp"].get<int>();
			p_->t_lvl = r_["t_lvl"].get<uint8_t>();
			p_->bb_lvl = r_["bb_lvl"].get<uint8_t>();
			p_->ff_lvl = r_["ff_lvl"].get<uint8_t>();
			p_->s_lvl = r_["s_lvl"].get<uint8_t>();
			p_->g_lvl = r_["g_lvl"].get<uint8_t>();
			p_->p_lvl = r_["p_lvl"].get<uint8_t>();
			p_->b_l = r_["b_l"].get<uint16_t>();
			p_->bp = r_["bp"].get<vector<pair<uint16_t, uint8_t>>>();
			p_->flagmay = r_["flagmay"].get<int>();
			p_->cc = r_["cc"].get<int>();
			p_->opc = r_["opc"].get<uint16_t>();
			p_->superdev = r_["superdev"].get<uint8_t>();
			p_->b_i = r_["b_i"].get<int>();
			p_->b_bill = r_["b_bill"].get<string>();
			p_->b_w = r_["b_w"].get<int>();
			p_->b_p = r_["b_p"].get<int>();
			p_->surgery_skill = r_["skl"].get<uint8_t>();
			p_->surgery_type = r_["sgt"].get<uint8_t>();
			p_->surgery_done = r_["sd"].get<uint16_t>();
			p_->b_ra = r_["b_ra"].get<int>();
			p_->b_lvl = r_["b_lvl"].get<int>();
			p_->i_11818_1 = r_["i_11818_1"].get<uint8_t>();
			p_->i_11818_2 = r_["i_11818_2"].get<uint8_t>();
			p_->roleSkin = r_["roleSkin"].get<uint8_t>();
			p_->roleIcon = r_["roleIcon"].get<uint8_t>();
			p_->radio = r_["rad"].get<uint8_t>();
			p_->w_w = r_["w_w"].get<uint8_t>();
			//p_->egg = (!(r_.find("egg") != r_.end()) ? p_->egg : r_["egg"].get<int>());
			p_->lvl125 = r_["lvl125"].get<uint8_t>();
			p_->donor = r_["dnr"].get<uint8_t>();
			p_->master = r_["mst"].get<uint8_t>();
			p_->all_in = r_["al"].get<uint8_t>();

			p_->radio2 =  r_["radio2"].get<bool>();
			p_->received_balloon_warz = r_["balloon_prize"].get<bool>();//2022-11-15
			p_->pure_shadow = r_["p_7"].get<int>(); //2022-10/06

			if (!(r_.find("on") == r_.end())) {
				p_->p_status = r_["on"].get<int>(); //2023-4/06
			}
			if (!(r_.find("tmod") == r_.end())) {
				p_->tmod = r_["tmod"].get<bool>(); //2023-4/06
			}
			if (!(r_.find("/whitelist") == r_.end())) {
				p_->whitelist_role = r_["/whitelist"].get<bool>(); //2023-7
			}
			if (!(r_.find("/custom_name_color") == r_.end())) {
				p_->custom_name_color = r_["/custom_name_color"].get<string>(); //2023-7
			}


				if (!(r_.find("wipe") == r_.end())) p_->wiped_invalid_worlds = r_["wipe"].get<bool>(); //2023-5/31
				if (!(r_.find("vips") == r_.end())) p_->vip_p = r_["vips"].get<uint8_t>(); //2023-5/31
				if (!(r_.find("load_item2") == r_.end())) p_->load_item2 = r_["load_item2"].get<bool>(); //2023-5/31


				/*
			if (server_port == main_port) {
				if (p_->wiped_invalid_worlds == false && rand() % 100 < 20) {
					int cleaned = 0;
					p_->wiped_invalid_worlds = true;
					cleaned = pInfo(peer)->worlds_owned.size();
					sort(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end());
					pInfo(peer)->worlds_owned.erase(unique(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end()), pInfo(peer)->worlds_owned.end());
					cleaned -= pInfo(peer)->worlds_owned.size();
					for (int i = 0; i < pInfo(peer)->worlds_owned.size(); i++) {
						if (to_lower(get_world(pInfo(peer)->worlds_owned[i]).owner_name) != to_lower(pInfo(peer)->tankIDName)) pInfo(peer)->worlds_owned.erase(remove(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end(), pInfo(peer)->worlds_owned[i]), pInfo(peer)->worlds_owned.end()), cleaned++;
						memory_clean_world(pInfo(peer)->worlds_owned[i]);
					}
					if (cleaned != 0) cout << "Cleaned invalid/accidental worlds: " << cleaned << endl;
				}
			}*/

				if (!(r_.find("rtg") == r_.end())) {
					p_->real_growtopia_name = r_["rtg"].get<string>(); //2023-4/06
				}

				if (!(r_.find(recycle_event_name) == r_.end())) {
					p_->received_recycle_prize = r_[recycle_event_name].get<bool>(); //2023-4/06
				}

				if (!(r_.find("wls_participated") == r_.end())) {
					p_->wls_participated = r_["wls_participated"].get<bool>(); //2023-4/06
				}

				if (!(r_.find("sm1") == r_.end())) {
					p_->summer_surprise = r_["sm1"].get<int>(); //2023-4/06
					p_->summer_total = r_["sm2"].get<int>(); //2023-4/06
					p_->summer_milestone = r_["sm3"].get<vector<int>>(); //2023-4/06
				}



			if (!(r_.find("g" + to_string(grow_pass_item)) == r_.end())) {
				p_->growpass_points = r_["g" + to_string(grow_pass_item)].get<int>(); //2023-5/31
				p_->growpass_prizes = r_["gp" + to_string(grow_pass_item)].get<vector<string>>(); //2023-5/31
				p_->growpass_quests = r_["gq" + to_string(grow_pass_item)].get<vector<string>>(); //2023-5/31
			}

			p_->grow_air_ballon = (!(r_.find("g_a_b") != r_.end()) ? p_->grow_air_ballon : r_["g_a_b"].get<uint8_t>());
			if (!(r_.find("egg") == r_.end())) {
				p_->egg_carton = r_["egg"].get<int>(); //2023-04-07
				p_->magic_egg = r_["egg2"].get<int>(); //2023-04-07
			}
			if (!(r_.find("rubble") == r_.end())) {
				p_->rubble = r_["rubble"].get<int>(); //2023-07
			}
			// Banner Bandolier
			p_->Banner_Item = (!(r_.find("ba_i") != r_.end()) ? p_->Banner_Item : r_["ba_i"].get<int>());
			p_->Banner_Flag = (!(r_.find("ba_f") != r_.end()) ? p_->Banner_Flag : r_["ba_f"].get<int>());
			// Crown of Season
			p_->Aura_Season = (!(r_.find("a_s") != r_.end()) ? p_->Aura_Season : r_["a_s"].get<int>());
			p_->Trail_Season = (!(r_.find("t_s") != r_.end()) ? p_->Trail_Season : r_["t_s"].get<int>());
			// Infinity Crown
			p_->Crown_Time_Change = (!(r_.find("c_t_c") != r_.end()) ? p_->Crown_Time_Change : r_["c_t_c"].get<bool>());
			p_->Crown_Cycle_Time = (!(r_.find("c_c_t") != r_.end()) ? p_->Crown_Cycle_Time : r_["c_c_t"].get<int>());
			p_->Base_R_0 = (!(r_.find("br0") != r_.end()) ? p_->Base_R_0 : r_["br0"].get<int>());
			p_->Base_G_0 = (!(r_.find("bg0") != r_.end()) ? p_->Base_G_0 : r_["bg0"].get<int>());
			p_->Base_B_0 = (!(r_.find("bb0") != r_.end()) ? p_->Base_B_0 : r_["bb0"].get<int>());
			p_->Gem_R_0 = (!(r_.find("gr0") != r_.end()) ? p_->Gem_R_0 : r_["gr0"].get<int>());
			p_->Gem_G_0 = (!(r_.find("gg0") != r_.end()) ? p_->Gem_G_0 : r_["gg0"].get<int>());
			p_->Gem_B_0 = (!(r_.find("gb0") != r_.end()) ? p_->Gem_B_0 : r_["gb0"].get<int>());
			p_->Crystal_R_0 = (!(r_.find("cr0") != r_.end()) ? p_->Crystal_R_0 : r_["cr0"].get<int>());
			p_->Crystal_G_0 = (!(r_.find("cg0") != r_.end()) ? p_->Crystal_G_0 : r_["cg0"].get<int>());
			p_->Crystal_B_0 = (!(r_.find("cb0") != r_.end()) ? p_->Crystal_B_0 : r_["cb0"].get<int>());
			p_->Crown_Floating_Effect_0 = (!(r_.find("cfe0") != r_.end()) ? p_->Crown_Floating_Effect_0 : r_["cfe0"].get<bool>());
			p_->Crown_Laser_Beam_0 = (!(r_.find("clb0") != r_.end()) ? p_->Crown_Laser_Beam_0 : r_["clb0"].get<bool>());
			p_->Crown_Crystals_0 = (!(r_.find("crc0") != r_.end()) ? p_->Crown_Crystals_0 : r_["crc0"].get<bool>());
			p_->Crown_Rays_0 = (!(r_.find("c0rr") != r_.end()) ? p_->Crown_Rays_0 : r_["c0rr"].get<bool>());
			p_->Base_R_1 = (!(r_.find("Base_R_1") != r_.end()) ? p_->Base_R_1 : r_["Base_R_1"].get<int>());
			p_->Base_G_1 = (!(r_.find("Base_G_1") != r_.end()) ? p_->Base_G_1 : r_["Base_G_1"].get<int>());
			p_->Base_B_1 = (!(r_.find("Base_B_1") != r_.end()) ? p_->Base_B_1 : r_["Base_B_1"].get<int>());
			p_->Gem_R_1 = (!(r_.find("Gem_R_1") != r_.end()) ? p_->Gem_R_1 : r_["Gem_R_1"].get<int>());
			p_->Gem_G_1 = (!(r_.find("Gem_G_1") != r_.end()) ? p_->Gem_G_1 : r_["Gem_G_1"].get<int>());
			p_->Gem_B_1 = (!(r_.find("Gem_B_1") != r_.end()) ? p_->Gem_B_1 : r_["Gem_B_1"].get<int>());
			p_->Crystal_R_1 = (!(r_.find("Crystal_R_1") != r_.end()) ? p_->Crystal_R_1 : r_["Crystal_R_1"].get<int>());
			p_->Crystal_G_1 = (!(r_.find("Crystal_G_1") != r_.end()) ? p_->Crystal_G_1 : r_["Crystal_G_1"].get<int>());
			p_->Crystal_B_1 = (!(r_.find("Crystal_B_1") != r_.end()) ? p_->Crystal_B_1 : r_["Crystal_B_1"].get<int>());
			p_->Crown_Floating_Effect_1 = (!(r_.find("Crown_Floating_Effect_1") != r_.end()) ? p_->Crown_Floating_Effect_1 : r_["Crown_Floating_Effect_1"].get<bool>());
			p_->Crown_Laser_Beam_1 = (!(r_.find("Crown_Laser_Beam_1") != r_.end()) ? p_->Crown_Laser_Beam_1 : r_["Crown_Laser_Beam_1"].get<bool>());
			p_->Crown_Crystals_1 = (!(r_.find("Crown_Crystals_1") != r_.end()) ? p_->Crown_Crystals_1 : r_["Crown_Crystals_1"].get<bool>());
			p_->Crown_Rays_1 = (!(r_.find("Crown_Rays_1") != r_.end()) ? p_->Crown_Rays_1 : r_["Crown_Rays_1"].get<bool>());
			p_->Crown_Value = (!(r_.find("Crown_Value") != r_.end()) ? p_->Crown_Value : r_["Crown_Value"].get<int>());
			p_->Crown_Value_0_0 = (!(r_.find("Crown_Value_0_0") != r_.end()) ? p_->Crown_Value_0_0 : r_["Crown_Value_0_0"].get<long long int>());
			p_->Crown_Value_0_1 = (!(r_.find("Crown_Value_0_1") != r_.end()) ? p_->Crown_Value_0_1 : r_["Crown_Value_0_1"].get<long long int>());
			p_->Crown_Value_0_2 = (!(r_.find("Crown_Value_0_2") != r_.end()) ? p_->Crown_Value_0_2 : r_["Crown_Value_0_2"].get<long long int>());
			p_->Crown_Value_1_0 = (!(r_.find("Crown_Value_1_0") != r_.end()) ? p_->Crown_Value_1_0 : r_["Crown_Value_1_0"].get<long long int>());
			p_->Crown_Value_1_1 = (!(r_.find("Crown_Value_1_1") != r_.end()) ? p_->Crown_Value_1_1 : r_["Crown_Value_1_1"].get<long long int>());
			p_->Crown_Value_1_2 = (!(r_.find("Crown_Value_1_2") != r_.end()) ? p_->Crown_Value_1_2 : r_["Crown_Value_1_2"].get<long long int>());
			// Crown of Season
			// Magic Magnet
			p_->Magnet_Item = (!(r_.find("mg") != r_.end()) ? p_->Magnet_Item : r_["mg"].get<int>());

			p_->carnival_credit = (!(r_.find("ca_c") != r_.end()) ? p_->carnival_credit : r_["ca_c"].get<int>());
			p_->C_QuestActive = (!(r_.find("CQuest") != r_.end()) ? p_->C_QuestActive : r_["CQuest"].get<bool>());
			p_->C_DeliverID = (!(r_.find("CQItem") != r_.end()) ? p_->C_DeliverID : r_["CQItem"].get<int>());
			p_->C_QuestProgress = (!(r_.find("CQProg") != r_.end()) ? p_->C_QuestProgress : r_["CQProg"].get<int>());
			p_->C_QuestKind = (!(r_.find("CQKind") != r_.end()) ? p_->C_QuestKind : r_["CQKind"].get<int>());
			p_->C_ProgressNeeded = (!(r_.find("CQNeed") != r_.end()) ? p_->C_ProgressNeeded : r_["CQNeed"].get<int>());
			p_->C_QuestStep = (!(r_.find("CQStep") != r_.end()) ? p_->C_QuestStep : r_["CQStep"].get<int>());
			if (!(r_.find("participated") == r_.end())) {
				p_->participated = r_["participated"].get<int>(); //2023-03-29
			}

			if (!(r_.find("bc") == r_.end())) {
				p_->black_color = r_["bc"].get<bool>(); //2023-03-10
			}

			if (!(r_.find("new_pass") == r_.end())) {
				p_->new_pass = r_["new_pass"].get<bool>(); //2023-06-29
			}

			if (!(r_.find("logger") == r_.end())) {
				p_->logger = r_["logger"].get<bool>(); //2023-03-10
			}
			if (!(r_.find("lr") == r_.end())) {
				p_->last_rated = r_["lr"].get<vector<string>>();
			}

			if (!(r_.find("gg4e") == r_.end())) {
				p_->grow4good_email = r_["gg4e"].get<bool>();
			}

			if (!(r_.find("sc") == r_.end())) {
				p_->skin_c = r_["sc"].get<string>();
				p_->autofarm_slot = r_["as"].get<int>();
			}


			if (!(r_.find("is_legend") == r_.end())) {
				p_->is_legend = r_["is_legend"].get<bool>(); //2023-03-20
			}

			if (!(r_.find("lw_1") == r_.end())) {
				p_->lwiz_quest = r_["lw_1"].get<int>();
				p_->lwiz_step = r_["lw_2"].get<int>();
				p_->lwiz_notification = r_["lw_3"].get<int>();
				p_->legendary_quest = r_["lw_4"].get<vector<vector<int>>>();
			}
			if (!(r_.find("set") == r_.end())) {
				p_->set = r_["set"].get<vector<vector<int>>>();
			}
			if (!(r_.find("ig") == r_.end())) {
				p_->ignored = r_["ig"].get<vector<string>>();
			}

			if (!(r_.find("mlb") == r_.end())) {
				p_->mailbox = r_["mlb"].get<int>(); //2023-02/02
				p_->total_credit_card = r_["ccd"].get<int>(); //2023-02/03
				p_->credit_card = r_["ccd2"].get<int>(); //2023-02/03
				p_->moderator = r_["mod2"].get<int>(); //2023-02/03
 			}
			if (p_->moderator == 1) p_->mod = 1;
			if (p_->vip_p) p_->vip = 1;



			//if (!(r_.find("blabo") == r_.end())) p_->black_box_consumed = r_["blabo"].get<int>(); //2022-11/25
			if (!(r_.find("playtime_items") == r_.end())) p_->playtime_items = r_["playtime_items"].get<vector<int>>(); //2023-01-16

			p_->drtitle = r_["drtt"].get<uint8_t>();
			p_->drlegend = r_["drll"].get<uint8_t>();
			p_->su_8552_1 = r_["su1"].get<uint16_t>();
			p_->su_8552_2 = r_["su2"].get<uint16_t>();
			p_->su_8552_3 = r_["su3"].get<uint16_t>();
			p_->mercy = r_["mer"].get<uint8_t>();
			p_->drt = r_["_drt"].get<uint8_t>();

			/*
			p_->pinata_day = (!(r_.find("p_d1") != r_.end()) ? p_->pinata_day : r_["p_d1"].get<int>());
			p_->pinata_prize = (!(r_.find("p_d2") != r_.end()) ? p_->pinata_prize : r_["p_d2"].get<bool>());
			p_->pinata_claimed = (!(r_.find("p_d3") != r_.end()) ? p_->pinata_claimed : r_["p_d3"].get<bool>());
			*/

			//p_->halloween_dark_king = (!(r_.find("smp") != r_.end()) ? 0 : r_["smp"].get<uint8_t>());
			p_->growtoken_worlds = (!(r_.find("gr_w") != r_.end()) ? p_->growtoken_worlds : r_["gr_w"].get<vector<string>>());

			p_->grow4good_gems = r_["g4g_7"].get<int>();
			p_->grow4good_surgery = r_["g4g_9"].get<int>();

		
			p_->grow4good_fish = r_["g4g_10"].get<int>();
			p_->grow4good_points =r_["g4g_11"].get<int>();
			p_->grow4good_30mins = r_["g4g_12"].get<uint8_t>();
			p_->grow4good_break = r_["g4g_14"].get<int>();
			p_->grow4good_place = r_["g4g_15"].get<int>();
			p_->grow4good_trade = r_["g4g_16"].get<int>();
			p_->grow4good_sb =r_["g4g_17"].get<int>();
			p_->grow4good_enter =r_["g4g_18"].get<bool>();
			p_->grow4good_provider =r_["g4g_19"].get<int>();
			p_->grow4good_provider2 =  r_["g4g_20"].get<int>();
			p_->grow4good_geiger = r_["g4g_21"].get<int>();
			p_->grow4good_geiger2 =r_["g4g_22"].get<int>();

			p_->cheater_ =r_["cheater"].get<int>();
			p_->support101_ =  r_["support101"].get<int>();
			p_->cheater_settings = (!(r_.find("c_s") != r_.end()) ? p_->cheater_settings : r_["c_s"].get<int>());

			//p_->growtoken_worlds = (!(r_.find("gr_w") != r_.end()) ? p_->growtoken_worlds : r_["gr_w"].get<vector<string>>());

			// 2023
			if (!(r_.find("gd_") == r_.end())) {
				p_->grow_reset_day = r_["gd_"].get<long long int>();
				p_->grow_reset_week = r_["gw_"].get<long long int>();
				p_->grow_reset_month = r_["gm_"].get<long long int>();
			}

			/*
			if (!(r_.find("h_1") == r_.end())) {
				p_->halloween_task_1 = r_["h_1"].get<int>();
				p_->halloween_task_2 = r_["h_2"].get<int>();
				p_->halloween_task_3 = r_["h_3"].get<int>();
				p_->halloween_task_4 = r_["h_4"].get<int>();
			}

			if (!(r_.find(to_string(halloween_quest)+ "1") == r_.end())) {
				p_->halloween_ptask_1 = r_[to_string(halloween_quest) + "1"].get<int>();
				p_->halloween_ptask_2 = r_[to_string(halloween_quest) + "2"].get<int>();
				p_->halloween_ptask_3 = r_[to_string(halloween_quest) + "3"].get<int>();
				p_->halloween_ptask_4 = r_[to_string(halloween_quest) + "4"].get<int>();
				p_->halloween_ptask_5 = r_[to_string(halloween_quest) + "5"].get<int>();
			}
			*/


			if (!(r_.find("h1") == r_.end())) {
				p_->won_hider = r_["h1"].get<int>();
				p_->won_seeker = r_["h2"].get<int>();
			}

			if (!(r_.find("vou") == r_.end())) {
				p_->voucher = r_["vou"].get<int>();
			}
			if (!(r_.find("ch_55") == r_.end())) {
				p_->chat_prefix = r_["ch_55"].get<string>();
			}

			if (!(r_.find("ri_1") == r_.end())) {
				p_->cape_t = r_["ri_1"].get<int>();
				p_->cape_c = r_["ri_2"].get<int>();
				p_->cape_t2 = r_["ri_3"].get<int>();
				p_->cape_c2 = r_["ri_4"].get<int>();
				p_->flags = r_["ri_5"].get<int>();
				if (p_->flags == 0) p_->flags = 19451;
				p_->TimeDilation = r_["ri_6"].get<int>();
				p_->CapeStyleColor_1 = r_["ri_7"].get<string>();
				p_->CapeStyleColor_2 = r_["ri_8"].get<string>();
				p_->CapeCollarColor_1 = r_["ri_9"].get<string>();
				p_->CapeCollarColor_2 = r_["ri_10"].get<string>();
			}

			if (!(r_.find("rw_1") == r_.end())) {
				p_->wings_t = r_["rw_1"].get<int>();
				p_->wings_c = r_["rw_2"].get<int>();
				p_->wings_t2 = r_["rw_3"].get<int>();
				p_->wings_c2 = r_["rw_4"].get<int>();
				p_->_flags = r_["rw_5"].get<int>();
				p_->_TimeDilation = r_["rw_6"].get<int>();
				p_->_CapeStyleColor_1 = r_["rw_7"].get<string>();
				p_->_CapeStyleColor_2 = r_["rw_8"].get<string>();
				p_->_CapeCollarColor_1 = r_["rw_9"].get<string>();
				p_->_CapeCollarColor_2 = r_["rw_10"].get<string>();
			}


			/*
			if (!(r_.find("w_t_d") == r_.end())) {
				p_->winterfest_task_day = r_["w_t_d"].get<int>();
				p_->winterfest_wishes = r_["w_t_w"].get<int>();
				p_->winterfest_quest_1 = r_["w_t_q1"].get<int>();
				p_->winterfest_quest_2 = r_["w_t_q2"].get<int>();
				p_->winterfest_quest_3 = r_["w_t_q3"].get<int>();

				p_->reset_winterfest_quest_1 = r_["w_t_rq1"].get<int>();
				p_->reset_winterfest_quest_2 = r_["w_t_rq2"].get<int>();
				p_->reset_winterfest_quest_3 = r_["w_t_rq3"].get<int>();
				p_->reset_winterfest_quest_4 = r_["w_t_rq4"].get<int>();
				p_->reset_winterfest_quest_5 = r_["w_t_rq5"].get<int>();
				p_->reset_winterfest_quest_6 = r_["w_t_rq6"].get<int>();
				p_->reset_winterfest_quest_7 = r_["w_t_rq7"].get<int>();
				p_->reset_winterfest_quest_8 = r_["w_t_rq8"].get<int>();
				p_->winterfest_stuff4toys = r_["w_t_st"].get<int>();

			}

			if (!(r_.find("got_4292") == r_.end())) {
				p_->got_4292 = r_["got_4292"].get<int>();
				p_->got_4286 = r_["got_4286"].get<int>();
				p_->got_4288 = r_["got_4288"].get<int>();
				p_->got_10500 = r_["got_10500"].get<int>();
			}*/
			if (!(r_.find("bb_1") == r_.end())) {
				p_->balloon_faction = r_["bb_1"].get<int>();
				p_->balloon_hit = r_["bb_2"].get<int>();
				p_->hit_by = r_["bb_3"].get<int>();
				p_->balloon_donated = r_["bb_4"].get<int>();
				p_->balloon_score = r_["bb_5"].get<int>();
			}
			p_->bans = r_["7bans"].get<vector<string>>();

			if (!(r_.find("ch") == r_.end())) {
				p_->crypto_history = r_["ch"].get<vector<string>>();
			}

			p_->minokawa_wings = r_["12640"].get<uint8_t>();
			p_->panda_spirit = r_["12872"].get<uint8_t>();

			if (!(r_.find("11506") == r_.end())) {
				p_->mask_dragon = r_["11506"].get<uint8_t>();
				p_->growformer = r_["7384"].get<uint8_t>();
			}
			p_->eq_aura = r_["12634"].get<uint16_t>();

			p_->fa_ip = r_["fa_ip"].get<string>();

			p_->gender = r_["gender"].get<string>();

			p_->fa2 = r_["2fa"].get<int>();
			if (p_->fa2 <= 999) p_->fa2 = 0;
			//if (!(r_.find("garuda") == r_.end())) p_->garuda = r_["garuda"].get<uint8_t>();
			p_->growmoji = r_["grm"].get<string>();

			p_->mini_you = r_["myou"].get<bool>();
			p_->display_age = r_["p_1"].get<bool>();
			p_->display_home = r_["p_2"].get<bool>();
			p_->ownership_role = r_["owner"].get<bool>();

				p_->buy_role = r_["/buy"].get<bool>();
				p_->ghost_role = r_["/ghost"].get<bool>();
				p_->nick_role = r_["/nick"].get<bool>();
				p_->give_role = r_["/give"].get<bool>();
				if (!(r_.find("/edit") == r_.end())) p_->give_editor = r_["/edit"].get<bool>();
				if (!(r_.find("/csn") == r_.end())) p_->csn_role = r_["/csn"].get<bool>();
			p_->fires = r_["fire"].get<int>();
			p_->grow4good_seed = r_["g4g_24"].get<uint16_t>();
			p_->grow4good_seed2 = r_["g4g_25"].get<uint8_t>();
			p_->grow4good_combine = r_["g4g_26"].get<uint8_t>();
			p_->grow4good_crystal = r_["g4g_28"].get<uint8_t>();
			p_->grow4good_honors = r_["g4g_29"].get<uint8_t>();


			p_->hair_color = r_["e_1"].get<uint32_t>();
			p_->eye_drop = r_["e_2"].get<uint32_t>();
			p_->eye_lenses = r_["e_3"].get<uint32_t>();

			if (!(r_.find("cry") == r_.end())) p_->crypto = r_["cry"].get<vector<pair<string, int>>>();


			//p_->carnival_credit = (!(r_.find("cnv_1") != r_.end()) ? p_->carnival_credit : r_["cnv_1"].get<int>());
			p_->pearl = r_["bea_1"].get<int>();
			p_->sprite = r_["spr"].get<uint8_t>();
			p_->wild = r_["spr2"].get<uint8_t>();
			p_->golem = (!(r_.find("spr3") != r_.end()) ? p_->golem : r_["spr3"].get<uint8_t>());

			p_->email = r_["email"].get<string>();
			p_->b_r = r_["b_r"].get<string>();
			p_->b_b = r_["b_b"].get<string>();
			p_->b_s = r_["b_s"].get<long long int>();
			p_->b_t = r_["b_t"].get<long long int>();
			p_->m_b = r_["m_b"].get<string>();
			p_->punch_count = r_["punch"].get<long long int>();
			p_->n = r_["n"].get<uint8_t>();
			p_->ghost = r_["ghost"].get<bool>();
			p_->invis = r_["invis"].get<bool>();
			p_->dev = r_["dev"].get<uint8_t>();
			p_->m_h = r_["m_h"].get<uint8_t>();
			p_->gems = r_["gems"].get<int>();
			p_->xp = r_["xp"].get<long long int>();
			p_->level = r_["level"].get<int>();
			p_->skin = r_["skin"].get<int>();
			p_->show_location_ = r_["show_location"].get<bool>();
			p_->show_friend_notifications_ = r_["show_notifications"].get<bool>();
			p_->playtime = time(NULL), p_->seconds = r_["playtime"].get<long long int>();
			p_->account_created = r_["date"].get<long long int>();
			if (p_->account_created == 0) p_->account_created = time(NULL) / 86400;
			p_->home_world = r_["home_world"].get<string>();
			p_->hair = r_["hair"].get<uint16_t>();
			p_->shirt = r_["shirt"].get<uint16_t>();
			p_->pants = r_["pants"].get<uint16_t>();
			p_->feet = r_["feet"].get<uint16_t>();
			p_->face = r_["face"].get<uint16_t>();
			p_->hand = r_["hand"].get<uint16_t>();
			p_->back = r_["back"].get<uint16_t>();
			p_->mask = r_["mask"].get<uint16_t>();
			p_->necklace = r_["necklace"].get<uint16_t>();
			p_->ances = r_["ances"].get<uint16_t>();
			if (r_.find(guild_name_player) != r_.end()) p_->guild_id = r_[guild_name_player].get<int>();
			if (r_.find("favitem") != r_.end()) p_->Fav_Items = r_["favitem"].get<vector<int>>();
			p_->geiger_ = r_["geiger"].get<uint8_t>();
			p_->booty_broken = r_["booty_broken"].get<int>();



			if (!(r_.find("trans") == r_.end())) {
				p_->transmute = r_["trans"].get<vector<pair<int, int>>>(); //2023-02/01
				for (int i = 0; i < p_->transmute.size(); i++) {
					if (p_->transmute[i].second == 10684 || p_->transmute[i].first == 10684) {
						p_->transmute.erase(p_->transmute.begin() + i);
					}
				}
			}

			p_->playmods = r_["playmods"].get<vector<PlayMods>>();
			//					if (give_playmod.id == 129 || give_playmod.id == 130 || give_playmod.id == 131 || give_playmod.id == 132 || give_playmod.id == 133) p_->subscriber = true;
			if (p_->dev || p_->superdev || has_playmod2(p_, 125)) p_->mod = 1;
			if (has_playmod2(p_, 126)) p_->vip = 1;
			if (p_->drlegend == false) p_->is_legend = false;
			if (p_->new_pass == false) {
				p_->fa2 = 0;
				p_->fa_ip = "";
			}
			/*
			if (r_.find("blarney") != r_.end()) {
				json list_blarney = r_["blarney"].get<json>();
				for (int i_ = 0; i_ < list_blarney.size(); i_++) {
					int w_ = list_blarney[i_]["world"].get<int>();
					long long tim_ = list_blarney[i_]["time"].get<long long>();
					for (int c_ = 0; c_ < p_->completed_blarneys.size(); c_++) {
						if ((int)p_->completed_blarneys[c_][0] == w_) {
							p_->completed_blarneys[c_][1] = tim_;
							break;
						}
					}
				}
			}*/
		}
		catch (exception) {
			return -1;
		}

		/*
		if (pInfo(peer)->dev == 0) {
			vector<Account_Rid_Switch>::iterator p = find_if(account_rid_detect.begin(), account_rid_detect.end(), [&](const Account_Rid_Switch& a) { return a.name == pInfo(peer)->tankIDName; });
			if (p != account_rid_detect.end()) {
				Account_Rid_Switch* acc = &account_rid_detect[p - account_rid_detect.begin()];
				if (find(acc->rids.begin(), acc->rids.end(), pInfo(peer)->rid + pInfo(peer)->mac) == acc->rids.end()) acc->rids.push_back(pInfo(peer)->rid + pInfo(peer)->mac);
				if (acc->rids.size() > 4) {
					send_logs(pInfo(peer)->tankIDName + " PROXY USER (RID SPOOF DETECTED)", "RID SPOOF DETECT");
					Server_Security.banned_ip_temporary.push_back(make_pair(pInfo(peer)->ip, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					enet_peer_disconnect_later(peer, 0);
				}
			}
			else {
				Account_Rid_Switch new_data;
				new_data.name = pInfo(peer)->tankIDName;
				new_data.rids = { pInfo(peer)->rid };
				account_rid_detect.push_back(new_data);
			}
		}*/
		if (pInfo(peer)->ghost or pInfo(peer)->invis) {
			if (not pInfo(peer)->mod and not pInfo(peer)->dev) {
				pInfo(peer)->invis = false;
			}
			if (not pInfo(peer)->dev) {
				pInfo(peer)->ghost = false;
				if (pInfo(peer)->skin == -2450) pInfo(peer)->skin = 0x8295C3FF;
			}
		}
		if (pInfo(peer)->b_s == 0) {
			if (pInfo(peer)->supp == 2) {
				/*gamepacket_t p;
				p.Insert("OnOverrideGDPRFromServer");
				p.Insert(39);
				p.Insert(1);
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);*/
				{
					gamepacket_t p;
					p.Insert("OnSetRoleSkinsAndTitles");
					// pirmas - farmer
					// antras - builder
					// trecias - surgeon
					// ketvirtas - fisherman
					// penktas - chef
					// sestas - starcaptain
					string a = (pInfo(peer)->bb_lvl >= 50 ? "1" : "0");
					string a1 = (pInfo(peer)->bb_lvl >= 50 ? "2" : "0");
					string farm_set_skins = (pInfo(peer)->t_lvl >= 50 ? "1" : "0") + a + (pInfo(peer)->s_lvl >= 50 ? "1" : "0") + (pInfo(peer)->ff_lvl >= 50 ? "1" : "0");
					string farm_set_titles = (pInfo(peer)->t_lvl >= 50 ? "2" : "0") + a1 + (pInfo(peer)->s_lvl >= 50 ? "2" : "0") + (pInfo(peer)->ff_lvl >= 50 ? "2" : "0");
					p.Insert(farm_set_skins + "00");
					p.Insert(farm_set_titles + "00");
					p.CreatePacket(peer);
				}
			}
				OnSetGems(peer);
				{
					gamepacket_t p;
					p.Insert("OnMagicCompassTrackingItemIDChanged");
					p.Insert(pInfo(peer)->Magnet_Item);
					p.CreatePacket(peer);
				}
				
				{
					gamepacket_t p;
					p.Insert("UpdateMainMenuTheme");
					p.Insert(1), p.Insert(int(16843263)), p.Insert(int(16843263));
					p.CreatePacket(peer);
				}
			{
				gamepacket_t p2;
				p2.Insert("SetHasAccountSecured"), p2.Insert(1), p2.CreatePacket(peer);
			}
			gamepacket_t p;
			p.Insert("SetHasGrowID"), p.Insert(1), p.Insert(p_->tankIDName), p.Insert(p_->tankIDPass), p.CreatePacket(peer);
			int jau_turi = 0;
			modify_inventory(peer, 6336, jau_turi);
			if (jau_turi == 0) modify_inventory(peer, 6336, jau_turi=1);
		}
		return 0;
	}
	return -1;
}
string r_dialog(const string& r_, const string& gender_ = "", const string& a_ = "", const string& b_ = "", const string& c_ = "", const string& d_ = "") {
	return "text_scaling_string|Dirttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt|\nset_default_color|`o\nadd_label_with_icon|big|`wGet a GrowID``|left|206|\nadd_spacer|small|\nadd_textbox|" + (r_.empty() ? "By choosing a `wGrowID``, you can use a name and password to logon from any device.Your `wname`` will be shown to other players!" : r_) + "|left|\nadd_textbox|Select your sex:|left|\nmax_checks|1|\ntext_scaling_string|Woman|\nadd_checkicon|man|Man||9834||"+ (gender_ == "man" ? "1" : "0") + "|\nadd_checkicon|woman|Woman||9836||" + (gender_ == "woman" ? "1" : "0") + "|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_text_input|logon|Name|" + a_ + "|18|\nadd_textbox|Your `wpassword`` must contain `w8 to 18 characters, 1 letter, 1 number`` and `w1 special character: @#!$^&*.,``|left|\nadd_text_input_password|password|Password|" + b_ + "|18|\nadd_text_input_password|password_verify|Password Verify|" + c_ + "|18|\nadd_textbox|Your `wemail`` will only be used for account verification and support. If you enter a fake email, you can't verify your account, recover or change your password.|left|\nadd_text_input|email|Email|" + d_ + "|64|\nadd_textbox|We will never ask you for your password or email, never share it with anyone!|left|\nend_dialog|growid_apply|Cancel|Get My GrowID!|\n";
}
string return_last_online(string player_) {
	string times_ = "";
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(player_)) {
			times_ = pInfo(currentPeer)->last_online;
			break;
		}
	}
	if (times_.empty()) {
		ifstream ifs("players/" + player_ + "_.json");
		if (ifs.is_open()) {
			json j;
			ifs >> j;
			times_ = j["lo"].get<string>();
		}
	}
	if (times_.empty()) return to_string(100 + rand() % 50);
	long long time_ = time(nullptr);
	replace_str(times_, "\n", "|"), replace_str(times_, "/", "|"), replace_str(times_, ":", "|"), replace_str(times_, " ", "|");
	vector<string> a_ = explode("|", times_);
	time_t rawtime;
	struct tm* timeinfo;
	int year = atoi(a_[2].c_str()), month = atoi(a_[0].c_str()), day = atoi(a_[1].c_str()), hour = atoi(a_[3].c_str()), min = atoi(a_[4].c_str()), sec = atoi(a_[5].c_str());
	if (year == 123) year = 2023;
	time(&rawtime); //or: rawtime = time(0);
	timeinfo = localtime(&rawtime);
	timeinfo->tm_year = year - 1900;
	timeinfo->tm_mon = month - 1;    //months since January - [0,11]
	timeinfo->tm_mday = day;          //day of the month - [1,31] 
	timeinfo->tm_hour = hour;         //hours since midnight - [0,23]
	timeinfo->tm_min = min;          //minutes after the hour - [0,59]
	timeinfo->tm_sec = sec;          //seconds after the minute - [0,59]
	string days = to_playmod_time(time_ - mktime(timeinfo), true);
	if (time_ - mktime(timeinfo) < 0) return "1";
	else  return days;
}

string form_mods(Player* p_, int text) {
	string t_ = "";
	vector<string> player_playmods;
	long long time_ = time(nullptr);
	vector<string> added_{};
	for (PlayMods peer_playmod : p_->playmods) {
		string playmod_name = info_about_playmods[peer_playmod.id - 1][3];
		if (find(added_.begin(), added_.end(), playmod_name) == added_.end()) {
			added_.push_back(playmod_name);
			if (peer_playmod.time - time_ >= 1) {
				t_ += (text == 0 ? "\nadd_label_with_icon|small|`w" + playmod_name + "`` (`w" + to_playmod_time(peer_playmod.time - time_) + "`` left)``|left|" + info_about_playmods[peer_playmod.id - 1][6] + "|" : "\n`w" + playmod_name + "``");
			}
		}
	}
	player_playmods.push_back(items[p_->hair].playmod), player_playmods.push_back(to_string(p_->hair));
	player_playmods.push_back(items[p_->shirt].playmod), player_playmods.push_back(to_string(p_->shirt));
	player_playmods.push_back(items[p_->pants].playmod), player_playmods.push_back(to_string(p_->pants));
	player_playmods.push_back(items[p_->feet].playmod), player_playmods.push_back(to_string(p_->feet));
	player_playmods.push_back(items[p_->face].playmod), player_playmods.push_back(to_string(p_->face));
	player_playmods.push_back(items[p_->hand].playmod), player_playmods.push_back(to_string(p_->hand));
	player_playmods.push_back(items[p_->back].playmod), player_playmods.push_back(to_string(p_->back));
	player_playmods.push_back(items[p_->mask].playmod), player_playmods.push_back(to_string(p_->mask));
	player_playmods.push_back(items[p_->necklace].playmod), player_playmods.push_back(to_string(p_->necklace));
	player_playmods.push_back(items[p_->ances].playmod), player_playmods.push_back(to_string(p_->ances));
	if (p_->ghost) player_playmods.push_back("Ghost in the Shell"), player_playmods.push_back("290");
	if (p_->b_s != 0) player_playmods.push_back("Duct Tape"), player_playmods.push_back("408");
	if (p_->hand == 2286 or p_->hand == 2560) player_playmods.push_back("Charging " + items[p_->hand].ori_name + "`` (" + to_string(p_->geiger_) + "%)"), player_playmods.push_back(""+to_string(p_->hand) + "");
	if (p_->spotlight) player_playmods.push_back("In the Spotlight"), player_playmods.push_back("2646");
	if (p_->cheater_) player_playmods.push_back("Cheater Role"), player_playmods.push_back("9726");
	if (p_->cheater_settings & Gtps3::SETTINGS_0) player_playmods.push_back("`wCheat Active: Autofarm Ĝ -> " + items[p_->last_used_block].ori_name + " ````"), player_playmods.push_back("18");
	int active = 0;
	for (int i_ = 0; i_ < player_playmods.size(); i_++) {
		if (player_playmods[i_].empty() or isdigit(player_playmods[i_][0])) continue;
		t_ += (text == 0 ? "\nadd_label_with_icon|small|`w" + player_playmods[i_] + "``|left|" + player_playmods[i_ + 1] + "|" : "\n`w" + player_playmods[i_] + "``");
		active++;
	}
	if (t_.empty())
		t_ = "";
	else
		if (text == 0) t_ = "\nadd_textbox|`wActive effects:``|left|\nadd_label_with_icon|small|" + t_;
		else t_ = "\n" + to_string(active) + " mods active:" + t_;
	return t_;
}

void gems_(ENetPeer* peer, World* world_, int c_, int x_, int y_, int from) {
	if (from == 5136 || from == 9386 || from == 9400 || from == 9384 || from == 9902 || from == 9600 || from == 10716) return;
	bool doubled = false;
	if (thedaytoday == 5 and rand() % 50 < 1) c_++;
	if (peer != NULL) {
		if (rand() % 10 < 4) {
			if (has_playmod2(pInfo(peer), 113) || pInfo(peer)->hand == 10930) {
				if (rand() % 100 < 10) c_++, doubled = true;
			}
			if (has_playmod(pInfo(peer), "Extra Wealth") && rand() % 5 + 1 == 5) {
				gamepacket_t p;
				p.Insert("OnParticleEffect"), p.Insert(29), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					p.CreatePacket(currentPeer);
				}
				c_ = ((items[pInfo(peer)->ances].chance + 100) * c_) / 100;
				doubled = true;
			}
			if (from % 2 == 0) {
				if (pInfo(peer)->lock == 2408) if (rand() % 100 < 10) c_ += 2;
				if (items[pInfo(peer)->hair].extra_gems != 0)	if (c_ != 0) c_ += ((rand() % c_ + 1) * items[pInfo(peer)->hair].extra_gems) / 4, doubled = true;
				if (items[pInfo(peer)->necklace].extra_gems != 0) if (c_ != 0) c_ += ((rand() % c_ + 1) * items[pInfo(peer)->necklace].extra_gems) / 4, doubled = true;
				if (items[pInfo(peer)->hand].extra_gems != 0) if (c_ != 0) c_ += ((rand() % c_ + 1) * items[pInfo(peer)->hand].extra_gems) / 4, doubled = true;
			}
			if (doubled) {
				PlayerMoving data_{};
				data_.packetType = 17, data_.netID = 125, data_.YSpeed = 125, data_.x = x_ + 16, data_.y = y_ + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
			}
		}
		if (pInfo(peer)->superdev) c_ *= 1.25;
	}
	if (from == 5196) c_ *= 1.13;
	// gem konvertavimas
	if (c_ > 300) c_ = 300;
	c_ *= x_gems;
	int a_ = c_;
//	if (has_playmod2(pInfo(peer), 134) && rand() % 10 < 3) c_ += rand() % 3 + 1;
	if (peer != NULL) {
		if ((pInfo(peer)->cheater_settings & Gtps3::SETTINGS_6 && pInfo(peer)->disable_cheater == 0)) {
			OnSetGems(peer, c_);
			return;
		}
	}
	int black_gems = c_ / 1000;
	if (black_gems != 0) c_ = c_ - (black_gems * 1000);
	int purple_ = c_ >= 100 ? c_ / 100 : 0, green_ = c_ - (purple_ * 100) >= 50 ? (c_ - (purple_ * 100)) / 50 : 0, red_ = c_ - (purple_ * 100) - (green_ * 50) >= 10 ? (c_ - (purple_ * 100) - (green_ * 50)) / 10 : 0, blue_ = c_ - (green_ * 50) - (purple_ * 100) - (red_ * 10) >= 5 ? (c_ - (green_ * 50) - (purple_ * 100) - (red_ * 10)) / 5 : 0, yellow_ = c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (blue_ * 5) > 0 ? (c_ - (red_ * 10) - (green_ * 50) - (purple_ * 100) - (blue_ * 5)) / 1 : 0;
	// dabar drop   
	WorldDrop item_{};
	if (black_gems != 0) {
		item_.id = 4490;
		item_.count = black_gems;
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		dropas_(world_, item_);
	}
	item_.id = 112;
	item_.count = 100;
	for (int i_ = 0; i_ < purple_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		dropas_(world_, item_);
	}
	item_.count = 50;
	for (int i_ = 0; i_ < green_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		dropas_(world_, item_);
	}
	item_.count = 10;
	for (int i_ = 0; i_ < red_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		dropas_(world_, item_);
	}
	item_.count = 5;
	for (int i_ = 0; i_ < blue_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		dropas_(world_, item_);
	}
	item_.count = 1;
	for (int i_ = 0; i_ < yellow_; i_++) {
		item_.x = x_ + rand() % 17, item_.y = y_ + rand() % 17;
		dropas_(world_, item_);
	}
}
void send_mail(ENetPeer* p_) {
	string player_name = to_lower(pInfo(p_)->tankIDName), mailbox = "\nadd_smalltext|Mailbox is empty.|left|";
	vector<pair<string, string>>::iterator paa = find_if(mails.begin(), mails.end(), [&](const pair<string, string>& a) { return a.first == player_name; });
	if (paa != mails.end()) mailbox = mails[paa - mails.begin()].second;
	string::difference_type count_of_symbol = std::count(mailbox.begin(), mailbox.end(), '\n');
	if (mailbox == "\nadd_smalltext|Mailbox is empty.|left|") count_of_symbol--;
	pInfo(p_)->mailbox = count_of_symbol;
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMailbox (" + to_string(count_of_symbol) + ")``|left|1366|\nadd_spacer|small|\nadd_button|send_mailbox|Send mail|noflags|0|0|\nadd_spacer|small|" + mailbox + "\nadd_spacer|small|\nadd_smalltext|All of your mails will get deleted every 30 days|left|" + (count_of_symbol == 0 ? "" : "\nadd_button|empty|Empty|noflags|0|0|") + "\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|friends|||\nadd_quick_exit|");
	p.CreatePacket(p_);
}
void send_friends(ENetPeer* p_, bool all = false) {
	// labai cia sudinai gavosi   
	int on_ = 0;
	string info_ = "";
	vector<string> friends_, online_friends_;
	vector<pair<string, int>> player_status;
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		friends_.push_back(to_lower(pInfo(p_)->friends[c_].name));
	} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (find(friends_.begin(), friends_.end(), to_lower(pInfo(currentPeer)->tankIDName)) != friends_.end()) {
			online_friends_.push_back(to_lower(pInfo(currentPeer)->tankIDName));
			player_status.push_back(make_pair(to_lower(pInfo(currentPeer)->tankIDName), pInfo(currentPeer)->p_status));
			on_++;
		}
	} 
	if (all and pInfo(p_)->friends.size() != 0) {
		long long time_t = time(NULL);
		for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
			if (find(online_friends_.begin(), online_friends_.end(), to_lower(pInfo(p_)->friends[c_].name)) == online_friends_.end()) {
				long long friend_last_online_ = time_t - pInfo(p_)->friends[c_].last_seen;
				info_ += "\nadd_friend_image_label_button|" + pInfo(p_)->friends[c_].name + "|`4(" + (friend_last_online_ < 60 ? to_string(friend_last_online_) + "s" : (friend_last_online_ < 3600 ? to_string(friend_last_online_ / 60) + "m" : (friend_last_online_ < 86400 ? to_string(friend_last_online_ / 3600) + "h" : to_string(friend_last_online_ / 86400) + "d"))) + ") ``" + pInfo(p_)->friends[c_].name + "|game/tiles_page14.rttex|1.6|31|23|32|" + (pInfo(p_)->friends[c_].mute ? "true" : "false") + "|" + (pInfo(p_)->friends[c_].block_trade ? "true" : "false") + "|";
			}
		}
		string ignore = "\nadd_textbox|`oYou aren't currently ignoring anyone.``|left|";
		if (pInfo(p_)->ignored.size() != 0) {
			ignore = "";
			for (int c_ = 0; c_ < pInfo(p_)->ignored.size(); c_++) ignore += "\nadd_button|" + pInfo(p_)->ignored[c_] + "|`4Stop ignoring "+ pInfo(p_)->ignored[c_] + "``|0|0|";
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + to_string(on_) + " of " + to_string(pInfo(p_)->friends.size()) + " `wFriends Online``|left|1366|\nadd_spacer|small|" + info_ + "\nadd_spacer|small|"+ignore+"\nadd_spacer|small|\nadd_button|all_friends|Edit Friends|noflags|0|0|\nadd_button|friends_options|Friend Options|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|friends|||\nadd_quick_exit|");
		p.CreatePacket(p_);
	}
	else {
		for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
			if (find(online_friends_.begin(), online_friends_.end(), to_lower(pInfo(p_)->friends[c_].name)) != online_friends_.end()) {
				int pstatus = 0;
				vector<pair<string, int>>::iterator pz = find_if(player_status.begin(), player_status.end(), [&](const pair < string, int>& element) { return element.first == to_lower(pInfo(p_)->friends[c_].name); });
				if (pz != player_status.end()) {
					pstatus = player_status[pz - player_status.begin()].second;
				}
				info_ += "\nadd_friend_image_label_button|" + pInfo(p_)->friends[c_].name + "|" + pInfo(p_)->friends[c_].name + "|game/tiles_page14.rttex|1.6|"+to_string(28+ pstatus) + "|23|32|" + (pInfo(p_)->friends[c_].mute ? "true" : "false") + "|" + (pInfo(p_)->friends[c_].block_trade ? "true" : "false") + "|";
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + to_string(on_) + " of " + to_string(pInfo(p_)->friends.size()) + " `wFriends Online``|left|1366|\nadd_spacer|small|" + (on_ == 0 and pInfo(p_)->friends.size() != 0 ? "\nadd_textbox|`oNone of your friends are currently online.``|left|\nadd_spacer|small|" : (pInfo(p_)->friends.size() == 0 ? "\nadd_textbox|`oYou currently have no friends.  That's just sad.  To make some, press a person's wrench icon, then choose `5Add as friend``.``|left|\nadd_spacer|small|" : (on_ != 0 ? info_ : "\nadd_textbox|`oNone of your friends are currently online.``|left|\nadd_spacer|small|"))) + "\nadd_spacer|small|\nadd_button|friend_all|Show offline and ignored too|noflags|0|0|\nadd_button|all_friends|Edit Friends|noflags|0|0|\nadd_button|friends_options|Friend Options|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|friends|||\nadd_quick_exit|");
		p.CreatePacket(p_);
	}
}
void send_social(ENetPeer* p_) {
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	string asddd_ = pInfo(p_)->guild_id != 0 ? "Show Guild Members" : "Create Guild";
	p.Insert("set_default_color|`o\nadd_label_with_icon|big| `wSocial Portal`` |left|1366|\nadd_spacer|small|\nadd_button|showfriend|`wShow Friends``|noflags|0|0|\nadd_button|showmailbox|`wShow Mailbox``|noflags|0|0|\nadd_button|showguild|`w" + asddd_ + "``|noflags|0|0|"/*"\nadd_button|showguild|`w" + asddd_ + "``|noflags|0|0|\nadd_button|communityhub|`wCommunity Hub``|noflags|0|0|\nadd_button|show_apprentices|`wShow Apprentices``|noflags|0|0|"*/"\nadd_button|tradehistory|`wTrade History``|noflags|0|0|"
		//"\nadd_button|bglbank|`eBGL Bank|noflags|0|0|"
		"\nadd_quick_exit|\nend_dialog|socialportal||Back|\n");
	p.CreatePacket(p_);
}
void edit_friend(ENetPeer* p_, string name_, bool back_ = false) {
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (pInfo(p_)->friends[c_].name == name_) {
			if (back_) {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(p_)->friends[c_].name)) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
				break;
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Remove Friend``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4remove`` " + pInfo(p_)->friends[c_].name + " as a friend?|left|\nadd_spacer|small|\nadd_button|remove|`4Remove Friend``|noflags|0|0|\nembed_data|friendID|" + pInfo(p_)->friends[c_].name + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_remove|||\nadd_quick_exit|");
			p.CreatePacket(p_);
			break;
		}
	}
}
void send_info_friend(ENetPeer* p_, string name_) {
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(name_)) {
			if (pInfo(currentPeer)->invis or pInfo(currentPeer)->m_h) continue;
			for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
				if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(pInfo(currentPeer)->tankIDName)) {
					pInfo(p_)->last_edit = pInfo(currentPeer)->tankIDName;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (not pInfo(currentPeer)->show_location_) {
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + pInfo(currentPeer)->tankIDName + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + pInfo(currentPeer)->tankIDName + "\nadd_textbox|`o" + pInfo(currentPeer)->tankIDName + " is `2online`` now, but has not made their location public to friends.|left|\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
					}
					else {
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + pInfo(currentPeer)->tankIDName + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + pInfo(currentPeer)->tankIDName + "\nadd_textbox|`o" + pInfo(currentPeer)->tankIDName + " is `2online`` now in the world `5" + (pInfo(currentPeer)->world.empty() ? "EXIT" : pInfo(currentPeer)->world) + "``.|left|\nadd_spacer|small|\nadd_button|goto|Warp to `5" + (pInfo(currentPeer)->world.empty() ? "EXIT" : pInfo(currentPeer)->world) + "``|noflags|0|0|" + (pInfo(p_)->friends[c_].mute ? "\nadd_button||`4Can't Send message``|disabled|0|0|\nadd_button|mute|Un Mute Friend|noflags|0|0|" : "\nadd_button|msg|`5Send message``|noflags|0|0|\nadd_button|mute|Mute Friend|noflags|0|0|") + (pInfo(p_)->friends[c_].block_trade ? "\nadd_button|trade_block|Enable Trade|noflags|0|0|" : "\nadd_button|trade_block|Disable Trade|noflags|0|0|") + "\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
					}
					p.CreatePacket(p_);
					return;
				}
			}
			return;
		}
	}
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(name_)) {
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + name_ + "``|left|1366|\nadd_spacer|small|\nembed_data|friendID|" + name_ + "\nadd_textbox|`o" + name_ + " is `4offline``.|left|\nadd_spacer|small|\nadd_button|remove|Remove as friend|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_edit|||\nadd_quick_exit|");
			p.CreatePacket(p_);
			break;
		}
	}
}

void change_guild_name(ENetPeer* peer, string error = "", bool errors = false) {
	if (inventory_contains(peer, 7190) == 0) return;
	uint32_t guild_id = pInfo(peer)->guild_id;
	if (guild_id == 0) {
		gamepacket_t p2;
		p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You must own a guild to change name!"), p2.Insert(1), p2.Insert(1), p2.CreatePacket(peer);
		return;
	}
	vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
	if (p != guilds.end()) {
		Guild* guild_information = &guilds[p - guilds.begin()];
		guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
		guild_information->guild_settings |= Gtps3::SETTINGS_0;
		for (GuildMember member_search : guild_information->guild_members) {
			if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
				if (member_search.role_id == 3) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					if (error .empty() || errors) {
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wChange Guild Name``|left|5814|\nadd_textbox|Current Guild Name:" + guild_information->guild_name + "|left|" + (errors ? "\nadd_textbox|" + error + "|left|" : "") + "\nadd_text_input|name|Guild Name:||32|\nadd_spacer|small|\nend_dialog|change_guild_name|Cancel|Confirm|");
					}
					else {
						string path_ = "guilds/" + guild_information->guild_name + ".json";
						remove(path_.c_str());
						guild_information->guild_name = error;
						save_guilds();
						int got = -1;
						modify_inventory(peer, 7190, got);
						string guild_info = get_guild_info(peer);
						if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
						p.Insert(guild_info);
						{
							gamepacket_t p_leave;
							p_leave.Insert("OnConsoleMessage");
							p_leave.Insert("`5[GUILD ALERT]`` " + pInfo(peer)->tankIDName + " changed guild name to " + error + "!");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->guild_id == guild_id) {
									p_leave.CreatePacket(currentPeer);
								}
							}
						}
					}
					p.CreatePacket(peer);
				}
				else error = "ownership", errors = false;
			}
		}
	}
	if (error == "ownership" && errors == false) {
		gamepacket_t p2;
		p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("You must own the guild to change name!"), p2.Insert(1), p2.Insert(1), p2.CreatePacket(peer);
	}
}

void update_guild_name(ENetPeer* peer, string guild_world, World* world_) {
	uint32_t guild_id = pInfo(peer)->guild_id;
	update_clothes_value(peer, true);
	uint32_t my_role = pInfo(peer)->guild_role;
	if (pInfo(peer)->world == guild_world and not guild_world.empty()) {
		if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) {
			if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`2";
		}
		else if (not guild_access(peer, guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end()) {
			if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`0";
		}
		else {
			if (pInfo(peer)->mod == 0 && pInfo(peer)->dev == 0) pInfo(peer)->name_color = "`^";
		}
		update_clothes(peer);
		nick_update_2(peer, NULL);
		return;
	}
}

void transfer_world(World* world_, ENetPeer* from_, ENetPeer* to_) {
	if (world_->owner_name.empty()) return;
	int lock_id = 0, lock_x = -1, lock_y = -1;
	int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;

	{
		vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg != 202 && a.fg != 204 && a.fg != 206 && a.fg != 4994 && a.fg != 10000; });
		if (p != world_->blocks.end()) {
			int i_ = p - world_->blocks.begin();
			WorldBlock* block__ = &world_->blocks[p - world_->blocks.begin()];
			uint32_t id_ = block__->fg;
			lock_id = id_, lock_x = i_ % xSize, lock_y = i_ / xSize;
		}
	}
	if (lock_id == 0) return;
	pInfo(from_)->worlds_owned.erase(remove(pInfo(from_)->worlds_owned.begin(), pInfo(from_)->worlds_owned.end(), world_->name), pInfo(from_)->worlds_owned.end());
	string before_name = world_->owner_name;
	world_->owner_name = pInfo(to_)->tankIDName;
	if (pInfo(to_)->name_color != "`0" or pInfo(to_)->mod || pInfo(to_)->dev || pInfo(to_)->superdev && pInfo(to_)->name_color != "`2")  world_->owner_named = pInfo(to_)->name_color + pInfo(to_)->tankIDName;
	else world_->owner_named = pInfo(to_)->tankIDName;
	pInfo(to_)->worlds_owned.push_back(world_->name);
	PlayerMoving data_{};
	data_.packetType = 15, data_.punchX = lock_x, data_.punchY = lock_y, data_.characterState = 0x8, data_.netID = name_to_number(to_lower(pInfo(to_)->tankIDName)), data_.plantingTree = lock_id;
	BYTE* raw = packPlayerMoving(&data_, 56);
	gamepacket_t p;
	p.Insert("OnTalkBubble");
	p.Insert(pInfo(to_)->netID);
	p.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
	p.Insert(0), p.Insert(0);
	gamepacket_t p2;
	{
		p2.Insert("OnConsoleMessage");
		p2.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + pInfo(to_)->name_color + world_->owner_name + "```5]``");
	}
	pInfo(to_)->name_color = (pInfo(to_)->give_role ? "`8@" : pInfo(to_)->Staff ? "`4@" : pInfo(to_)->superdev ? "`8@" : pInfo(to_)->dev ? "`6@" : (pInfo(to_)->mod) ? "`#@" : (to_lower(pInfo(to_)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
	pInfo(from_)->name_color = (pInfo(from_)->give_role ? "`8@" : pInfo(from_)->Staff ? "`4@" : pInfo(from_)->superdev ? "`8@" : pInfo(from_)->dev ? "`6@" : (pInfo(from_)->mod) ? "`#@" : (to_lower(pInfo(from_)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
	nick_update_2(to_, NULL);
	nick_update_2(from_, NULL);
	string t_ = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0";
	BYTE* const d_ = new BYTE[5 + t_.length()];
	*(__int8*)(d_) = 3;
	memcpy(d_ + 4, t_.c_str(), t_.length());
	*(__int8*)(d_ + 4 + t_.length()) = 0;
	ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
		pInfo(currentPeer)->world_owner = (world_->owner_named.empty() ? "`#" + world_->owner_name : world_->owner_named);
		enet_peer_send(currentPeer, 0, p_m);
		send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
	}
	delete[]d_;
	delete[] raw;
	if (world_->guild_id != 0) {
 		uint32_t guild_id = world_->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
			guild_information->guild_settings |= Gtps3::SETTINGS_0;
			for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
				GuildMember* edit_member = &guild_information->guild_members[i_];
				if (to_lower(edit_member->member_name) == to_lower(before_name)) edit_member->role_id = 2, update_clothes_value(from_, true);
				if (to_lower(edit_member->member_name) == to_lower(pInfo(to_)->tankIDName)) edit_member->role_id = 3, update_clothes_value(to_, true);
				update_clothes(from_);
			}
		}
		int x_ = 0, y_ = 0;
		int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
		{
			vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
			if (p != world_->blocks.end()) {
				int i_ = p - world_->blocks.begin();
				WorldBlock* block__ = &world_->blocks[p - world_->blocks.begin()];
				uint32_t id_ = block__->fg;
				x_ = i_ % xSize;
				y_ = i_ / xSize;
			}
		}
		WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
		tile_update(to_, world_, block_, x_, y_);
		update_guild_name(from_, world_->name, world_);
		update_guild_name(to_, world_->name, world_);
	}
}
void remove_friend(ENetPeer* p_, World* world_, string name_, bool show_Dialog = true) {
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(name_)) {
			if (show_Dialog) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Friend removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`oOk, you are no longer friends with " + pInfo(p_)->friends[c_].name + ".|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_remove_finish|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			bool on_ = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(name_)) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("`3FRIEND ALERT:`` " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` has removed you as a friend.");
					p.CreatePacket(currentPeer);
					for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
						if (to_lower(pInfo(currentPeer)->friends[c_].name) == to_lower(pInfo(p_)->tankIDName)) {
							pInfo(currentPeer)->friends.erase(pInfo(currentPeer)->friends.begin() + c_);
							break;
						}
					}
					on_ = true;
					break;
				}
			} if (not on_) {
				try {
					string path_ = "players/" + name_ + "_.json";
					if (_access_s(path_.c_str(), 0) == 0) {
						json r_;
						ifstream f_(path_, ifstream::binary);
						if (f_.fail()) {
							cout << "failed reading data for " << name_ << endl;
							return;
						}
						f_ >> r_;
						f_.close();
						try {
							json f_ = r_["friends"].get<json>();
							for (int i_ = 0; i_ < f_.size(); i_++) {
								if (f_[i_]["name"] == pInfo(p_)->tankIDName) {
									f_.erase(f_.begin() + i_);
									break;
								}
							}
							r_["friends"] = f_;
						}
						catch (exception) {
							return;
						}
						{
							ofstream f_(path_, ifstream::binary);
							f_ << r_;
							f_.close();
						}
					}
				}
				catch (exception) {
					cout << "something failed players/json 2" << endl;
				}
			}
			pInfo(p_)->friends.erase(pInfo(p_)->friends.begin() + c_);
		}
	}
}

void send_all_edit_friends(ENetPeer* p_) {
	string info_ = "";
	for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
		info_ += "\nadd_checkbox|cf_" + to_string(c_) + "|" + pInfo(p_)->friends[c_].name + (pInfo(p_)->friends[c_].mute ? " <Muted>" : "") + (pInfo(p_)->friends[c_].block_trade ? " <Trade Block>" : "") + "|0";
	}
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wAll Friends``|left|1366|\nadd_spacer|small|\nadd_button|remove_multi_friends|Remove|noflags|0|0|\nadd_button|block_multi_friends|Block / Unblock Trade|noflags|0|0|\nadd_button|mute_multi_friends|Mute / Unmute|noflags|0|0|\nadd_spacer|small|" + info_ + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|all_friends|||\nadd_quick_exit|");
	p.CreatePacket(p_);
}
string make_trade_offer(Player* p_, bool special_ = false) {
	if (p_->trade_items.size() == 0 and not special_)
		return "\nadd_textbox|`4Nothing!``|left|";
	string list_ = "";
	for (int i_ = 0; i_ < p_->trade_items.size(); i_++) {
		map<string, int>::iterator it;
		for (auto it = p_->trade_items[i_].begin(); it != p_->trade_items[i_].end(); it++) {
			if (special_) {
				list_ += "add_slot|" + to_string(it->first) + "|" + to_string(it->second) + "\n";
			}
			else {
				list_ += "\nadd_label_with_icon|small|(`w" + to_string(it->second) + "``) " + items[it->first].ori_name + "|left|" + to_string(it->first) + "|";
			}
		}
	}
	return list_;
}
void send_wrench_self(ENetPeer* peer, string tabst = "") {
	time_t s__;
	s__ = time(NULL);
	int days_ = int(s__) / (60 * 60 * 24);
	double hours_ = (double)((s__ - pInfo(peer)->playtime) + pInfo(peer)->seconds) / 3600;
	string num_text = to_string(hours_);
	string rounded = num_text.substr(0, num_text.find(".") + 3);
	int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
	get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
	string a = "";
	string tabs =
		"set_default_color|`o"
		"\nstart_custom_tabs|"
		"\nadd_custom_button|info|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:" + a + (tabst.empty() ? "1,6" : "0,6") + ";width:0.14;min_width:60;|"
		"\nadd_custom_button|level|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:0,5;width:0.14;min_width:60;|"
		"\nadd_custom_button|skills|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:" + a + (tabst == "skills" ? "1,4" : "0,4") + ";width:0.14;min_width:60;|"
		"\nadd_custom_button|quests|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:0,3;width:0.14;min_width:60;|"
		"\nadd_custom_button|cheats|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:0,2;width:0.14;min_width:60;|"
		"\nadd_custom_button|badges|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:0,1;width:0.14;min_width:60;|"
		"\nadd_custom_button|mod|image:interface/large/gtps_wrench_tabs.rttex;image_size:228,92;frame:0,0;width:0.14;min_width:60;|"
		"\nend_custom_tabs|"
		;

	if (tabst == "skills") {
		gamepacket_t OnDialog(400);
		OnDialog.Insert("OnDialogRequest");
		OnDialog.Insert(
			tabs+
			"\nadd_label_with_icon|big|My Skills|left|12436|"
			"\nadd_spacer|small|"
			"\nadd_smalltext|`9All of your life-skills will be displayed here below! Life skills are defined as a group of psychosocial competencies and interpersonal skills that help people make informed decisions, solve problems, think critically and creatively, communicate effectively.``|left|"
			"\nadd_textbox|`9You've Punched``|left|"
			"\nadd_label_with_icon|small|" + to_string(pInfo(peer)->punch_count) + " times|left|18|"
			"\nadd_spacer|small|"
			"\nadd_textbox|`9Fires Put Out``|left|"
			"\nadd_label_with_icon|small|" + to_string(pInfo(peer)->fires) + "|left|3062|"
			"\nadd_spacer|small|"
			"\nadd_textbox|`9Carnival Games Won``|left|"
			"\nadd_label_with_icon|small|" + to_string(pInfo(peer)->carnivalgameswon) + "|left|1882|"
			"\nadd_spacer|small|"
			"\nadd_textbox|`9Surgeries Completed (using Bling set)``|left|"
			"\nadd_label_with_icon|small|" + to_string(pInfo(peer)->su_8552_1) + " `$(2000 more until Angel of Mercy's Wings)|left|1270|"
			"\nadd_label_with_icon|small|" + to_string(pInfo(peer)->su_8552_1) + " `$(3000 more until `4Dr.`` Title)|left|1270|"
			"\nadd_spacer|small|"
			"\nadd_textbox|`9Online Point Currency``|left|"
			"\nadd_label_with_icon|small|"+ to_string(pInfo(peer)->opc) +"|left|10668|"
			"\nadd_spacer|small|"
			"\nadd_textbox|`9Hide And Seek``|left|"
			"\nadd_label_with_icon|small|as a Hider `$"+ to_string(pInfo(peer)->won_hider) +"|left|10016|"
			"\nadd_label_with_icon|small|as a Seeker `$"+ to_string(pInfo(peer)->won_seeker) +"``|left|10016|"
			"\nadd_spacer|small|"
			"\nadd_textbox||left|"
			"\nadd_spacer|small|"
			"\nadd_quick_exit|"
			"\nend_dialog|popup|||"
		);
		OnDialog.CreatePacket(peer);
		return;
	}

	string extra = "", Ezio = "", status = "\nadd_custom_button|online_status|image:interface/large/gui_wrench_online_status_"+a+(pInfo(peer)->p_status == 0 ? "1green" : pInfo(peer)->p_status == 1 ? "2yellow" : "3red") + ".rttex;image_size:400,260;width:0.19;|";


	if (pInfo(peer)->feet == 10618) {
		Ezio += "\nadd_custom_button|feet|image:interface/large/gui_wrench_pps_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	if (pInfo(peer)->back == 10424) {
		Ezio += "\nadd_custom_button|Rift_Cape|image:interface/large/gui_wrench_rift_cape.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	else if (pInfo(peer)->back == 11478) {
		Ezio += "\nadd_custom_button|Rift_Wings|image:interface/large/gui_wrench_rift_wings.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	else if (pInfo(peer)->back == 12640) {
		Ezio += "\nadd_custom_button|minokawa_wings|image:interface/large/gui_wrench_mkw.rttex;image_size:400,260;width:0.19;|";
	}
	else if (pInfo(peer)->back == 10182) {
		Ezio += "\nadd_custom_button|piano_wings_edit|image:interface/large/gui_wrench_musical_wings.rttex;image_size:400,260;width:0.19;|";
	}


	if (pInfo(peer)->necklace == 13220 || pInfo(peer)->necklace == 13196) {
		Ezio += "\nadd_custom_button|neck|image:interface/large/gui_wrench_u2_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	else if (pInfo(peer)->necklace == 11560 || pInfo(peer)->necklace == 11554 || pInfo(peer)->necklace == 11556 || pInfo(peer)->necklace == 11558) {
		Ezio += "\nadd_custom_button|neck|image:interface/large/gui_wrench_u_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	else if (pInfo(peer)->necklace == 11748) {
		Ezio += "\nadd_custom_button|bannerbandolier|image:interface/large/gui_wrench_banner_bandolier.rttex;image_size_x:400;image_size_y:260;width:0.19;|";
	}
	else if (pInfo(peer)->necklace == 11818) {
		Ezio += "\nadd_custom_button|scarf_of_seasons_edit|image:interface/large/gui_wrench_banner_seasons_item2.rttex;image_size:400,260;width:0.19;|";
	}
	else if (pInfo(peer)->necklace == 12648 || pInfo(peer)->necklace == 12646 || pInfo(peer)->necklace == 12650) {
		Ezio += "\nadd_custom_button|neck|image:interface/large/gui_wrench_a15.rttex;image_size:400,260;width:0.19;|";
	}

	if (pInfo(peer)->hand == 10952 || pInfo(peer)->hand == 10954 || pInfo(peer)->hand == 10956 || pInfo(peer)->hand == 10958 || pInfo(peer)->hand == 10960) {
		Ezio += "\nadd_custom_button|hand|image:interface/large/gui_wrench_space_animals_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	else if (pInfo(peer)->hand == 12866 || pInfo(peer)->hand == 12868) {
		Ezio += "\nadd_custom_button|hand|image:interface/large/gui_wrench_st_ani.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}
	else if (pInfo(peer)->hand == 12014 || pInfo(peer)->hand == 12016 || pInfo(peer)->hand == 12018 || pInfo(peer)->hand == 12020) {
		Ezio += "\nadd_custom_button|hand|image:interface/large/gui_wrench_st_transform.rttex;image_size_x:400;image_size_y:260;width: 0.19;|";
	}

	if (pInfo(peer)->ances == 12634) {
		Ezio += "\nadd_custom_button|eq_aura|image:interface/large/gui_wrench_eq_a.rttex;image_size:400,260;width:0.19;|";
	}

	if (pInfo(peer)->hair == 12958) {
		Ezio += "\nadd_custom_button|infinity_crown_edit|image:interface/large/gui_wrench_icr.rttex;image_size:400,260;width:0.19;|";
	}
	else if (pInfo(peer)->hair == 10674) {
		Ezio += "\nadd_custom_button|cernuous_mask_edit|image:interface/large/gui_wrench_crown_seasons.rttex;image_size:400,260;width:0.19;|";
	}
	else if (pInfo(peer)->hair == 12872 || pInfo(peer)->hair == 12874) {
		Ezio += "\nadd_custom_button|panda_spirit|image:interface/large/gui_wrench_rpan.rttex;image_size:400,260;width:0.19;|";
	}
	if (pInfo(peer)->guild_id != 0) {
		uint32_t guild_id = pInfo(peer)->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			uint32_t my_rank = 0;
			for (GuildMember member_search : guild_information->guild_members) {
				if (to_lower(member_search.member_name) == to_lower(pInfo(peer)->tankIDName)) {
					my_rank = member_search.role_id;
					break;
				}
			}
			if (guild_information->guild_mascot[1] == 0 and guild_information->guild_mascot[0] == 0) {
			//	extra += "\nadd_dual_layer_icon_label|small|`9Guild: `2" + guild_information->guild_name + "``|left|0|5814|1.0|1|\nadd_smalltext|`9Rank: `2" + (my_rank == 0 ? "Member" : (my_rank == 1 ? "Elder" : (my_rank == 2 ? "Co-Leader" : "Leader"))) + "``|left|";
				extra += "\nadd_label_with_icon|small|`9Guild: `2" + guild_information->guild_name + "``|left|5814|\nadd_textbox|`9Rank: `2" + (my_rank == 0 ? "Member" : (my_rank == 1 ? "Elder" : (my_rank == 2 ? "Co-Leader" : "Leader"))) + "``|left|";
			}
			else {
				extra += "\nadd_dual_layer_icon_label|small|`9Guild: `2" + guild_information->guild_name + "``|left|" + to_string(guild_information->guild_mascot[1]) + "|" + to_string(guild_information->guild_mascot[0]) + "|1.0|1|\nadd_smalltext|`9Rank: `2" + (my_rank == 0 ? "Member" : (my_rank == 1 ? "Elder" : (my_rank == 2 ? "Co-Leader" : "Leader"))) + "``|left|";
			}
		}
	}
	if (pInfo(peer)->access_offers.size() != 0) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) {
				if (pInfo(peer)->access_offers.find(pInfo(currentPeer)->netID) != pInfo(peer)->access_offers.end()) {
					string name_ = pInfo(peer)->world;
					vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
					if (p != worlds.end()) {
						World* world_ = &worlds[p - worlds.begin()];
						string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(currentPeer)->tankIDName);
						WorldBlock block_ = world_->blocks[pInfo(peer)->access_offers[pInfo(currentPeer)->netID]];
						if (block_.fg == 202 or block_.fg == 204 or block_.fg == 206 or block_.fg == 4994 or block_.fg == 10000) {
							if (to_lower(block_.owner_name) != user_name) break;
						}
						else {
							if (owner_name != user_name) break;
						}
						extra += "\nadd_button|acceptlock|`2Accept Access on " + items[block_.fg].name + "``|noflags|0|0|";
					}
					break;
				}
			}
		}
		if (extra.empty()) pInfo(peer)->access_offers.clear();
	}
	if (pInfo(peer)->pending_guild != 0 and pInfo(peer)->guild_id == 0) {
		uint32_t guild_id = pInfo(peer)->pending_guild;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			Guild* guild_information = &guilds[p - guilds.begin()];
			if (guild_information->guild_members.size() < guild_information->guild_level * 5) {
				extra += "\nadd_button|acceptguild|`2Join " + guild_information->guild_name + " Guild``|noflags|0|0|";
			}
		}
	}
	/*
	uint16_t stage = pInfo(peer)->stage_pineapple;
	if (stage >= 200) stage -= (stage / 200) * 200;
	if (stage == 0 && (pInfo(peer)->stage_pineapple == 200 || pInfo(peer)->stage_pineapple == 400 || pInfo(peer)->stage_pineapple == 600)) stage = 200;
	uint8_t stage_level = (pInfo(peer)->stage_pineapple <= 200 ? 1 : (pInfo(peer)->stage_pineapple <= 400 ? 2 : 3));
	
	string pineapple = "\nadd_progress_bar||small|Pineapple Stage "+to_string(stage_level) + "|" + (pInfo(peer)->stage_pineapple >= 600 && stage_level == 3 ? "200" : to_string(stage)) + "|200|"+(pInfo(peer)->stage_pineapple >=600 && stage_level == 3 ? "(MAX)" : "(" + to_string(stage) + "/200)") + "|16777215|";
	*/
	string pineapple = "";

	
	
	gamepacket_t p(400);
	p.Insert("OnDialogRequest");
	p.Insert(tabs+"\nadd_label_with_icon|big|My Profile|left|12436|\nadd_progress_bar|`w"+ pInfo(peer)->tankIDName +"``|big|Level " + to_string(pInfo(peer)->level) + "|" + to_string(pInfo(peer)->xp) + "|" + to_string(50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2)) + "|(" + to_string(pInfo(peer)->xp) + "/" + to_string(50 * ((pInfo(peer)->level * pInfo(peer)->level) + 2)) + ")|-3669761|" + pineapple + "\nadd_spacer|small|" + extra + ""/*"\nadd_button|glory|Road to Glory|noflags|0|0|"*/"\nadd_spacer|small|\nset_custom_spacing|x:5;y:10|\nadd_custom_button|open_personlize_profile|image:interface/large/gui_wrench_personalize_profile.rttex;image_size:400,260;width:0.19;|"+ status +"" + (pInfo(peer)->supp != 0 ? "\nadd_custom_button|billboard_edit|image:interface/large/gui_wrench_edit_billboard.rttex;image_size:400,260;width:0.19;|" : "") + "\nadd_custom_button|notebook_edit|image:interface/large/gui_wrench_notebook.rttex;image_size:400,260;width:0.19;|\nadd_custom_button|goals|image:interface/large/gui_wrench_goals_quests.rttex;image_size:400,260;width:0.19;|" + (pInfo(peer)->gp ? "\nadd_custom_button|bonus|image:interface/large/gui_wrench_daily_bonus_active.rttex;image_size:400,260;width:0.19;|" : "") + "\nadd_custom_button|my_worlds|image:interface/large/gui_wrench_my_worlds.rttex;image_size:400,260;width:0.19;|\nadd_custom_button|alist2|image:interface/large/gui_wrench_backpack.rttex;image_size:400,260;width:0.19;|\nadd_custom_label|(" + to_string(pInfo(peer)->bp.size()) + "/" + to_string(pInfo(peer)->b_l * 10) + ")|target:alist2;top:0.72;left:0.5;size:small|\nadd_custom_button|alist|image:interface/large/gui_wrench_achievements.rttex;image_size:400,260;width:0.19;|\nadd_custom_label|(" + to_string(pInfo(peer)->achievements.size()) + "/169)|target:alist;top:0.72;left:0.5;size:small|\nadd_custom_button|emojis|image:interface/large/gui_wrench_growmojis.rttex;image_size:400,260;width:0.19;|\nadd_custom_button|title_edit|image:interface/large/gui_wrench_title.rttex;image_size:400,260;width:0.19;|" + Ezio + ""/*"\nadd_custom_button|g4g_personal_dialog|image:interface/large/gui_wrench_g4g.rttex;image_size:400,260;width:0.19;|"*/""/*"\nadd_custom_button|marvelous_missions|image:interface/large/gui_wrench_marvelous_missions.rttex;image_size:400,260;width:0.19;|"*/"\nadd_custom_break|\nadd_spacer|small|\nset_custom_spacing|x:0;y:0|\nadd_small_font_button|account_security|Account Security|noflags|0|0|\nadd_small_font_button|cheats|Cheat Menu|noflags|0|0|" + (pInfo(peer)->vip ? "\nadd_small_font_button|set|Set|noflags|0|0|" : "") + "" + (pInfo(peer)->glo >= 1 ? "\nadd_small_font_button|glory|Road to Glory|noflags|0|0|" : "") + ""  + form_mods(pInfo(peer), 0) + "\nadd_spacer|small|\nadd_textbox|`oYou have `w" + to_string(pInfo(peer)->inv.size() - 1) + "`` backpack slots.``|left|\nadd_textbox|`oCurrent world: `w" + pInfo(peer)->world + "`` (`w" + to_string(pInfo(peer)->x / 32) + "``, `w" + to_string(pInfo(peer)->y / 32) + "``) (`w" + to_string(w_c) + "`` person)````|left|" + (pInfo(peer)->mod or pInfo(peer)->moderator ? "\nadd_textbox|`oYou are a `5Moderator`` and have the `wPunish View`` and `w/mhelp``.``|left|" : "") + (pInfo(peer)->vip ? "\nadd_textbox|`oYou are a `5VIP`` and have the `w/vhelp``.``|left|" : "") + "\nadd_textbox|" + (pInfo(peer)->supp == 0 ? "`oYou are not yet a `2Supporter`` or `5Super Supporter``.``" : pInfo(peer)->supp == 1 ? "`oYou are a `5Supporter`` and have the `wRecycler``.``" : pInfo(peer)->supp == 2 ? "`oYou are a `5Super Supporter`` and have the `wRecycler`` and `w/warp``.``" : "") + "|left|\nadd_textbox|`oYou are standing on the note \"A\".``|left|\nadd_spacer|small|\nadd_textbox|`oTotal time played is `w" + rounded + "`` hours.  This account was created `w" + to_string(days_ - pInfo(peer)->account_created) + "`` days ago.``|left|\nadd_spacer|small|\nend_dialog|popup|||\nadd_quick_exit|");
	p.CreatePacket(peer);
}

string add_small_font_summer(string which) {
	return "\nadd_small_font_button|"+which+"|Claim Reward|noflags|0|0|";
}
void send_trade_confirm_dialog(ENetPeer* peer, ENetPeer* currentPeer, bool self_only = false) {
	pInfo(peer)->block_trade = true;
	pInfo(currentPeer)->block_trade = true;
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		bool world_key_p = false, world_key_cp = false;
		bool guild_key_p = false, guild_key_cp = false;
		string lock = "";
		for (int i_ = 0; i_ < pInfo(peer)->trade_items.size(); i_++) {
			if (world_key_p  or guild_key_p) break;
			map<string, int>::iterator it;
			for (auto it = pInfo(peer)->trade_items[i_].begin(); it != pInfo(peer)->trade_items[i_].end(); it++) {
				if (it->first == 1424  or it->first == 5816) {
					if (it->first == 5816) guild_key_p = true;
					else world_key_p = true;
					{
						vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg != 202 && a.fg != 204 && a.fg != 206 && a.fg != 4994 && a.fg != 10000; });
						if (p != world_->blocks.end()) {
							int i_ = p - world_->blocks.begin();
							WorldBlock* block__ = &world_->blocks[p - world_->blocks.begin()];
							uint32_t id_ = block__->fg;
							lock = items[id_].name;
						}
					}
					break;
				}
			}
		} for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
			if (world_key_cp  or guild_key_cp) break;
			map<string, int>::iterator it;
			for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
				if (it->first == 1424  or it->first == 5816) {
					if (it->first == 5816) guild_key_cp = true;
					else world_key_cp = true;
					{
						vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg != 202 && a.fg != 204 && a.fg != 206 && a.fg != 4994 && a.fg != 10000; });
						if (p != world_->blocks.end()) {
							int i_ = p - world_->blocks.begin();
							WorldBlock* block__ = &world_->blocks[p - world_->blocks.begin()];
							uint32_t id_ = block__->fg;
							lock = items[id_].name;
						}
					}
					break;
				}
			}
		}
		string g_name = "";
		if (guild_key_p or guild_key_cp) {
			uint32_t guild_id = world_->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				g_name = guild_information->guild_name;
			}
		}
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(peer)) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(currentPeer)) + "\nadd_spacer|small|" + (pInfo(currentPeer)->trade_items.size() == 0 ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|" : "") + (guild_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are taking leadership of the guild: `#" + g_name + " and the guild world: " + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a guild world for its name, guild mascot and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (world_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (guild_key_p ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to transfer guild leadership and your guild world `#" + world_->name + "`` - the guild lock ownership will be transferred over to " + get_player_nick(peer) + ".|left|\nadd_spacer|small|" : (world_key_p ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world_->name + "`` - the world lock ownership will be transferred over to " + get_player_nick(currentPeer) + ".|left|\nadd_spacer|small|" : "")))) + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
		p.CreatePacket(peer);
		if (not self_only) {
			{
				gamepacket_t p;
				p.Insert("OnForceTradeEnd");
				p.CreatePacket(currentPeer);
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|1366|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(currentPeer)) + "\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|" + make_trade_offer(pInfo(peer)) + "\nadd_spacer|small|" + (pInfo(peer)->trade_items.size() == 0 ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are about to do a trade without receiving anything in return. Once you do the trade you cannot get the items back.|left|\nadd_textbox|`4Do you really want to do this?``|left|\nadd_spacer|small|" : "") + (guild_key_p ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are taking leadership of the guild: `#" + g_name + " and the guild world: " + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a guild world for its name, guild mascot and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (world_key_p ? "\nadd_spacer|small|\nadd_textbox|`4SCAM WARNING: ``You are buying this world, `#" + world_->name + "``. Don't buy a world just to get its rare items, because scammers can easily place secret doors allowing someone to jump in and `4steal the items back`` after a trade!|left|\nadd_spacer|small|\nadd_textbox|Also, all ratings will be removed from a world when it is traded. Don't buy a world for its ranking!|left|\nadd_spacer|small|\nadd_textbox|To be safe, only buy a world for its name and placed blocks, not loose items or high ratings. Consider yourself warned!|left|\nadd_spacer|small|\nadd_textbox|This world is locked by " + lock + ".|left|\nadd_spacer|small|" : (guild_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to transfer guild leadership and your guild world `#" + world_->name + "`` - the guild lock ownership will be transferred over to " + get_player_nick(peer) + ".|left|\nadd_spacer|small|" : (world_key_cp ? "\nadd_spacer|small|\nadd_textbox|`4WARNING: ``You are about to sell your world `#" + world_->name + "`` - the world lock ownership will be transferred over to " + get_player_nick(peer) + ".|left|\nadd_spacer|small|" : "")))) + "\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|trade_confirm|||");
			p.CreatePacket(currentPeer);
		}
	}
}
void mod_trade(ENetPeer* p_, int item_id, int count, bool remove = false) {
	if (pInfo(p_)->trading_with == -1) return;
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(p_)->world) {
			if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (pInfo(p_)->block_trade or pInfo(currentPeer)->block_trade) {
						cancel_trade(pInfo(p_)->block_trade ? p_ : currentPeer, false);
						return;
					}
					if (item_id == 5816 and to_lower(pInfo(p_)->tankIDName) != to_lower(world_->owner_name) and not pInfo(p_)->dev or item_id == 1424 and to_lower(pInfo(p_)->tankIDName) != to_lower(world_->owner_name) and not pInfo(p_)->dev) {
						packet_(p_, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("You can only trade World Keys in a world you own!");
						p.CreatePacket(p_);
						break;
					}
					if (item_id == 5816 and pInfo(p_)->guild_id == 0 or item_id == 5816 and pInfo(p_)->guild_id != pInfo(currentPeer)->guild_id) {
						packet_(p_, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("The person must join your guild first!");
						p.CreatePacket(p_);
						break;
					}
					if (remove) {
						int count_ = 0;
						for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
							auto i = pInfo(p_)->trade_items[i_].find(item_id);
							if (i != pInfo(p_)->trade_items[i_].end()) {
								map<string, int>::iterator it;
								for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
									if (it->first == item_id)
										count_ = it->second;
								}
								pInfo(p_)->trade_items.erase(pInfo(p_)->trade_items.begin() + i_);
								break;
							}
						}
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`1TRADE CHANGE: `` " + get_player_nick(p_) + " removed `w" + to_string(count_) + "`` " + items[item_id].name);
						p.CreatePacket(currentPeer);
						if (count_ == 0) cancel_trade(p_);
					}
					else {
						if (count == 0)break;
						bool f_ = false;
						for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
							map<string, int>::iterator it;
							for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
								if (it->first == item_id and it->second == count) {
									swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
									f_ = true;
									break;
								}
								else if (it->first == item_id and it->second != count) {
									swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
									f_ = true;
									it->second = count;
									break;
								}
							}
						} if (not f_) {
							if (count == 0)break;
							if (pInfo(p_)->trade_items.size() > 3) return;
							map<int, int> new_;
							new_.insert({ item_id, count });
							pInfo(p_)->trade_items.push_back(new_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`1TRADE CHANGE: `` " + get_player_nick(p_) + " removed `w" + to_string(count) + "`` " + items[item_id].name);
							p.CreatePacket(currentPeer);
							if (count == 0) cancel_trade(currentPeer);
						}
						if (count == 0)break;
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`1TRADE CHANGE: `` " + get_player_nick(p_) + " added `w" + to_string(count) + "`` " + items[item_id].name);
						p.CreatePacket(currentPeer);
					}
					if (pInfo(p_)->trade_accept == 1) {
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(p_)->netID);
						p.Insert("");
						p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
						p.Insert("locked|0\naccepted|1");
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
					}
					gamepacket_t p;
					p.Insert("OnTradeStatus");
					p.Insert(pInfo(p_)->netID);
					p.Insert("");
					p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
					p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\naccepted|0");
					p.CreatePacket(p_);
					{
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(currentPeer)->netID);
						p.Insert("");
						p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
						p.Insert("locked|0\naccepted|1");
						p.CreatePacket(currentPeer);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(p_)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
							p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(p_);
						}
					}
					{
						packet_(p_, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
						packet_(currentPeer, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
						gamepacket_t p;
						p.Insert("OnTextOverlay");
						p.Insert("The deal has changed");
						p.CreatePacket(p_), p.CreatePacket(currentPeer);
					}
					pInfo(p_)->trade_accept = 0, pInfo(currentPeer)->trade_accept = 0;
				}
				return;
			}
		}
	}
	if (remove) {
		for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
			auto i = pInfo(p_)->trade_items[i_].find(item_id);
			if (i != pInfo(p_)->trade_items[i_].end()) {
				pInfo(p_)->trade_items.erase(pInfo(p_)->trade_items.begin() + i_);
				break;
			}
		}
	}
	else {
		if (count == 0)return;
		bool f_ = false;
		for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
			map<string, int>::iterator it;
			for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
				if (it->first == item_id and it->second == count) {
					swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
					f_ = true;
					break;
				}
				else if (it->first == item_id and it->second != count) {
					swap(pInfo(p_)->trade_items[i_], pInfo(p_)->trade_items.back());
					f_ = true;
					it->second = count;
					break;
				}
			}
		}
		if (not f_) {
			if (count == 0)return;
			if (pInfo(p_)->trade_items.size() > 3) return;
			map<int, int> new_;
			new_.insert({ item_id, count });
			pInfo(p_)->trade_items.push_back(new_);
		}
	}
	string name_ = pInfo(p_)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (pInfo(p_)->trade_accept == 1) {
			{
				gamepacket_t p;
				p.Insert("OnTradeStatus");
				p.Insert(pInfo(p_)->netID);
				p.Insert("");
				p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
				p.Insert("locked|0\nreset_locks|1\naccepted|0");
				p.CreatePacket(p_);
			}
			gamepacket_t p;
			p.Insert("OnTradeStatus");
			p.Insert(pInfo(p_)->netID);
			p.Insert("");
			p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
			p.Insert("locked|0\naccepted|1");
			p.CreatePacket(p_);
			{
				gamepacket_t p;
				p.Insert("OnTradeStatus");
				p.Insert(pInfo(p_)->netID);
				p.Insert("");
				p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
				p.Insert("locked|0\nreset_locks|1\naccepted|0");
				p.CreatePacket(p_);
			}
		}
		gamepacket_t p;
		p.Insert("OnTradeStatus");
		p.Insert(pInfo(p_)->netID);
		p.Insert("");
		p.Insert("`o" + get_player_nick(p_) + "'s offer.``");
		p.Insert(make_trade_offer(pInfo(p_), true) + "locked|0\naccepted|0");
		p.CreatePacket(p_);
		{
			if (pInfo(p_)->trade_accept == 1) {
				packet_(p_, "action|play_sfx\nfile|audio/tile_removed.wav\ndelayMS|0");
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("The deal has changed");
				p.CreatePacket(p_);
				pInfo(p_)->trade_accept = 0;
			}
		}
	}
}

void chat_message(ENetPeer* peer, string message) {
	if (pInfo(peer)->hider && pInfo(peer)->world == Hide_N_Seek.hidenseekworld) {
		message = "[HIDER ONLY]: " + message;
	}
	string::difference_type count_of_symbol = std::count(message.begin(), message.end(), '`');
	if (count_of_symbol > 10) return;
	if (has_playmod2(pInfo(peer), 11) || has_playmod(pInfo(peer), "Iron MMMFF")) {
		string msg2 = "";
		for (int i = 0; i < message.length(); i++) {
			if (isspace(message[i])) msg2 += " ";
			else {
				if (isupper(message[i])) msg2 += i % 2 == 0 ? "M" : "F";
				else msg2 += i % 2 == 0 ? "m" : "f";
			}
		}
		message = msg2;
	}
	string check_ = message;
	transform(check_.begin(), check_.end(), check_.begin(), ::tolower);
	{
		string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (world_->world_settings & Gtps3::SETTINGS_8 and pInfo(peer)->superdev != 1 and to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end()) {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`1(Peasants must not speak)"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
				return;
			}
		}
	}
	bool warned = false;
	pInfo(peer)->not_same++;
	if (pInfo(peer)->last_input_text == message) pInfo(peer)->same_input++;
	pInfo(peer)->last_input_text = message;
	if (pInfo(peer)->last_spam_detection + 5500 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->last_spam_detection = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count(), pInfo(peer)->same_input = 0, pInfo(peer)->not_same = 0;
	if (pInfo(peer)->same_input >= 3 || pInfo(peer)->not_same >= 5) {
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("`6>>`4Spam detected! ``Please wait a bit before typing anything else.  Please note, any form of bot/macro/auto-paste will get all your accounts banned, so don't do it!"), p.CreatePacket(peer);
	}
	else {
		string chat_color = "`$";
		if (pInfo(peer)->d_name.empty() && pInfo(peer)->tmod == 0) {
			chat_color = pInfo(peer)->superdev ? "`5" : pInfo(peer)->dev ? "`1" : pInfo(peer)->mod ? "`^" : "`$";
		}
		if (has_playmod2(pInfo(peer), 28) || pInfo(peer)->hair == 5718) {
			chat_color = "`2";
			if (has_playmod2(pInfo(peer), 28) && rand() % 5 < 1) chat_color += "Brraaiinnss...";
		}
		if (pInfo(peer)->face == 1170) {
			chat_color = "`4";
			replaceAll(message, "w", "v");
		}
		gamepacket_t p, p2;
		p.Insert("OnConsoleMessage");
		p.Insert("CP:_PL:0_OID:_CT:[W]_ `6<`w" + (get_player_nick(peer)) + "`6> " + chat_color + pInfo(peer)->chat_prefix + message);
		p2.Insert("OnTalkBubble");
		p2.Insert(pInfo(peer)->netID);
		string log = "";
		if (check_ != ":/" and check_ != ":p" and check_ != ":*" and check_ != ";)" and check_ != ":d" and check_ != ":o" and check_ != ":'(" and check_ != ":(") {
			log = "CP:_PL:0_OID:_player_chat=" + (chat_color == "`$" ? "" : chat_color) + pInfo(peer)->chat_prefix + message;
			for (int i = 0; i < count_of_symbol; i++) log += "``";
			p2.Insert(log);
		}
		else p2.Insert(message);
		if (not Server_Security.log_player.empty() && Server_Security.log_player == pInfo(peer)->tankIDName) cout << "LOGGING: " << pInfo(peer)->tankIDName << " | " << "\nTEXT in world" << "|" << log << endl;
		p2.Insert(0), p2.Insert(0);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) {
				if (find(pInfo(currentPeer)->ignored.begin(), pInfo(currentPeer)->ignored.end(), to_lower(pInfo(peer)->tankIDName)) == pInfo(currentPeer)->ignored.end()) {
					/*
					bool muted_ = false;
					for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
						if (pInfo(currentPeer)->friends[c_].name == pInfo(peer)->tankIDName) {
							if (pInfo(currentPeer)->friends[c_].mute) {
								muted_ = true;
								break;
							}
						}
					}
					if (not muted_) {*/
					if (pInfo(peer)->hider && pInfo(peer)->world == Hide_N_Seek.hidenseekworld) {
						if (pInfo(currentPeer)->hider) {
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
						}
					}
					else {
						p.CreatePacket(currentPeer);
						p2.CreatePacket(currentPeer);
					}
				}
				//}
			}
		}
	}
}

unsigned long createRGB(int r, int g, int b)
{
	return ((r & 0xff) << 16) + ((g & 0xff) << 8) + (b & 0xff);
}

void send_edit_lock(ENetPeer* peer, World* world_, int t_, int x_, int y_) {
	gamepacket_t p_d;
	p_d.Insert("OnDialogRequest");
	if (t_ == 5814 && world_->guild_id != 0) {
		uint32_t guild_id = world_->guild_id;
		vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
		if (p != guilds.end()) {
			string access_list_ = "";
			for (int i_ = 0; i_ < world_->admins.size(); i_++) {
				access_list_ += "\nadd_checkbox|checkbox_/" + world_->admins[i_] + "|`w" + world_->admins[i_] + "``|1";
			}
			if (access_list_.empty())
				access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
			Guild* guild_information = &guilds[p - guilds.begin()];
			string guild_key = "\nadd_button|getKey|Get Guild Key|noflags|0|0|";
			int c_ = 0;
			modify_inventory(peer, 5816, c_);
			if (c_ != 0) {
				guild_key = "";
			}
			p_d.Insert("add_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_player_info|" + guild_information->guild_name + " |" + (guild_information->guild_level < guild_lvl.size() ? to_string(guild_information->guild_level) + "|" + to_string(guild_information->guild_xp) + "|" + to_string(guild_lvl[guild_information->guild_level - 1][0]) + "|" : "15|91125000|91125000|") + (guild_information->guild_level < guild_lvl.size() && guild_information->guild_xp >= guild_lvl[guild_information->guild_level - 1][0] ? "\nadd_spacer|small|\nadd_button|upgrade_guild|`wUpgrade Guild``|noflags|0|0|\nadd_textbox|`oCost:`` `2" + to_string(guild_lvl[guild_information->guild_level - 1][1]) + " Gems``|left|" : "") + "\nadd_spacer|small|\nadd_textbox|`wManage Guild Member access:``|left|\nadd_checkbox|checkbox_coleader|Enable Co-Leader access|" + to_string(guild_information->guild_settings & Gtps3::SETTINGS_3) + "\nadd_checkbox|checkbox_elder|Enable Co-Leader and Elder access|" + to_string(guild_information->guild_settings & Gtps3::SETTINGS_2) + "\nadd_checkbox|checkbox_member|Enable all Members access|" + to_string(guild_information->guild_settings & Gtps3::SETTINGS_1) + "\nadd_spacer|small|" + (guild_information->guild_settings & Gtps3::SETTINGS_1 ? "\nadd_label|small|`2All guild members have access.``|left" : (guild_information->guild_settings & Gtps3::SETTINGS_2 ? "\nadd_label|small|`2Guild Co-Leaders and Elders have access.``|left" : (guild_information->guild_settings & Gtps3::SETTINGS_3 ? "\nadd_label|small|`2Guild Co-Leaders have access.``|left" : ""))) + "\nadd_spacer|small|\nadd_label|small|`wAccess List:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|" + (guild_information->guild_mascot[0] == 0 && guild_information->guild_mascot[1] == 0 ? (guild_information->guild_level >= 3 && guild_information->guild_members.size() >= 15 ? "\nadd_spacer|small|\nadd_button|create_guild_mascot|`wCreate Guild Mascot``|noflags|0|0|" : "\nadd_spacer|small|\nadd_textbox|Increase your guild size to `w15`` or more members and you can set a guild mascot!|left|") : "\nadd_spacer|small|\nadd_button|create_guild_mascot|`wChange Guild Mascot``|noflags|0|0|") + "\nadd_spacer|small|"/*"\nadd_checkbox|checkbox_displaymascot|Display Guild Mascot on the Guild Lock|" + (guild_information->unlocked_mascot == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_public|Allow anyone to build|" + (world_->open_to_public ? "1" : "0") + ""*/"\nadd_checkbox|checkbox_disable_music|Disable Custom Music Blocks|" + (world_->world_settings & Gtps3::SETTINGS_7 ? "1" : "0") + "\nadd_text_input|tempo|Music BPM|" + to_string(world_->music_bpm) + "|3|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + to_string(world_->world_settings & Gtps3::SETTINGS_6) + (not pInfo(peer)->home_world.empty() ? "\nadd_smalltext|Your current home world is: " + pInfo(peer)->home_world + "|left|" : "") + "\nadd_checkbox|checkbox_set_as_home_world|Set as Home World|" + (pInfo(peer)->home_world == world_->name ? "1" : "0") + "|\nadd_text_input|minimum_entry_level|World Level: |" + to_string(world_->entry_level) + "|3|\nadd_smalltext|Set minimum world entry level.|" + (world_->World_Time != 0 ? "\nadd_smalltext|Current World Timer set to: `2" + to_string(world_->World_Time) + " minutes``.|left|" : "") + "\nadd_button|sessionlength_dialog|`wSet World Timer``|noflags|0|0|\nadd_spacer|small|\nadd_button|changecat|`wCategory: " + (world_->category.empty() ? "None" : world_->category) + "``|noflags|0|0|" + guild_key + "\nadd_button|abondonguildconfirm|`wAbandon Guild``|noflags|0|0|\nend_dialog|editguildlock|Cancel|OK|\nadd_quick_exit|");

		}
	}
	else {
		string access_list_ = "";
		for (int i_ = 0; i_ < world_->admins.size(); i_++) access_list_ += "\nadd_checkbox|checkbox_/" + world_->admins[i_] + "|`w" + world_->admins[i_] + "``|1";
		if (access_list_.empty()) access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
		string world_key = "\nadd_button|getKey|Get World Key|noflags|0|0|";
		int c_ = 0;
		modify_inventory(peer, 1424, c_);
		if (c_ != 0) world_key = "";
		p_d.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build and Break|" + to_string(world_->world_settings & Gtps3::SETTINGS_4) + "\nadd_checkbox|checkbox_vending|Allow admins to edit vending|" + to_string(world_->world_settings & Gtps3::SETTINGS_3) + "\nadd_checkbox|checkbox_magplant|Allow admins to edit magplant|" + to_string(world_->world_settings & Gtps3::SETTINGS_10) + "\nadd_checkbox|checkbox_drop|Block picking up items|" + to_string(world_->world_settings & Gtps3::SETTINGS_2) + "\nadd_checkbox|checkbox_cheater|Disable Cheater Role|" + to_string(world_->world_settings & Gtps3::SETTINGS_12) + "\nadd_checkbox|checkbox_disable_music|Disable Custom Music Blocks|" + (world_->world_settings & Gtps3::SETTINGS_5 ? "1" : "0") + "\nadd_text_input|tempo|Music BPM|" + to_string(world_->music_bpm) + "|3|\nadd_checkbox|checkbox_disable_music_render|Make Custom Music Blocks invisible|" + (to_string(world_->world_settings & Gtps3::SETTINGS_6)) + a + (not pInfo(peer)->home_world.empty() ? "\nadd_smalltext|Your current home world is: " + pInfo(peer)->home_world + "|left|" : "") + "\nadd_checkbox|checkbox_set_as_home_world|Set as Home World|" + (pInfo(peer)->home_world == world_->name ? "1" : "0") + (t_ == 4802 ? "\nadd_label|small|Ye Royal Options|left\nadd_checkbox|checkbox_silence|Silence, Peasants!|" + to_string(world_->world_settings & Gtps3::SETTINGS_8) + "\nadd_checkbox|checkbox_rainbows|Royal Rainbows!|" + to_string(world_->world_settings & Gtps3::SETTINGS_7) : "") + "|\nadd_text_input|minimum_entry_level|World Level: |" + to_string(world_->entry_level) + "|3|\nadd_smalltext|Set minimum world entry level.|" + (world_->World_Time != 0 ? "\nadd_smalltext|Current World Timer set to: `2" + to_string(world_->World_Time) + " minutes``.|left|" : "") + "\nadd_button|sessionlength_dialog|`wSet World Timer``|noflags|0|0|\nadd_button|changecat|`wCategory: "+(world_->category.empty() ? "None" : world_->category) + "``|noflags|0|0|" + world_key + "\nend_dialog|lock_edit|Cancel|OK|");
	}
	p_d.CreatePacket(peer);
}

void SendCmd2(ENetPeer* peer, string cmd, bool c_ = false) {
	if (pInfo(peer)->tankIDName .empty()) return;
	string actual_command = cmd;
	transform(actual_command.begin(), actual_command.end(), actual_command.begin(), ::tolower);
	if (actual_command.find("player_chat=") != string::npos) return;
	if (actual_command == "!ghc" and pInfo(peer)->give_role) {
		pInfo(peer)->ghc = (pInfo(peer)->ghc ? false : true);
	}
	else if (actual_command == "!emoji" and pInfo(peer)->give_role) {
		pInfo(peer)->emoji_gg = (pInfo(peer)->emoji_gg ? false : true);
		nick_update_2(peer, NULL);
	}
	else if (actual_command == "!worlds" and pInfo(peer)->give_role) {
		console_msg(peer, "all worlds: " + to_string(worlds.size()) + "!");
		for (int i = 0; i < worlds.size(); i++) {
			World* world_ = &worlds[i];
			int w_c = 0, s_c = 0, net_ = 0, r_c = 0;
			get_players(world_->name, w_c, s_c, net_, r_c);
			if (w_c == 0) save_world(world_->name, true);
		}
		console_msg(peer, "inactive worlds cleared: " + to_string(worlds.size()) + "!");
	}
	else if (actual_command.substr(0, 9) == "!turn2id " && pInfo(peer)->superdev) {
		int item_ = atoi(cmd.substr(9, cmd.length() - 9).c_str());
		string world = pInfo(peer)->world;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world) continue;
			gamepacket_t p(0, pInfo(currentPeer)->netID);
			p.Insert("OnSetClothing");
			p.Insert((float)0, (float)0, (float)0); // hair shirt pants
			p.Insert((float)0, (float)0, (float)0); // feet face hand 
			p.Insert((float)item_, (float)0, (float)0); // back mask neck
			p.CreatePacket(currentPeer); // kiti tau
			for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
				if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer2)->world != pInfo(currentPeer)->world) continue;
				p.CreatePacket(currentPeer2); // kiti tau
			}
			p.CreatePacket(peer); // kiti tau
		}
	}
	else if (actual_command.substr(0, 13) == "!givepremium " && pInfo(peer)->give_role) {
		int prem = atoi(cmd.substr(13, cmd.length() - 13).c_str());
		if (prem <= 0) return;
		if (prem >= 50) prem = 50;
		string world = pInfo(peer)->world;
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`6>> Received `2"+to_string(prem) + "`` Premium World Lock from Administrator!``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world) continue;
			pInfo(currentPeer)->gtwl += prem;
			p.CreatePacket(currentPeer);
		}
	}
	else if (actual_command == "!resetgems") OnSetGems(peer, pInfo(peer)->gems * -1);
	else if (actual_command.substr(0, 3) == "!x ") {
		punched = atoi(cmd.substr(3, cmd.length() - 3).c_str());
	}
	else if (actual_command.substr(0, 5) == "!spq ") {
		string message = "", username = "";
		if (cmd.substr(5).find(" ") == string::npos) return;
		string s = cmd.substr(5);
		stringstream ss(s);
		istream_iterator<string> begin(ss);
		istream_iterator<string> end;
		vector<string> vstrings(begin, end);
		if (vstrings.size() < 1) return;
		username = vstrings[0];
		if (username .empty()) return;
		for (int i = 1; i < vstrings.size(); i++) {
			message = message + vstrings[i] + (vstrings.size() - i == 1 ? "" : " ");
		}
		bool playerFound = false;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username)) {
				bool msg = false;
				playerFound = true;
				chat_message(currentPeer, message);
				break;
			}
		}
		if (!playerFound) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (username.length() < 5) p.Insert("`6>> `$" + username + "`` is not online right now (you need to enter at least 5 letters if you meant a longer name!).``");
			else p.Insert("`6>> No one online who has a name starting with `$" + username + "``.``");
			p.CreatePacket(peer);
		}
	}
	else if (actual_command == "!trashall" and pInfo(peer)->give_role) {
		string recycled = "";
		for (int i_ = 0, remove = 0; i_ < pInfo(peer)->inv.size(); i_++) {
			if (items[pInfo(peer)->inv[i_].first].untradeable == 0) {
				remove = pInfo(peer)->inv[i_].second * -1;
				recycled += to_string(abs(remove)) + " `w" + items[pInfo(peer)->inv[i_].second].ori_name + "`` trashed.\n";
				modify_inventory(peer, pInfo(peer)->inv[i_].first, remove);
				remove = 0;
			}
		}
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert(recycled), p.CreatePacket(peer);
	}
	else if (actual_command == "!bpclear" and pInfo(peer)->give_role) {
		pInfo(peer)->bp.clear();
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("Backpack is cleared."), p.CreatePacket(peer);
	}
	else if (actual_command == "!aura") {
		pInfo(peer)->punch_aura = (pInfo(peer)->punch_aura ? false : true);
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("Punch aura set to "+to_string(pInfo(peer)->punch_aura) + "."), p.CreatePacket(peer);
	}
	else if (actual_command.substr(0, 7) == "!paura ") {
		pInfo(peer)->punch_aura_id = atoi(cmd.substr(7, cmd.length() - 7).c_str());
	}
	else if (actual_command.substr(0, 5) == "!qsb " and pInfo(peer)->give_role) {
		string textss = cmd.substr(5);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->tankIDName.empty()) continue;
			variants::OnConsoleMessage(currentPeer, textss);
			gamepacket_t p;
			p.Insert("OnAddNotification"), p.Insert("interface/atomic_button.rttex"), p.Insert(textss), p.Insert("audio/hub_open.wav"), p.CreatePacket(currentPeer);
		}
	}
	else {
		string name_ = pInfo(peer)->world;
		vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (paa != worlds.end()) {
			World* world_ = &worlds[paa - worlds.begin()];
			world_->fresh_world = true;
			string owner_name = to_lower(world_->owner_name), player_name = to_lower(pInfo(peer)->tankIDName);
			if (actual_command == "!removedrop" && pInfo(peer)->give_role) {
				{
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(" >> Removed all dropped items."), p.CreatePacket(peer);
				}
				PlayerMoving data_{};
				 data_.packetType = 14, data_.netID = 0;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
					for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
						data_.plantingTree = world_->drop_new[i_][2];
						BYTE* raw = packPlayerMoving(&data_);
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[]raw;
					}
				}
				world_->drop_new.clear();
			}
			else if (actual_command == "!gl" and pInfo(peer)->give_role) {
				world_->fresh_world = true;
				{
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(" >> Removed all golden lock items."), p.CreatePacket(peer);
				}
				PlayerMoving data_{};
				data_.packetType = 14, data_.netID = 0;
				for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
					if (world_->drop_new[i_][0] == 8470) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
							data_.plantingTree = world_->drop_new[i_][2];
							BYTE* raw = packPlayerMoving(&data_);
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[]raw;
						}
						world_->drop_new.erase(world_->drop_new.begin() + i_);
					}
				}
				for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
					if (world_->blocks[i_].fg == 8470) {
						world_->blocks[i_].fg = 242;
						update_tile(peer, i_ % 100, i_ / 100, 242, false, true);
					}
				}
				for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
					if (world_->sbox1[i_].id == 8470) {
						world_->sbox1.erase(world_->sbox1.begin() + i_);
					}
				}
			}
			else if (actual_command == "!maxlevel" and pInfo(peer)->give_role) {
				if (world_->world_settings & Gtps3::SETTINGS_11) world_->world_settings &= ~Gtps3::SETTINGS_11;
				else 	world_->world_settings |= Gtps3::SETTINGS_11;
				gamepacket_t p;
				p.Insert("OnConsoleMessage"), p.Insert(" >> Set maximum level to "+to_string(world_->world_settings & Gtps3::SETTINGS_11) + "."), p.CreatePacket(peer);
			}
			else if (actual_command == "!resetworld" and pInfo(peer)->give_role) {
				pInfo(peer)->confirm_reset++;
				if (pInfo(peer)->confirm_reset == 1) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(" >> Type `2!resetworld`` again to confirm the reset of the world `#" + pInfo(peer)->world + "``."), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->confirm_reset = 0;
					gamepacket_t p;
					p.Insert("OnTextOverlay"), p.Insert("Cleared the world..."), p.CreatePacket(peer);
					{
						world_->world_settings = 0;
						world_->nuked_by = "";
						world_->admins.clear();
						world_->drop_new.clear();
						world_->sbox1.clear();
						world_->bulletin.clear();
						world_->weather = 0;
						world_->bannedPlayers.clear();
						world_->music_bpm = 100;
						world_->entry_level = 1;
						world_->active_jammers.clear();
						//	world_->npc.clear();
						world_->machines.clear();
						for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
							world_->blocks[i_].flags = 0;
							if (i_ <= 5400) {
								if (world_->blocks[i_].fg != 0 and world_->blocks[i_].fg != 6 and world_->blocks[i_].fg != 8 and items[world_->blocks[i_].fg].blockType != BlockTypes::LOCK) world_->blocks[i_].fg = 0, world_->blocks[i_].locked = false;
								if (world_->blocks[i_].bg != 0) world_->blocks[i_].bg = 0;
							}
						}
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
						exit_(currentPeer);
					}
				}
			}
		}
	}
}

bool SendCmdPlus(ENetPeer* peer, World* world_, string cmd) {
	if (world_ == NULL or world_ == nullptr) return false;
	string actual_command = cmd;
	string astr = cmd;
	transform(actual_command.begin(), actual_command.end(), actual_command.begin(), ::tolower);
	if ((actual_command == "/restockmag" or actual_command.substr(0, 12) == "/restockmag ") and (pInfo(peer)->Staff)) {
		if (actual_command.size() > 12) {
			int count = atoi(actual_command.substr(12).c_str());
			for (int i = 0; i < 100 * 60; i++) {
				int id = world_->blocks[i].fg;
				if (id == 5638 or id == 9850 or id == 10266) {
					if (world_->blocks[i].id == 0) continue;
					if (items.at(world_->blocks[i].id).blockType == BlockTypes::SEED) continue;
					if (items.at(world_->blocks[i].id).blockType == BlockTypes::CLOTHING) continue;
					if (items.at(world_->blocks[i].id).blockType == BlockTypes::LOCK) continue;
					world_->blocks[i].pr = count;
				}
			}
			variants::OnConsoleMessage(peer, "all number of items in the magplant has been set to (" + to_string(count) + ")");
		}
		else {
			variants::OnConsoleMessage(peer, "Usage: /restockmag <count> #This will set the number of items for all magplants in this world (except `4SEED``)");
		}
		return true;
	}
	else if ((actual_command == "/clearmagseed") and (pInfo(peer)->Staff)) {
		if (actual_command.size() > 12) {
			for (int i = 0; i < 100 * 60; i++) {
				int id = world_->blocks[i].fg;
				if (id == 5638 or id == 9850 or id == 10266) {
					if (world_->blocks[i].id == 0) continue;
					if (items.at(world_->blocks[i].id).blockType == BlockTypes::SEED)
					world_->blocks[i].pr = 0;
				}
			}
			variants::OnConsoleMessage(peer, "Seed Removed from Magplant.");
		}
		else {
			variants::OnConsoleMessage(peer, "Usage: /restockmag <count> #This will set the number of items for all magplants in this world (except `4SEED``)");
		}
		return true;
	}
	else if ((actual_command == "/restockvend" or actual_command.substr(0, 13) == "/restockvend ") and (pInfo(peer)->Staff)) {
		if (actual_command.size() > 13) {
			int count = atoi(actual_command.substr(13).c_str());
			for (int i = 0; i < 100 * 60; i++) {
				int id = world_->blocks[i].fg;
				if (id == 2978 or id == 9268) {
					if (world_->blocks[i].id == 0) continue;
					if (items.at(world_->blocks[i].id).blockType == BlockTypes::SEED) continue;
					if (items.at(world_->blocks[i].id).blockType == BlockTypes::LOCK) continue;
					world_->blocks[i].c_ = count;
				}
			}
			variants::OnConsoleMessage(peer, "all number of items in the vending machine has been set to (" + to_string(count) + ")");
		}
		else {
			variants::OnConsoleMessage(peer, "Usage: /restockmag <count> #This will set the number of items for all vending machine in this world (except `4SEED``)");
		}
		return true;
	}
	else if ((astr == "/fl" or astr.substr(0, 4) == "/fl ") and pInfo(peer)->dev) {
		if (actual_command.size() < 4) {
			variants::OnConsoleMessage(peer, "Usage: /fl <CountryID>. Example: `5/fl id`o.");
			return true;
		}
		string flag = actual_command.substr(4);
		pInfo(peer)->country = flag;
		gamepacket_t p(0, pInfo(peer)->netID);
		p.Insert("OnCountryState");
		p.Insert(flag);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name)
				p.CreatePacket(currentPeer);
		}
		return true;
	}
	else if (astr.substr(0, 8) == "/vernick" and pInfo(peer)->dev) {
		if (actual_command.size() < 9) {
			variants::OnConsoleMessage(peer, "Usage: /vernick <name (auto split)>");
			return true;
		}
		string str_ = actual_command.substr(9);
		if (str_.empty()) {
			variants::OnConsoleMessage(peer, "Input at least `w1`` parameter");
			return true;
		}
		vector<string>param = explode(" ", str_);
		string name = "";
		for (int i = 0; i < param.size(); i++)
			name += param[i] + "\n";
		gamepacket_t p2(0, pInfo(peer)->netID);
		p2.Insert("OnNameChanged");
		p2.Insert(name);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name)
				p2.CreatePacket(currentPeer);
		}
		return true;
	}
	else if (astr.substr(0, 10) == "/trollnick" and pInfo(peer)->dev) {
		if (actual_command.size() < 11) {
			variants::OnConsoleMessage(peer, "Usage: /trollnick <size>");
			return true;;
		}
		int size = atoi(actual_command.substr(11).c_str());
		if (size <= 0) {
			variants::OnConsoleMessage(peer, "At least the minimum size is `51``, the maximum is `5100``.");
			return true;;
		}
		if (size > 100) {
			variants::OnConsoleMessage(peer, "The maximum size is `5100``.");
			return true;;
		}
		variants::OnTextOverlay(peer, "Vertical Name: size set to `w" + to_string(size) + "``.");
		string generated_size = "";
		for (int i = 0; i < size; i++)
			generated_size += "A\n";
		gamepacket_t p2(0, pInfo(peer)->netID);
		p2.Insert("OnNameChanged");
		p2.Insert(generated_size);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer)
		{
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name)
				p2.CreatePacket(currentPeer);
		}
		return true;
	}
	else if ((astr == "/tp" or astr.substr(0, 4) == "/tp ")) {
		if (astr.size() > 4) {
			string name = astr.substr(4);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->tankIDName.empty()) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(name)) {

					break;
				}
			}
		}
		else variants::OnConsoleMessage(peer, "Usage: /tp <name> #Teleport to any user.");
		return true;
	}
	else if ((astr == "/pay" or astr.substr(0, 5) == "/pay ")) {
		if (astr.size() > 5) {
			vector<string>param = explode(" ", astr.substr(5));
			string name = param[0]; int gems = (param.size() == 1 ? 0 : atoi(param[1].c_str()));
			if (name.empty()) { variants::OnConsoleMessage(peer, "Enter the user's name, as it is not possible to give someone without having a name."); return true; }
			if (gems <= 0 or gems > pInfo(peer)->gems) {
				if (gems <= 0) variants::OnConsoleMessage(peer, "There's nothing to give.");
				else variants::OnConsoleMessage(peer, "You don't have enough gems. You only have `2" + setGems(pInfo(peer)->gems) + "`o gems");
				return true;;
			}
			if (to_lower(name) == to_lower(pInfo(peer)->tankIDName)) {
				variants::OnConsoleMessage(peer, "Giving yourself gems?... But how?");
				return true;;
			}
			bool found = false;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->tankIDName.empty()) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(name)) {
					if (gems + pInfo(currentPeer)->gems >= INT_MAX) {
						variants::OnConsoleMessage(peer, "Unable to send gems to " + pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + " because gems have reached the maximum limit.");
						return true;;
						break;
					}
					found = true;
					name = pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName;
					variants::OnAddNotification(currentPeer, "You received `2" + setGems(gems) + "`o Gems from " + pInfo(peer)->name_color + pInfo(peer)->tankIDName, "interface/cash_icon_overlay.rttex", "audio/achievement.wav");
					variants::OnConsoleMessage(currentPeer, "You received `2" + setGems(gems) + "`o Gems from " + pInfo(peer)->name_color + pInfo(peer)->tankIDName);
					pInfo(currentPeer)->gems += gems;
					{
						gamepacket_t p;
						p.Insert("OnSetBux");
						p.Insert(pInfo(currentPeer)->gems < INT_MAX ? pInfo(currentPeer)->gems : INT_MAX);
						p.Insert(0);
						p.Insert((pInfo(currentPeer)->supp >= 1) ? 1 : 0);
						if (pInfo(currentPeer)->supp >= 2) {
							p.Insert((float)33796, (float)1, (float)0);
						}
						p.CreatePacket(currentPeer);
					}
					break;
				}
			}
			if (found) {
				pInfo(peer)->gems -= gems;
				variants::OnConsoleMessage(peer, "Your gems have been sent to " + name + " `o<- `w" + setGems(gems));
				{
					gamepacket_t p;
					p.Insert("OnSetBux");
					p.Insert(pInfo(peer)->gems < INT_MAX ? pInfo(peer)->gems : INT_MAX);
					p.Insert(0);
					p.Insert((pInfo(peer)->supp >= 1) ? 1 : 0);
					if (pInfo(peer)->supp >= 2) {
						p.Insert((float)33796, (float)1, (float)0);
					}
					p.CreatePacket(peer);
				}
			}
			else {
				variants::OnConsoleMessage(peer, "We couldn't find a user with name `w" + name + "`o, maybe he is `4offline`o.");
			}
		}
		else variants::OnConsoleMessage(peer, "Usage: /pay <username> <amount> #With this, you can easily give your gems to someone.");
		return true;
	}
	return false;
}

void testo(ENetPeer* peer) {
	
}

void SendCmd(ENetPeer* peer, string cmd, bool c_ = false) {
	if (pInfo(peer)->world == Hide_N_Seek.hidenseekworld) return;
	string actual_command = cmd;
	transform(actual_command.begin(), actual_command.end(), actual_command.begin(), ::tolower);
	if (actual_command.find("player_chat=") != string::npos) return;
	if (actual_command.substr(0, 5) == "/msg " || actual_command.substr(0, 3) == "/r " || actual_command == "/msg" || actual_command == "/r") packet_(peer, "action|log\nmsg|CT:[MSG]_ `6" + cmd + "``", "");
	else if (actual_command.substr(0, 4) == "/sb " || actual_command == "/sb") packet_(peer, "action|log\nmsg|CT:[SB]_ `6" + cmd + "``", "");
	else if (actual_command.substr(0, 4) == "/bc " || actual_command == "/bc") packet_(peer, "action|log\nmsg|CT:[BC]_ `6" + cmd + "``", "");
	else if (not c_) packet_(peer, "action|log\nmsg| `6" + cmd + "``", "");
	{
		if (actual_command == "/shelp" and (pInfo(peer)->Staff)) {
			packet_(peer, a + "action|log\nmsg|>> Commands: /logs /restockvend /restockmag /clearmagseed");
			return;
		}
		if (actual_command == "/event") {
			variants::OnConsoleMessage(peer, "`9** There is currently gems event of x" + to_string(x_gems) + "!");
			return;
		}
	}
	if (actual_command == "/help" || actual_command == "/?") 
		packet_(peer, a + "action|log\nmsg|>> Commands: /event /pay /msg /status /broadcast /sb /sdb /stats /top /ignore /time /who /me /radio /mods /uba /r /go /hub /rgo /pull /kick /ban /wave /dance /love /sleep /facepalm /fp /smh /yes /no /omg  /idk /shrug /trade "/*"/pb"*/" /furious /rolleyes /unaccess /report /rate /foldarms /fa /stubborn /fold /fc /gc /gwarp /guild " 
			+ (pInfo(peer)->supp >= 2 ? "/hidestatus " : "")
			+ (pInfo(peer)->mod ? "/mhelp " : "")
		);
	else if (actual_command == "/mhelp" && pInfo(peer)->mod) 
		packet_(peer, a + "action|log\nmsg|>> Commands: /warpto <plr> /find <plr> /summon <plr> /freeze <plr> /info <plr> /inventory <plr> /inv <plr> /punch <id> / <text> /warp <worldName> /nuke /eff /radio2 /togglemods /skin /invis /invis2 /invis3 "
			+ (pInfo(peer)->moderator ? "/magic /nohands /nobody " : "")
			+ (pInfo(peer)->dev ? "/banrid <rid/plr> /rbn <Ban Last Wrenched Player> <-RID BAN /fakewarn <plr> /flag <country> /banall /cursenuke /1hit /hide /mute /curse /unmute /uncurse /pullall " : "")
			+ (pInfo(peer)->superdev ? "/removeid <blockID> /boostworld /freezeall /skin2 " : "")
			+ (pInfo(peer)->ghost_role || pInfo(peer)->dev ? "/ghost " : "")
			+ (pInfo(peer)->buy_role ? "/copyset <plr> " : "")
			+ (pInfo(peer)->whitelist_role ? "/whitelist /whitelists /drop " : "")
			+ (pInfo(peer)->give_editor ? "/setbuy /changeprice <itemID> <Price> " : "")
			+ (pInfo(peer)->nick_role || pInfo(peer)->superdev ? "/nick <nickname> " : "")
		);
	else if (actual_command == "/ghelp" and pInfo(peer)->give_role) 
		packet_(peer, a + "action|log\nmsg|>> Owner/ServerCreator Commands: !resetworld !givepremium <amount> <- giveaway /copyset /resetgems /givecreator /givestaff /givegive /givebuy /giveown /givewhitelist /givedrt /givetitle /givevip /giveeditor /givemoderator /giveghost /givecheater /givecsn /givelogger /givenick /givesdev /givedev /givemod");
	else if (actual_command == "/pullall" && pInfo(peer)->dev) {
		int pullx = pInfo(peer)->x, pully = pInfo(peer)->y;
		gamepacket_t pf;
		pf.Insert("OnTextOverlay"), pf.Insert("You were pulled by " + pInfo(peer)->tankIDName);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or currentPeer == peer) continue;
			if (pInfo(peer)->world == pInfo(currentPeer)->world) {
				if (not pInfo(currentPeer)->invis) {
					pInfo(currentPeer)->x = pullx, pInfo(currentPeer)->y = pully;
					OnSetPos(currentPeer, pullx, pully);
					pf.CreatePacket(currentPeer);
				}
			}
		}
	}
	else if (actual_command.substr(0, 8) == "/banrid " && pInfo(peer)->dev) {
		string name = cmd.substr(8, cmd.length() - 8).c_str();
		if (find(Server_Security.ridbans.begin(), Server_Security.ridbans.end(), name) != Server_Security.ridbans.end()) {
			Server_Security.ridbans.erase(remove(Server_Security.ridbans.begin(), Server_Security.ridbans.end(), name), Server_Security.ridbans.end());
			console_msg(peer, "`o >>Unbanned RID " + name);
		}
		else {
			Server_Security.ridbans.push_back(name);
			console_msg(peer, "`o >>Banned RID " + name);
		}
	}
	else if (actual_command == "/wipeworlds") {
		sort(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end());
		pInfo(peer)->worlds_owned.erase(unique(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end()), pInfo(peer)->worlds_owned.end());
		console_msg(peer, "Removed worlds that you don't own from your list.");
	}
	else if (actual_command == "/discord") {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDiscord``|left|10568|\nadd_spacer|small|\nadd_textbox|`oVisit the Growtopia Discord page?``|left|\nadd_spacer|small|\nadd_url_button|comment|`wLaunch``|noflags|" + discord_url + "||0|0|\nend_dialog|generic|||\nadd_quick_exit|");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/rules") {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wHelp & Rules``|left|18|\nadd_spacer|small|\nadd_textbox|`w`2World or Accounts`` may be deleted after long periods of inactivity if a world is not visited regularly. `2Item function and prices are subject to change`` at anytime and without warning as we are constantly trying to balance different aspects of the game.``|left|\nadd_spacer|small|\nadd_textbox|`wProtect your worlds and the items by using Doors, Locks, and Blocks wisely, `2never share your login credentials`` with anyone, and be aware of `2fake system messages and phishing websites``.``|left|\nadd_spacer|small|\nadd_textbox|`w`2Inappropriate behavior`` (profanity, racist, sexist or sexual content, abusive behavior, and bullying); any form of scam game such as Drop Game, Dirt Game, etc.; `2buying, selling, or trading GTPS accounts, items, or worlds`` for real money; `2purchase fraud``; and usage of `2third party software``, including, but not limited to, client-side manipulation, auto-clickers, speed hacks, clock manipulation, bots, macroing, and auto-farming, will be sanctioned and may result in a permanent suspension.``|left|\nadd_spacer|small|\nadd_textbox|`wTo report a world, type `2/report`` and exit the world immediately. To report a player, `2wrench and report`` them, or contact us directly. For any issues and questions you may have, please visit our discord server`` `2" + web_url + "``|left|\nadd_spacer|small|\nadd_textbox|`wAdvertising another `2Private servers or any social medias`` is `4not allowed``.|left|\nadd_spacer|small|\nadd_textbox|`wThere is account creation limit,creating mass account might get you `4banned``.Punishment might applied to you alternative accounts or account that have the same ip address.|left|\nadd_spacer|small|\nadd_textbox|`wAny kind of abusing behaviour is not tolerated such as abusing commands, bugs or glitches will result a `4permanent`` suspension.|left|\nadd_spacer|small|\nadd_textbox|`wPlayers that faking `2System`` messages will be punished.Stolen/Scammed item will never be restored.|left|\nadd_spacer|small|\nadd_textbox|`wBugs and Glitches are bound to happen.if you lost item/rollback it will always happen we will do anything in our power to prevent this sort thing to happen.|left|\nadd_spacer|small|\nadd_button|news|`wI accept these rules!``|noflags|0|0|end_dialog|generic|||");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/clearevent" and pInfo(peer)->give_role) clear_event();
	else if (actual_command == "/startevent" and pInfo(peer)->give_role) start_event();
	else if (actual_command == "/event2" and pInfo(peer)->give_role) clear_event2();
	else if (actual_command == "/wotd" and pInfo(peer)->give_role) {
		string world_owner = get_world(pInfo(peer)->world).owner_name;
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (world_owner.empty()) p.Insert("-> Can not add new WOTD (owner name is empty)");
		else {
			vector<string> wotd_found, a_;
			for (int i = 0; i < World_Stuff.wotd.size(); i++) {
				a_ = explode("|", World_Stuff.wotd[i]);
				wotd_found.push_back(a_[0].c_str());
			}
			if (find(wotd_found.begin(), wotd_found.end(), pInfo(peer)->world) != wotd_found.end()) {
				p.Insert("-> Can not add new WOTD (this world already existed)");
				return;
			}
			string name = pInfo(peer)->world;
			vector<World>::iterator pz = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
			if (pz != worlds.end()) {
				World* world = &worlds[pz - worlds.begin()];
				world->world_settings &= ~Gtps3::SETTINGS_1;
				world->world_settings |= Gtps3::SETTINGS_1;
			}
			save_world(name, false);
			refresh_wotd_worlds();
			p.Insert("-> Added new WOTD. (" + pInfo(peer)->world + "|" + world_owner);
			World_Stuff.wotd.push_back(pInfo(peer)->world + "|" + world_owner);
		}
		p.CreatePacket(peer);
	}
	else if ((actual_command == "/surgerystats") and (pInfo(peer)->vip)) {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSurgery Stats``|left|1270|\nadd_spacer|small|\nadd_textbox|`oSurgery Skill:`` `2" + to_string(pInfo(peer)->surgery_skill) + "``    `oSurgery Completed:`` `2" + to_string(pInfo(peer)->surgery_done) + "``|left|\nadd_spacer|small|\nadd_textbox|`oRoad to Angel of Mercy:`` `2" + to_string(pInfo(peer)->su_8552_1) + "/2000``    `oRoad to Dr.Title:`` `2" + to_string(pInfo(peer)->su_8552_2) + "/3000``    `oRoad to Legend title:`` `2" + to_string(pInfo(peer)->su_8552_3) + "/50000``|left|\nadd_spacer|small|\nadd_button|close|`wThanks!``|noflags|0|0|end_dialog|generic|||");
		p.CreatePacket(peer);
	}

	else if ((actual_command == "/rainbow" || actual_command == "/valentine") && (pInfo(peer)->vip)) {
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (actual_command == "/rainbow") {
			pInfo(peer)->rb = (pInfo(peer)->rb ? 0 : 1);
			pInfo(peer)->valentine = 0;
			p.Insert("Rainbow name status is " + a + (pInfo(peer)->rb == 1 ? "visible" : "hidden") + "!");
		}
		else {
			pInfo(peer)->valentine = (pInfo(peer)->valentine ? 0 : 1);
			pInfo(peer)->rb = 0;
			p.Insert("`4Valentine`` name status is " + a + (pInfo(peer)->valentine ? "visible" : "hidden") + "!");
		}
		p.CreatePacket(peer);
		if (pInfo(peer)->rb == 0 or pInfo(peer)->valentine == 0) {
			nick_update_2(peer, NULL);
		}
	}
	else if (actual_command == "/vhelp" && (pInfo(peer)->vip)) packet_(peer, "action|log\nmsg|>> Commands: /surgerystats /vhelp /v (set tab in wrench menu) /buy /rainbow /find /info <name> (shows inventory) /hidestatus (big name) /warp <world> /warpto <player name> /sb /bc");
	else if (actual_command == "/deposit") {
		sendDeposit(peer);
	}
	else if (actual_command == "/skin" && pInfo(peer)->mod) {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSkin Color``|left|5468|\nadd_spacer|small|\nadd_text_input|color|Color - R,G,B:|" + pInfo(peer)->skin_c + "|11|\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|skin_color|Close|Update|\nadd_quick_exit|");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/shop") {
		int dls = 0, wls = 0, bgl = 0;
		dls = pInfo(peer)->gtwl / 100;
		wls = pInfo(peer)->gtwl - (dls * 100);
		if (dls >= 100) {
			bgl = pInfo(peer)->gtwl / 10000;
			dls -= 100 * bgl;
		}
		string inventory = (wls + dls != 0 ? "\nadd_textbox|`2Premium World lock you currently have:``|" : "\nadd_textbox|`2You don't have any premium world lock!``|") + (bgl != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|7188|" + to_string(bgl) + "|" : "") + (dls != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|1796|" + to_string(dls) + "|" : "") + (wls != 0 ? "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|242|" + to_string(wls) + "|" : "") + "" + (wls + dls + bgl != 0 ? "\nadd_button_with_icon||END_LIST|noflags|0||" : "");
		gamepacket_t p;
		p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Growtopia Private Server Market``|left|5172|\nadd_spacer|\nadd_textbox|Choose what you want to purchase:|left|\nadd_smalltext|Note: You can purchase roles/items/xp/untradeable items for real growtopia currency.|left|\ntext_scaling_string|Subscribtions+++|\nadd_button_with_icon|shoprank|`9Roles``|noflags|278|\nadd_button_with_icon|shopsubscribtion|`9Subscribtion``|noflags|8188|\nadd_button_with_icon|shopitems|`9Items``|noflags|9474|\nadd_button_with_icon|shopmoney|`9Gems``|noflags|9436|\nadd_button_with_icon|shopxp|`9XP``|noflags|1488|\nadd_button_with_icon|shopgrowtoken|`9Growtoken``|noflags|1486|||\nadd_button_with_icon||END_LIST|noflags|0||" + inventory + "\nadd_button|deposit|`2Deposit/Purchase``|noflags|0|0|\nadd_quick_exit|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|"), p.CreatePacket(peer);
	}
	else if (actual_command.substr(0, 4) == "/fc ") {
		int fonline = 0;
		string message = cmd.substr(4, cmd.length() - 4).c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->temp_radio) continue;
			for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
				if (to_lower(pInfo(currentPeer)->friends[c_].name) == to_lower(pInfo(peer)->tankIDName)) {
					fonline++;
					if (fonline != 0) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("CT:[FC]_>> `3>> from (``" + get_player_nick(peer) + "`3) in [```$" + pInfo(peer)->world + "```3] > ```$" + message + "``");
						p.CreatePacket(currentPeer);
					}
				}
			}
		}
		if (fonline == 0) {
			console_msg(peer, "`3>> There isn't any friends online.");
		}
		else {
			console_msg(peer, "`3>> You friendcasted to `0" + to_string(fonline) + "`` person online.");
		}
	}
	else if (actual_command == "/top") {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`oWorld Rankings``|left|394|\nadd_spacer|\nadd_textbox|World Rankings are based on unique daily visitors. Where do your worlds stack up?|\nadd_button|toprated|`8Top Rated Worlds``|noflags|0|0|\nadd_button|toplist|`8Top worlds today``|noflags|0|0|\nadd_button|yesterdaylist|`5Top worlds yesterday``|noflags|0|0|\nadd_button|overalllist|`0Top worlds overall``|noflags|0|0|\nadd_button|wotw|`$World of the Week winners``|noflags|0|0|"/*\nadd_button|opclist|`8Online Point Currency Leaderboard``|noflags|0|0|\nadd_button|wlslist|`8World Locks Leaderboard``|noflags|0|0|"\nadd_button|wotwlist|`$World of the Week winners``|noflags|0|0|"*/"\nend_dialog|top|Close||\n");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/news") news(peer);
	else if (actual_command == "/stopf" && (pInfo(peer)->give_role)) {
		cout << "server stop by: " << pInfo(peer)->tankIDName << endl;
		trigger_save_(true);
	}
	else if (actual_command == "/stop" && (pInfo(peer)->give_role)) {
		cout << "server stop by: " << pInfo(peer)->tankIDName << endl;

		trigger_save_(false);
	}
	else if (actual_command == "/stop_server" && pInfo(peer)->give_role) Server_Security.restart_server_status = true;
	else if ((actual_command == "/invis" || actual_command == "/invis2" || actual_command == "/invis3") && (pInfo(peer)->mod || pInfo(peer)->dev || pInfo(peer)->invis)) {
		vector<int> random_{ 32, 64, -32, -64, 0, 0 };
		PlayerMoving data_{};
		data_.packetType = 17, data_.netID = 105, data_.YSpeed = 105;
		BYTE* raw = packPlayerMoving(&data_);
		packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		if (pInfo(peer)->invis) {
			pInfo(peer)->invis = false;
			console_msg(peer, "`oYou are once again visible to mortals.");
			{
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnInvis");
				p.Insert(0);
				string t_ = "action|play_sfx\nfile|audio/already_used.wav\ndelayMS|750";
				if (pInfo(peer)->tankIDName == "Tron")
					t_ = "action|play_sfx\nfile|audio/stoptime.wav\ndelayMS|0";
				BYTE* const d_ = new BYTE[5 + t_.length()];
				*(__int8*)(d_) = 3;
				memcpy(d_ + 4, t_.c_str(), t_.length());
				*(__int8*)(d_ + 4 + t_.length()) = 0;
				ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						if (actual_command == "/invis2") {
							for (int i = 0; i < 6; i++) {
								data_.x = pInfo(peer)->x + 16 + random_[rand() % random_.size()], data_.y = pInfo(peer)->y + 16 + random_[rand() % random_.size()];
								raw = packPlayerMoving(&data_);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							enet_peer_send(currentPeer, 0, p_m);
						}
						if (actual_command == "/invis3") {
							gamepacket_t p;
							p.Insert("OnParticleEffectV2"), p.Insert(85), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
							p.CreatePacket(currentPeer);
						}
						if (pInfo(peer)->tankIDName == "Tron")
							variants::OnPlayPositioned(currentPeer, pInfo(peer)->netID, "audio/stoptime.wav");
						p.CreatePacket(currentPeer);
					}
				}
				delete[]d_;
			}
			update_clothes_value(peer);
			update_clothes(peer);
		}
		else {
			pInfo(peer)->invis = true;
			console_msg(peer, "`oYou are now ninja, invisible at all.");
			{
				gamepacket_t p(0, pInfo(peer)->netID);
				p.Insert("OnInvis");
				p.Insert(1);
				string t_ = "action|play_sfx\nfile|audio/already_used.wav\ndelayMS|750";
				BYTE* const d_ = new BYTE[5 + t_.length()];
				*(__int8*)(d_) = 3;
				memcpy(d_ + 4, t_.c_str(), t_.length());
				*(__int8*)(d_ + 4 + t_.length()) = 0;
				ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						if (actual_command == "/invis2") {
							for (int i = 0; i < 6; i++) {
								data_.x = pInfo(peer)->x + 16 + random_[rand() % random_.size()], data_.y = pInfo(peer)->y + 16 + random_[rand() % random_.size()];
								raw = packPlayerMoving(&data_);
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							enet_peer_send(currentPeer, 0, p_m);
						}
						p.CreatePacket(currentPeer);
					}
				}
				delete[]d_;
			}
			update_clothes_value(peer);
			update_clothes(peer);
		}
		delete[] raw;
	}
	else if ((actual_command == "/magic" || actual_command == "/nohands" || actual_command == "/nobody") && pInfo(peer)->moderator) {
		if (actual_command == "/magic") {
			vector<int> random_{ 32, 64, -32, -64, 0, 0 };
			PlayerMoving data_{};
			data_.packetType = 17, data_.netID = 105, data_.YSpeed = 105;
			BYTE* raw = packPlayerMoving(&data_);
			string t_ = "action|play_sfx\nfile|audio/magic.wav\ndelayMS|750";
			BYTE* const d_ = new BYTE[5 + t_.length()];
			*(__int8*)(d_) = 3;
			memcpy(d_ + 4, t_.c_str(), t_.length());
			*(__int8*)(d_ + 4 + t_.length()) = 0;
			ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					for (int i = 0; i < 6; i++) {
						data_.x = pInfo(peer)->x + 16 + random_[rand() % random_.size()], data_.y = pInfo(peer)->y + 16 + random_[rand() % random_.size()];
						raw = packPlayerMoving(&data_);
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					enet_peer_send(currentPeer, 0, p_m);
				}
			}
			delete[]d_;
		}
		else {
			if (actual_command == "/nohands") pInfo(peer)->no_hands = (pInfo(peer)->no_hands ? false : true);
			else if (actual_command == "/nobody") 	pInfo(peer)->no_body = (pInfo(peer)->no_body ? false : true);
			update_clothes_value(peer);
			update_clothes(peer);
		}
	}
	else if (actual_command == "/ghost" && (pInfo(peer)->dev || pInfo(peer)->superdev || pInfo(peer)->ghost_role)) { //Fyatz = cyrus
		if (!pInfo(peer)->give_role and pInfo(peer)->world == "CARNIVAL") return;
		packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		pInfo(peer)->ghost = (pInfo(peer)->ghost ? false : true);
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (pInfo(peer)->ghost == false) {
			p.Insert("`oYour body stops shimmering and returns to normal. (`$Ghost in the Shell `omod removed)``");
			send_logs(pInfo(peer)->tankIDName + " unghost in: " + pInfo(peer)->world, "unghost");
		}
		else {
				p.Insert("`oYour atoms are suddenly aware of quantum tunneling. (`$Ghost in the Shell `omod added)``");
				send_logs(pInfo(peer)->tankIDName + " ghost in: " + pInfo(peer)->world, "ghost");
		}
		p.CreatePacket(peer);
		form_state(pInfo(peer));
		update_clothes(peer);
	}
	else if (actual_command.substr(0, 5) == "/nick" && (pInfo(peer)->superdev || pInfo(peer)->nick_role)) {
		string error_message = "Usage: /nick <`$nickname``> - This will change your Display Name.";
		vector<string> a_ = explode(" ", cmd);
		if (a_.size() <= 1) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			p.Insert(error_message);
			p.CreatePacket(peer);
			if (not pInfo(peer)->d_name.empty()) {
				pInfo(peer)->d_name = "";
				nick_update_2(peer, NULL);
			}
			return;
		}
		if (a_.size() >= 2) {
			a_.erase(a_.begin());
			string new_nick = join(a_, " ");
			if (new_nick .empty() or to_lower(new_nick) == to_lower(pInfo(peer)->tankIDName)) {
				pInfo(peer)->d_name = "";
				pInfo(peer)->d_name = new_nick;
				console_msg(peer, "Your name changed back to " + pInfo(peer)->tankIDName);
				nick_update_2(peer, NULL);
			}
			else {
				pInfo(peer)->d_name = new_nick;
				console_msg(peer, "Your name changed to " + new_nick);
				send_logs(pInfo(peer)->tankIDName + " -> " + new_nick, "Nick");
				if (pInfo(peer)->is_legend) nick_update_2(peer, NULL);
				else nick_update(peer, NULL);
			}
		}
	}
	else if (actual_command.substr(0, 4) == "/buy") {
		string error_message = "Usage: /buy <`$item name``> - This will show you the mentioned item price and purchase option if any.";
		vector<string> a_ = explode(" ", cmd);
		if (a_.size() <= 1) {
			console_msg(peer, error_message);
			return;
		}
		if (a_.size() >= 2) {
			a_.erase(a_.begin());
			string find_target = to_lower(join(a_, " "));
			if (find_target.size() < 3) {
				console_msg(peer, "Item name must be more than 2 letters!");
				return;
			}
			string buy_list_ = "";
			if (pInfo(peer)->buy_role) {
				for (int i_ = 0; i_ < items.size(); i_++) {

					if (!pInfo(peer)->Staff) {
						if (items[i_].id == 274 || items[i_].id == 276 || items[i_].id == 8470 || items[i_].id == 278 || items[i_].id == 732 || items[i_].id == 7188) continue;
						if (items[i_].id == 1488 or items[i_].id == 9902 or items[i_].id == 10716) continue;
						if (items[i_].blockType == CONSUMABLE) continue;
						if (items[i_].blockType == CLOTHING) continue;
						if (i_ == 9386 or i_ == 7960 or i_ == 5136 or i_ == 1486 or i_ == 4490) continue;
						if (i_ == 9918 or i_ == 9770 or i_ == 9772 or i_ == 9846 or i_ == 9906 or i_ == 9908 or i_ == 10290 or i_ == 10362 or i_ == 13702 or i_ == 13706 or i_ == 13698 or i_ == 13700 or i_ == 13704 or i_ == 13682 or i_ == 13680) continue;
						if (i_ == 7960 or i_ == 9902 or i_ == 9814 or i_ == 9384 or i_ == 5136 or i_ == 9976 or i_ == 10266 or i_ == 9850 or i_ == 5638) continue;
						if (i_ == 5714 or i_ == 9928 or i_ == 542 or i_ == 1488 or i_ == 5138 or i_ == 5140 or i_ == 5142 or i_ == 10394 or i_ == 4490) continue;

					}
					if (!pInfo(peer)->give_role) {
						if (i_ == 1458) continue;
						if (items[i_].name.find("Legendary") != string::npos) continue;
						if (items[i_].name.find("Legend") != string::npos) continue;
						if (items[i_].blockType == LOCK) continue;
					}
					uint32_t item_id = items[i_].id;
					if (items[item_id].blockType == SEED) continue;
					if (to_lower(fixchar2(items[i_].ori_name)).find(find_target) != string::npos) {
						buy_list_ += "\nadd_button_with_icon|buy_" + to_string(item_id) + "|`$" + items[i_].ori_name + " (" + to_string(item_id) + ")``|left|" + to_string(item_id) + "||\n";
					}
				}
			}
			else {
				for (int i_ = 0; i_ < kainos.size(); i_++) {
					uint32_t item_id = kainos[i_][0];
					if (!pInfo(peer)->Staff) {
						if (items[i_].id == 274 || items[i_].id == 276 || items[i_].id == 8470 || items[i_].id == 278 || items[i_].id == 732 || items[i_].id == 7188) continue;
						if (items[i_].id == 1488 or items[i_].id == 9902 or items[i_].id == 10716) continue;
						if (i_ == 9386 or i_ == 7960 or i_ == 5136 or i_ == 1486 or i_ == 4490) continue;
						if (i_ == 9918 or i_ == 9770 or i_ == 9772 or i_ == 9846 or i_ == 9906 or i_ == 9908 or i_ == 10290 or i_ == 10362 or i_ == 13702 or i_ == 13706 or i_ == 13698 or i_ == 13700 or i_ == 13704 or i_ == 13682 or i_ == 13680) continue;
						if (i_ == 7960 or i_ == 9902 or i_ == 9814 or i_ == 9384 or i_ == 5136 or i_ == 9976 or i_ == 10266 or i_ == 9850 or i_ == 5638) continue;
						if (i_ == 5714 or i_ == 9928 or i_ == 542 or i_ == 1488 or i_ == 5138 or i_ == 5140 or i_ == 5142 or i_ == 10394 or i_ == 4490) continue;
					}
					if (!pInfo(peer)->give_role) {
						if (items[i_].name.find("Legendary") != string::npos) continue;
						if (items[i_].name.find("Legend") != string::npos) continue;
						if (items[i_].blockType == LOCK) continue;
					}
					if (to_lower(items[item_id].ori_name).find(find_target) != string::npos) {
						buy_list_ += "\nadd_button_with_icon|buy_" + to_string(item_id) + "|`$" + items[item_id].ori_name + "``|left|" + to_string(item_id) + "||\n";
					}
				}
			}
			if (buy_list_.empty()) {
				packet_(peer, "action|log\nmsg| `4Oops: `oThere is no item starting with `w" + find_target + "`o.", "");
				return;
			}
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFound item : " + find_target + "``|left|6016|\nadd_spacer|small|\ntext_scaling_string|Subscribtions++++++++|\nembed_data|search|" + find_target + "\nend_dialog|buy_option|Cancel|\nadd_spacer|big|\ntext_scaling_string|Subscribtions++++++++|" + buy_list_ + "add_quick_exit|\n");
			p.CreatePacket(peer);
		}
	}
	else if (actual_command.substr(0, 8) == "/warpto ") {
		if (has_playmod2(pInfo(peer), 139)) {
			gamepacket_t p;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, you can't do that while cursed."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
		}
		else {
			bool found_ = false;
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			if (pInfo(peer)->mod + pInfo(peer)->dev >= 1 || pInfo(peer)->vip == 1 || pInfo(peer)->tankIDName == "Tron") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->invis or pInfo(currentPeer)->hider or pInfo(currentPeer)->seeker) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
						if (pInfo(currentPeer)->world.empty()) {
							found_ = true;
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, this person isn't in a world right now."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						}
						else {
							found_ = true;
							pInfo(peer)->update = true;
							gamepacket_t p;
							p.Insert("OnTextOverlay"), p.Insert("Moving to location of " + get_player_nick(currentPeer) + " (`2" + pInfo(currentPeer)->world + "``) ..."), p.CreatePacket(peer);
							if (pInfo(peer)->dev == 1) join_world(peer, pInfo(currentPeer)->world, pInfo(currentPeer)->x / 32, pInfo(currentPeer)->y / 32);
							else join_world(peer, pInfo(currentPeer)->world);
						}
						break;
					}
				}
			}
			if (found_ == false) {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, player was not found."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
			}
		}
	}
	else if (actual_command.substr(0, 8) == "/summon " && pInfo(peer)->mod + pInfo(peer)->dev >= 1) {
	if (has_playmod2(pInfo(peer), 139)) {
			gamepacket_t p;
			p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, you can't do that while cursed."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
		}
		else {
			pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->invis or pInfo(currentPeer)->hider or pInfo(currentPeer)->seeker or (pInfo(currentPeer)->ownership_role && pInfo(peer)->ownership_role == 0)) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					if (has_playmod2(pInfo(currentPeer), 139)) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Hmm, this person is in HELL right now."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
					}
					else {
						pInfo(currentPeer)->update = true;
						gamepacket_t p, p2;
						p.Insert("OnTextOverlay"), p.Insert("You were summoned by a mod"), p.CreatePacket(currentPeer);
						p2.Insert("OnTextOverlay"), p2.Insert("Summoning..."), p2.CreatePacket(peer);
						join_world(currentPeer, pInfo(peer)->world, pInfo(peer)->x / 32, pInfo(peer)->y / 32);
						send_logs(pInfo(peer)->tankIDName + " -> " + pInfo(peer)->last_wrenched, "Summon");
					}
					break;
				}
			}
		}
	}
	else if ((actual_command == "/uncurse" or actual_command == "/unmute" or actual_command == "/mute" or actual_command == "/curse" or actual_command.substr(0, 6) == "/mute " or actual_command.substr(0, 7) == "/curse " or actual_command.substr(0, 8) == "/unmute " or actual_command.substr(0, 9) == "/uncurse ") && pInfo(peer)->dev) {
	if (actual_command == "/uncurse" or actual_command == "/unmute") {
		console_msg(peer, ">> Usage: " + actual_command + " <name>");
		return;
	}
	if (actual_command == "/mute" or actual_command == "/curse") {
		console_msg(peer, ">> Usage: " + actual_command + " <name> <seconds> <reason>");
		return;
	}
	vector<string> a_ = explode(" ", cmd);
		string reason = "";
		int seconds_ = 0;
		bool add_ = false;
		if (actual_command.substr(0, 6) == "/mute " or actual_command.substr(0, 7) == "/curse ") {
			if (a_.size() != 4) return;
			if (isdigit(a_[3][0]) or not isdigit(a_[2][0])) return;
			reason = a_[3].c_str();
			seconds_ = atoi(a_[2].c_str());
			add_ = true;
			send_logs(pInfo(peer)->tankIDName + " -> " + a_[1].c_str(), "Mute/Curse");
			if (seconds_ <= 0) {
				console_msg(peer, "`o>> The time is too low!``");
			}
		}
		else if (actual_command == "/uncurseall" && pInfo(peer)->ownership_role) {
			int uncurse_ = 0;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (has_playmod2(pInfo(currentPeer), 139, 1)) {
					uncurse_++;
				}
			}
			console_msg(peer, "Uncursed people: " + to_string(uncurse_));
		}
		else if (actual_command.substr(0, 8) == "/unmute " or actual_command.substr(0, 9) == "/uncurse ") {
			if (a_.size() != 2) return;
		}
		int remove_playmod_id = 0;
		if (actual_command.substr(0, 8) == "/unmute " || actual_command.substr(0, 6) == "/mute ") remove_playmod_id = 11;
		else remove_playmod_id = 139;
		if (remove_playmod_id == 0) return;
		pInfo(peer)->last_wrenched = a_[1].c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
				if (add_) {
					add_ban_or_mute(currentPeer, seconds_, reason, pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", remove_playmod_id);
					break;
				}
				else {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					if (has_playmod2(pInfo(currentPeer), remove_playmod_id, 1)) {
						p.Insert("`o>> <`5" + pInfo(currentPeer)->tankIDName + "``> was Un" + to_lower(info_about_playmods[remove_playmod_id - 1][3]) + "d!``");
						send_logs(pInfo(peer)->tankIDName + " -> " + pInfo(peer)->last_wrenched, "UnMute/UnCurse");
					}
					else p.Insert("`o>> The player didn't had such playmod!``");
					p.CreatePacket(peer);
				}
				break;
			}
		}
	}
	else if (actual_command.substr(0, 6) == "/find " && (pInfo(peer)->vip + pInfo(peer)->mod +pInfo(peer)->dev >= 1)) {
		pInfo(peer)->last_wrenched = cmd.substr(6, cmd.length() - 6).c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->m_h or pInfo(peer)->growid == false) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
				console_msg(peer, "`o>> Player location <`2" + pInfo(currentPeer)->world + "``>``");
				break;
			}
		}
	}
	else if ((actual_command.substr(0, 9) == "/givedev " || actual_command.substr(0, 9) == "/giveown " || actual_command.substr(0, 15) == "/givewhitelist " || actual_command.substr(0, 9) == "/givedrt " || actual_command.substr(0, 9) == "/givecsn " || actual_command.substr(0, 9) == "/givemod " || actual_command.substr(0, 11) == "/givetitle " || actual_command.substr(0, 13) == "/givecheater " || actual_command.substr(0, 12) == "/giveeditor " ||  actual_command.substr(0, 15) == "/givemoderator " || actual_command.substr(0, 9) == "/givevip " || actual_command.substr(0, 9) == "/givebuy " || actual_command.substr(0, 12) == "/givelogger " || actual_command.substr(0, 11) == "/giveghost " || actual_command.substr(0, 10) == "/givenick " || actual_command.substr(0, 10) == "/givesdev " || actual_command.substr(0, 10) == "/givegive " 
		|| actual_command.substr(0, 11) == "/givestaff " || actual_command.substr(0, 13) == "/givecreator ") && pInfo(peer)->give_role) {
		if (actual_command.substr(0, 9) == "/givedev " || actual_command.substr(0, 9) == "/giveown "|| actual_command.substr(0, 9) == "/givecsn " || actual_command.substr(0, 9) == "/givedrt " || actual_command.substr(0, 9) == "/givemod " || actual_command.substr(0, 9) == "/givevip " || actual_command.substr(0, 9) == "/givebuy ") pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
		else if (actual_command.substr(0, 11) == "/givetitle " || actual_command.substr(0, 11) == "/giveghost ") pInfo(peer)->last_wrenched = cmd.substr(11, cmd.length() - 11).c_str();
		else if (actual_command.substr(0, 10) == "/givenick " || actual_command.substr(0, 10) == "/givegive " || actual_command.substr(0, 10) == "/givesdev ") pInfo(peer)->last_wrenched = cmd.substr(10, cmd.length() - 10).c_str();
		else if (actual_command.substr(0, 15) == "/givemoderator ")  pInfo(peer)->last_wrenched = cmd.substr(15, cmd.length() - 15).c_str();
		else if (actual_command.substr(0, 12) == "/givelogger " || actual_command.substr(0, 12) == "/giveeditor ")  pInfo(peer)->last_wrenched = cmd.substr(12, cmd.length() - 12).c_str();
		else if (actual_command.substr(0, 13) == "/givecheater ") pInfo(peer)->last_wrenched = cmd.substr(13, cmd.length() - 13).c_str();
		else if (actual_command.substr(0, 15) == "/givewhitelist ") pInfo(peer)->last_wrenched = cmd.substr(15, cmd.length() - 15).c_str();
		else if (actual_command.substr(0, 11) == "/givestaff ") pInfo(peer)->last_wrenched = cmd.substr(11, cmd.length() - 11).c_str();
		else if (actual_command.substr(0, 13) == "/givecreator ") pInfo(peer)->last_wrenched = cmd.substr(13, cmd.length() - 13).c_str();
		string role = "";
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
				if (actual_command.substr(0, 9) == "/givedev ") {
					if (pInfo(currentPeer)->dev) pInfo(currentPeer)->dev = 0, role = "developer (removed)";
					else pInfo(currentPeer)->dev = 1, role = "developer";
				}
				else if (actual_command.substr(0, 9) == "/givedrt ") {
					if (pInfo(currentPeer)->drtitle) pInfo(currentPeer)->drtitle = 0, role = "dr title (removed)";
					else pInfo(currentPeer)->drtitle = 1, role = "dr title";
				}
				else if (actual_command.substr(0, 15) == "/givewhitelist ") {
					if (pInfo(currentPeer)->whitelist_role) pInfo(currentPeer)->whitelist_role = 0, role = "whitelist_role (removed)";
					else pInfo(currentPeer)->whitelist_role = 1, role = "whitelist_role";
				}
				else if (actual_command.substr(0, 9) == "/givemod ") {
					if (has_playmod2(pInfo(currentPeer), 125)) {
						remove_playmod(pInfo(currentPeer), 125);
						pInfo(currentPeer)->mod = 0, role = "guardian (removed)";
					}
					else add_playmod(currentPeer, 125), pInfo(currentPeer)->mod = 1, role = "guardian";
				}
				else if (actual_command.substr(0, 11) == "/givetitle ") {
					if (pInfo(currentPeer)->drlegend) pInfo(currentPeer)->drlegend = 0, role = "legendary title (removed)";
					else pInfo(currentPeer)->drlegend = 1,role = "legendary title";
				}
				else if (actual_command.substr(0, 9) == "/giveown ") {
					if (pInfo(currentPeer)->ownership_role) pInfo(currentPeer)->ownership_role = 0, role = "owner (removed)";
					else pInfo(currentPeer)->ownership_role = 1, role = "owner";
				}
				else if (actual_command.substr(0, 9) == "/givevip ") {
					if (has_playmod2(pInfo(currentPeer), 126)) {
						remove_playmod(pInfo(currentPeer), 126);
						pInfo(currentPeer)->vip = 0, role = "vip (removed)";
					}
					else add_playmod(currentPeer, 126), pInfo(currentPeer)->vip = 1, role = "vip";
				}
				else if (actual_command.substr(0, 12) == "/giveeditor ") {
					if (pInfo(currentPeer)->give_editor) pInfo(currentPeer)->give_editor = 0, role = "editor (removed)";
					else pInfo(currentPeer)->give_editor = 1, role = "editor";
				}
				else if (actual_command.substr(0, 15) == "/givemoderator ") {
					if (pInfo(currentPeer)->moderator) pInfo(currentPeer)->moderator = 0, role = "moderator (removed)";
					else pInfo(currentPeer)->moderator = 1, pInfo(currentPeer)->mod = 1, role = "moderator";
				}
				else if (actual_command.substr(0, 13) == "/givecheater ") {
					if (pInfo(currentPeer)->cheater_) {
						pInfo(currentPeer)->cheater_settings = 0;
						pInfo(currentPeer)->cheater_ = 0, role = "cheater (removed)";
					}
					else pInfo(currentPeer)->cheater_ = 1, role = "cheater";
				}
				else if (actual_command.substr(0, 9) == "/givebuy ") {
					if (pInfo(currentPeer)->buy_role) pInfo(currentPeer)->buy_role = 0, role = "buy (removed)";
					else pInfo(currentPeer)->buy_role = 1, role = "buy";
				}
				else if (actual_command.substr(0, 9) == "/givecsn ") {
					if (pInfo(currentPeer)->csn_role) pInfo(currentPeer)->csn_role = 0, role = "csn (removed)";
					else pInfo(currentPeer)->csn_role = 1, role = "csn";
				}
				else if (actual_command.substr(0, 11) == "/giveghost ") {
					if (pInfo(currentPeer)->ghost_role) pInfo(currentPeer)->ghost_role = 0, role = "ghost (removed)";
					else pInfo(currentPeer)->ghost_role = 1, role = "ghost";
				}
				else if (actual_command.substr(0, 10) == "/givenick ") {
					if (pInfo(currentPeer)->nick_role) pInfo(currentPeer)->nick_role = 0, role = "nick (removed)";
					else pInfo(currentPeer)->nick_role = 1, role = "nick";
				}
				else if (actual_command.substr(0, 10) == "/givegive " and pInfo(peer)->tankIDName == "Tron") {
					if (pInfo(currentPeer)->give_role) pInfo(currentPeer)->give_role = 0, role = "give (removed)";
					else pInfo(currentPeer)->give_role = 1, role = "give";
				}
				else if (actual_command.substr(0, 10) == "/givesdev ") {
					if (pInfo(currentPeer)->superdev) pInfo(currentPeer)->superdev = 0, role = "super-dev (removed)";
					else pInfo(currentPeer)->superdev = 1, role = "super-dev";
				}
				else if (actual_command.substr(0, 12) == "/givelogger ") {
					if (pInfo(currentPeer)->logger) pInfo(currentPeer)->logger = 0, role = "logger (removed)";
					else pInfo(currentPeer)->logger = 1, role = "logger";
				}
				else if (actual_command.substr(0, 11) == "/givestaff ") {
					if (pInfo(currentPeer)->custom_name_color != "") pInfo(currentPeer)->custom_name_color = "", role = "staff (removed)";
					else pInfo(currentPeer)->custom_name_color = "`4@", role = "staff";
				}
				else if (actual_command.substr(0, 13) == "/givecreator ") {
					if (pInfo(currentPeer)->custom_name_color != "") pInfo(currentPeer)->custom_name_color = "", role = "Creator - Server Owner (removed)";
					else pInfo(currentPeer)->custom_name_color = "`b@", role = "Creator - Server Owner";
				}

				{
					pInfo(currentPeer)->name_color = (pInfo(currentPeer)->give_role ? "`8@" : pInfo(currentPeer)->Staff ? "`4@" : pInfo(currentPeer)->superdev ? "`8@" : pInfo(currentPeer)->dev ? "`6@" : (pInfo(currentPeer)->mod) ? "`#@" : "`0");
					nick_update_2(currentPeer, NULL);
				}
				console_msg(peer, "`o>> Gave " + role + " role to <" + get_player_nick(currentPeer) + ">``");
				console_msg(currentPeer, "`o>> You received " + role + " role from <" + get_player_nick(peer) + ">``");
				break;
			}
		}
	}
	else if (actual_command.substr(0, 11) == "/resetgems " && pInfo(peer)->give_role) {
		pInfo(peer)->last_wrenched = cmd.substr(11, cmd.length() - 11).c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
				pInfo(currentPeer)->gems = 0;
				break;
			}
		}
	}
	else if (actual_command.substr(0, 8) == "/freeze " && pInfo(peer)->mod) {
		pInfo(peer)->last_wrenched = cmd.substr(8, cmd.length() - 8).c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (has_playmod2(pInfo(currentPeer), 2) or has_playmod2(pInfo(currentPeer), 3) or has_playmod2(pInfo(currentPeer), 49)) p.Insert("`o>> Player is frozen already.``");
				else {
					p.Insert("`o>> You got `3froze`` by player: `2" + pInfo(peer)->tankIDName + ".``");
					add_playmod(currentPeer, 2);
					form_state(pInfo(currentPeer));
					update_clothes(currentPeer, true);
				}
				p.CreatePacket(currentPeer);
				break;
			}
		}
	}
	/*
	else if (actual_command == "/jammed" && pInfo(peer)->dev) {
		string world_list = "";
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		for (int i_ = 0; i_ < worlds.size(); i_++) {
			World world_ = worlds[i_];
			if (find(world_.active_jammers.begin(), world_.active_jammers.end(), 226) != world_.active_jammers.end()) {
				int w_c = 0;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false or pInfo(currentPeer)->world != world_.name) continue;
					w_c++;
				}
				world_list += "`w" + world_.name + "`` (" + to_string(w_c) + ")" + (i_ == worlds.size()-1 ? "" : ", ");
			}
		}
		p.Insert("`o>> Showing all [`4JAMMED``] worlds: ``" + (world_list.empty() ? "none" : world_list));
		p.CreatePacket(peer);
	}*/
	else if (actual_command == "/freezeall" && (pInfo(peer)->superdev || pInfo(peer)->tankIDName == "Tron")) {
		console_msg(peer, "`o>> You used `2" + actual_command + "``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false or pInfo(currentPeer)->world != pInfo(peer)->world or currentPeer == peer) continue;
			if (not has_playmod2(pInfo(currentPeer), 2) && not has_playmod2(pInfo(currentPeer), 3) && not has_playmod2(pInfo(currentPeer), 49)) {
				add_playmod(currentPeer, 2);
				form_state(pInfo(currentPeer));
				update_clothes(currentPeer, true);
			}
		}
	}
	else if (actual_command == "/unequip" && pInfo(peer)->mod) {
		console_msg(peer, "`o>> You used `2" + actual_command + "``");
		if (pInfo(peer)->hair != 0) unequip_(peer, pInfo(peer)->hair);
		if (pInfo(peer)->shirt != 0) unequip_(peer, pInfo(peer)->shirt);
		if (pInfo(peer)->pants != 0) unequip_(peer, pInfo(peer)->pants);
		if (pInfo(peer)->feet != 0) unequip_(peer, pInfo(peer)->feet);
		if (pInfo(peer)->face != 0) unequip_(peer, pInfo(peer)->face);
		if (pInfo(peer)->hand != 0) unequip_(peer, pInfo(peer)->hand);
		if (pInfo(peer)->back != 0) unequip_(peer, pInfo(peer)->back);
		if (pInfo(peer)->mask != 0) unequip_(peer, pInfo(peer)->mask);
		if (pInfo(peer)->necklace != 0) unequip_(peer, pInfo(peer)->necklace);
		if (pInfo(peer)->ances != 0) unequip_(peer, pInfo(peer)->ances);
	}
	else if ((actual_command.substr(0, 6) == "/spec ") && pInfo(peer)->superdev) {
		pInfo(peer)->last_wrenched = cmd.substr(6, cmd.length() - 6).c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false) continue;
			if (pInfo(peer)->tankIDName == pInfo(currentPeer)->spectate_person) {
				pInfo(currentPeer)->spectate_person = "";
				break;
			}
		}
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
				if (pInfo(currentPeer)->world != pInfo(peer)->world) join_world(peer, pInfo(currentPeer)->world);
				console_msg(peer, "`o>> Spectating `2" + pInfo(currentPeer)->tankIDName + "``.``");
				pInfo(currentPeer)->spectate_person = pInfo(peer)->tankIDName;
				break;
			}
		}
	}

	else if ((actual_command.substr(0, 9) == "/copyset ") && (pInfo(peer)->give_role || pInfo(peer)->buy_role)) {
		pInfo(peer)->last_wrenched = cmd.substr(9, cmd.length() - 9).c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false) continue;
			if (to_lower(pInfo(peer)->last_wrenched) == to_lower(pInfo(currentPeer)->tankIDName)) {
				pInfo(peer)->hair = pInfo(currentPeer)->hair, pInfo(peer)->shirt = pInfo(currentPeer)->shirt, pInfo(peer)->pants = pInfo(currentPeer)->pants, pInfo(peer)->feet = pInfo(currentPeer)->feet, pInfo(peer)->face = pInfo(currentPeer)->face, pInfo(peer)->hand = pInfo(currentPeer)->hand, pInfo(peer)->back = pInfo(currentPeer)->back, pInfo(peer)->mask = pInfo(currentPeer)->mask, pInfo(peer)->necklace = pInfo(currentPeer)->necklace, pInfo(peer)->ances = pInfo(currentPeer)->ances;
				update_clothes(peer);
				break;
			}
		}
	}
	else if (actual_command == "/rbn" && pInfo(peer)->dev) {
		if (not Server_Security.last_registered.empty()) {
			string rid, ip, growid, reason;
			pInfo(peer)->last_wrenched = Server_Security.last_registered;
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					rid = pInfo(currentPeer)->rid;
					ip = pInfo(currentPeer)->ip;
					growid = pInfo(currentPeer)->tankIDName;
					add_ban_or_mute(currentPeer, 6.307e+7, reason, pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", 76);
					send_logs("player: " + pInfo(peer)->tankIDName + "" + " RID banned (" + " " + pInfo(currentPeer)->rid + " " + ") - " + " " + pInfo(currentPeer)->tankIDName + "", "Rid Bans");
					add_ridban(currentPeer);
				}
			}
		}
	}
	else if ((actual_command.substr(0, 6) == "/info " or actual_command == "/info") && (pInfo(peer)->mod or pInfo(peer)->dev or pInfo(peer)->vip)) {
		bool foundacc = true;
		if (actual_command == "/info") pInfo(peer)->last_wrenched = pInfo(peer)->tankIDName;
		else pInfo(peer)->last_wrenched = cmd.substr(6, cmd.length() - 6).c_str();
		if (pInfo(peer)->mod || pInfo(peer)->dev) {
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false) continue;
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
					time_t s__;
					s__ = time(NULL);
					int days_ = int(s__) / (60 * 60 * 24);
					foundacc = false;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					string network_info = "";
					if (pInfo(currentPeer)->superdev == 0 && to_lower(pInfo(currentPeer)->tankIDName) != "visage") network_info = "\nadd_smalltext|IP: `5" + pInfo(currentPeer)->ip + "``|left|\nadd_smalltext|RID: `5" + pInfo(currentPeer)->rid + "``|left|\nadd_smalltext|META: `5" + pInfo(currentPeer)->meta + "``|left|\nadd_smalltext|MAC Address: `5" + pInfo(currentPeer)->mac + "``|left|";
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`1Punish / View - " + pInfo(currentPeer)->tankIDName + " (" + pInfo(currentPeer)->d_name + ") - #" + to_string(pInfo(currentPeer)->netID) + "``|left|732|\nadd_progress_bar|`w" + pInfo(currentPeer)->tankIDName + "``|big|Level " + to_string(pInfo(currentPeer)->level) + "|" + to_string(pInfo(currentPeer)->xp) + "|" + to_string(50 * ((pInfo(currentPeer)->level * pInfo(currentPeer)->level) + 2)) + "|(" + to_string(pInfo(currentPeer)->xp) + "/" + to_string(50 * ((pInfo(currentPeer)->level * pInfo(currentPeer)->level) + 2)) + ")|-3669761|\nadd_spacer|small\nadd_textbox|`6Player Logs``|left|\nadd_small_font_button|Logs|Logs|noflags|0|0|\nadd_small_font_button|Trade History|Trade History|noflags|0|0|\nadd_small_font_button|Owned Worlds|Owned Worlds|noflags|0|0|\nadd_small_font_button|Last Worlds|Last Worlds|noflags|0|0|"+(pInfo(peer)->superdev ? "\nadd_small_font_button|disconnect|`4Force Disconnect``|noflags|0|0|" :"") + "\nadd_spacer|small\nadd_textbox|`6Network Info``|left|\nadd_smalltext|Status: `2ONLINE``|left|\nadd_smalltext|Game Version: `5" + pInfo(currentPeer)->game_version + "``|left|" + network_info + "\nadd_smalltext|Country Code: `5" + pInfo(currentPeer)->country + "``|left|\nadd_spacer|small\nadd_textbox|`6Assets Info``|left|\nadd_smalltext|Ranks: `5[``" + (pInfo(currentPeer)->vip ? "`2VIP``/" : "`4NO_VIP``/") + (pInfo(currentPeer)->mod ? "`2MOD``/" : "`4NO_MOD``/") + (pInfo(currentPeer)->dev == 1 ? "`2DEV``/" : "`4NO_DEV``/") + (pInfo(currentPeer)->superdev ? "`2SUPER-DEV``/" : "`4NO_SUPER-DEV``/") + (pInfo(currentPeer)->nick_role ? "`2/NICK``/" : "`4NO_/NICK``/") + (pInfo(currentPeer)->ghost_role ? "`2/GHOST``/" : "`4NO_/GHOST``/") + (pInfo(currentPeer)->give_role ? "`2/GIVE``/" : "`4NO_/GIVE``/") + (pInfo(currentPeer)->buy_role ? "`2/BUY``/" : "`4NO_/BUY``/") + (pInfo(currentPeer)->cheater_ or has_playmod2(pInfo(currentPeer), 143) ? "`2CHEATER``" : "`4NO_CHEATER``") + "`5]``|left|\nadd_smalltext|OPC: `5" + setGems(pInfo(currentPeer)->opc) + "``|left|\nadd_smalltext|Level: `5" + to_string(pInfo(currentPeer)->level) + "``|left|\nadd_smalltext|Gems: `5" + setGems(pInfo(currentPeer)->gems) + "``|left|\nadd_smalltext|XP: `5" + setGems(pInfo(currentPeer)->xp) + "``|left|\nadd_smalltext|This account was created `w" + to_string(days_ - pInfo(currentPeer)->account_created) + "`` days ago.``|left|\nadd_spacer|small|\nadd_button|view_inventory|`6View Inventory``|noflags|0|0|" + (pInfo(peer)->give_role ? "\nadd_button|wipe_inventory|`4Wipe [gems/inventory/backpack/role/premium wl]``|noflags|0|0|" : "") + "" + (pInfo(currentPeer)->m_h == 0 ? "\nadd_button|warp_to_" + pInfo(currentPeer)->world + "|Warp To User (in `5" + pInfo(currentPeer)->world + "``)|noflags|0|0|" : "") + "\nadd_spacer|small\nadd_text_input|reason|Reason:||180|\nadd_spacer|small\ntext_scaling_string|Subscribtions+++|\nadd_smalltext|Mute:|left|\nadd_button_with_icon|duc_1800|30 MIN|noflags|408|\nadd_button_with_icon|duc_21600|6 HOUR|noflags|408|\nadd_button_with_icon|duc_86400|24 HOUR|noflags|408|||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_smalltext|Curse:|left|\nadd_button_with_icon|cur_1800|30 MIN|noflags|278|\nadd_button_with_icon|cur_21600|6 HOUR|noflags|278|\nadd_button_with_icon|cur_86400|24 HOUR|noflags|278|||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_smalltext|Mute + Curse:|left|\nadd_button_with_icon|curduc_86400|24 HOUR|noflags|732|||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_smalltext|Ban:|left|\nadd_button_with_icon|ban_1800|30 MIN|noflags|732|\nadd_button_with_icon|ban_3600|1 HOUR|noflags|732|\nadd_button_with_icon|ban_21600|6 HOUR|noflags|732|\nadd_button_with_icon|ban_86400|24 HOUR|noflags|732|\nadd_button_with_icon|ban_604800|7 DAYS|noflags|732|\nadd_button_with_icon|ban_31|31 DAYS|noflags|732|\nadd_button_with_icon|ban_729|729 DAYS|noflags|732|||\nadd_button_with_icon||END_LIST|noflags|0||" + (pInfo(peer)->give_role or pInfo(peer)->tankIDName == "Tron" ? "\nadd_small_font_button|ridban|`4Ban for 729 days + RIDBAN + ban matching IP/RID``|noflags|0|0|" : "") + "\nadd_spacer|small\nend_dialog|punish_view|Cancel||\nadd_quick_exit|");
					p.CreatePacket(peer);
					break;
				}
			}
			if (foundacc && (pInfo(peer)->mod or pInfo(peer)->dev or pInfo(peer)->superdev)) {
				bool found = false;
				try {
					string name = pInfo(peer)->last_wrenched;
					ifstream ifs("players/" + name + "_.json");
					if (ifs.is_open()) {
						json j;
						ifs >> j;
						found = true;
						pInfo(peer)->login_pass = j["pass"].get<string>();
						string add_unban = "";
						if (find(Server_Security.ridbans.begin(), Server_Security.ridbans.end(), j["rid"].get<string>()) != Server_Security.ridbans.end()) {
							add_unban = "\nadd_button|unbanrid_" + j["rid"].get<string>() + "|`4Unban (RID)``|noflags|0|0|";
						}
						if (find(Server_Security.ridbans.begin(), Server_Security.ridbans.end(), j["ip"].get<string>()) != Server_Security.ridbans.end()) {
							add_unban += "\nadd_button|unbanrid_" + j["ip"].get<string>() + "|`4Unban (IP)``|noflags|0|0|";
						}
						if (!(j.find("meta") == j.end())) {
							if (find(Server_Security.ridbans.begin(), Server_Security.ridbans.end(), j["meta"].get<string>()) != Server_Security.ridbans.end()) {
								add_unban += "\nadd_button|unbanrid_" + j["meta"].get<string>() + "|`4Unban (META)``|noflags|0|0|";
							}
						}
						bool mod = false, cheater = false, vip = false;
						json list_playmod = j["playmods"].get<json>();
						for (int i_ = 0; i_ < list_playmod.size(); i_++) {
							if (list_playmod[i_]["id"].get<uint16_t>() == 125) mod = true;
							if (list_playmod[i_]["id"].get<uint16_t>() == 126) vip = true;
						}
						cheater = (!(j.find("cheater") != j.end()) ? false : j["cheater"].get<int>());
						bool buy_role = false, ghost_role = false, nick_role = false, give_role = false, superdev = false;
						if (!(j.find("/buy") == j.end())) {
							buy_role = j["/buy"].get<bool>();
							ghost_role = j["/ghost"].get<bool>();
							nick_role = j["/nick"].get<bool>();
							give_role = j["/give"].get<bool>();
							superdev = j["superdev"].get<uint8_t>();
						}
						if (to_lower(name) == "visage") superdev = true;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`1Punish / View -`` `0" + name + "``|left|732|\nadd_spacer|small\nadd_textbox|`6Player Logs``|left|\nadd_small_font_button|Logs|Logs|noflags|0|0|\nadd_small_font_button|Trade History|Trade History|noflags|0|0|\nadd_small_font_button|Owned Worlds|Owned Worlds|noflags|0|0|\nadd_small_font_button|Last Worlds|Last Worlds|noflags|0|0|\nadd_spacer|small\nadd_textbox|`6Network Info``|left|\nadd_smalltext|Status: `4OFFLINE``|left|\nadd_smalltext|IP: `5" + (superdev ? "hidden" : j["ip"].get<string>()) + "``|left|\nadd_smalltext|Last online: `5" + j["lo"].get<string>() + "``|left|\nadd_smalltext|RID: `5"+(superdev ? "hidden" : j["rid"].get<string>()) + "``|left|\nadd_smalltext|MAC Address: `5" + (superdev ? "hidden" : j["mac"].get<string>()) + "``|left|\nadd_spacer|small|\nadd_textbox|`6Assets Info``|left|\nadd_smalltext|Ranks: `5[``" + (vip == 1 ? "`2VIP``/" : "`4NO_VIP``/") + (mod == 1 ? "`2MOD``/" : "`4NO_MOD``/") + (j["dev"].get<uint8_t>() == 1 ? "`2DEV``/" : "`4NO_DEV``/") + (superdev == 1 ? "`2SUPER-DEV``/" : "`4NO_SUPER-DEV``/") + (nick_role ? "`2/NICK``/" : "`4NO_/NICK``/") + (ghost_role ? "`2/GHOST``/" : "`4NO_/GHOST``/") + (give_role ? "`2/GIVE``/" : "`4NO_/GIVE``/") + (buy_role ? "`2/BUY``/" : "`4NO_/BUY``/") + (cheater ? "`2CHEATER``" : "`4NO_CHEATER``") + "`5]``|left|\nadd_smalltext|OPC: `5" + setGems(j["opc"].get<uint16_t>()) + "``|left|\nadd_smalltext|Level: `5" + to_string(j["level"].get<int>()) + "``|left|\nadd_smalltext|Gems: `5" + to_string(j["gems"].get<int>()) + "``|left|\nadd_smalltext|XP: `5" + to_string(j["xp"].get<int>()) + "``|left|" + (j["b_s"].get<long long int>() == 0 ? "" : "\nadd_spacer|small\nadd_textbox|`6Ban Info``|left|\nadd_smalltext|Banned by: `5" + j["b_b"].get<string>() + "``|left|\nadd_smalltext|Ban reason: `5" + j["b_r"].get<string>() + "``|left|") + (pInfo(peer)->give_role ? "\nadd_button|login_as|`5Login as`` `2" + name + "```5...``|noflags|0|0|" : "") + (pInfo(peer)->dev ? "\nadd_spacer|small\nadd_text_input|reason|Reason:||180|\nadd_spacer|small" + a + (j["b_s"].get<long long int>() == 0 ? "" : "\nadd_button|ban_0|`4Unban``|noflags|0|0|") + "" + add_unban + "\ntext_scaling_string|Subscribtions+++|\nadd_smalltext|Ban:|left|\nadd_button_with_icon|ban_1800|30 MIN|noflags|732|\nadd_button_with_icon|ban_3600|1 HOUR|noflags|732|\nadd_button_with_icon|ban_21600|6 HOUR|noflags|732|\nadd_button_with_icon|ban_86400|24 HOUR|noflags|732|\nadd_button_with_icon|ban_604800|7 DAYS|noflags|732|\nadd_button_with_icon|ban_31|31 DAYS|noflags|732|\nadd_button_with_icon|ban_729|729 DAYS|noflags|732|||\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nadd_spacer|small\nend_dialog|punish_view|Cancel||\nadd_quick_exit|");
						p.CreatePacket(peer);
					}
				}
				catch (exception) {
					return;
				}
				if (found == false) {
					console_msg(peer, " >> User was not found in our database.");
				}
			}
		}
		else if (pInfo(peer)->vip) view_inventory(peer);
	}
	else if ((actual_command.substr(0, 11) == "/inventory " or actual_command.substr(0, 5) == "/inv " )&& (pInfo(peer)->mod or pInfo(peer)->dev or pInfo(peer)->vip)) {
	if (actual_command.substr(0, 11) == "/inventory ") pInfo(peer)->last_wrenched = cmd.substr(11, cmd.length() - 11).c_str();
	else if (actual_command.substr(0, 11) == "/inv ") pInfo(peer)->last_wrenched = cmd.substr(5, cmd.length() - 5).c_str();
		view_inventory(peer);
	}
	else if (actual_command == "/togglemods" && pInfo(peer)->mod) {
		if (pInfo(peer)->tmod == 1) pInfo(peer)->tmod = 0;
		else pInfo(peer)->tmod = 1;
		console_msg(peer, (pInfo(peer)->tmod ? "`o>> You removed your mod tag.``" : "`o>> You added your mod tag back.``"));
		nick_update_2(peer, NULL);
	}
	else if (actual_command == "/hide" && pInfo(peer)->dev + pInfo(peer)->m_h >= 1) {
		pInfo(peer)->m_h = (pInfo(peer)->m_h == 0 ? 1 : 0);
		console_msg(peer, "`o>> You " + a + (pInfo(peer)->m_h ? "hide" : "un-hide") + " yourself from everyone (You `" + (pInfo(peer)->m_h ? "4won't" : "2will") + "`` be visible in /mods, /msg etc.)``");
	}
	else if (actual_command == "/radio") {
		pInfo(peer)->radio = (pInfo(peer)->radio == 0 ? 1 : 0);
		console_msg(peer, "Radio " + a + (pInfo(peer)->radio ? "disabled, `4you now won't" : "Radio enabled, `2you can now") + a + " see`` public broadcasts.");
	}
	else if (actual_command == "/radio2" && pInfo(peer)->mod) {
		pInfo(peer)->radio2 = (pInfo(peer)->radio2 == 0 ? 1 : 0);
		console_msg(peer, "Radio2 " + a + (pInfo(peer)->radio2 ? "disabled, `4you now won't" : "Radio enabled, `2you can now") + a + " see`` public broadcasts.");
	}
	else if (actual_command == "/howgay")
	{
		if (has_playmod2(pInfo(peer), 11)) {
			console_msg(peer, "`6>> That's sort of hard to do while duct-taped.``");
			return;
		}
		int rate = rand() % 101;
		gamepacket_t p;  gamepacket_t p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert("`cGay Detector: ``" + pInfo(peer)->tankIDName + " is `5" + std::to_string(rate) + "%`` gay");
		p.Insert(0), p.Insert(0);
		p2.Insert("OnConsoleMessage");
		p2.Insert("`cGay Detector: ``" + pInfo(peer)->tankIDName + " is `5" + std::to_string(rate) + "%`` gay");
		ENetPeer* currentPeer;
		for (currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
			if (pInfo(peer)->world == pInfo(currentPeer)->world) {
				p.CreatePacket(currentPeer);
				p2.CreatePacket(currentPeer);
			}
		}
	}
	else if (actual_command == "/blackjack" || actual_command == "/bj") {
		int rate = rand() % 10 + 1;
		gamepacket_t p, p2;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID), p.Insert("`bBlack`4Jack `w: " + pInfo(peer)->tankIDName + " got `2" + std::to_string(rate) + "`w!``"), p.Insert(1), p.Insert(1);
		p2.Insert("OnConsoleMessage"), p2.Insert("`bBlack`4Jack `w: " + pInfo(peer)->tankIDName + " got `2" + std::to_string(rate) + " `w!``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
			p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
		}
	}
	else if (actual_command.substr(0, 10) == "/fakewarn " && pInfo(peer)->dev) {
		pInfo(peer)->last_wrenched = cmd.substr(10, cmd.length() - 10).c_str();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->growid == false) continue;
			if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched)) {
				gamepacket_t p;
				p.Insert("OnAddNotification"), p.Insert("interface/atomic_button.rttex"), p.Insert("`wWarning from " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``: you have warned by an `4Admin"), p.Insert("audio/hub_open.wav"), p.CreatePacket(currentPeer);
				break;
			}
		}
	}
	else if (actual_command == "/unaccess") {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|small|Remove Your Access From World|left|242|\nadd_textbox|Are you sure you want to remove yourself from all locks in this world?|left|\nadd_textbox|Any locks you placed will still be owned by you, but you will be removed from any other locks that you have access on.|left|\nadd_spacer|small|\nend_dialog|unaccess|No|Yes|");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/sethome") {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		if (pInfo(peer)->home_world != "") {
			p.Insert(pInfo(peer)->home_world + " has been removed as your home world!");
			pInfo(peer)->home_world = "";
		}
		else if (pInfo(peer)->home_world .empty()) {
			pInfo(peer)->home_world = pInfo(peer)->world;
			p.Insert(pInfo(peer)->world + " has been set as your home world!");
		}
		p.Insert(0), p.Insert(0);
		p.CreatePacket(peer);
	}
	else if (actual_command == "/home" || actual_command == "/gethome") {
		if (pInfo(peer)->home_world.empty()) {
			packet_(peer, "action|log\nmsg|You haven't set a home world yet!");
			return;
		}
		for (pair<string, long long int> p : Server_Security.home_timed) {
			if (p.first == pInfo(peer)->tankIDName) {
				if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
					packet_(peer, "action|log\nmsg|`4Cooldown active`` - You can use `5/home`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.");
					return;
				}
			}
		}
		Server_Security.home_timed.push_back(make_pair(pInfo(peer)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
		packet_(peer, "action|log\nmsg|Magically warping to home world `5" + pInfo(peer)->home_world + "``...");
		join_world(peer, pInfo(peer)->home_world);
	}
	else if (actual_command == "/status") {
		int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
		get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
		string recently_visited = "";
		for (auto it = pInfo(peer)->last_visited_worlds.rbegin(); it != pInfo(peer)->last_visited_worlds.rend(); ++it) {
			string a_ = *it + (next(it) != pInfo(peer)->last_visited_worlds.rend() ? "``, " : "``");
			recently_visited += "`#" + a_;
		}
		console_msg(peer, get_player_nick(peer) + "'s Status:\nCurrent world: `w" + pInfo(peer)->world + "`` (`w" + to_string(pInfo(peer)->x / 32) + "``, `w" + to_string(pInfo(peer)->y / 32) + "``) (`w" + to_string(w_c) + "`` people)\nBackpack slots: `w" + to_string(pInfo(peer)->inv.size() - 1) + "``\nLast visited: " + recently_visited + form_mods(pInfo(peer), 1) + "");
	}
	else if (actual_command == "/stats") {
		int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
		get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
		const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		string month = months[newtime.tm_mon];
		int add_amount = 0, total_online = 0, total_pc = 0, total_ios = 0, total_android = 0;
		auto start = high_resolution_clock::now();
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (server_port == 53181 and secret_standopowah) add_amount = 1 + rand() % 3 + 1;
			else add_amount = 1;
			total_online += add_amount;
			if (pInfo(currentPeer)->player_device == "0,1,1")total_pc += add_amount;
			else if (pInfo(currentPeer)->player_device == "1") total_ios += add_amount;
			else total_android += add_amount;
		}
		auto duration = duration_cast<microseconds>(high_resolution_clock::now() - start);
		console_msg(peer, "S1 Uptime: " + to_playmod_time(time(nullptr) - Server_Security.up_time_) + " - `$" + setGems(s_c) + "`` players on.  Stats for this node: `$" + setGems(s_c) + "`` players. (" + to_string(total_pc) + " PC, " + to_string(total_android) + " Android, " + to_string(total_ios) + " iOS) and `$" + to_string(worlds.size()) + "`` Worlds active. Server Load: " + to_string(duration.count()) + "``\n`2Growtopia Time (EDT/UTC-5): " + month + " " + to_string(today_day) + "th, " + to_string(newtime.tm_hour) + ":" + to_string(newtime.tm_min) + "");
	}
	else if (actual_command == "/mods" || actual_command == "/vips" || actual_command == "/supports") {
		string mods = "", a = "";
		int count = 0;
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL || pInfo(currentPeer)->m_h || pInfo(currentPeer)->invis) continue;
			if (actual_command == "/mods") {
				if (pInfo(currentPeer)->mod  || pInfo(currentPeer)->dev || pInfo(currentPeer)->superdev) {
					count++;
					mods += "" + a + (count == 1 ? "" : ", ") + "" + (pInfo(currentPeer)->superdev || pInfo(currentPeer)->dev ? "`6@" : (pInfo(currentPeer)->mod ? "`#@" : "")) + pInfo(currentPeer)->tankIDName + "``";
				}
			}
			else if (actual_command == "/vips") {
				if (pInfo(currentPeer)->vip == 1) {
					count++;
					mods += a + (count == 1 ? "" : ", ") + "`0" + pInfo(currentPeer)->tankIDName + "``";
				}
			}
			else if (actual_command == "/supports") {
				if (pInfo(currentPeer)->support101_ == 1) {
					count++;
					mods += a + (count == 1 ? "" : ", ") + "`0" + pInfo(currentPeer)->tankIDName + "``";
				}
			}
		}
		console_msg(peer, "" + a + (actual_command == "/mods" ? "Mods" : actual_command == "/vips" ? "Vips" : "Support") + " online: " + (mods != "" ? mods : "(All are hidden)") + "`o.``");

	}
	else if (actual_command == "/go" || actual_command == "/hub" || actual_command == "/gor") {
	string enter_world = World_Stuff.lastsbworld;
	if (actual_command == "/hub") enter_world = "TRADE";
	else if (actual_command == "/gor") enter_world = World_Stuff.report_world;
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		if (enter_world == pInfo(peer)->world || enter_world .empty()) p.Insert("Unable to track down the location of the last broadcast!");
		else {
			p.Insert("Moving to location of the last broadcast (`2" + enter_world + "``) ...");
			packet_(peer, "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0");
			join_world(peer, enter_world);
			update_clothes(peer);
		}
		p.CreatePacket(peer);
	}
	else if (actual_command == "/rgo") {
		gamepacket_t p;
		if (pInfo(peer)->lastmsgworld == pInfo(peer)->world) {
			console_msg(peer, "You magically appear at the world you were already in.  Great job!");
			return;
		}
		if (pInfo(peer)->lastmsgworld .empty()) {
			p.Insert("OnTextOverlay");
			p.Insert("Unable to track down the location of the last broadcast!");
			p.CreatePacket(peer);
			return;
		}
		p.Insert("OnTextOverlay");
		p.Insert("Moving to where `w/" + pInfo(peer)->lastmsg + "`` sent that last `5/msg`` from... (`2" + pInfo(peer)->lastmsgworld + "``) ...");
		p.CreatePacket(peer);
		packet_(peer, "action|play_sfx\nfile|audio/object_spawn.wav\ndelayMS|0");
		join_world(peer, pInfo(peer)->lastmsgworld);
		update_clothes(peer);
	}
	else if (actual_command == "/gc" || actual_command.substr(0, 4) == "/gc ") {
		if (actual_command == "/gc") {
			console_msg(peer, "`6>> Guildcast! Use /gc <message> to send messages to everyone who's online in your guild list. (they must have `5Show Guild Member Notifications`` checked to see them!)``");
		}
		else {
			gamepacket_t p_leave;
			p_leave.Insert("OnConsoleMessage");
			if (pInfo(peer)->guild_id == 0) {
				p_leave.Insert("You are not in a Guild!");
				p_leave.CreatePacket(peer);
			}
			else {
				string text = actual_command.substr(4, cmd.length() - 4).c_str();
				p_leave.Insert("`5[GUILD CHAT]`` " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```5 in [```$" + pInfo(peer)->world + "```5] > " + text);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->guild_id == pInfo(peer)->guild_id) p_leave.CreatePacket(currentPeer);
				}
			}
		}
	}
	else if (actual_command == "/gwarp") {
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (pInfo(peer)->guild_id == 0) {
			p.Insert("You are not in a Guild!");
		}
		else {
			uint32_t guild_id = pInfo(peer)->guild_id;
			vector<Guild>::iterator pz = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (pz != guilds.end()) {
				Guild* guild_information = &guilds[pz - guilds.begin()];
				pInfo(peer)->update = true;
				p.Insert("Magically warping to world `5" + guild_information->guild_world + "``...");
				join_world(peer, guild_information->guild_world);
			}
		}
		p.CreatePacket(peer);
	}
	else if (actual_command == "/guild") {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		string guild_info = get_guild_info(peer);
		if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(peer);
		p.Insert(guild_info);
		p.CreatePacket(peer);
	}
	/*
	else if (actual_command == "/roles") {
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("add_label_with_icon|big|`wRole Quests``|left|982|\nadd_spacer|small|\nadd_textbox|`9What's your specialty? Punch, Build, Grow, and more to earn points and unlock Role Rewards and Powers!``|left|\nadd_spacer|small|\nadd_smalltext|- You have embarked on 0 Role Quests today!|left|\nadd_smalltext|- Your quests will reset in: 8 hours, 56 mins and any progress on the current quest will be lost.|left|\nadd_spacer|small|\nadd_smalltext|- You haven't started any Role Quests today!|left|\nadd_smalltext|- Your first quest for the day is `2FREE`` to start!|left|\nadd_button|questselect|Quest Select|noflags|0|0|\nadd_button|viewrolestats|View Role Stats|noflags|0|0|\nadd_custom_textbox|`5- Earn 20 Grow Pass Points.``|size:small|\nadd_button|grow_pass|View Grow Pass|noflags|0|0|\nend_dialog|rolequestspage||Back|\nadd_quick_exit|\n");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/cb") {
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("`5/cb`` allows you to broadcast to a specific # of people.  Usage: `5/cb <people to hit> <message>``.  It will max out at the current people online.  `5/cb <person count>`` with no other parms will show the cost to send to that many people.");
		p.CreatePacket(peer);
	}*/
	else if (actual_command == "/sdb") {
		/*
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("`6>>`` `4oops:`` `6The super duper broadcast has been disabled for now, either because it was causing lag or just too dang annoying. Try again later.");
	p.CreatePacket(peer);*/
	
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`2Super Duper Broadcast|left|660|\nadd_textbox|Super Duper Broadcasts pop up a box with your message on every player's screen. The box even includes a button to visit your world! It costs 200 Growtokens to send.|left|\nadd_spacer|small|\nadd_smalltext|Enter up to 3 lines of text!|left|\nadd_text_input|sdb_1|||128|\nadd_text_input|sdb_2|||128|\nadd_text_input|sdb_3|||128||\nadd_spacer|small|\nend_dialog|sdbsend|Cancel|Send|");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/me") packet_(peer, "action|log\nmsg|`6>> Type `5/me looks around suspiciously`` or any other text, useful for role playing.", "");
	else if (actual_command == "/hidestatus" && pInfo(peer)->supp >= 2) {
	pInfo(peer)->hs = (pInfo(peer)->hs ? 0 : 1);
		console_msg(peer, "Super Supporter status " + a + (pInfo(peer)->hs == 1 ? "visible" : "hidden") + "!");
		form_state(pInfo(peer));
		update_clothes(peer, true);
	}
	else if (actual_command.substr(0, 6) == "/warp " && pInfo(peer)->supp + pInfo(peer)->mod + pInfo(peer)->vip + pInfo(peer)->dev >= 1) {
		string world = actual_command.substr(6, cmd.length() - 6).c_str();
		transform(world.begin(), world.end(), world.begin(), ::toupper);
		gamepacket_t p;
		bool passed = true;
		p.Insert("OnConsoleMessage");
		if (pInfo(peer)->dev == 0) {
			if (pInfo(peer)->warp_time + 15000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) pInfo(peer)->warp_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
			else {
				p.Insert("`4Cooldown active`` - You can use  `5/warp`` in `5" + to_string((pInfo(peer)->warp_time + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) + "`` seconds.");
				passed = false;
			}
		}
		if (passed) {
			pInfo(peer)->update = true;
			p.Insert("Magically warping to world `5" + world + "``...");
			p.CreatePacket(peer);
			join_world(peer, world);
		}
		else p.CreatePacket(peer);
	}
	else if (actual_command == "/who") {
		string who = "`wWho's in `$" + pInfo(peer)->world + "``:`` " + get_player_nick(peer);
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->tankIDName == pInfo(peer)->tankIDName || pInfo(currentPeer)->invis || pInfo(currentPeer)->world != pInfo(peer)->world) continue;
			who += ", " + get_player_nick(currentPeer);
			gamepacket_t p2;
			p2.Insert("OnTalkBubble");
			p2.Insert(pInfo(currentPeer)->netID);
			p2.Insert(get_player_nick(currentPeer));
			p2.Insert(1), p2.Insert(1);
			p2.CreatePacket(peer);
		}
		p.Insert(who);
		p.CreatePacket(peer);
	}
	else if (actual_command == "/1hit" && (pInfo(peer)->dev == 1 || pInfo(peer)->tankIDName == "Tron" || pInfo(peer)->hair == 9838)) {
		/*if (pInfo(peer)->hit1 == false) pInfo(peer)->hit1 = true;
		else pInfo(peer)->hit1 = false;*/
		pInfo(peer)->hit1 = pInfo(peer)->hit1 ? false : true;
		console_msg(peer, "1HIT " + a + (pInfo(peer)->hit1 == false ? "disabled" : "enabled") + a + ".");
	}
	else if (actual_command == "/trade" || actual_command.substr(0, 7) == "/trade ") {
	if (actual_command == "/trade") {
		console_msg(peer, "To trade with a specific person in this world, do `2/trade <``full or partial name`2>``");
	}
	else {
		pInfo(peer)->last_wrenched = cmd.substr(7, cmd.length() - 7).c_str();
		if (to_lower(pInfo(peer)->last_wrenched) == to_lower(pInfo(peer)->tankIDName)) {
			packet_(peer, "action|log\nmsg|You trade all your stuff to yourself in exchange for all your stuff.", "");
			return;
		}
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world or pInfo(currentPeer)->tankIDName == pInfo(peer)->tankIDName) continue;
			if ((to_lower(pInfo(currentPeer)->tankIDName).find(to_lower(pInfo(peer)->last_wrenched)) != std::string::npos && pInfo(peer)->last_wrenched.length() >= 3 && pInfo(peer)->last_wrenched.length() != pInfo(currentPeer)->tankIDName.length()) || to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->last_wrenched) || (not pInfo(currentPeer)->d_name.empty() && (to_lower(pInfo(currentPeer)->d_name).find(to_lower(pInfo(peer)->last_wrenched)) != std::string::npos && pInfo(peer)->last_wrenched.length() >= 3 && pInfo(peer)->last_wrenched.length() != pInfo(currentPeer)->d_name.length()) || to_lower(pInfo(currentPeer)->d_name) == to_lower(pInfo(peer)->last_wrenched))) {
				for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
					if (to_lower(pInfo(currentPeer)->friends[c_].name) == to_lower(pInfo(peer)->tankIDName)) {
						if (pInfo(currentPeer)->friends[c_].block_trade)
							return;
					}
				}
				if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->tankIDName)) {
					packet_(peer, "action|log\nmsg|You trade all your stuff to yourself in exchange for all your stuff.", "");
					return;
				}
				if (pInfo(currentPeer)->trading_with != -1 and pInfo(currentPeer)->trading_with != pInfo(peer)->netID) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("That person is busy.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					pInfo(peer)->block_trade = false, pInfo(peer)->trading_with = -1;
					{
						gamepacket_t p;
						p.Insert("OnForceTradeEnd");
						p.CreatePacket(peer);
					}
					return;
				}
				pInfo(peer)->trading_with = pInfo(currentPeer)->netID;
				pInfo(peer)->trade_accept = 0;
				pInfo(currentPeer)->trade_accept = 0;
				gamepacket_t p;
				p.Insert("OnStartTrade");
				p.Insert(fixchar2(get_player_nick(currentPeer)));
				p.Insert(pInfo(currentPeer)->netID);
				p.CreatePacket(peer);
				if (pInfo(currentPeer)->trading_with != -1) {
					// as neisivaizduoju kdl real gt taip daro bet noriu kad butu kaip rgt.
					gamepacket_t p;
					p.Insert("OnTradeStatus");
					p.Insert(pInfo(peer)->netID);
					p.Insert("");
					p.Insert("`o" + get_player_nick(peer) + "'s offer.``");
					p.Insert("locked|0\nreset_locks|1\naccepted|0");
					p.CreatePacket(peer);
					{
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(peer)->netID);
						p.Insert("");
						p.Insert("`o" + get_player_nick(peer) + "'s offer.``");
						p.Insert("locked|0\naccepted|1");
						p.CreatePacket(peer);
					}
					{
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(peer)->netID);
						p.Insert("");
						p.Insert("`o" + get_player_nick(peer) + "'s offer.``");
						p.Insert("locked|0\nreset_locks|1\naccepted|0");
						p.CreatePacket(peer);
					}
					{
						gamepacket_t p;
						p.Insert("OnTradeStatus");
						p.Insert(pInfo(currentPeer)->netID);
						p.Insert("");
						p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
						p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
							p.Insert("locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
							p.Insert("locked|0\naccepted|1");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(currentPeer)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(currentPeer) + "'s offer.``");
							p.Insert(make_trade_offer(pInfo(currentPeer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
						{
							gamepacket_t p;
							p.Insert("OnTradeStatus");
							p.Insert(pInfo(peer)->netID);
							p.Insert("");
							p.Insert("`o" + get_player_nick(peer) + "'s offer.``");
							p.Insert(make_trade_offer(pInfo(peer), true) + "locked|0\nreset_locks|1\naccepted|0");
							p.CreatePacket(currentPeer);
						}
					}
					break;
				}
				packet_(currentPeer, "action|play_sfx\nfile|audio/cash_register.wav\ndelayMS|0");
				{
					console_msg(currentPeer, "`#TRADE ALERT:`` `w" + get_player_nick(peer) + "`` wants to trade with you!  To start, use the `wWrench`` on that person's wrench icon, or type `w/trade " + get_player_nick(peer));
				}
				break;
			}
		}
	}
	}
	else if (actual_command.substr(0, 12) == "/changenick " && pInfo(peer)->give_role) {
	vector<string> a_ = explode(" ", cmd);
	if (a_.size() != 3) return;
	string name_ = a_[1].c_str(), to_name = a_[2].c_str();
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (to_lower(name_) == to_lower(pInfo(currentPeer)->tankIDName)) {
			gamepacket_t p;
			p.Insert("OnConsoleMessage");
			if (to_name.empty() or to_lower(to_name) == to_lower(pInfo(currentPeer)->tankIDName)) {
				pInfo(currentPeer)->d_name = "";
				p.Insert("Your name was changed back to " + pInfo(currentPeer)->tankIDName);
			}
			else {
				p.Insert("Your name was changed to " + to_name);
				pInfo(currentPeer)->d_name = to_name;
			}
			p.CreatePacket(currentPeer);
			nick_update_2(currentPeer, NULL);

		}
	}
	}
	else if (actual_command == "/setbuy" && pInfo(peer)->give_editor) {
		Server_Security.buy_enabled = (Server_Security.buy_enabled ? false : true);
		console_msg(peer, " >> /buy has been "+ a + (Server_Security.buy_enabled ? "enabled" : "disabled"));
	}
	else if (actual_command.substr(0, 13) == "/changeprice " && pInfo(peer)->give_editor) {
		vector<string> a_ = explode(" ", cmd);
		if (a_.size() != 3) return;
		if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
		int i_ = atoi(a_[1].c_str()), c_ = atoi(a_[2].c_str());
		if (i_ <= 0 || i_ >= items.size() || i_ == 242 || i_ == 1796 || i_ == 7188 || i_ == 243 || i_ == 1797 || i_ == 7189 || i_ == 9852 || i_ == 9853 || i_ == 9854 || i_ == 9855) return;
		int previous_price = items[i_].buy_price;
		items[i_].buy_price = c_;
		console_msg(peer, "Edited item <`2" + items[i_].ori_name + "``> price to `$" + setGems(items[i_].buy_price * 3) + "`` World Locks. (previous price `$" + setGems(previous_price * 3) + "``!)");
		load_item_price(true);
	}
	else if ((actual_command.substr(0, 6) == "/givd " || actual_command.substr(0, 6) == "/giva " || actual_command.substr(0, 6) == "/givr ") && (pInfo(peer)->give_role)) {
	vector <string> ips_;
		bool vip = false, random = false;
		if (actual_command.substr(0, 6) == "/giva ") vip = true;
		if (actual_command.substr(0, 6) == "/givr ") random = true;
		vector<string> a_ = explode(" ", cmd);
		if (a_.size() != 3) return;
		if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
		int i_ = atoi(a_[1].c_str());
		if (i_ <= 0 || i_ >= items.size() || i_ == 7188 || i_ == 243 || i_ == 1797 || i_ == 7189 || i_ == 9852 || i_ == 9853 || i_ == 9854 || i_ == 9855) return;
		if (items[i_].ori_name.find("null") != string::npos) {
			console_msg(peer, "the item contains null' stuff");
			return;
		}
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or find(ips_.begin(), ips_.end(), pInfo(currentPeer)->ip) != ips_.end()) continue;
			if (vip) {
				if (pInfo(currentPeer)->vip || pInfo(currentPeer)->mod || pInfo(currentPeer)->gp || pInfo(currentPeer)->all_in || pInfo(currentPeer)->dev || pInfo(currentPeer)->superdev || pInfo(currentPeer)->level >= 40) {

				}
				else continue;
			}
			if (random) {
				if (rand() % 10 < 3) {
					int c_ = atoi(a_[2].c_str());
					ips_.push_back(pInfo(currentPeer)->ip);
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					if (modify_inventory(currentPeer, i_, c_) == -1) p.Insert("Failed to add inventory item");
					else p.Insert("`2[`6RANDOM GIVEAWAY```2]`` Received from giveaway:`` `w" + a_[2] + " " + items[i_].name + "``." + (items[i_].rarity > 363 ? "" : " Rarity: `w" + to_string(items[i_].rarity) + "``") + "");
					p.CreatePacket(currentPeer);
				}
			}
			else {
				int c_ = atoi(a_[2].c_str());
				ips_.push_back(pInfo(currentPeer)->ip);
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (modify_inventory(currentPeer, i_, c_) == -1) p.Insert("Failed to add inventory item");
				else p.Insert("`2" + a + (vip ? "[`9SPECIAL ONLY```2]`` " : "") + "Received from giveaway:`` `w" + a_[2] + " " + items[i_].name + "``." + (items[i_].rarity > 363 ? "" : " Rarity: `w" + to_string(items[i_].rarity) + "``") + "");
				p.CreatePacket(currentPeer);
			}
		}
		return;
	}
	else if (actual_command.substr(0, 7) == "/punch " && pInfo(peer)->mod) {
	int punch = atoi(cmd.substr(7, cmd.length() - 7).c_str());
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	if (punch >= 0 && punch < 300) {
		pInfo(peer)->punched = punch;
		p.Insert("`2Set punch effect to ID``: " + to_string(pInfo(peer)->punched) + " (set to `20`` to reset).");
	}
	else p.Insert("`2This punch effect does not exist only (0-300).");
	p.CreatePacket(peer);
	update_clothes_value(peer);
	update_clothes(peer, true);
		}
		/*
	else if (actual_command.substr(0, 3) == "/p " && (pInfo(peer)->dev == 1 || pInfo(peer)->hair == 9838)) {
		gamepacket_t p;
		p.Insert("OnParticleEffectV2"), p.Insert(atoi(cmd.substr(3, cmd.length() - 3).c_str())), p.Insert((float)pInfo(peer)->x  + 16, (float)pInfo(peer)->y  + 16);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) p.CreatePacket(currentPeer);
		}
	}
	else if (actual_command.substr(0, 4) == "/p3 ") {
	vector<string> a_ = explode(" ", cmd);
	int first_ = atoi(a_[1].c_str()), second_ = atoi(a_[2].c_str());
	gamepacket_t p5(0, pInfo(peer)->netID);
	p5.Insert("OnTransmutateLinkDataModified"), p5.Insert(to_string(first_) + ":" + to_string(second_));
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		p5.CreatePacket(currentPeer);
	}
	}
	else if (actual_command.substr(0, 4) == "/p2 " && pInfo(peer)->dev) {
	gamepacket_t p;
	p.Insert("OnParticleEffectV2");
	p.Insert(atoi(cmd.substr(4, cmd.length() - 4).c_str()));
	p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == pInfo(peer)->world) p.CreatePacket(currentPeer);
	}
	}
	//balloon ignore
	else if (actual_command.substr(0, 4) == "/p3 ") {
	vector<string> a_ = explode(" ", cmd);
	cout << info_about_playmods[atoi(a_[1].c_str())][atoi(a_[2].c_str())] << endl;
	/*
	gamepacket_t p5(0, pInfo(peer)->netID);
	p5.Insert("OnFactionDataChanged"), p5.Insert(pInfo(peer)->balloon_faction), p5.Insert(atoi(a_[1].c_str())), p5.Insert(atoi(a_[2].c_str())), p5.Insert("bountyLevel|" + a + a_[3].c_str() + "\nbountyScore|" + a_[4].c_str() + "\n"), p5.Insert(1);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		p5.CreatePacket(currentPeer);
	}*/
//	}
	else if (actual_command.substr(0, 5) == "/log " && pInfo(peer)->give_role) {
		Server_Security.log_player = cmd.substr(5, cmd.length() - 5).c_str();
		console_msg(peer, "`2Logging " + Server_Security.log_player);
	}
	else if (actual_command == "/logs" && pInfo(peer)->logger) {
	//\nadd_button|additem|Add Items to the machine|noflags|0|0|
	pInfo(peer)->search_page = 20;
	string buttons = "";
	for (int i = 0; i < Server_Security.logs.size(); i++) buttons += "\nadd_button|" + Server_Security.logs[i].first + "|" + Server_Security.logs[i].first + "|noflags|0|0|";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wLogs``|left|3732|\nadd_textbox|Growtopia Private Server logs system.|left|" + buttons + "\nadd_button|Empty Logs|`5Empty Logs``|noflags|0|0|\nend_dialog|logs|Cancel||");
	p.CreatePacket(peer);
	}
	else if (actual_command == "/cheats") cheats(peer);
	else if (actual_command.substr(0, 6) == "/gems " && pInfo(peer)->give_role) {
	x_gems = atoi(cmd.substr(6, cmd.length() - 6).c_str());
	if (x_gems < 1) x_gems = 1;
	if (x_gems > 50) x_gems = 50;
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	if (x_gems > 1) p.Insert("CP:_PL:0_OID:_CT:[SB]_ `9** " + get_player_nick(peer) + " has started gems event of " + to_string(x_gems) + "x!``");
	else p.Insert("CP:_PL:0_OID:_CT:[SB]_ `9** gems event ended``");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		p.CreatePacket(currentPeer);
	}
	}
	else if (actual_command == "/skin2" && pInfo(peer)->superdev) {
		pInfo(peer)->bb_lvl = 50;
		pInfo(peer)->t_lvl = 50;
		pInfo(peer)->ff_lvl = 50;
		pInfo(peer)->s_lvl = 50;
	}
	else if (actual_command.substr(0, 6) == "/flag " && pInfo(peer)->dev) {
		string flag =cmd.substr(6, cmd.length() - 6).c_str();
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (flag == "rt" || flag == "ha") {
			p.Insert("Your flag was set. (reenter world)");
			pInfo(peer)->country = flag;
		}
		else {
			p.Insert("Invalid flag, try rt or ha!");
		}
		p.CreatePacket(peer);
	}
	/*
	* 
	* 	else if (actual_command.substr(0, 3) == "/x ") {
	punched = atoi(cmd.substr(3, cmd.length() - 3).c_str());
	update_clothes_value(peer);
	update_clothes(peer);
	gamepacket_t p;
	p.Insert("OnSetCurrentWeather");
	p.Insert(punched);
	p.CreatePacket(peer);
	}
	}
	* 	else if (actual_command.substr(0, 5) == "/npc ") {
	vector<string> a_ = explode(" ", cmd);
	string name_ = pInfo(peer)->world;
	vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (paa != worlds.end()) {
		World* world_ = &worlds[paa - worlds.begin()];
		world_->npc_uid++;
		add_packet(world_->name, packNPC(34, pInfo(peer)->x + 64, pInfo(peer)->y + 64, pInfo(peer)->x + 128, pInfo(peer)->y + 128, 100, 3, 8, world_->npc_uid, 180));
	}
	}
	else if (actual_command.substr(0, 3) == "/d ") {
	pInfo(peer)->minokawa_wings = atoi(cmd.substr(3, cmd.length() - 3).c_str());
	update_clothes(peer);
	}
	}
	else if (actual_command.substr(0, 3) == "/x ") {
	punched = atoi(cmd.substr(3, cmd.length() - 3).c_str());
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					p.Insert(world_->weather == 0 ? 80 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer);
						}
					}
	}
	else if (actual_command.substr(0, 3) == "/t ") {
	punched = atoi(cmd.substr(3, cmd.length() - 3).c_str());
	gamepacket_t p(0, pInfo(peer)->netID);
	p.Insert("OnFlagMay2019"), p.Insert(punched);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED) continue;
		if (pInfo(peer)->world == pInfo(currentPeer)->world) p.CreatePacket(currentPeer);
	}
	}
	else if (actual_command.substr(0, 3) == "/p " && pInfo(peer)->dev) {
		{
			PlayerMoving data_{};
			data_.packetType = 17;
			data_.netID = atoi(cmd.substr(3, cmd.length() - 3).c_str());
			data_.YSpeed = atoi(cmd.substr(3, cmd.length() - 3).c_str());
			data_.x = pInfo(peer)->x + 16;
			data_.y = pInfo(peer)->y + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
		}
	}
		else if (actual_command.substr(0, 3) == "/p " && pInfo(peer)->dev) {
		{
			PlayerMoving data_{};
			data_.packetType = 17;
			data_.netID = atoi(cmd.substr(3, cmd.length() - 3).c_str());
			data_.YSpeed = atoi(cmd.substr(3, cmd.length() - 3).c_str());
			data_.x = pInfo(peer)->x + 16;
			data_.y = pInfo(peer)->y + 16;
			BYTE* raw = packPlayerMoving(&data_);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
		}
	}
	*/
	else if (actual_command.substr(0, 5) == "/nsb " && (pInfo(peer)->hair == 9838)) {
	if (has_playmod2(pInfo(peer), 142)) {
		int time_ = 0;
		for (PlayMods peer_playmod : pInfo(peer)->playmods) {
			if (peer_playmod.id == 142) {
				time_ = peer_playmod.time - time(nullptr);
				break;
			}
		}
		packet_(peer, "action|log\nmsg|>> (" + to_playmod_time(time_) + " before you can broadcast again)", "");
	}
	else {
		packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		add_playmod(peer, 142);
		string text = cmd.substr(5, cmd.length() - 5).c_str();
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[SB]_ `9** [`6Legend SB`9] (`0" + (get_player_nick(peer)) + "`9) in [```w" + pInfo(peer)->world + "```9] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`5") + "" + text + "``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
	}
	}
	else if (actual_command.substr(0, 5) == "/osb " && (pInfo(peer)->give_role)) {
	if (has_playmod2(pInfo(peer), 122)) {
		int time_ = 0;
		for (PlayMods peer_playmod : pInfo(peer)->playmods) {
			if (peer_playmod.id == 122) {
				time_ = peer_playmod.time - time(nullptr);
				break;
			}
		}
		packet_(peer, "action|log\nmsg|>> (" + to_playmod_time(time_) + " before you can broadcast again)", "");
	}
	else {
		packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		add_playmod(peer, 122);
		string text = cmd.substr(5, cmd.length() - 5).c_str();
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[SB]_ `4[SECRET-SB]`p** from (`0" + (get_player_nick(peer)) + "`p) in [```4SECRET!```p] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`5") + "" + text + "``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
	}
	}
	/*
	else if (actual_command.substr(0, 5) == "/vsb " && pInfo(peer)->vip) {
	if (has_playmod(pInfo(peer), "VIP SB!")) {
		int time_ = 0;
		for (PlayMods peer_playmod : pInfo(peer)->playmods) {
			if (peer_playmod.id == 121) {
				time_ = peer_playmod.time - time(nullptr);
				break;
			}
		}
		packet_(peer, "action|log\nmsg|>> (" + to_playmod_time(time_) + "before you can broadcast again)", "");
	}
	else {
		PlayMods new_playmod{};
		new_playmod.id = 121, new_playmod.time = time(nullptr) + 60;
		pInfo(peer)->playmods.push_back(new_playmod);
		packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
		{
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("Broadcasting to ALL! (`$VIP SB!`` mod added)"), p.CreatePacket(peer);
		}
		string text = cmd.substr(5, cmd.length() - 5).c_str();
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[SB]_ `e[VIP-SB]`p** from (`0" + (get_player_nick(peer)) + "`````p) in [```4HIDDEN!```p] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`1") + "" + text + "``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio) continue;
			p.CreatePacket(currentPeer);
		}
	}
	}*/
	else if (actual_command.substr(0, 4) == "/gm " && (pInfo(peer)->give_role)) {
		string text = cmd.substr(4, cmd.length() - 4).c_str();
		gamepacket_t p;
		p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` `$Global System Message:`` `4" + text + "``");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			p.CreatePacket(currentPeer);
		}
	}
	else if (actual_command.substr(0, 2) == "/ " && pInfo(peer)->mod + pInfo(peer)->dev >= 1) {
		string text = cmd.substr(2, cmd.length() - 2).c_str();
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		p.Insert("CT:[FC]_>> `r>> [MOD-CHAT] from (``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```r) in [```$" + pInfo(peer)->world + "```r] > ```$`3" + text + "`c");
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->mod == 0 or pInfo(currentPeer)->radio or pInfo(currentPeer)->temp_radio or pInfo(currentPeer)->radio2) continue;
			p.CreatePacket(currentPeer);
		}
	}
	else if (actual_command.substr(0, 3) == "/v " && (pInfo(peer)->vip)) {
	string text = cmd.substr(3, cmd.length() - 3).c_str();
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `p>> [VIP-CHAT] from (``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```p) in [```$" + pInfo(peer)->world + "```p] > ```$`3" + text + "`p");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->vip == 0 or pInfo(currentPeer)->radio or pInfo(currentPeer)->temp_radio) continue;
		p.CreatePacket(currentPeer);
	}
	}
	/*
	else if (actual_command.substr(0, 3) == "/c " && pInfo(peer)->cheater_) {
	string text = cmd.substr(3, cmd.length() - 3).c_str();
	gamepacket_t p;
	p.Insert("OnConsoleMessage");
	p.Insert("CT:[FC]_>> `p>> [Cheater-CHAT] from (``" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "```p) in [```$" + pInfo(peer)->world + "```p] > ```$`3" + text + "`p");
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->cheater_ == 0 or pInfo(currentPeer)->radio or pInfo(currentPeer)->temp_radio) continue;
		p.CreatePacket(currentPeer);
	}
	}*/
	else if (actual_command.substr(0, 5) == "/csn " && (pInfo(peer)->csn_role)) {
		string csn = cmd.substr(5, cmd.length() - 5).c_str();
		int csns = atoi(csn.c_str());
		if (csns > 36 || csns < 0) pInfo(peer)->csn = -1;
		pInfo(peer)->csn = atoi(csn.c_str());
	}
	else if (actual_command == "/report") {
		gamepacket_t p(500);
		p.Insert("OnDialogRequest");
		p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wReport this world as a scam``|left|3732|\nadd_textbox|If this world is being used to scam or bully players, you can press `3Report`` to flag it for moderators to check.|left|\nadd_smalltext|- This feature is for reporting the `2world``, not the players. If the world is fine, but people are being inappropriate, send a /msg to a mod instead.|left|\nadd_smalltext|- We record who uses this feature. You will be banned if you file false reports.|left|\nadd_smalltext|- Reporting multiple times doesn't do anything - just report once, and the world will be on our list to check.|left|\nadd_smalltext|- There is no way to un-report, so don't report unless you are sure the world is bad!|left|\nadd_smalltext|- Provide a short 32 character description of why you are reporting the world below.|left|\nadd_text_input|report_reason|Reason:||32|\nadd_textbox|`1If you are sure you want to report this world as a scam, press Report below!``|left|\nend_dialog|worldreport|Cancel|Report|");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/rr") {
		gamepacket_t p, p2;
		p2.Insert("OnTalkBubble");
		p2.Insert(pInfo(peer)->netID);
		p.Insert("OnConsoleMessage");
		pInfo(peer)->rr_used++;
		if (pInfo(peer)->rr_used == pInfo(peer)->rr_) {
			pInfo(peer)->rr_ = rand() % 6;
			if (pInfo(peer)->rr_ == 0) pInfo(peer)->rr_++;
			pInfo(peer)->rr_used = 0;
			if (rand() % 100 < 3) {
				p.Insert("`0RU```eSS```4IAN`` `bRoulette`` (" + get_player_nick(peer) + "): `oPULLED THE TRIGGER and `2survived!``");
				p2.Insert("`2I survive.`` `4with an injury..``");
			}
			else {
				p.Insert("`0RU```eSS```4IAN`` `bRoulette`` (" + get_player_nick(peer) + "): `oPULLED THE TRIGGER and `4died!``");
				p2.Insert("`4DEAAAAAD.``");
				int spawn_x = pInfo(peer)->x, spawn_y = pInfo(peer)->y;
				SendRespawn(peer, true, 0, 1);
				OnSetPos(peer, spawn_x, spawn_y);
			}
		}
		else {
			p.Insert("`0RU```eSS```4IAN`` `bRoulette`` (" + get_player_nick(peer) + "): `oPULLED THE TRIGGER and `2survived!`` `$(" + to_string(pInfo(peer)->rr_used) + "/6 shots)``");
			p2.Insert("`2I survive.``");
		}
		p2.Insert(0), p2.Insert(0);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
		}
	}
	else if (actual_command == "/time") {
		const char* months[12] = { "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" };
		struct tm newtime;
		time_t now = time(0);
		localtime_s(&newtime, &now);
		console_msg(peer, "`2Growtopia Time (EDT/UTC-5): " + a + months[newtime.tm_mon] + " " + to_string(newtime.tm_mday) + "th, " + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : "" + to_string(newtime.tm_hour) + "") + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min) + "") + ".");
	}
	else if (actual_command.substr(0, 6) == "/give " && (pInfo(peer)->give_role)) {
		vector<string> a_ = explode(" ", cmd);
		if (a_.size() != 3) return;
		if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
		int i_ = atoi(a_[1].c_str()), c_ = atoi(a_[2].c_str());
		if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;
		if (items[i_].id == 274 || items[i_].id == 276 || items[i_].id == 8470 || items[i_].id == 278 || items[i_].id == 732 || items[i_].id == 7188) return;
		gamepacket_t p;
		p.Insert("OnConsoleMessage");
		if (modify_inventory(peer, i_, c_) == -1) p.Insert("Failed to add inventory item");
		else p.Insert("Collected `w" + a_[2] + " " + items[i_].name + "``." + (items[i_].rarity > 363 ? "" : " Rarity: `w" + to_string(items[i_].rarity) + "``") + "");
		p.CreatePacket(peer);
	}
	else if (actual_command == "/dance" || actual_command == "/sad" || actual_command == "/wave" || actual_command == "/lol" || actual_command == "/love" || actual_command == "/sleep" || actual_command == "/wink" || actual_command == "/troll" || actual_command == "/cheer" || actual_command == "/fa" || actual_command == "/furious" || actual_command == "/dab" || actual_command == "/dance2" || actual_command == "/cheer" || actual_command == "/laugh" || actual_command == "/cry" || actual_command == "/mad" || actual_command == "/shower" || actual_command == "/rolleyes" || actual_command == "/omg" || actual_command == "/yes" || actual_command == "/idk" || actual_command == "/fold" || actual_command == "/no" || actual_command == "/sassy" || actual_command == "/fp" || actual_command == "/troll" || actual_command == "/facepalm" || actual_command == "/foldarms" || actual_command == "/stubborn" || actual_command == "/grumpy" || actual_command == "/shy" || actual_command == "/smh") {
		if (actual_command == "/cry") {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert(":'(");
			p.Insert(0), p.Insert(0);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
				p.CreatePacket(currentPeer);
			}
		}
		else {
			gamepacket_t p(0, pInfo(peer)->netID);
			p.Insert("OnAction");
			if (actual_command == "/fa" || actual_command == "/foldarms") actual_command = "/fold";
			p.Insert(actual_command);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == pInfo(peer)->world) {
					bool muted_ = false;
					for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
						if (to_lower(pInfo(currentPeer)->friends[c_].name) == to_lower(pInfo(peer)->tankIDName)) {
							if (pInfo(currentPeer)->friends[c_].mute) {
								muted_ = true;
								break;
							}
						}
					}
					if (not muted_)
						p.CreatePacket(currentPeer);
				}
			}
		}
	}
	else {
		string name_ = pInfo(peer)->world;
		vector<World>::iterator paa = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (paa != worlds.end()) {
			World* world_ = &worlds[paa - worlds.begin()];
			world_->fresh_world = true;
			string owner_name = to_lower(world_->owner_name), player_name = to_lower(pInfo(peer)->tankIDName);
			if (actual_command.substr(0, 11) == "/copyworld " && (pInfo(peer)->give_role)) {
				string world_name = cmd.substr(11, cmd.length() - 11).c_str();
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						exit_(currentPeer, true);
					}
				}
				World world_s;
				world_s = get_world(world_name);
				world_s.name = name_;
				worlds.push_back(world_s);
			}
			else if (actual_command.substr(0, 10) == "/removeid " && (pInfo(peer)->superdev || pInfo(peer)->tankIDName == "Tron")) {
				int blockid = atoi(cmd.substr(10, cmd.length() - 10).c_str());
				string world_name = pInfo(peer)->world;
				if (blockid <= 0 || blockid > items.size()) {
					console_msg(peer, " >> Can't remove (invalid id).");
				}
				else {
					vector<BYTE*>blocks;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == blockid or world_->blocks[i_].bg == blockid) {
							world_->blocks[i_].pr = 0;
							world_->blocks[i_].wl = 0;
							world_->blocks[i_].id = 0;
							world_->blocks[i_].c_ = 0;
							world_->blocks[i_].hp = -1;
							world_->blocks[i_].lock_origin = -1;
							world_->blocks[i_].planted = 0;
							world_->blocks[i_].flags = 0x00000000;
							world_->blocks[i_].shelf_1 = 0;
							world_->blocks[i_].shelf_2 = 0;
							world_->blocks[i_].shelf_3 = 0;
							world_->blocks[i_].shelf_4 = 0;
						}
						if (world_->blocks[i_].fg == blockid) {
							world_->blocks[i_].fg = 0;
							blocks.push_back(packBlockType(3, 0, i_ % 100, i_ / 100));
						}
						else if (world_->blocks[i_].bg == blockid) {
							world_->blocks[i_].bg = 0;
							blocks.push_back(packBlockType(3, 0, i_ % 100, i_ / 100));
						}
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_name) continue;
						for (auto& b : blocks) send_raw(currentPeer, 4, b, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					blocks.clear();
				}
			}
			else if (actual_command == "/boostworld" && pInfo(peer)->superdev) {
				string name = pInfo(peer)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name](const World& a) { return a.name == name; });
				if (p != worlds.end()) {
					World* world = &worlds[p - worlds.begin()];
					if (owner_name == player_name || pInfo(peer)->superdev) {
						for (int i_ = 0; i_ < world->blocks.size(); i_++) world->blocks[i_].planted = _int64(2.592e+6);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name) {
								int x = pInfo(currentPeer)->x, y = pInfo(currentPeer)->y;
								exit_(currentPeer, true);
								join_world(currentPeer, name);
							}
						}
					}
					else {
						console_msg(peer, "`wYou must own the world!``");
					}
				}
			}
			/*
			else if (actual_command == "/fixworld" && pInfo(peer)->mod) {
				{
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert(" >> Fixed the world."), p.CreatePacket(peer);
				}
				string extra = "";
				add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "`8fixed world " + extra + "``: `#" + pInfo(peer)->world, "");
				send_fix_world(world_);
			}*/
			else if (actual_command == "/wl") {
				if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) or pInfo(peer)->superdev) {
					vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg != 202 && a.fg != 204 && a.fg != 206 && a.fg != 4994 && a.fg != 10000; });
					if (p != world_->blocks.end()) {
						int x_ = int(p - world_->blocks.begin()) % 100, y_ = int(p - world_->blocks.begin()) / 100;
						send_edit_lock(peer, world_, world_->blocks[x_ + (y_ * 100)].fg, x_, y_);
					}
				}
			}
			else if (actual_command == "/nuke" && pInfo(peer)->mod + pInfo(peer)->dev >= 1) {
				if (not world_->nuked_by.empty()) {
					world_->nuked_by = "";
					console_msg(peer, "This world is once again available to everyone!");
					add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "UNNUKED WORLD: `#" + pInfo(peer)->world, "");
				}
				else {
					struct tm newtime;
					time_t now = time(0);
					localtime_s(&newtime, &now);
					world_->nuked_by = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``, " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "/" + to_string(1900 + newtime.tm_year) + " " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + "";
					string t_ = "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0";
					BYTE* const d_ = new BYTE[5 + t_.length()];
					*(__int8*)(d_) = 3;
					memcpy(d_ + 4, t_.c_str(), t_.length());
					*(__int8*)(d_ + 4 + t_.length()) = 0;
					ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("`o>> `4" + world_->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio or pInfo(currentPeer)->temp_radio) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world and not pInfo(currentPeer)->mod and not pInfo(currentPeer)->dev) exit_(currentPeer);
						enet_peer_send(currentPeer, 0, p_m);
						p.CreatePacket(currentPeer);
					}
					delete[]d_;
					add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "NUKED WORLD: `#" + pInfo(peer)->world, "");
				}
			}
			else if (actual_command == "/cursenuke" && pInfo(peer)->dev) {
				if (not world_->nuked_by.empty()) {
					world_->nuked_by = "";
					console_msg(peer, "This world is once again available to everyone!");
					add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "UNNUKED WORLD: `#" + pInfo(peer)->world, "");
				}
				else {
					struct tm newtime;
					time_t now = time(0);
					localtime_s(&newtime, &now);
					world_->nuked_by = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``, " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "/" + to_string(1900 + newtime.tm_year) + " " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min)) + ":" + to_string(newtime.tm_sec) + "";
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("`o>> `4" + world_->name + " `4was nuked from orbit`o. It's the only way to be sure. Play nice, everybody!");
					string t_ = "action|play_sfx\nfile|audio/bigboom.wav\ndelayMS|0";
					BYTE* const d_ = new BYTE[5 + t_.length()];
					*(__int8*)(d_) = 3;
					memcpy(d_ + 4, t_.c_str(), t_.length());
					*(__int8*)(d_ + 4 + t_.length()) = 0;
					ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world and not pInfo(currentPeer)->mod and not pInfo(currentPeer)->dev) {
							add_ban_or_mute(currentPeer, 3600, "illegal activity", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", 139);
							exit_(currentPeer);
						}
						enet_peer_send(currentPeer, 0, p_m);
						p.CreatePacket(currentPeer);
					}
					delete[]d_;
					add_modlogs(peer, pInfo(peer)->name_color + pInfo(peer)->tankIDName, "NUKED WORLD: `#" + pInfo(peer)->world, "");
				}
			}
			else if (actual_command.substr(0, 4) == "/me ") {
				if (pInfo(peer)->world .empty()) return;
				if (has_playmod2(pInfo(peer), 11)) {
					console_msg(peer, "`6>> That's sort of hard to do while duct-taped.``");
					return;
				}
				string text = cmd.substr(4, cmd.length() - 4).c_str();
				if (text.length() <= 0 || text.empty()) return;
				{
					if (world_->world_settings & Gtps3::SETTINGS_8 and pInfo(peer)->superdev != 1 and owner_name != player_name and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end()) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`1(Peasants must not speak)");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						return;
					}
				}
				gamepacket_t p, p2;
				p.Insert("OnConsoleMessage");
				p.Insert("CP:0_PL:0_OID:__CT:[W]_ `6<``" + get_player_nick(peer) + "`` `#" + text + "```6>``");
				p2.Insert("OnTalkBubble");
				p2.Insert(pInfo(peer)->netID);
				p2.Insert("player_chat= `6<```0" + get_player_nick(peer) + "`` `#" + text + "```6>``");
				p2.Insert(0), p2.Insert(0);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(peer)->world) {
						p.CreatePacket(currentPeer);
						p2.CreatePacket(currentPeer);
					}
				}
			}
			else if (((actual_command.substr(0, 11) == "/whitelist " or actual_command == "/whitelist") && pInfo(peer)->whitelist_role)) {
				string username = "";
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				if (actual_command != "/whitelist") username = to_lower(cmd.substr(11, cmd.length() - 11).c_str());
				if (username.empty() || username.length() < 3) {
					world_->whitelist.clear();
					p.Insert("Whitelist cleared");
				}
				else {
					if (find(world_->whitelist.begin(), world_->whitelist.end(), username) != world_->whitelist.end()) {
						world_->whitelist.erase(remove(world_->whitelist.begin(), world_->whitelist.end(), username), world_->whitelist.end());
						p.Insert("Whitelist removed for  " + username);
					}
					else {
						world_->whitelist.push_back(username);
						p.Insert("Whitelisted " + username);
					}
				}
				p.CreatePacket(peer);
			}
			else if ((actual_command == "/whitelists" && pInfo(peer)->whitelist_role)) {
				console_msg(peer, "`oWhitelist: " + join(world_->whitelist, "\n") + "");
			}
			else if (actual_command.substr(0, 6) == "/kick " or actual_command.substr(0, 5) == "/ban " or actual_command.substr(0, 6) == "/pull " || actual_command == "/pull" || actual_command == "/kick" || actual_command == "/ban") {
				if (actual_command == "/pull" || actual_command == "/kick" || actual_command == "/ban") {
					console_msg(peer, "You'll need to enter at least the first three characters of the person's name.");
					return;
				}
				string username = "", cmdas = "";
				if (actual_command.substr(0, 6) == "/kick ") {
					username = cmd.substr(6, cmd.length() - 6).c_str();
					cmdas = "kick";
				}
				else if (actual_command.substr(0, 6) == "/pull ") {
					username = cmd.substr(6, cmd.length() - 6).c_str();
					cmdas = "pull";
				}
				else {
					username = cmd.substr(5, cmd.length() - 5).c_str();
					cmdas = "ban";
				}
				if (to_lower(pInfo(peer)->tankIDName) == to_lower(username)) {
					console_msg(peer, "`oYou give yourself a solid boot to the backside. But what did that really accomplish?");
					return;
				}
				string by_name = "";
				if ((pInfo(peer)->name_color == "`0" || pInfo(peer)->name_color == "`2" || pInfo(peer)->name_color == "`^") && not pInfo(peer)->d_name.empty()) by_name = "`o" + pInfo(peer)->tankIDName + "``";
				else by_name = get_player_nick(peer);
				bool playerFound = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(peer)->world == pInfo(currentPeer)->world) {
						if ((to_lower(pInfo(currentPeer)->tankIDName).find(to_lower(username)) != std::string::npos && username .length() >= 3 && username.length() != pInfo(currentPeer)->tankIDName.length()) || to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username) || (not pInfo(currentPeer)->d_name.empty() && (to_lower(pInfo(currentPeer)->d_name).find(to_lower(username)) != std::string::npos && username.length() >= 3 && username.length() != pInfo(currentPeer)->d_name.length()) || to_lower(pInfo(currentPeer)->d_name) == to_lower(username))) {
							int x_ = pInfo(peer)->x / 32, y_ = pInfo(peer)->y / 32, x__ = pInfo(currentPeer)->x / 32, y__ = pInfo(currentPeer)->y / 32;
							if ((cmdas == "ban" && (world_->owner_name.empty() || find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(currentPeer)->tankIDName)) != world_->admins.end() || to_lower(pInfo(currentPeer)->tankIDName) == owner_name || to_lower(pInfo(currentPeer)->tankIDName) == to_lower(pInfo(peer)->tankIDName) || pInfo(currentPeer)->superdev || pInfo(currentPeer)->dev)) or x_ < 0 or x_ >= world_->max_x or y_ < 0 or y_ >= world_->max_y or x__ < 0 or x__ >= world_->max_x or y__ < 0 or y__ >= world_->max_y) {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("Can't `4" + cmdas + "``, is not in a locked area you control!");
								p.CreatePacket(peer);
								return;
							}
							if (pInfo(peer)->superdev || pInfo(peer)->dev or (block_access(peer, world_, &world_->blocks[x_ + (y_ * 100)], false, false, false, true) && block_access(peer, world_, &world_->blocks[x__ + (y__ * 100)], false, false, false, true))) {

							}
							else {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("Can't `4" + cmdas + "``, is not in a locked area you control!");
								p.CreatePacket(peer);
								return;
							}
							playerFound = true;
							if (not pInfo(currentPeer)->d_name.empty()) {
								username = pInfo(currentPeer)->d_name;
							}
							else {
								if (not pInfo(currentPeer)->d_name.empty() && (pInfo(currentPeer)->name_color == "`0" || pInfo(currentPeer)->name_color == "`2" || pInfo(currentPeer)->name_color == "`^")) username = "`o" + pInfo(currentPeer)->tankIDName + "``";
								else username = get_player_nick(currentPeer);
							}

							if (cmdas == "kick") SendRespawn(currentPeer, true, 0, 1);
							else if (cmdas == "pull") {
								pInfo(currentPeer)->x = pInfo(peer)->x, pInfo(currentPeer)->y = pInfo(peer)->y;
								OnSetPos(currentPeer, pInfo(peer)->x, pInfo(peer)->y);
								{
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("You were pulled by " + by_name);
									p.CreatePacket(currentPeer);
								}
							}
							else if (cmdas == "ban") {
								console_msg(currentPeer, by_name + "`` `4world bans```` " + username + "`` `ofrom`` `0" + pInfo(peer)->world + "``!");
								world_->bannedPlayers.push_back(make_pair(to_lower(pInfo(currentPeer)->tankIDName), (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
								exit_(currentPeer);
							}
							break;
						}
					}
				}
				if (playerFound) {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					string t_ = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0";
					if (cmdas == "pull") {
						p.Insert(by_name + "`` `5pulls`` `o" + username + "``!``");
						t_ = "action|play_sfx\nfile|audio/teleport.wav\ndelayMS|0";
					}
					else if (cmdas == "kick") {
						p.Insert(by_name + "`` `4kicks`` `o" + username + "``!``");
					}
					else if (cmdas == "ban") {
						p.Insert(by_name + "`` `4world bans```` " + username + "`` `ofrom`` `0" + pInfo(peer)->world + "``!");
						t_ = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0";
					}
					BYTE* const d_ = new BYTE[5 + t_.length()];
					*(__int8*)(d_) = 3;
					memcpy(d_ + 4, t_.c_str(), t_.length());
					*(__int8*)(d_ + 4 + t_.length()) = 0;
					ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
					if (cmdas == "ban") {
						gamepacket_t p2;
						p2.Insert("OnConsoleMessage");
						p2.Insert("You've banned " + username + "```` from `w" + pInfo(peer)->world + "`` for one hour.  You can also type `#/uba`` to unban him/her early.");
						p2.CreatePacket(peer);
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						p.CreatePacket(currentPeer);
						if (cmdas != "kick") enet_peer_send(currentPeer, 0, p_m);
					}
					delete[]d_;
				}
				else packet_(peer, "action|log\nmsg| `4Oops: `oThere is nobody currently in this world with a name starting with `w" + username + "`o.", "");
			}
			else if (actual_command == "/kickall") {
				if (owner_name != player_name and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end())) {
					gamepacket_t p;
					p.Insert("OnTextOverlay"), p.Insert("Can't `4kick``, is not in a locked area you control!"), p.CreatePacket(peer);
					return;
				}
				if (not pInfo(peer)->dev && world_->kickall + 600000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
					world_->kickall = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					gamepacket_t p;
					p.Insert("OnConsoleMessage"), p.Insert("`4(KICKALL ACTIVATED!)``");
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName or pInfo(currentPeer)->dev) continue;
						pInfo(currentPeer)->c_x = 0, pInfo(currentPeer)->c_y = 0;
						SendRespawn(currentPeer, true, 0, 1);
						p.CreatePacket(currentPeer);
					}
					p.CreatePacket(peer);
				}
				else console_msg(peer, "You can use `5/kickall`` again in few minutes.");
			}
			else if (actual_command == "/uba") {
				if (world_->owner_name.empty() || owner_name != player_name and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end())) {
					console_msg(peer, "You don't have access to the world lock, so you can't unban all!");
					return;
				}
				world_->bannedPlayers.clear();
				console_msg(peer, "CP:_PL:0_OID:_CT:[S]_ You've unbanned everybody from this world.");
			}
			else if (actual_command == "/banall" && pInfo(peer)->dev == 1) {
				string t_ = "action|play_sfx\nfile|audio/repair.wav\ndelayMS|0";
				BYTE* const d_ = new BYTE[5 + t_.length()];
				*(__int8*)(d_) = 3;
				memcpy(d_ + 4, t_.c_str(), t_.length());
				*(__int8*)(d_ + 4 + t_.length()) = 0;
				ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->tankIDName == pInfo(currentPeer)->tankIDName or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
					if (pInfo(currentPeer)->superdev == 0 or pInfo(currentPeer)->dev == 0) world_->bannedPlayers.push_back(make_pair(to_lower(pInfo(currentPeer)->tankIDName), (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert(get_player_nick(peer) + " `4world bans`` " + get_player_nick(currentPeer) + " from `0" + pInfo(currentPeer)->world + "``!");
					if (pInfo(currentPeer)->superdev == 0 or pInfo(currentPeer)->dev == 0) {
						p.CreatePacket(currentPeer);
						p.CreatePacket(peer);
						world_->bannedPlayers.push_back(make_pair(to_lower(pInfo(currentPeer)->tankIDName), (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
						enet_peer_send(currentPeer, 0, p_m);
						 exit_(currentPeer);
					}
				}
				delete[]d_;
			}
			else if (actual_command.substr(0, 8) == "/ignore " or actual_command == "/ignore") {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (actual_command == "/ignore") p.Insert("Type `5/ignore`` <`5name``> to mute them.  (You can unmute people using the `5Friends List``)");
				else {
					bool playerfound = false;
					string name = to_lower(cmd.substr(8, cmd.length() - 8).c_str());
					if (to_lower(pInfo(peer)->tankIDName) == name or find(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), name) != pInfo(peer)->ignored.end()) p.Insert((to_lower(pInfo(peer)->tankIDName) == name ? "Don't look now, but that person is `5IN YOUR HOUSE``!" : "That jerk `5" + name + "`` is already being ignored!"));
					else {
						string current_name = "";
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (to_lower(pInfo(currentPeer)->tankIDName.substr(0, 3)) == to_lower(name.substr(0, 3)) || name == to_lower(pInfo(currentPeer)->tankIDName)) {
								if (find(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), to_lower(pInfo(currentPeer)->tankIDName)) != pInfo(peer)->ignored.end() || pInfo(currentPeer)->dev) {
									console_msg(peer, (pInfo(currentPeer)->dev ? "That would be silly!" : "That jerk `5" + pInfo(currentPeer)->tankIDName + "`` is already being ignored!"));
									return;
								}
								pInfo(peer)->ignored.push_back(to_lower(pInfo(currentPeer)->tankIDName));
								current_name = pInfo(currentPeer)->tankIDName;
								playerfound = true;
								break;
							}
						}
						if (playerfound) p.Insert("`4PERSON IGNORED!`` Ok, you won't see messages from `5" + current_name + "``. If you change your mind, you can remove him/her from ignore by using the `5Friends List``.");
						else p.Insert("Hmm, nobody is currently online with a name starting with `5" + name + "``.");
					}
				}
				p.CreatePacket(peer);
			}
			else if (actual_command.substr(0, 6) == "/rate " or actual_command == "/rate") {
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (actual_command == "/rate") p.Insert("Type \"/rate X\" to rate a world. You can rate a world 1-5! A 1 or 2 means you don't like it. 3 is average. 4 or 5 means you liked it! You can't rate a world of your own, our use alts to rate up your world. Nobody will ever see how you rated, so don't pay people to rate your world!");
				else {
					if (world_->category.empty()) {
						p.Insert("A world needs to have a category set on the World Lock to be rated.");
					}
					else {
						p.Insert("Thanks for rating! World ratings are updated once a day. If you rate the same world again, it will replace this rating.");
						string rate = cmd.substr(6, cmd.length() - 6).c_str();
						if (find(pInfo(peer)->last_rated.begin(), pInfo(peer)->last_rated.end(), pInfo(peer)->world) == pInfo(peer)->last_rated.end()) {
							if (is_number(rate)) {
								double rating = stod(cmd.substr(6, cmd.length() - 6).c_str());
								if (rating < 1) rating = 1;
								else if (rating > 5) rating = 5;
								rating *= 100;
								add_ratings(pInfo(peer)->world, pInfo(peer)->world_owner, world_->category, rating);
								pInfo(peer)->last_rated.push_back(pInfo(peer)->world);
							}
						}
					}
				}
				p.CreatePacket(peer);
			}
			else if (actual_command == "/r" || actual_command.substr(0, 5) == "/msg " || actual_command.substr(0, 3) == "/r " || actual_command == "/msg") {
				if (actual_command == "/r") {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /r <`$your message``> - This will send a private message to the last person who sent you a message. Use /msg to talk to somebody new!");
					p.CreatePacket(peer);
				}
				else if (actual_command == "/msg") {
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
					p.CreatePacket(peer);
				}
				else {
					if (has_playmod2(pInfo(peer), 11)) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`6>> That's sort of hard to do while duct-taped.``");
						p.CreatePacket(peer);
						return;
					}
					string message = "";
					string username = "";
					if (actual_command.substr(0, 5) == "/msg ") {
						if (cmd.substr(5).find(" ") == string::npos) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
							p.CreatePacket(peer);
							return;
						}
						string s = cmd.substr(5);
						stringstream ss(s);
						istream_iterator<string> begin(ss);
						istream_iterator<string> end;
						vector<string> vstrings(begin, end);
						if (vstrings.size() < 1) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
							p.CreatePacket(peer);
							return;
						}
						username = vstrings[0];
						if (username.empty()) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Usage: /msg <`$full or first part of a name``> <`$your message``> - This will send a private message to someone anywhere in the universe.  If you don't include a message, you can just see if he/she is online or not.");
							p.CreatePacket(peer);
							return;
						}
						if (find(pInfo(peer)->ignored.begin(), pInfo(peer)->ignored.end(), to_lower(username)) != pInfo(peer)->ignored.end()) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("(Sent to nobody) `0(`4Note:`` `0You can't send messages to people you are currently ignoring)``");
							p.CreatePacket(peer);
							return;
						}
						message = "";
						for (int i = 1; i < vstrings.size(); i++) {
							message = message + vstrings[i] + (vstrings.size() - i == 1 ? "" : " ");
						}
					}
					else {
						message = cmd.substr(3, cmd.length() - 3).c_str();
						username = pInfo(peer)->lastmsg;
						if (username.empty()) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Usage: /r <`$your message``> - This will send a private message to the last person who sent you a message. Use /msg to talk to somebody new!");
							p.CreatePacket(peer);
							return;
						}
					}
					bool playerFound = false;
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->m_h == 1 or pInfo(currentPeer)->invis == true) continue;
						if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(username) || to_lower(pInfo(currentPeer)->tankIDName.substr(0, 5)) == to_lower(username.substr(0, 5))) {
							if (find(pInfo(currentPeer)->ignored.begin(), pInfo(currentPeer)->ignored.end(), to_lower(pInfo(peer)->tankIDName)) != pInfo(currentPeer)->ignored.end()) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6>> `4SYSTEM``: That user is ignoring you.");
								p.CreatePacket(peer);
								return;
							}
							bool msg = false;
							playerFound = true;
							if (message.length() < 1) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6>> `$" + get_player_nick(currentPeer) + "`` is online now.``");
								p.CreatePacket(peer);
							}
							else {
								bool muted_ = false;
								for (int c_ = 0; c_ < pInfo(peer)->friends.size(); c_++) {
									if (to_lower(pInfo(peer)->friends[c_].name) == to_lower(pInfo(currentPeer)->tankIDName)) {
										if (pInfo(peer)->friends[c_].mute) {
											muted_ = true;
											break;
										}
									}
								}
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									if (pInfo(currentPeer)->mod == 1 || pInfo(currentPeer)->dev == 1) p.Insert("CT:[MSG]_`6>> (Sent to`` `$" + (pInfo(currentPeer)->name_color == "`0" || pInfo(currentPeer)->name_color == "`2" || pInfo(currentPeer)->name_color == "`^" ? fixchar2(get_player_nick(currentPeer)) : get_player_nick(currentPeer)) + "```o)`` (`4Note: ``Message a mod `4ONLY ONCE`` about an issue. Mods don't fix scams or replace items, they punish players who break the `5/rules``.  For issues related to account recovery or purchasing, contact support at `5" + web_url + "``)");
									else {
										if (muted_) p.Insert("CT:[MSG]_`6>> (Sent to`` `$" + (pInfo(currentPeer)->name_color == "`0" || pInfo(currentPeer)->name_color == "`2" || pInfo(currentPeer)->name_color == "`^" ? fixchar2(get_player_nick(currentPeer)) : get_player_nick(currentPeer)) + "`o)`` (`4Note: ```6You can't send messages to people you muted)``");
										else p.Insert("CT:[MSG]_`6>> (Sent to`` `$" + (pInfo(currentPeer)->name_color == "`0" || pInfo(currentPeer)->name_color == "`2" || pInfo(currentPeer)->name_color == "`^" ? fixchar2(get_player_nick(currentPeer)) : get_player_nick(currentPeer)) + "`o)``");
									}
									p.CreatePacket(peer);
								}
								{
									for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
										if (to_lower(pInfo(currentPeer)->friends[c_].name) == to_lower(pInfo(peer)->tankIDName)) {
											if (pInfo(currentPeer)->friends[c_].mute) msg = true;
										}
									}
									if (msg == false) {
										pInfo(currentPeer)->lastmsg = pInfo(peer)->tankIDName;
										pInfo(currentPeer)->lastmsgworld = pInfo(peer)->world;
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("CP:0_PL:0_OID:_CT:[MSG]_>> `c>> from (``" + get_player_nick(peer) + "`c) in [`$" + (pInfo(peer)->m_h || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "``] > ```$" + message + "``");
										p.CreatePacket(currentPeer);
										packet_(currentPeer, "action|play_sfx\nfile|audio/pay_time.wav\ndelayMS|0");
									}
								}
							}
							break;
						}
					}
					if (!playerFound) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						if (username.length() < 5) p.Insert("`6>> `$" + username + "`` is not online right now (you need to enter at least 5 letters if you meant a longer name!).``");
						else p.Insert("`6>> No one online who has a name starting with `$" + username + "``.``");
						p.CreatePacket(peer);
					}
				}
			}
			else if (actual_command == "/sb" || actual_command == "/bc" || actual_command == "/broadcast" || actual_command.substr(0, 4) == "/sb " || actual_command.substr(0, 4) == "/bc ") {
				if (actual_command == "/sb") {
					int w_c = 0, s_c = 0, net_ = 1, r_c = 0;
					get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
					packet_(peer, "action|log\nmsg|>> This lets you send a message to " + setGems(s_c) + "`` random users online and make an annoying beep noise.  Costs `$" + setGems(s_c*2.5) + " Gems`` to use. Example:`` `w/sb Hey guys, come to my world!", "");
				}
				else if (actual_command == "/broadcast" || actual_command == "/bc") packet_(peer, "action|log\nmsg|>> This lets you send a message to `5100`` random users online.  Costs `$250 Gems`` to use.  Example:`` `w/broadcast Hey guys, come to my world!", "");
				else {
					if (pInfo(peer)->level < 5) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("`4OOPS:`` To cut down on spam, you require at least `$Level 5`` in order to send a broadcast to everybody!");
						p.CreatePacket(peer);
					}
					else {
						if (has_playmod2(pInfo(peer), 11)) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`6>> That's sort of hard to do while duct-taped.``");
							p.CreatePacket(peer);
							return;
						}
						if (has_playmod2(pInfo(peer), 13)) {
							int time_ = 0;
							for (PlayMods peer_playmod : pInfo(peer)->playmods) {
								if (peer_playmod.id == 13) {
									time_ = peer_playmod.time - time(nullptr);
									break;
								}
							}
							packet_(peer, "action|log\nmsg|>> (" + to_playmod_time(time_) + " before you can broadcast again)", "");
							return;
						}
						int w_c = 0, s_c = 250, net_ = 1, r_c = 0;
						if (actual_command.substr(0, 4) == "/sb ") {
							s_c = 0;
							get_players(pInfo(peer)->world, w_c, s_c, net_, r_c);
							s_c *= 2.5;
						}
						if (pInfo(peer)->gems >= s_c or pInfo(peer)->usedmegaphone) {
							if (pInfo(peer)->grow4good_sb < 10 && pInfo(peer)->grow4good_sb != -1)daily_quest(peer, false, "sb", 1);
							int removemegaphone = -1, megacount = 0;
							if (pInfo(peer)->usedmegaphone == 0) {
								OnSetGems(peer, s_c * -1);
							}
							else {
								modify_inventory(peer, 2480, removemegaphone);
								modify_inventory(peer, 2480, megacount);
							}

							if (!pInfo(peer)->superdev) add_playmod(peer, 13);

							{
								packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
								gamepacket_t p2;
								p2.Insert("OnConsoleMessage"), p2.Insert(a + "`#" + (actual_command.substr(0, 4) == "/sb " ? "Super-" : "") + "Broadcast sent. Used `$" + (pInfo(peer)->usedmegaphone ? "1 Megaphone``. (`$" + to_string(megacount) : setGems(s_c) + " Gems``. (`$" + setGems(pInfo(peer)->gems)) + "`` left)`` (5 mins before you can broadcast again)"), p2.CreatePacket(peer);
							}
						}
						else {
							gamepacket_t p;
							p.Insert("OnConsoleMessage"), p.Insert(">> You don't have `$" + setGems(s_c) + " Gems``, you can't broadcast a message!"), p.CreatePacket(peer);
							return;
						}
						pInfo(peer)->usedmegaphone = 0;
						string text = cmd.substr(4, cmd.length() - 4).c_str();
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						if (pInfo(peer)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) {
							World_Stuff.lastsbworld = pInfo(peer)->world;
						}
						int sentto = 0;
						if (actual_command.substr(0, 4) == "/sb ") p.Insert("CP:_PL:0_OID:_CT:[SB]_ `5** from (`0" + (get_player_nick(peer)) + "`5) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```5] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`^") + "" + text + "``");
						else p.Insert("CP:_PL:0_OID:_CT:[BC]_ `p** from (`0" + (get_player_nick(peer)) + "`p) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```p] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`^") + "" + text + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio or pInfo(currentPeer)->temp_radio) continue;
							if (actual_command.substr(0, 4) == "/bc " && sentto > 100) continue;
							sentto++;
							if (actual_command.substr(0, 4) == "/sb ") variants::OnPlaySound(currentPeer, "audio/beep.wav");
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			else if ((actual_command == "/online" and pInfo(peer)->give_role) and web_url.find("gtps7") != string::npos) {
				int online = 0; string names = "";
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					names += pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "`o, ";
					online++;
				}
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("{REAL} Online [`2" + to_string(online) + "`o]: " + names);
				p.CreatePacket(peer);
			}
			else if (actual_command.substr(0, 6) == "/drop " && (pInfo(peer)->give_role or pInfo(peer)->whitelist_role)) {
				vector<string> a_ = explode(" ", cmd);
				if (a_.size() != 3) return;
				if (not isdigit(a_[1][0]) or not isdigit(a_[2][0])) return;
				int i_ = atoi(a_[1].c_str()), c_ = atoi(a_[2].c_str());
				if (i_ <= 0 or c_ <= 0 or i_ >= items.size()) return;
				if (items[i_].id == 274 || items[i_].id == 276 || items[i_].id == 8470 || items[i_].id == 278 || items[i_].id == 732) return;
				WorldDrop drop_block_{};
				drop_block_.x = (pInfo(peer)->state == 16 ? pInfo(peer)->x - ((rand() % 12) + 18) : pInfo(peer)->x + ((rand() % 12) + 22)), drop_block_.y = pInfo(peer)->y + rand() % 16, drop_block_.id = i_, drop_block_.count = c_;
				dropas_(world_, drop_block_);
			}
			else if (!SendCmdPlus(peer, world_, actual_command)) packet_(peer, "action|log\nmsg|`4Unknown command.``  Enter `$/?`` for a list of valid commands.");
		}
	}
}


void SendReceive(ENetPeer* peer) {
	ifstream openFile2("db/depo/" + to_lower(pInfo(peer)->tankIDName) + ".txt");
	if (openFile2.is_open()) {
		int add_more_time = 0;
		string stringToStore = "0";
		getline(openFile2, stringToStore);
		openFile2.close();
		int deposit = atoi(stringToStore.c_str()), voucher = atoi(stringToStore.c_str()) / 500;
		if (deposit > 0) {
			if (pInfo(peer)->all_in) deposit *= 2;
			pInfo(peer)->gtwl += deposit;
			if (voucher > 1) {
				OnSetVoucher(peer, voucher);
				gamepacket_t p, p2;
				p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("Received `o" + setGems((voucher)) + "`` Voucher's!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
				p2.Insert("OnConsoleMessage"), p2.Insert("Received `o" + setGems((voucher)) + "`` Voucher's!"), p2.CreatePacket(peer);
				add_more_time += 2000;
			}
			save_player(pInfo(peer), false);
			SendCmd(peer, "/shop", true);
			ofstream m;
			m.open("db/depo/" + to_lower(pInfo(peer)->tankIDName) + ".txt"), m << "0", m.close();
			gamepacket_t p(add_more_time), p2(add_more_time);
			p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("Received `o" + setGems((deposit)) + "`` GTPS WL!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
			p2.Insert("OnConsoleMessage"), p2.Insert("You got `0" + setGems((deposit)) + "`` GTPS WL!"), p2.CreatePacket(peer);
			if (pInfo(peer)->supp == 0) {
				pInfo(peer)->supp = 1;
				gamepacket_t p(add_more_time += 2000), p2(add_more_time += 2000);
				p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've unlocked `5Supporter`` `oskin colors``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
				p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("You've unlocked the `5Recycle Tool``!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
				form_emoji(peer, true, add_more_time += 2000);
			}
			if (pInfo(peer)->supp != 2) {
				if (deposit >= 100) {
					pInfo(peer)->supp = 2;
					pInfo(peer)->hs = 1;
					gamepacket_t p(add_more_time += 2000), p2(add_more_time += 2000);
					p.Insert("OnAddNotification"), p.Insert("interface/cash_icon_overlay.rttex"), p.Insert("You've unlocked `5Super Supporter`` `oskin colors``!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(peer);
					p2.Insert("OnAddNotification"), p2.Insert("interface/cash_icon_overlay.rttex"), p2.Insert("You've unlocked the `5Super Supporter`` only command `5/warp``!"), p2.Insert("audio/piano_nice.wav.wav"), p2.Insert(0), p2.CreatePacket(peer);
					form_emoji(peer, true, add_more_time += 2000);
				}
			}
		}
	}
}


bool trade_space_check(ENetPeer* peer, ENetPeer* currentPeer) {
	int slots_needed = int(pInfo(currentPeer)->trade_items.size());
	for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
		map<string, int>::iterator it;
		for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
			int c_ = 0;
			modify_inventory(peer, it->first, c_);
			if (c_ != 0) {
				if (c_ + it->second > 200) {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("`4Oops - " + get_player_nick(peer) + " is carrying too many " + items[it->first].name + " and can't fit that many in their backpack.");
					p.CreatePacket(peer), p.CreatePacket(currentPeer);
					return false;
				}
				slots_needed--;
			}
		}
	}
	int free_slots = get_free_slots(pInfo(peer));
	if (free_slots < slots_needed) {
		gamepacket_t p;
		p.Insert("OnTextOverlay");
		p.Insert(get_player_nick(peer) + " needs more backpack room first!");
		p.CreatePacket(peer), p.CreatePacket(currentPeer);
		return false;
	}
	return true;
}
string get_sucker(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	if (block_->id == 0) {
		return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|`6The machine is empty.``|left|\nadd_item_picker|selectitem|`wChoose Item``|Choose an item to put in the " + items[block_->fg].name + "!|\nend_dialog|itemsucker_block|Close||";
	}
	bool ar_turi = false;
	int c_ = 0;
	if (block_->id != 0) {
		modify_inventory(peer, block_->id, c_);
		if (c_ != 0) {
			ar_turi = true;
		}
	}
	bool ar_turi_mag = false;
	{
		if (block_->fg == 9850 || block_->fg == 10266 || block_->fg == 5638) {
			int c_ = 0;
			if (block_->id != 0) {
				modify_inventory(peer, 5640, c_);
				if (c_ != 0) {
					if (pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_ and pInfo(peer)->magnetron_id == block_->id) {
						ar_turi_mag = true;
					}
				}
			}
		}
		else ar_turi_mag = false;
	}
	bool dont_give = false;
	if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != SEED and not items[block_->id].farmable or items[block_->id].rarity == 999) {
		dont_give = true;
	}
	string alalala = (block_->spin ? "`5ACTIVE" : "`6DISABLED");
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|" + (block_->pr == 0 ? "\nadd_textbox|`6The machine is currently empty!``|left|" : "\nadd_textbox|The machine contains " + to_string(block_->pr) + " `2" + items[block_->id].ori_name + "``|left|") + (ar_turi ? (block_->pr >= (block_->fg == 5638 ? 5000 : block_->fg == 9850 ? 15000 : block_->fg == 10266 ? 100000 : 1500) ? "\nadd_smalltext|`4The machine is at maximum capacity!``|left|" : "\nadd_button|additem|Add Items to the machine|noflags|0|0|" + a+(pInfo(peer)->give_role ? "\nadd_button|addstocks5000|Add 5000 to the machine|noflags|0|0|\nadd_button|remove_stock|Remove World Locks/Stock from the machine|noflags|0|0|" : "") + "") : (block_->pr >= (block_->fg == 5638 ? 5000 : block_->fg == 9850 ? 15000 : block_->fg == 10266 ? 100000 : 1500) ? "\nadd_smalltext|`4The machine is at maximum capacity!``|left|" : "")) + (block_->pr != 0 ? (c_ == 200 ? "\nadd_textbox|`6You are already carrying 200 " + items[block_->id].name + "!``|left|" : "\nadd_button|retrieveitem|Retrieve Item|noflags|0|0|") : "\nadd_button|clearitem|Change Item|noflags|0|0|") + (block_->fg == 5638 || block_->fg == 9850 || block_->fg == 10266 ? "\nadd_textbox|Building mode: " + alalala + "``|left|" : "") + (block_->fg == 5638 || block_->fg == 9850 || block_->fg == 10266 ? "\nadd_textbox|Use the " + items[block_->fg].name + " to build `2" + items[block_->id].name + "`` directly from the " + items[block_->fg].name + "'s storage.|left|" : "") + ((block_->fg == 5638 or block_->fg == 9850 or block_->fg == 10266) and not ar_turi_mag and not dont_give ? "\nadd_button|getplantationdevice|Get Remote|noflags|0|0|" : "") + "\nadd_checkbox|chk_enablesucking|Enable Collection.|" + (block_->enabled ? "1" : "0") + "\nend_dialog|itemsucker_block|Close|Update|";
}
bool not_mod(WorldBlock block_, int total_, int max_size) {
	if (total_ < 0 || total_ >= max_size || block_.locked or items[block_.fg].blockType == LOCK) {
		return false;
	} if (block_.fg == 0) return true;
	if (items[block_.fg].properties & Property_Mod) {
		return false;
	}
	return true;
}

void lwiz_points(ENetPeer* peer) {
	if (pInfo(peer)->lwiz_quest == 21) return;
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
		if (not block_access(peer, world_, block_)) return;
		if (block_->fg == 1790) {
			if (pInfo(peer)->lwiz_quest > 0) {
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				if (pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][0] == pInfo(peer)->legendary_quest[pInfo(peer)->lwiz_step - 1][1]) {
					pInfo(peer)->lwiz_notification = 0;
					p.Insert("`9Quest step complete!!``");
					pInfo(peer)->lwiz_step++;
					gamepacket_t p;
					p.Insert("OnParticleEffect"), p.Insert(48), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						p.CreatePacket(currentPeer);
					}
					if (pInfo(peer)->lwiz_step > 20) {
						int give_item = 0;
						if (pInfo(peer)->lwiz_quest == 1) {
							pInfo(peer)->drlegend = 1;
							pInfo(peer)->is_legend = true;
							nick_update_2(peer, NULL);
							give_item = -1;
						}
						else if (pInfo(peer)->lwiz_quest == 2) {
							give_item = 1782;
						}
						else if (pInfo(peer)->lwiz_quest == 3) {
							give_item = 1780;
						}
						else if (pInfo(peer)->lwiz_quest == 4) {
							give_item = 1784;
						}
						else if (pInfo(peer)->lwiz_quest == 5) {
							give_item = 2592;
						}
						else if (pInfo(peer)->lwiz_quest == 6) {
							give_item = 6026;
						}
						else if (pInfo(peer)->lwiz_quest == 7) {
							give_item = 7734;
						}
						else if (pInfo(peer)->lwiz_quest == 9) {
							give_item = 11140;
						}
						else if (pInfo(peer)->lwiz_quest == 8) {
							give_item = 11142;
						}
						else if (pInfo(peer)->lwiz_quest == 10) {
							give_item = 9774;
						}
						if (give_item != -1 && give_item != 0) {
							int give_count = 1;
							if (modify_inventory(peer, give_item, give_count) == 0) {
							}
							else {
								gamepacket_t p2;
								p2.Insert("OnTalkBubble"), p2.Insert(pInfo(peer)->netID), p2.Insert("Your inventory is full!"), p2.Insert(0), p2.Insert(0), p2.CreatePacket(peer);
								pInfo(peer)->lwiz_step = 20;
								give_item = 0;
							}
						}
						if (give_item != 0) {
							block_->fg = 0;
							update_tile(peer, pInfo(peer)->lastwrenchx, pInfo(peer)->lastwrenchy, 0, false, true);
							if (give_item != -1) equip_clothes(peer, give_item);
							pInfo(peer)->legendary_quest.clear();
							pInfo(peer)->lwiz_quest = 0;
							pInfo(peer)->lwiz_notification = 0;
							pInfo(peer)->lwiz_step = 1;
							SendCmd(peer, "/cheer", true);
							gamepacket_t p;
							p.Insert("OnParticleEffect"), p.Insert(90), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
							}
						}
					}
				}
				else p.Insert("`9Thanks! Keep it coming!``");
				p.CreatePacket(peer);
			}
		}
	}
}

string get_vending(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	int c_ = 0;
	string ex_ = "";
	if (block_->id != 0) {
		modify_inventory(peer, block_->id, c_);
		if (c_ != 0 && block_->c_ < (block_->fg == 2978 ? 5199 : 9999)) ex_ = "\nadd_smalltext|You have " + to_string(c_) + " " + items[block_->id].ori_name + " in your backpack.|\nadd_button|addstocks|Add them to the machine|noflags|0|0|";
		if (pInfo(peer)->give_role) ex_ = "\nadd_button|addstocks5000|Add 5000 to the machine|noflags|0|0|";
	}
	string a_ = (block_->pr < 0 and (block_->pr * -1 > block_->c_) ? "\nadd_smalltext|`4(You need to add more items or people can't purchase at this price!)``|left|" : "");
	if (block_->id == 0) block_->pr = 0;
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->id == 0 ? "\nadd_textbox|This machine is empty.|left|\nadd_item_picker|stockitem|`wPut an item in``|Choose an item to put in the machine!|" : "\nadd_label_with_icon|sml|The machine contains a total of " + to_string(block_->c_) + " `2" + items[block_->id].ori_name + +"``. |left|" + to_string(block_->id) + "|") + (block_->pr == 0 ? (block_->id != 0 ? "\nadd_spacer|small|\nadd_textbox|Not currently for sale!|left|" + ex_ + "\nadd_button|pullstocks|Empty the machine|noflags|0|0|" : "") : "\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? "1" : to_string(block_->pr)) + " x `8World `8Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? to_string(block_->pr * -1) : "1") + " x `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|" + (block_->pr > 0 ? "\nadd_spacer|small|\nadd_smalltext|Value Check: Based on current trading, this item is priced" + item_average(items[block_->id].price, block_->pr) + "|left|" : "") + "\nadd_spacer|small|" + ex_ + "\nadd_button|pullstocks|Empty the machine|noflags|0|0|") + (block_->id != 0 ? "" + a_ + "\nadd_smalltext|`5(" + items[block_->fg].name + " will not function when price is set to 0)``|left|\nadd_text_input|setprice|Price|" + (block_->pr < 0 ? to_string(block_->pr * -1) : to_string(block_->pr)) + "|7|\nadd_checkbox|chk_peritem|World Locks per Item|" + (block_->pr >= 0 ? "1" : "0") + "\nadd_checkbox|chk_perlock|Items per World Lock|" + (block_->pr < 0 ? "1" : "0") + "" : "") + (block_->wl != 0 ? "\nadd_smalltext|You have earned " + to_string(block_->wl) + " World Locks.|left|\nadd_button|withdraw|Withdraw World Locks|noflags|0|0|" : "") + "" + (block_->fg == 2978 ? "\nadd_smalltext|Upgrade to a DigiVend Machine for `44,000 Gems``.|left|\nadd_button|upgradedigital|Upgrade to DigiVend|noflags|0|0|" : "") + "\nadd_spacer|small|\nend_dialog|vending|Close|" + (block_->id != 0 ? "Update" : "") + "|";
}
string get_vending_buyer_side(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_) {
	return "set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->id == 0 or block_->pr == 0 ? "\nadd_textbox|This machine is out of order.|left|\nend_dialog|vending|Close||" : "\nadd_label_with_icon|sml|The machine contains a total of " + to_string(block_->c_) + " `2" + items[block_->id].ori_name + "``. |left|" + to_string(block_->id) + "|\nadd_spacer|small|\nadd_textbox|For a cost of:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? "1" : to_string(block_->pr)) + " x `8World Lock``|left|242|\nadd_spacer|small|\nadd_textbox|You will get:|left|\nadd_label_with_icon|small|" + (block_->pr < 0 ? to_string(block_->pr * -1) : "1") + " x `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|" + (block_->pr > 0 ?  "\nadd_spacer|small|\nadd_smalltext|Value Check: Based on current trading, this item is priced"+item_average(items[block_->id].price, block_->pr) + "|left|" : "") + "\nadd_spacer|small|" + (block_->pr < 0 and (block_->pr * -1 > block_->c_) ? "\nadd_textbox|You'll need to wait for the owner to stock up to at least 1 World Lock's worth before you can buy.|left|\nend_dialog|vending|Close||" : "\nadd_textbox|You have " + to_string(get_wls(peer, true)) + " World Locks.|left|\nadd_text_input|buycount|How many would you like to buy?|0|3|\nembed_data|expectprice|" + to_string(block_->pr) + "\nembed_data|expectitem|" + to_string(block_->id) + "\nend_dialog|vending|Close|Buy|"));
}
uint16_t get_weather_id(uint32_t block_id) {
	switch (block_id) {
	case 3694: {
		return 28;
	}
	case 3832: {
		return 29;
	}
	case 5000: {
		return 34;
	}
	case 1490: {
		return 10;
	}
	case 934: {
		return 2;
	}
	case 946: {
		return 3;
	}
	case 932: {
		return 4;
	}
	case 984: {
		return 5;
	}
	case 1210: {
		return 8;
	}
	case 1364: {
		return 11;
	}
	case 1750: {
		return 15;
	}
	case 2046: {
		return 17;
	}
	case 2284: {
		return 18;
	}
	case 2744: {
		return 19;
	}
	case 3252: {
		return 20;
	}
	case 3446: {
		return 21;
	}
	case 3534: {
		return 22;
	}
	case 4242: {
		return 30;
	}
	case 4486: {
		return 31;
	}
	case 4776: {
		return 32;
	}
	case 4892: {
		return 33;
	}
	case 5112: {
		return 35;
	}
	case 5654: {
		return 36;
	}
	case 5716: {
		return 37;
	}
	case 5958: {
		return 38;
	}
	case 6854: {
		return 42;
	}
	case 7644: {
		return 44;
	}
	case 8896: {
		return 47;
	}
	case 8836: {
		return 48;
	}
	case 10286: {
		return 51;
	}
	case 11880: {
		return 59;
	}
	case 12054: {
		return 60;
	}
	case 12056: {
		return 61;
	}
	case 12408: {
		return 62;
	}
	case 12844: {
		return 64;
	}
	case 13004: {
		return 65;
	}
	case 13070: {
		return 66;
	}
	}
	return 0;
}
bool is_false_state(WorldBlock block_, int t_) {
	if (items[block_.fg].collisionType == 0) return false;
	if (items[block_.fg].collisionType == 1) {
		return true;
	}
	if (block_.flags & t_) {
		return false;
	}
	return true;
}

std::size_t number_of_files_in_directory(std::filesystem::path path)
{
	using std::filesystem::directory_iterator;
	return std::distance(directory_iterator(path), directory_iterator{});
}


vector<vector<int>> lock_tiles(World* w_, int st_x, int st_y, int lock_size) {
	try {
		int layer_ = 0;
		int og_lock_size = lock_size;
		vector<vector<int>> new_tiles{};
		vector<vector<int>> new_lock{};
		if (w_->blocks.at(st_x + (st_y * 100)).locked) {
			return new_lock;
		}
		if (st_x - 1 > 0) {
			new_tiles.push_back({ st_x - 1 + (st_y * 100), 1 });
			if (not_mod(w_->blocks.at(st_x - 1 + (st_y * 100)), st_x - 1 + (st_y * 100), w_->blocks.size())) new_lock.push_back({ st_x - 1, st_y });
		}
		if (st_y - 1 > 0) {
			new_tiles.push_back({ st_x + ((st_y - 1) * 100), 2 });
			if (not_mod(w_->blocks.at(st_x + ((st_y - 1) * 100)), st_x + ((st_y - 1) * 100), w_->blocks.size())) new_lock.push_back({ st_x, st_y - 1 });
		}
		if (st_x + 1 < w_->max_x) {
			new_tiles.push_back({ st_x + 1 + (st_y * 100), 3 });
			if (not_mod(w_->blocks.at(st_x + 1 + (st_y * 100)), st_x + 1 + (st_y * 100), w_->blocks.size())) new_lock.push_back({ st_x + 1, st_y });
		}
		if (st_y + 1 < w_->max_y) {
			new_tiles.push_back({ st_x + ((st_y + 1) * 100), 4 });
			if (not_mod(w_->blocks.at(st_x + ((st_y + 1) * 100)), st_x + ((st_y + 1) * 100), w_->blocks.size())) new_lock.push_back({ st_x, st_y + 1 });
		}
		int ySize = w_->blocks.size() / 100, xSize = w_->blocks.size() / ySize;
		int max_up = 0;
		int max_down = 0;
		int max_right = 0;
		int max_left = 0;
		vector<WorldBlock> shadow_copy = w_->blocks;
		for (int i_ = 0; i_ < new_tiles.size(); i_++) {
			if (new_lock.size() >= og_lock_size) {
				break;
			}
			vector<int> test__ = new_tiles.at(i_);
			int x_ = test__.at(0) % 100, y_ = test__.at(0) / 100;
			int where_ = test__.at(1);
			if (where_ == 1) {
				if (y_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ + ((y_ - 1) * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ + ((y_ - 1) * 100)), x_ + ((y_ - 1) * 100), w_->blocks.size())) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * 100), 1 });
							}
							new_lock.push_back({ x_, y_ - 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_up != 0 and y_ > max_up + 1 and y_ - 1 > 0) {
								new_tiles.push_back({ x_ + ((y_ - 1) * 100), 1 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}
			}
			if (where_ == 2) {
				if (x_ + 1 > w_->max_x) {

				}
				else {
					if (not shadow_copy.at(x_ + 1 + (y_ * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ + 1 + (y_ * 100)), x_ + 1 + (y_ * 100), w_->blocks.size())) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < w_->max_x) {
								new_tiles.push_back({ x_ + 1 + (y_ * 100), 2 });
							}
							new_lock.push_back({ x_ + 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_left != 0 and x_ < max_left - 1 and x_ + 1 < w_->max_x) {
								new_tiles.push_back({ x_ + 1 + (y_ * 100), 2 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}

			}
			if (where_ == 3) {
				if (y_ + 1 > w_->max_y) {

				}
				else {
					if (not shadow_copy.at(x_ + ((y_ + 1) * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ + ((y_ + 1) * 100)), x_ + ((y_ + 1) * 100), w_->blocks.size())) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < w_->max_y) {
								new_tiles.push_back({ x_ + ((y_ + 1) * 100), 3 });
							}
							new_lock.push_back({ x_, y_ + 1 });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_down != 0 and y_ < max_down - 1 and y_ + 1 < w_->max_y) {
								new_tiles.push_back({ x_ + ((y_ + 1) * 100), 3 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}

			}
			if (where_ == 4) {
				if (x_ - 1 < 0) {
				}
				else {
					if (not shadow_copy.at(x_ - 1 + (y_ * 100)).scanned) {
						if (not_mod(shadow_copy.at(x_ - 1 + (y_ * 100)), x_ - 1 + (y_ * 100), w_->blocks.size())) {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * 100), 4 });
							}
							new_lock.push_back({ x_ - 1, y_ });
							if (new_lock.size() >= og_lock_size) {
								break;
							}
						}
						else {
							shadow_copy.at(x_ + (y_ * 100)).scanned = true;
							if (max_right != 0 and x_ > max_right + 1 and x_ - 1 > 0) {
								new_tiles.push_back({ x_ - 1 + (y_ * 100), 4 });
								if (new_lock.size() >= og_lock_size) {
									break;
								}
							}
							lock_size++;
						}
					}
				}

			}
			if (i_ == new_tiles.size() - 1) {
				layer_++;
				if (og_lock_size <= 10 or lock_size - new_lock.size() <= 5) layer_ = 0;
				int t_ = 1;
				if (st_x - t_ < 0) {
					//lock_size++;

				}
				else {
					while (shadow_copy.at(st_x - t_ + (st_y * 100)).scanned) {
						t_++;
						if (st_x - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x - t_ + (st_y * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x - t_ + ((st_y + layer_) * 100)), st_x - t_ + ((st_y + layer_) * 100), w_->blocks.size())) {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * 100), 1 });
									new_lock.push_back({ st_x - t_, (st_y + layer_) });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_right = st_x - t_;
									new_tiles.push_back({ st_x - t_ + ((st_y + layer_) * 100), 1 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y - t_ < 0) {
					//lock_size++;

				}
				else {
					while (shadow_copy.at(st_x + ((st_y - t_) * 100)).scanned) {
						t_++;
						if (st_y - t_ < 0) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y - t_) * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x - layer_ + ((st_y - t_) * 100)), st_x - layer_ + ((st_y - t_) * 100), w_->blocks.size())) {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * 100), 2 });
									new_lock.push_back({ st_x - layer_, st_y - t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_up = st_y - t_;
									new_tiles.push_back({ st_x - layer_ + ((st_y - t_) * 100), 2 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_x + t_ > w_->max_x) {

				}
				else {
					while (shadow_copy.at(st_x + t_ + (st_y * 100)).scanned) {
						t_++;
						if (st_x + t_ > w_->max_x) {
							break;
						}
						else {
							if (st_y - layer_ < 0) layer_ = 0;
							if (not shadow_copy.at(st_x + t_ + (st_y * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x + t_ + ((st_y - layer_) * 100)), st_x + t_ + ((st_y - layer_) * 100), w_->blocks.size())) {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * 100), 3 });
									new_lock.push_back({ st_x + t_, st_y - layer_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									max_left = st_x + t_;
									new_tiles.push_back({ st_x + t_ + ((st_y - layer_) * 100), 3 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
				t_ = 1;
				if (st_y + t_ > w_->max_y) {

				}
				else {
					while (shadow_copy.at(st_x + ((st_y + t_) * 100)).scanned) {
						t_++;
						if (st_y + t_ > w_->max_y) {
							break;
						}
						else {
							if (not shadow_copy.at(st_x + ((st_y + t_) * 100)).scanned) {
								if (not_mod(shadow_copy.at(st_x + layer_ + ((st_y + t_) * 100)), st_x + layer_ + ((st_y + t_) * 100), w_->blocks.size())) {
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * 100), 4 });
									new_lock.push_back({ st_x + layer_, st_y + t_ });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
								}
								else {
									if (st_x == 0 or st_y == 0) break;
									max_down = st_y + t_;
									new_tiles.push_back({ st_x + layer_ + ((st_y + t_) * 100), 4 });
									if (new_lock.size() >= og_lock_size) {
										break;
									}
									lock_size++;
								}
								break;
							}
						}
					}
				}
			}
		}
		if (new_lock.size() > og_lock_size) {
			int fix_size = (new_lock.size() - og_lock_size);
			for (int i_ = 0; i_ < fix_size; i_++) {
				new_lock.pop_back();
			}
		} vector<int> erase_later{};
		vector<WorldBlock> shadow_copy_2 = w_->blocks;
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * 100)).locked = true;
			shadow_copy_2.at(asd_.at(0) + (asd_.at(1) * 100)).lock_origin = (st_x + (st_y * 100));
		}
		WorldBlock target_to_reach = shadow_copy_2.at(st_x + (st_y * 100)); // og coordinatess
		for (int i_ = 0; i_ < new_lock.size(); i_++) {
			vector<int> asd_ = new_lock.at(i_);
			vector<int> new_tiles{};
			new_tiles.push_back(asd_.at(0) + (asd_.at(1) * 100));
			int ySize = w_->blocks.size() / 100, xSize = w_->blocks.size() / ySize;
			bool reachable = false;
			vector<vector<int>> after_process{};
			for (int i2 = 0; i2 < new_tiles.size(); i2++) {
				int x_ = new_tiles.at(i2) % 100, y_ = new_tiles.at(i2) / 100;
				if ((x_ + (y_ * 100)) == st_x + (st_y * 100) or (x_ + 1 + (y_ * 100)) == st_x + (st_y * 100) or (x_ - 1 + (y_ * 100)) == st_x + (st_y * 100) or (x_ + ((y_ + 1) * 100)) == st_x + (st_y * 100) or (x_ + ((y_ - 1) * 100)) == st_x + (st_y * 100)) {
					reachable = true;
				} if (x_ < (w_->max_x - 1) and shadow_copy_2.at(x_ + 1 + (y_ * 100)).locked and shadow_copy_2.at(x_ + 1 + (y_ * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + 1 + (y_ * 100)).scanned) {
						shadow_copy_2.at(x_ + 1 + (y_ * 100)).scanned = true;
						after_process.push_back({ x_ + 1, y_ });
						new_tiles.push_back(x_ + 1 + (y_ * 100));
					}
				} if (x_ > 0 and shadow_copy_2.at(x_ - 1 + (y_ * 100)).locked and shadow_copy_2.at(x_ - 1 + (y_ * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ - 1 + (y_ * 100)).scanned) {
						shadow_copy_2.at(x_ - 1 + (y_ * 100)).scanned = true;
						after_process.push_back({ x_ - 1, y_ });
						new_tiles.push_back(x_ - 1 + (y_ * 100));
					}
				} if (y_ < (w_->max_y - 1) and shadow_copy_2.at(x_ + ((y_ + 1) * 100)).locked and shadow_copy_2.at(x_ + ((y_ + 1) * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + ((y_ + 1) * 100)).scanned) {
						shadow_copy_2.at(x_ + ((y_ + 1) * 100)).scanned = true;
						after_process.push_back({ x_, y_ + 1 });
						new_tiles.push_back(x_ + ((y_ + 1) * 100));
					}
				} if (y_ > 0 and shadow_copy_2.at(x_ + ((y_ - 1) * 100)).locked and shadow_copy_2.at(x_ + ((y_ - 1) * 100)).lock_origin == (st_x + (st_y * 100))) {
					if (not shadow_copy_2.at(x_ + ((y_ - 1) * 100)).scanned) {
						shadow_copy_2.at(x_ + ((y_ - 1) * 100)).scanned = true;
						after_process.push_back({ x_, y_ - 1 });
						new_tiles.push_back(x_ + ((y_ - 1) * 100));
					}
				}
			}
			for (vector<int> cleanup : after_process) {
				shadow_copy_2.at(cleanup.at(0) + ((cleanup.at(1)) * 100)).scanned = false;
			}
			if (not reachable) {
				erase_later.push_back(i_);
			}
		}
		int er_ = 0;
		for (int a_ : erase_later) {
			int aa = a_ - er_;
			new_lock.erase(new_lock.begin() + aa);
			er_++;
		} return new_lock;
	}
	catch (out_of_range) {
		vector<vector<int>> asd{};
		return asd;
	}
}

void reset_(WorldBlock* block_, int x_, int y_, World* world_) {
	for (int i_ = 0; i_ < world_->machines.size(); i_++) {
		if (world_->machines[i_].x == x_ and world_->machines[i_].y == y_) {
			world_->machines.erase(world_->machines.begin() + i_);
			break;
		}
	}
	if (items[block_->fg].blockType == BlockTypes::MANNEQUIN) {
		block_->mannequin.c_hair = 0;
		block_->mannequin.c_shirt = 0;
		block_->mannequin.c_pants = 0;
		block_->mannequin.c_feet = 0;
		block_->mannequin.c_head = 0;
		block_->mannequin.c_hand = 0;
		block_->mannequin.c_back = 0;
		block_->mannequin.c_mask = 0;
		block_->mannequin.c_neck = 0;
	}
	else if (items[block_->fg].blockType == BlockTypes::BULLETIN_BOARD || items[block_->fg].blockType == BlockTypes::MAILBOX) {
		for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
			if (world_->bulletin[i_].x == x_ and world_->bulletin[i_].y == y_) {
				world_->bulletin.erase(world_->bulletin.begin() + i_);
				i_--;
			}
		}
	}
	else if (block_->fg == 12598) {
		block_->donates.clear();
		block_->shelf_1 = 0;
	}
	else if (block_->fg == 8246 || block_->fg == 10258 || block_->fg == 1436) {
		for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) {
			if (world_->cctv_settings[i_][0] == x_ and world_->cctv_settings[i_][1] == y_) {
				world_->cctv_settings.erase(world_->cctv_settings.begin() + i_);
				i_--;
			}
		}
		for (int i_ = 0; i_ < world_->cctv.size(); i_++) {
			if (world_->cctv[i_].x == x_ and world_->cctv[i_].y == y_) {
				world_->cctv.erase(world_->cctv.begin() + i_);
				i_--;
			}
		}
	}
	else if (block_->fg == 2646) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or world_->name != pInfo(currentPeer)->world or block_->heart_monitor != pInfo(currentPeer)->tankIDName) continue;
			pInfo(currentPeer)->spotlight = false;
			form_state(pInfo(currentPeer));
			update_clothes(currentPeer, true);
			gamepacket_t p, p2;
			p.Insert("OnConsoleMessage"), p.Insert("Back to anonymity. (`$In the Spotlight`` mod removed)"), p.CreatePacket(currentPeer);
			p2.Insert("OnTalkBubble"), p2.Insert(pInfo(currentPeer)->netID), p2.Insert("Lights out!"), p2.Insert(0), p2.Insert(0), p2.CreatePacket(currentPeer);
		}
	}
	else if (block_->fg == 2072) {
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or world_->name != pInfo(currentPeer)->world) continue;
			if (pInfo(currentPeer)->xenonite != 0) {
				pInfo(currentPeer)->xenonite = 0;
				update_clothes(currentPeer, true);
			}
		}
		world_->xenonite = 0;
	}
	if (block_->fg == 0) block_->bg = 0;
	else block_->fg = 0;
	block_->block_day = "";
	block_->kranken_pattern = 0;
	block_->shelf_1 = 0;
	block_->shelf_2 = 0;
	block_->shelf_3 = 0;
	block_->shelf_4 = 0;
	block_->id = 0;
	block_->hp = -1, block_->planted = 0, block_->fruit = 1,block_->txt = "";
	block_->wl = 0, block_->pr = 0, block_->c_ = 0;
	block_->door_destination = "", block_->door_id = "", block_->open = true;
	block_->flags = (block_->flags & 0x04000000 || block_->flags & 0x08000000 || block_->flags & 0x10000000 ? block_->flags : 0);
	block_->projectile_speed = 100, block_->rate_of_fire = 10;
	block_->enabled = false;
	block_->invert = false, block_->spin = false, block_->gravity = 50;
	block_->admins.clear();
	block_->owner_name = "";
	block_->build_only = false;
	block_->limit_admins = false;
	block_->crystals.clear();
	block_->r = 255;
	block_->g = 128;
	block_->b = 64;
	block_->portrait.c_expression = 1;
	block_->portrait.c_face = 0;
	block_->portrait.c_hair = 0;
	block_->portrait.c_hair_colour = 0;
	block_->portrait.c_head = 0;
	block_->portrait.c_skin = 0;
	block_->shelf_1 = 0;
	block_->heart_monitor = "";

}

string get_embed(string cch, string name) {
	return explode("|", explode(name + "|", cch)[1])[0];
}

void call_dialog(ENetPeer* p_, string cch) {
	if (pInfo(p_)->trading_with != -1 and cch.find("trade_") == string::npos) {
		cancel_trade(p_, false, true);
		return;
	}
	if (pInfo(p_)->world.empty() and not pInfo(p_)->tankIDName.empty()) return;
	stringstream ss(cch);
	if (cch.find("carnival") != string::npos) {
		stringstream ss(cch);
		string to = "", btn = "";
		bool ringmasterDialog = false;
		bool ringmasterGiveUp = false;
		while (getline(ss, to, '\n')) {
			vector<string> infoDat = explode("|", to);
			if (infoDat[0] == "buttonClicked") btn = infoDat[1];
			if (infoDat[0] == "dialog_name" and infoDat[1] == "carnival") ringmasterDialog = true;
			if (infoDat[0] == "dialog_name" and infoDat[1] == "carnival_give_up") ringmasterGiveUp = true;

			if (ringmasterDialog) {
				if (btn == "c_quest") {
					int removeTicket = -10;
					if (modify_inventory(p_, 1898, removeTicket) == 0) {
						pInfo(p_)->C_QuestActive = true;
						pInfo(p_)->CQ = true;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Quest For The Ring``|left|1900|\nadd_textbox|`oYou are about to embark on a magical journey! it won't be easy, but the reward is one of the fine rings from my vast collection. You don't get to pick which one, mind you.<CR>I've got a lot of rings sitting in my bag, with a lot of magical properties. If you want one, picked randomly at my discretion, you'll need to complete 10 little tasks for me.<CR>Doesn't sound so bad does it?<CR>Remember that i travel with the carnival, so if you don't get your quest done this time but don't worry because in GTPS i won't be travel somewhere and i will be here everyday!<CR>There's one last thing you should know before you begin. You can quit your quest at any time, but be aware that if you do, you'll lose all your progress, and you'll have to pay another 10 Golden Tickets to start again!``|\nadd_spacer|small|\nadd_label|small|`oSo... now that you've received the official disclaimer, are you truly prepared to hand over 10 Golden Tickets and embark on the Quest For The Ring?``|\nend_dialog|carnival|No!|Yes!|");
						p.CreatePacket(p_);
						break;
					}
				}
				else if (btn == "deliver") {
					if (pInfo(p_)->C_QuestKind == 1 or pInfo(p_)->C_QuestKind == 8) {
						if (pInfo(p_)->C_QuestStep != 10) {
							int adaBrp = 0;
							modify_inventory(p_, pInfo(p_)->C_DeliverID, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->C_QuestProgress + adaBrp > pInfo(p_)->C_ProgressNeeded) adaBrp = pInfo(p_)->C_ProgressNeeded - pInfo(p_)->C_QuestProgress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, pInfo(p_)->C_DeliverID, removeItem);
								pInfo(p_)->C_QuestProgress += adaBrp;
								if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
									pInfo(p_)->C_QuestProgress = 0;
									pInfo(p_)->C_QuestKind = 0;
									pInfo(p_)->C_QuestStep++;
									gamepacket_t p, p2;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest step complete!!");
									p2.Insert("OnParticleEffect");
									p2.Insert(48);
									p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
									p.CreatePacket(p_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											p2.CreatePacket(p_);
										}
									}
									RandomizeCQuest(p_);
									SendCarnivalQuest(p_, 500);
									break;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Thanks! Keep it coming!");
									p.CreatePacket(p_);
									break;
								}
							}
							else {
								goto GoodLuck;
							}
						}
						else {
							int adaBrp = 0;
							modify_inventory(p_, pInfo(p_)->C_DeliverID, adaBrp);
							if (adaBrp != 0) {
								if (pInfo(p_)->C_QuestProgress + adaBrp > pInfo(p_)->C_ProgressNeeded) adaBrp = pInfo(p_)->C_ProgressNeeded - pInfo(p_)->C_QuestProgress;
								int removeItem = 0 - adaBrp;
								modify_inventory(p_, pInfo(p_)->C_DeliverID, removeItem);
								pInfo(p_)->C_QuestProgress += adaBrp;
								if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
									int amount = 1;
									vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
									int randomRing = listRing[rand() % listRing.size()];
									modify_inventory(p_, randomRing, amount);
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("`9Quest completed!!");
									p.CreatePacket(p_);
									SendCmd(p_, "/cheer", true);
									// WEAR CLOTHES
									equip_clothes(p_, randomRing);
									string t_ = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0";
									BYTE* const d_ = new BYTE[5 + t_.length()];
									*(__int8*)(d_) = 3;
									memcpy(d_ + 4, t_.c_str(), t_.length());
									*(__int8*)(d_ + 4 + t_.length()) = 0;
									ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world) {
											gamepacket_t p3, p4;
											p3.Insert("OnParticleEffect");
											p3.Insert(73);
											p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
											p4.Insert("OnConsoleMessage");
											p4.Insert("`9>> " + get_player_nick(p_) + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
											p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
											enet_peer_send(currentPeer, 0, p_m);
										}
									}
									delete[]d_;
									pInfo(p_)->C_QuestProgress = 0;
									pInfo(p_)->C_ProgressNeeded = 0;
									pInfo(p_)->C_QuestStep = 1;
									pInfo(p_)->C_QuestActive = false;
									pInfo(p_)->C_QuestKind = 0;
									pInfo(p_)->C_DeliverID = 0;
									break;
								}
							}
							else {
								goto GoodLuck;
							}
						}
					}
					else if (pInfo(p_)->C_QuestKind == 7) {
						if (pInfo(p_)->C_QuestStep != 10) {
							int cost = pInfo(p_)->C_ProgressNeeded;
							if (pInfo(p_)->gems >= cost) {
									OnSetGems(p_, cost * -1);
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_QuestStep++;
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p2.CreatePacket(p_);
									}
								}
								RandomizeCQuest(p_);
								SendCarnivalQuest(p_, 500);
								break;
							}
							else {
								goto GoodLuck;
							}
						}
						else {
							int cost = pInfo(p_)->C_ProgressNeeded;
							if (pInfo(p_)->gems >= cost) {
								OnSetGems(p_, cost * -1);
								int amount = 1;
								vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
								int randomRing = listRing[rand() % listRing.size()];
								modify_inventory(p_, randomRing, amount);
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest completed!!");
								p.CreatePacket(p_);
								SendCmd(p_, "/cheer", true);
								// WEAR CLOTHES
								equip_clothes(p_, randomRing);
								string t_ = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0";
								BYTE* const d_ = new BYTE[5 + t_.length()];
								*(__int8*)(d_) = 3;
								memcpy(d_ + 4, t_.c_str(), t_.length());
								*(__int8*)(d_ + 4 + t_.length()) = 0;
								ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										gamepacket_t p3, p4;
										p3.Insert("OnParticleEffect");
										p3.Insert(73);
										p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
										p4.Insert("OnConsoleMessage");
										p4.Insert("`9>> " + get_player_nick(p_) + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
										p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
										enet_peer_send(currentPeer, 0, p_m);
									}
								}
								delete[]d_;
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_ProgressNeeded = 0;
								pInfo(p_)->C_QuestStep = 1;
								pInfo(p_)->C_QuestActive = false;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_DeliverID = 0;
								break;
							}
							else {
								goto GoodLuck;
							}
						}
					}
					else {
						if (pInfo(p_)->C_QuestStep != 10) {
							if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_QuestStep++;
								gamepacket_t p, p2;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest step complete!!");
								p2.Insert("OnParticleEffect");
								p2.Insert(48);
								p2.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
								p.CreatePacket(p_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										p2.CreatePacket(p_);
									}
								}
								RandomizeCQuest(p_);
								SendCarnivalQuest(p_, 500);
								break;
							}
							else {
								goto GoodLuck;
							}
						}
						else {
							if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
								int amount = 1;
								vector<int> listRing{ 1874, 1876, 1996, 2970, 1932, 3140, 1904, 1986, 3174, 6028, 6846, 8962, 11094 };
								int randomRing = listRing[rand() % listRing.size()];
								modify_inventory(p_, randomRing, amount);
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("`9Quest completed!!");
								p.CreatePacket(p_);
								SendCmd(p_, "/cheer", true);
								// WEAR CLOTHES
								equip_clothes(p_, randomRing);
								string t_ = "action|play_sfx\nfile|audio/achievement.wav\ndelayMS|0";
								BYTE* const d_ = new BYTE[5 + t_.length()];
								*(__int8*)(d_) = 3;
								memcpy(d_ + 4, t_.c_str(), t_.length());
								*(__int8*)(d_ + 4 + t_.length()) = 0;
								ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										gamepacket_t p3, p4;
										p3.Insert("OnParticleEffect");
										p3.Insert(73);
										p3.Insert((float)pInfo(p_)->x + 10, (float)pInfo(p_)->y + 16);
										p4.Insert("OnConsoleMessage");
										p4.Insert("`9>> " + get_player_nick(p_) + " `9has completed the Quest For The Ring and earned the " + items[randomRing].ori_name + "!");
										p3.CreatePacket(currentPeer), p4.CreatePacket(currentPeer);
										enet_peer_send(currentPeer, 0, p_m);
									}
								}
								delete[]d_;
								pInfo(p_)->C_QuestProgress = 0;
								pInfo(p_)->C_ProgressNeeded = 0;
								pInfo(p_)->C_QuestStep = 1;
								pInfo(p_)->C_QuestActive = false;
								pInfo(p_)->C_QuestKind = 0;
								pInfo(p_)->C_DeliverID = 0;
								break;
							}
							else {
								goto GoodLuck;
							}
						}
					}
				GoodLuck:
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("`9Good luck! You can do it!");
					p.CreatePacket(p_);
					break;
				}
				else if (btn == "give_up") {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("\nadd_label_with_icon|big|`9Quest For The Ring|left|1900|\nadd_textbox|`oIf you quit, any progress you've made will be lost forever.<CR>There is no benefit to quitting the Ring Quest, except that you can start over and hope for easier tasks (not likely!). You'll also have to pay 10 more Golden Tickets when you start again.``|\nadd_spacer|small|\nadd_label|small|`4Are you absolutely sure you want to quit this quest?``|\nadd_spacer|small|\nend_dialog|carnival_give_up|`wNo!|`wYes!|\nadd_quick_exit|\n");
					p.CreatePacket(p_);
					break;
				}
				else if (pInfo(p_)->CQ) {
					RandomizeCQuest(p_);
					SendCarnivalQuest(p_, 500);
					break;
				}
			}
			if (ringmasterGiveUp) {
				pInfo(p_)->C_QuestActive = false;
				pInfo(p_)->C_QuestKind = 0;
				pInfo(p_)->C_DeliverID = 0;
				pInfo(p_)->C_QuestStep = 1;
				pInfo(p_)->C_ProgressNeeded = 0;
				pInfo(p_)->C_QuestProgress = 0;
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("`9Okay! You are no longer on the Ring Quest! Good luck!");
				p.CreatePacket(p_);
				break;
			}
		}
	}
	string to = "", btn = "";
	bool kranken = false;
	bool kranken_pattern = false;
	while (getline(ss, to, '\n')) {
		vector<string> infoDat = explode("|", to);
		if (infoDat.size() == 2) {
			if (infoDat[0] == "buttonClicked") btn = infoDat[1];
			if (infoDat[0] == "dialog_name" && infoDat[1] == "kranken_edit") kranken = true;
			if (infoDat[0] == "dialog_name" && infoDat[1] == "kranken_edit_pattern") kranken_pattern = true;
			if (kranken) {
				int x = atoi(get_embed(cch, "tilex").c_str());
				int y = atoi(get_embed(cch, "tiley").c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					int k_r = atoi(get_embed(cch, "kranken_r").c_str());;
					int k_g = atoi(get_embed(cch, "kranken_g").c_str());;
					int k_b = atoi(get_embed(cch, "kranken_b").c_str());;
					if (k_r < 0 or k_r > 255 or k_g < 0 or k_g > 255 or k_b < 0 or k_b > 255) break;
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (items[block_->fg].blockType != BlockTypes::KRANKEN) break;
					if (btn == "kranken_block_pattern") {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert(
							"set_default_color|`o\n"
							"add_label_with_icon|big|`wSelect Pattern``|left|10962|\n"
							"add_spacer|small|\n"
							"add_button_with_icon|0|Pattern 0||10962||\n"
							"add_button_with_icon|1|Pattern 1||10964||\n"
							"add_button_with_icon|2|Pattern 2||10966||\n"
							"add_button_with_icon|3|Pattern 3||10968||\n"
							"add_button_with_icon|4|Pattern 4||10970||\n"
							"add_button_with_icon|5|Pattern 5||10972||\n"
							"add_button_with_icon||END_ROW|noflags|0||\n"
							"add_spacer|big|\n"
							"add_button_with_icon|6|Pattern 6||10974||\n"
							"add_button_with_icon|7|Pattern 7||10976||\n"
							"add_button_with_icon|8|Pattern 8||10978||\n"
							"add_button_with_icon|9|Pattern 9||10980||\n"
							"add_button_with_icon|10|Pattern 10||10982||\n"
							"add_button_with_icon|11|Pattern 11||10984||\n"
							"add_button_with_icon||END_ROW|noflags|0||\n"
							"add_spacer|big|\n"
							"add_button_with_icon|12|Pattern 12||10986||\n"
							"add_button_with_icon||END_ROW|noflags|0||\n"
							"add_spacer|big|\n"
							"end_dialog|kranken_edit_pattern||Cancel|\n"
							"embed_data|tilex|" + to_string(x) + "|\n"
							"embed_data|tiley|" + to_string(y) + "|\n"
							"embed_data|pattern|" + to_string(block_->kranken_pattern) + "|\n"
							"embed_data|kranken_r|" + get_embed(cch, "kranken_r") + "|\n"
							"embed_data|kranken_g|" + get_embed(cch, "kranken_g") + "|\n"
							"embed_data|kranken_b|" + get_embed(cch, "kranken_b") + "|"
						);
						p.CreatePacket(p_);
					}
					if (infoDat[0] == "kranken_world_save") {
						if (infoDat[1] == "1") {
							world_->r = k_r;
							world_->g = k_g;
							world_->b = k_b;
						}
					}

					block_->r = k_r;
					block_->g = k_g;
					block_->b = k_b;
					block_->kranken_pattern = atoi(get_embed(cch, "pattern").c_str());
					block_->fg = kranken_pattern::get_pattern(block_->kranken_pattern).second;
					tile_update(p_, world_, block_, x, y);
					return;
				}
			}
			if (kranken_pattern) {
				int x = atoi(get_embed(cch, "tilex").c_str());
				int y = atoi(get_embed(cch, "tiley").c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x + (y * 100)];
					if (btn == "0" or btn == "1" or btn == "2" or btn == "3" or btn == "4" or btn == "5" or btn == "6" or btn == "7" or btn == "8" or btn == "9" or btn == "10" or btn == "11" or btn == "12" or btn == "13") {
						string k_r = get_embed(cch, "kranken_r");
						string k_g = get_embed(cch, "kranken_g");
						string k_b = get_embed(cch, "kranken_b");
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert(
							"set_default_color|`o\n"
							"add_label_with_icon|big|`wKranken's Galactic Block``|left|10962|\n"
							"add_spacer|small|\n"
							"add_custom_textbox|`wAdjust the color of your block here, by including 0-255 of Red, Green and Blue.`|size:medium|\n"
							"add_text_input|kranken_r|Red|" + k_r + "|3|\n"
							"add_text_input|kranken_g|Green|" + k_g + "|3|\n"
							"add_text_input|kranken_b|Blue|" + k_b + "|3|\n"
							"add_spacer|small|\n"
							"add_custom_textbox|`wPick one of the available patterns for your block.`|size:medium|\n"
							"add_button_with_icon|kranken_block_pattern|||" + to_string(kranken_pattern::get_pattern(atoi(btn.c_str())).second) + "||\n"
							"add_button_with_icon||END_LIST|noflags|0||\n"
							"add_checkbox|kranken_world_save|Set this color as the default for this world.|0\n"
							"end_dialog|kranken_edit|Cancel|Save|\n"
							"add_quick_exit|\n"
							"embed_data|tilex|" + to_string(x) + "|\n"
							"embed_data|tiley|" + to_string(y) + "|\n"
							"embed_data|pattern|" + btn + "|"
						);
						p.CreatePacket(p_);
					}
				}
			}
		}
	}
	vector<string> a_ = explode("|", replace_str(cch, "\n", "|"));
	for (int i_ = 0; i_ < a_.size(); i_++) {
		if (a_[i_] == "dispshelf") {
			if (a_.size() != 13 and a_.size() != 14) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break; 
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::Display_Shelf || block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
				for (int b_ = 0; b_ < a_.size(); b_++) {
					if (a_[b_] == "replace1" || a_[b_] == "replace2" || a_[b_] == "replace3" || a_[b_] == "replace4") {
						if (a_.size() >= (b_ + 1) - 1) {
							if (not isdigit(a_[b_ + 1][0])) break;
							int item_id = atoi(a_[b_ + 1].c_str());
							if (item_id <= 0 || item_id >= items.size()) break;
							if (items[item_id].untradeable || item_id == 1424 || item_id == 5816 || items[item_id].blockType == BlockTypes::FISH) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("You can't display untradeable items.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								return;
							}
							if ((a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4) != 0) {
								int b = 1;
								if (modify_inventory(p_, (a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4), b) == 0) {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Picked up 1 " + items[(a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + ".");
									p.CreatePacket(p_);
									if (pInfo(p_)->dev)send_logs(pInfo(p_)->tankIDName + " stole `" + items[(a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + "` in(" + pInfo(p_)->world + ") from Display Shelf", "Display Shelf");
									(a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4) = 0;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("No room to take " + items[(a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + ".");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
							}
							int b = -1;
							if (modify_inventory(p_, item_id, b) == 0) {
								(a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4) = item_id;
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Put " + items[(a_[b_] == "replace1" ? block_->shelf_1 : a_[b_] == "replace2" ? block_->shelf_2 : a_[b_] == "replace3" ? block_->shelf_3 : block_->shelf_4)].name + " on display.");
								p.CreatePacket(p_);
							}
						}
					}
					else if (a_[b_] == "remove") {
						if (block_->shelf_1 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_1, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_1].name + ".");
								p.CreatePacket(p_);
								if (pInfo(p_)->dev)send_logs(pInfo(p_)->tankIDName + " stole `" + items[block_->shelf_1].name + "` in(" + pInfo(p_)->world + ") from Display Shelf", "Display Shelf");
								block_->shelf_1 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_1].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_2 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_2, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_2].name + ".");
								p.CreatePacket(p_);
								if (pInfo(p_)->dev)send_logs(pInfo(p_)->tankIDName + " stole `" + items[block_->shelf_2].name + "` in(" + pInfo(p_)->world + ") from Display Shelf", "Display Shelf");
								block_->shelf_2 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_2].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_3 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_3, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_3].name + ".");
								p.CreatePacket(p_);
								if (pInfo(p_)->dev)send_logs(pInfo(p_)->tankIDName + " stole `" + items[block_->shelf_3].name + "` in(" + pInfo(p_)->world + ") from Display Shelf", "Display Shelf");
								block_->shelf_3 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_3].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						if (block_->shelf_4 != 0) {
							int b = 1;
							if (modify_inventory(p_, block_->shelf_4, b) == 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Picked up 1 " + items[block_->shelf_4].name + ".");
								p.CreatePacket(p_);
								if (pInfo(p_)->dev)send_logs(pInfo(p_)->tankIDName + " stole `" + items[block_->shelf_4].name + "` in(" + pInfo(p_)->world + ") from Display Shelf", "Display Shelf");
								block_->shelf_4 = 0;
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("No room to take " + items[block_->shelf_4].name + ".");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								break;
							}
						}
						break;
					}
				}
				tile_update(p_, world_, block_, x_, y_);
			}
			return;
		}
		else if (a_[i_] == "sdbrespond") {
				join_world(p_, World_Stuff.lastsdbworld);
			return;
		}
		else if (a_[i_] == "sdbsend") {
			if (a_.size() != 11) break;
			string line_1 = a_[i_ + 2];
			string line_2 = a_[i_ + 4];
			string line_3 = a_[i_ + 6];
			if (line_1.empty() and line_2.empty() and line_3.empty()) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(p_)->netID);
				p.Insert("`5[`2I'm not wasting Growtokens on an empty broadcast!``]``");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(p_);
				break;
			}
			if (has_playmod2(pInfo(p_), 3)) {
				int time_ = 0;
				for (PlayMods peer_playmod : pInfo(p_)->playmods) {
					if (peer_playmod.id == 13) {
						time_ = peer_playmod.time - time(nullptr);
						break;
					}
				}
				packet_(p_, "action|log\nmsg|>> (" + to_playmod_time(time_) + " before you can broadcast again)", "");
				return;
			}
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				bool jammed = find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? true : false;
				if (pInfo(p_)->m_h == 1) jammed = true;
				int b = -200;
				int totaltoken = 0, tokencount = 0, mega_token = 0, token = 200;
				modify_inventory(p_, 1486, tokencount);
				modify_inventory(p_, 6802, mega_token);
				totaltoken = tokencount + (mega_token * 100);
				if (totaltoken < token) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You need 200 Growtoken to do this!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You need 200 Growtoken to do this!");
						p.CreatePacket(p_);
					}
				}
				else {
					{
						add_playmod(p_, 13);
						packet_(p_, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
					}
					gamepacket_t p;
					p.Insert("OnSDBroadcast");
					p.Insert((get_player_nick(p_) + "``") + "\n" + (jammed ? "`4JAMMED!``" : pInfo(p_)->world) + "\n" + line_1 + "\n" + line_2 + "\n" + line_3);
					p.Insert(jammed ? 0 : 1);
					if (not jammed) {
						World_Stuff.lastsdbworld = pInfo(p_)->world;
						World_Stuff.lastsbworld = pInfo(p_)->world;
					}
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio or pInfo(currentPeer)->temp_radio or pInfo(currentPeer)->surgery_started or pInfo(currentPeer)->world.empty()) continue;
						p.CreatePacket(currentPeer);
					}
					if (tokencount >= token) modify_inventory(p_, 1486, token *= -1);
					else {
						modify_inventory(p_, 1486, tokencount *= -1);
						modify_inventory(p_, 6802, mega_token *= -1);
						int givemegatoken = (totaltoken - token) / 100;
						int givetoken = (totaltoken - token) - (givemegatoken * 100);
						modify_inventory(p_, 1486, givetoken);
						modify_inventory(p_, 6802, givemegatoken);
					}
				}
			}
			return;
		}
		else if (a_[i_] == "portrait") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				if (x_ < 0  or y_ < 0 ) break;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (y_ >= world_->max_y || x_ >= world_->max_x) break;
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::PORTRAIT|| block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.size() > b_ + 1) {
							if (a_.at(b_ + 1) == "chk1") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 1;
								}
							}
							else if (a_.at(b_ + 1) == "chk2") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 2;
								}
							}
							else if (a_.at(b_ + 1) == "chk3") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 3;
								}
							}
							else if (a_.at(b_ + 1) == "chk4") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 4;
								}
							}
							else if (a_.at(b_ + 1) == "chk5") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 5;
								}
							}
							else if (a_.at(b_ + 1) == "chk6") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 6;
								}
							}
							else if (a_.at(b_ + 1) == "chk7") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 7;
								}
							}
							else if (a_.at(b_ + 1) == "chk9") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 9;
								}
							}
							else if (a_.at(b_ + 1) == "chk11") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 11;
								}
							}
							else if (a_.at(b_ + 1) == "chk12") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 12;
								}
							}
							else if (a_.at(b_ + 1) == "chk14") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 14;
								}
							}
							else if (a_.at(b_ + 1) == "chk16") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 16;
								}
							}
							else if (a_.at(b_ + 1) == "chk18") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 18;
								}
							}
							else if (a_.at(b_ + 1) == "chk22") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 22;
								}
							}
							else if (a_.at(b_ + 1) == "chk27") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 27;
								}
							}
							else if (a_.at(b_ + 1) == "chk28") {
								if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
								if (a_.size() >= (b_ + 2) - 1) {
									if (not isdigit(a_.at(b_ + 2).at(0))) break;
									if (a_.at(b_ + 2) == "1") block_->portrait.c_expression = 28;
								}
							}
						}
						if (a_.at(b_) == "erase") {
							int b = -4;
							if (modify_inventory(p_, 3492, b) == 0) {
								block_->portrait.c_expression = 1;
								block_->portrait.c_skin = 0;
								block_->portrait.c_face = 0;
								block_->portrait.c_head = 0;
								block_->portrait.c_hair = 0;
							}
						}
						else if (a_.at(b_) == "playerNetID") {
							if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) {
								if (a_.size() >= (b_ + 1) - 1) {
									if (not isdigit(a_.at(b_ + 1).at(0))) break;
									uint32_t netID = atoi(a_.at(b_ + 1).c_str());
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == netID) {
											int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
											{
												modify_inventory(p_, 3478, red);
												modify_inventory(p_, 3480, yellow);
												modify_inventory(p_, 3482, green);
												modify_inventory(p_, 3484, aqua);
												modify_inventory(p_, 3486, blue);
												modify_inventory(p_, 3488, purple);
												modify_inventory(p_, 3490, charcoal);
												modify_inventory(p_, 3492, varnish);
												if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
													red = -2, yellow = -2, green = -2, aqua = -2, blue = -2, purple = -2, charcoal = -2, varnish = -2;
													if (modify_inventory(p_, 3478, red) == 0 and modify_inventory(p_, 3480, yellow) == 0 and modify_inventory(p_, 3482, green) == 0
														and modify_inventory(p_, 3484, aqua) == 0 and modify_inventory(p_, 3486, blue) == 0 and modify_inventory(p_, 3488, purple) == 0
														and modify_inventory(p_, 3490, charcoal) == 0 and modify_inventory(p_, 3492, varnish) == 0) {
														block_->portrait.c_expression = 1;
														block_->portrait.c_skin = pInfo(currentPeer)->skin;
														block_->portrait.c_face = pInfo(currentPeer)->face;
														block_->portrait.c_head = pInfo(currentPeer)->hair;
														block_->portrait.c_hair = pInfo(currentPeer)->mask;
														block_->txt = pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName;
													}
												}
											}
											break;
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "artname") {
							if (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0) continue;
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_.at(b_ + 1);
								if (txt.size() > 60) break;
								block_->txt = txt;
							}
						}
					}
					tile_update(p_, world_, block_, x_, y_);
				}
			}
			catch (out_of_range) {
				return;
			}
			return;
		}
		else if (a_.at(i_) == "artcanvas") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				if (x_ < 0  or y_ < 0) break;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (y_ >= world_->max_y || x_ >= world_->max_x) break;
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::Painting_Easel || block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.at(b_) == "erase") {
							int b = -4;
							if (modify_inventory(p_, 3492, b) == 0) {
								block_->id = 0;
							}
						}
						else if (a_.at(b_) == "paint") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (not isdigit(a_.at(b_ + 1).at(0))) break;
								int item_id = atoi(a_.at(b_ + 1).c_str());
								if (item_id <= 0 || item_id >= items.size()) break;
								int kiek_turi = 0;
								modify_inventory(p_, item_id, kiek_turi);
								if (kiek_turi == 0) break;
								{
									int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
									{
										modify_inventory(p_, 3478, red);
										modify_inventory(p_, 3480, yellow);
										modify_inventory(p_, 3482, green);
										modify_inventory(p_, 3484, aqua);
										modify_inventory(p_, 3486, blue);
										modify_inventory(p_, 3488, purple);
										modify_inventory(p_, 3490, charcoal);
										modify_inventory(p_, 3492, varnish);
										if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
											red = -2, yellow = -2, green = -2, aqua = -2, blue = -2, purple = -2, charcoal = -2, varnish = -2;
											if (modify_inventory(p_, 3478, red) == 0 and modify_inventory(p_, 3480, yellow) == 0 and modify_inventory(p_, 3482, green) == 0
												and modify_inventory(p_, 3484, aqua) == 0 and modify_inventory(p_, 3486, blue) == 0 and modify_inventory(p_, 3488, purple) == 0
												and modify_inventory(p_, 3490, charcoal) == 0 and modify_inventory(p_, 3492, varnish) == 0) {
												block_->id = item_id;
											}
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "artname") {
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_.at(b_ + 1);
								if (txt.size() > 60) break;
								block_->txt = txt;
							}
						}
					}
					tile_update(p_, world_, block_, x_, y_);
				}
			}
			catch (out_of_range) {
				cout << "crash try by " << pInfo(p_)->tankIDName << endl;
				return;
			}
			return;
		}
		else if (a_[i_] == "mannequin_edit") {
			if (a_.size() == 14) { // put item
				if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[i_ + 8][0])) break;
				int x_ = 0, y_ = 0, tile_ = 0;
				try {
					x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str()), tile_ = atoi(a_[i_ + 8].c_str());
				}
				catch (out_of_range) {
					return;
				}
				if (x_ < 0 or y_ < 0) break;
				if (tile_ <= 0 || tile_ >= items.size()) break;
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					if (y_ >= world_->max_y || x_ >= world_->max_x) break;
					if (items[tile_].blockType != CLOTHING or items[tile_].untradeable or items[tile_].clothType == ClothTypes::ANCES) return;
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::MANNEQUIN || block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
					uint16_t current_mannequin_item = 0;
					switch (items[tile_].clothingType) {
					case 0: current_mannequin_item = block_->mannequin.c_hair;
						break;
					case 1: current_mannequin_item = block_->mannequin.c_shirt;
						break;
					case 2: current_mannequin_item = block_->mannequin.c_pants;
						break;
					case 3: current_mannequin_item = block_->mannequin.c_feet;
						break;
					case 4: current_mannequin_item = block_->mannequin.c_head;
						break;
					case 5: current_mannequin_item = block_->mannequin.c_hand;
						break;
					case 6: current_mannequin_item = block_->mannequin.c_back;
						break;
					case 7: current_mannequin_item = block_->mannequin.c_mask;
						break;
					case 8: current_mannequin_item = block_->mannequin.c_neck;
						break;
					case 9: {
						return;
					}
					} if (current_mannequin_item == tile_) {
						return;
					}
					else {
						if (current_mannequin_item != 0) {
							int b = 1;
							if (modify_inventory(p_, int(current_mannequin_item), b) != 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("`5[`2You don't have inventory space!``]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);
								return;
							}
						}
						int c_ = -1;
						if (modify_inventory(p_, tile_, c_) == 0) {
							switch (items[tile_].clothingType) {
							case 0: block_->mannequin.c_hair = tile_;
								break;
							case 1: block_->mannequin.c_shirt = tile_;
								break;
							case 2: block_->mannequin.c_pants = tile_;
								break;
							case 3: block_->mannequin.c_feet = tile_;
								break;
							case 4: block_->mannequin.c_head = tile_;
								break;
							case 5: block_->mannequin.c_hand = tile_;
								break;
							case 6: block_->mannequin.c_back = tile_;
								break;
							case 7: block_->mannequin.c_mask = tile_;
								break;
							case 8: block_->mannequin.c_neck = tile_;
								break;
							case 9: {
								return;
							}
							}
							gamepacket_t p(0, pInfo(p_)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/change_clothes.wav");
							tile_update(p_, world_, block_, x_, y_);
						}
					}
				}
			}
			else {
				if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
				int x_ = 0, y_ = 0;
				try {
					x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
				}
				catch (out_of_range) {
					return;
				}
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::MANNEQUIN || block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
					bool clear_all = false;
					int fkthis = 0;
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_].substr(0, 9) == "checkbox_") {
							if (a_.size() >= (b_ + 1) - 1) {
								vector<string> target_ = explode("_", a_[b_]);
								if (not isdigit(target_[1][0])) continue;
								int item_remove = atoi(target_[1].c_str());
								int aa = 1;
								if (item_remove <= 0 || item_remove >= items.size()) continue;
								if (a_[b_ + 1] == "1" or clear_all) {
									if (block_->mannequin.c_hair != item_remove and block_->mannequin.c_shirt != item_remove and block_->mannequin.c_pants != item_remove and block_->mannequin.c_feet != item_remove
										and block_->mannequin.c_head != item_remove and block_->mannequin.c_hand != item_remove and block_->mannequin.c_back != item_remove
										and block_->mannequin.c_mask != item_remove and block_->mannequin.c_neck != item_remove) return;
									if (modify_inventory(p_, item_remove, aa) == 0) {
										switch (items[item_remove].clothingType) {
										case 0: block_->mannequin.c_hair = 0;
											break;
										case 1: block_->mannequin.c_shirt = 0;
											break;
										case 2: block_->mannequin.c_pants = 0;
											break;
										case 3: block_->mannequin.c_feet = 0;
											break;
										case 4: block_->mannequin.c_head = 0;
											break;
										case 5: block_->mannequin.c_hand = 0;
											break;
										case 6: block_->mannequin.c_back = 0;
											break;
										case 7: block_->mannequin.c_mask = 0;
											break;
										case 8: block_->mannequin.c_neck = 0;
											break;
										}
									}
								}
							}
						}
						else if (a_[b_] == "buttonClicked") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (a_[b_ + 1] == "clear") clear_all = true;
							}
						}
						else if (a_[b_] == "sign_text") {
							if (a_.size() >= (b_ + 1) - 1) {
								string txt = a_[b_ + 1];
								if (txt.size() > 128) break;
								block_->txt = txt;
							}
						}
					}
					tile_update(p_, world_, block_, x_, y_);
				}
			}
			return;
		}
		else if (a_.at(i_) == "vip_edit") {
			try {
				if (not isdigit(a_.at(i_ + 2).at(0)) or not isdigit(a_.at(i_ + 5).at(0))) break;
				int x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					WorldBlock* block_ = &world_->blocks.at(x_ + (y_ * 100));
					uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
					if (items[t_].blockType != BlockTypes::VIP_ENTRANCE) break;
					if (to_lower(world_->owner_name) != to_lower(pInfo(p_)->tankIDName)) break;
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_.at(b_).substr(0, 9) == "checkbox_") {
							vector<string> target_ = explode("_", a_.at(b_));
							if (target_.at(1) == "public") {
								if (not block_->limit_admins and a_.at(b_ + 1) == "1") {
									block_->limit_admins = true;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(get_player_nick(p_) + " has set a `$VIP Entrance`` to `$PUBLIC");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
								else if (block_->limit_admins and a_[b_ + 1] == "0") {
									block_->limit_admins = false;
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(get_player_nick(p_) + " has set a `$VIP Entrance`` to `4PRIVATE``");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
							else if (target_.size() == 2 and a_.at(b_ + 1) == "0") {
								string user_name = target_.at(1);
								if (find(block_->admins.begin(), block_->admins.end(), to_lower(user_name)) != block_->admins.end()) {
									block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), to_lower(user_name)), block_->admins.end());
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert(user_name + " was removed from a VIP List.");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(user_name)) {
											packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(currentPeer)->netID);
											if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
											p.Insert(get_player_nick(p_) + " has `4removed`` you from a VIP List in `w" + world_->name + "``.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(currentPeer);
										}
										if (pInfo(currentPeer)->world == world_->name) {
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
						}
						else if (a_.at(b_) == "playerNetID") {
							if (a_.size() >= (b_ + 1) - 1) {
								if (not isdigit(a_.at(b_ + 1).at(0))) break;
								uint32_t netID = atoi(a_.at(b_ + 1).c_str());
								if (netID == pInfo(p_)->netID) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("I'm already a VIP!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
								if (block_->admins.size() >= 26) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("VIP Entrance has reached access limit!");
									p.Insert(0);
									p.Insert(0);
									p.CreatePacket(p_);
									continue;
								}
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == world_->name and pInfo(currentPeer)->netID == netID) {
										if (find(block_->admins.begin(), block_->admins.end(), to_lower(pInfo(currentPeer)->tankIDName)) != block_->admins.end()) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert(get_player_nick(currentPeer) + " is already on the VIP list.");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(p_);
											return;
										}
										block_->admins.push_back(to_lower(pInfo(currentPeer)->tankIDName));
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Put " + get_player_nick(currentPeer) + " on the VIP List.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(get_player_nick(currentPeer) + " was added to a VIP List.");
											for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
												if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
												if (pInfo(currentPeer2)->world == world_->name) {
													p.CreatePacket(currentPeer2);
												}
											}
										}
										break;
									}
								}
								break;
							}
						}
					}
					tile_update(p_, world_, block_, x_, y_);
				}
			}
			catch (out_of_range) {
				return;
			}
			catch (exception) {
				return;
			}
			return;
		}
		else if (a_[i_] == "sellstuff") {
			if (a_.size() != 8) break;
			string itemChosen = a_[5];
			vector<string> cv = explode("_", itemChosen);
			if (cv.size() != 2) break;
			int itemID = atoi(cv[1].c_str()), amount = 0;
			int adaBrp = 0;
			modify_inventory(p_, itemID, adaBrp);
			// Selling Dirt
			vector<pair<int, int>>::iterator pz = find_if(janeway_.janeway_item.begin(), janeway_.janeway_item.end(), [&](const pair < int, int>& element) { return element.first == itemID; });
			if (pz != janeway_.janeway_item.end()) {
				if (adaBrp == 200) {
					amount = 200;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Confirmation``|left|242|\nembed_data|sellID|" + to_string(itemID) + "_" + to_string(amount) + "|\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + to_string(amount) + " " + items[itemID].ori_name + "|left|" + to_string(itemID) + "|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|"+to_string(janeway_.janeway_item[pz - janeway_.janeway_item.begin()].second) + " "+items[janeway_.janeway_payout].ori_name + "|left|" + to_string(janeway_.janeway_payout) + "|\nadd_spacer|small|\nadd_button|accept|Do The Trade!|noflags|0|0|\nadd_button|back|Cancel|noflags|0|0|\nend_dialog|sellstuffconfirm|||");
					p.CreatePacket(p_);
				}
				else {
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("Janeway only intrested in buying 200pcs of item at once");
					p.CreatePacket(p_);
				}
			}
		}
		else if (a_[i_] == "sellstuffconfirm") {
			if (a_.size() != 12) break;
			string checkItem = a_[5];
			string buttonClick = explode("\n", explode("buttonClicked|", cch)[1])[0];
			vector<string> buttonClicked = explode("|", buttonClick);
			if (buttonClicked[0] == "back") {
				janeway(p_);
				break;
			}
			else {
				vector<string> x = explode("_", checkItem);
				if (not isdigit(x[0][0]) and not isdigit(x[1][0])) break;
				int sellID = atoi(x[0].c_str()), sellAmount = atoi(x[1].c_str()), adaBrp = 0, removeItem = -sellAmount, itemPrice = 0;
				modify_inventory(p_, sellID, adaBrp);
				if (adaBrp != sellAmount) break;
				if (adaBrp == sellAmount) {
					vector<pair<int, int>>::iterator pz = find_if(janeway_.janeway_item.begin(), janeway_.janeway_item.end(), [&](const pair < int, int>& element) { return element.first == sellID; });
					if (pz != janeway_.janeway_item.end()) {
						itemPrice = janeway_.janeway_item[pz - janeway_.janeway_item.begin()].second;
						if (modify_inventory(p_, sellID, removeItem) == 0) {
							gamepacket_t p2;
							p2.Insert("OnConsoleMessage");
							p2.Insert("`1You`` traded " + to_string(sellAmount) + " " + items[sellID].ori_name + " to janeway_.``");
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`1Janeway`` traded " + to_string(itemPrice) + " " + items[janeway_.janeway_payout].ori_name + " to You.``");
							p2.CreatePacket(p_), p.CreatePacket(p_);
							modify_inventory(p_, janeway_.janeway_payout, itemPrice);
						}
						{
							gamepacket_t p(1250, pInfo(p_)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/keypad_hit.wav");
							p.CreatePacket(p_), p.CreatePacket(p_);
						}
					}
					break;
				}
			}
		}
		else if (a_[i_] == "crystal_exchange") {
			if (a_.size() != 14) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[11][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			int item_id = atoi(a_[11].c_str());
			if (item_id <= 0 || item_id >= items.size()) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::CRYSTAL) break;
				if (block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
				vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
				for (int i = 0; i < block_->crystals.size(); i++) {
					vector<int> c_ = block_->crystals[i];
					for (int a = 0; a < current_.size(); a++) {
						if (current_[a][0] == c_[0]) {
							current_[a][1] = block_->crystals[i][1];
							break;
						}
					}
				}
				for (vector<vector<int>> a_ : crystal_receptai) {
					if (a_[5][0] == item_id) {
						bool can_ = true;
						for (vector<int> b_ : a_) {
							for (int i = 0; i < current_.size(); i++) {
								if (current_[i][0] == b_[0] and current_[i][1] < b_[1]) {
									can_ = false;
									break;
								}
							} if (not can_) {
								break;
							}
						} if (can_) {
							if (pInfo(p_)->C_QuestActive && pInfo(p_)->C_QuestKind == 12 && pInfo(p_)->C_QuestProgress < pInfo(p_)->C_ProgressNeeded) {
								pInfo(p_)->C_QuestProgress++;
								if (pInfo(p_)->C_QuestProgress >= pInfo(p_)->C_ProgressNeeded) {
									pInfo(p_)->C_QuestProgress = pInfo(p_)->C_ProgressNeeded;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
								}
							}
							PlayerMoving data_{};
							data_.packetType = 0x11, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
							data_.YSpeed = 97, data_.XSpeed = t_;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[] raw;
							{
								if (pInfo(p_)->grow4good_crystal < 4) daily_quest(p_, false, "crystal", 1);
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("The crystal shatters and drops " + items[a_[5][0]].name + "!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(p_);

								WorldDrop drop_block_{};
								drop_block_.id = a_[5][0], drop_block_.count = a_[5][1],  drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
								dropas_(world_, drop_block_);
							}
							reset_(block_, x_, y_, world_);
							tile_update(p_, world_, block_, x_, y_);
						}
						else {
							break;
						}
						break;
					}
				}
			}
			return;
		}
		else if (a_[i_] == "nupirkti") {
			if (a_.size() != 17 and a_.size() != 14) break;
			if (not isdigit(a_[8][0]) or not isdigit(a_[11][0])) break;
			string item_name = a_[5];
			int item_id = atoi(a_[8].c_str());
			int item_price = atoi(a_[11].c_str());
			if (a_.size() == 17) {
				SendCmd(p_, "/buy " + item_name, true);
				break;
			}
			if (pInfo(p_)->buy_role) {
				for (int i_ = 0; i_ < items.size(); i_++) {
					uint32_t item_ids = items[i_].id;
					if (items[i_].ori_name == items[item_id].ori_name) {

						if (!pInfo(p_)->Staff) {
							if (items[i_].id == 274 || items[i_].id == 276 || items[i_].id == 8470 || items[i_].id == 278 || items[i_].id == 732 || items[i_].id == 7188) continue;
							if (items[i_].id == 1488 or items[i_].id == 9902 or items[i_].id == 10716) continue;
							if (items[i_].blockType == CONSUMABLE) continue;
							if (items[i_].blockType == CLOTHING) continue;
							if (i_ == 9386 or i_ == 7960 or i_ == 5136 or i_ == 1486 or i_ == 4490) continue;
							if (i_ == 9918 or i_ == 9770 or i_ == 9772 or i_ == 9846 or i_ == 9906 or i_ == 9908 or i_ == 10290 or i_ == 10362 or i_ == 13702 or i_ == 13706 or i_ == 13698 or i_ == 13700 or i_ == 13704 or i_ == 13682 or i_ == 13680) continue;
							if (i_ == 7960 or i_ == 9902 or i_ == 9814 or i_ == 9384 or i_ == 5136 or i_ == 9976 or i_ == 10266 or i_ == 9850 or i_ == 5638) continue;
							if (i_ == 5714 or i_ == 9928 or i_ == 542 or i_ == 1488 or i_ == 5138 or i_ == 5140 or i_ == 5142 or i_ == 10394 or i_ == 4490) continue;

						}
						if (!pInfo(p_)->give_role) {
							if (i_ == 1458) continue;
							if (items[i_].name.find("Legendary") != string::npos) continue;
							if (items[i_].name.find("Legend") != string::npos) continue;
							if (items[i_].blockType == LOCK) continue;
						}
						uint32_t item_id = items[i_].id;
						if (items[item_id].blockType == SEED) continue;
						int free_slots = get_free_slots(pInfo(p_));
						if (free_slots == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You don't have room in your backpack!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You don't have room in your backpack!");
								p.CreatePacket(p_);
							}
							break;
						}
						int a_ = 1;
						int jau_turi = 0;
						modify_inventory(p_, item_ids, jau_turi);
						a_ = 200 - jau_turi;
						if (modify_inventory(p_, item_ids, a_) == 0) {
							{
								PlayerMoving data_{};
								data_.x = pInfo(p_)->x + 10, data_.y = pInfo(p_)->y + 16;
								data_.packetType = 19, data_.plantingTree = 100;
								data_.punchX = item_ids, data_.punchY = pInfo(p_)->netID;
								int32_t to_netid = pInfo(p_)->netID;
								BYTE* raw = packPlayerMoving(&data_);
								raw[3] = 5;
								memcpy(raw + 8, &to_netid, 4);
								send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[] raw;
							}
							gamepacket_t p(0, pInfo(p_)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/cash_register.wav");
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`7[```9" + pInfo(p_)->tankIDName + " bought " + to_string(a_) + " " + items[item_ids].ori_name + " for 0 World Locks.```7]``");
								if (pInfo(p_)->buy_role) send_logs(pInfo(p_)->tankIDName + " bought " + to_string(a_) + " " + items[item_ids].ori_name + " for 0 World Locks. in World: [" + pInfo(p_)->world + "]", "/buy");
								p.CreatePacket(p_);
							}
						}
						break;
					}
				}
			}
			else {
				if (Server_Security.buy_enabled == false) break;
				for (int i_ = 0; i_ < kainos.size(); i_++) {
					uint32_t item_ids = kainos[i_][0];
					int kaina = kainos[i_][1];
					if (web_url == "https://reugtps.ddns.net/") kaina *= 6;
					if (items[item_ids].ori_name == items[item_id].ori_name) {
						int my_wls = get_wls(p_, true);
						if (kaina > my_wls) break;
						int free_slots = get_free_slots(pInfo(p_));
						if (free_slots == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You don't have room in your backpack!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You don't have room in your backpack!");
								p.CreatePacket(p_);
							}
							break;
						}
						int is_viso_worldlock = kaina, a_ = 1;
						if (modify_inventory(p_, item_ids, a_) == 0) {
							get_wls(p_, true, true, is_viso_worldlock);
						}
						{
							PlayerMoving data_{};
							data_.x = pInfo(p_)->x + 10, data_.y = pInfo(p_)->y + 16;
							data_.packetType = 19, data_.plantingTree = 100;
							data_.punchX = item_ids, data_.punchY = pInfo(p_)->netID;
							int32_t to_netid = pInfo(p_)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							memcpy(raw + 8, &to_netid, 4);
							send_raw(p_, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							delete[] raw;
						}
						gamepacket_t p(0, pInfo(p_)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/cash_register.wav");
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`7[```9" + pInfo(p_)->tankIDName + " bought 1 " + items[item_ids].ori_name + " for " + to_string(kaina) + " World Locks.```7]``");
							p.CreatePacket(p_);
							send_logs(pInfo(p_)->tankIDName + " - > 1 " + items[item_ids].ori_name + " for " + to_string(kaina) + " [wl]", "/buy with wl");
						}
						break;
					}
				}
			}
			break;
		}
		else if (a_[i_] == "buy_option") {
			if (a_.size() != 11) break;
			string name_ = a_[5];
			string target_ = a_[8];
			vector<string> buys = explode("_", target_);
			if (buys.size() != 2) break;
			if (not isdigit(buys[1][0])) break;
			int item_id = atoi(buys[1].c_str());
			if (item_id <= 0 || item_id >= items.size()) break;
			if (pInfo(p_)->buy_role) {
				for (int i_ = 0; i_ < items.size(); i_++) {
					uint32_t item_ids = items[i_].id;
					if (item_ids < 0 || item_ids >= items.size()) break;
					if (items[i_].ori_name == items[item_id].ori_name) {

						if (!pInfo(p_)->Staff) {
							if (items[i_].id == 274 || items[i_].id == 276 || items[i_].id == 8470 || items[i_].id == 278 || items[i_].id == 732 || items[i_].id == 7188) continue;
							if (items[i_].id == 1488 or items[i_].id == 9902 or items[i_].id == 10716) continue;
							if (items[i_].blockType == CONSUMABLE) continue;
							if (items[i_].blockType == CLOTHING) continue;
							if (i_ == 9386 or i_ == 7960 or i_ == 5136 or i_ == 1486 or i_ == 4490) continue;
							if (i_ == 9918 or i_ == 9770 or i_ == 9772 or i_ == 9846 or i_ == 9906 or i_ == 9908 or i_ == 10290 or i_ == 10362 or i_ == 13702 or i_ == 13706 or i_ == 13698 or i_ == 13700 or i_ == 13704 or i_ == 13682 or i_ == 13680) continue;
							if (i_ == 7960 or i_ == 9902 or i_ == 9814 or i_ == 9384 or i_ == 5136 or i_ == 9976 or i_ == 10266 or i_ == 9850 or i_ == 5638) continue;
							if (i_ == 5714 or i_ == 9928 or i_ == 542 or i_ == 1488 or i_ == 5138 or i_ == 5140 or i_ == 5142 or i_ == 10394 or i_ == 4490) continue;

						}
						if (!pInfo(p_)->give_role) {
							if (i_ == 1458) continue;
							if (items[i_].name.find("Legendary") != string::npos) continue;
							if (items[i_].name.find("Legend") != string::npos) continue;
							if (items[i_].blockType == LOCK) continue;
						}
						uint32_t item_id = items[i_].id;
						if (items[item_id].blockType == SEED) continue;

						uint32_t item_count = 200;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nembed_data|name|" + name_ + "\nembed_data|pirkti_id|" + to_string(item_ids) + "\nembed_data|pirkti_kaina|" + to_string(item_count) + "\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(item_count) + "``) `8World Locks (You are Developer)``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`wMaximum``) `2" + items[item_ids].ori_name + "``|left|" + to_string(item_ids) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|nupirkti|Cancel|OK");
						p.CreatePacket(p_);
						break;
					}
				}
			}
			else {
				for (int i_ = 0; i_ < kainos.size(); i_++) {
					uint32_t item_ids = kainos[i_][0];
					if (item_ids <= 0 || item_ids >= items.size()) break;
					if (items[item_ids].ori_name == items[item_id].ori_name) {
						int my_wls = get_wls(p_, true), item_count = kainos[i_][1];
						if (web_url == "https://reugtps.ddns.net/") item_count *= 6;
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nembed_data|name|" + name_ + "\nembed_data|pirkti_id|" + to_string(item_ids) + "\nembed_data|pirkti_kaina|" + to_string(item_count) + "\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(item_count) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w1``) `2" + items[item_ids].ori_name + "``|left|" + to_string(item_ids) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|" + (item_count > my_wls ? "`4You can't afford this item you're " + to_string(item_count - my_wls) + " World Lock's short" : "Are you sure you want to make this purchase?") + "|left|\nadd_spacer|small|\nadd_button|back|Back|noflags|0|0|\nend_dialog|nupirkti|Cancel|" + (item_count > my_wls ? "" : Server_Security.buy_enabled == false ? "TEMPORARELY DISABLED" : "BUY") + "|");
						p.CreatePacket(p_);
						break;
					}
				}
			}
			break;
		}
		else if (a_[i_] == "weatherspcl") {
			if (a_.size() != 13 and a_.size() != 17 and a_.size() != 19) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
				if (block_->fg != 5000 and block_->fg != 3832 and block_->fg != 3694) break;
				bool update_ = false;
				if (block_->fg == 3694 and a_.size() == 17) {
					if (not isdigit(a_[i_ + 8][0]) or not isdigit(a_[i_ + 10][0]) or not isdigit(a_[i_ + 12][0])) break;
					int r = atoi(a_[i_ + 8].c_str()), g = atoi(a_[i_ + 10].c_str()), b = atoi(a_[i_ + 12].c_str());
					if (r < 0 or g < 0 or b < 0 or r > 255 or g > 255 or b > 255) return;
					if (r < 40 and g < 40 and b < 40) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You can't make a heatwave that dark (one of the colors must be 40+)!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						return;
					}
					block_->r = r;
					block_->g = g;
					block_->b = b;
					update_ = true;
				}
				else if (block_->fg == 3832 and a_.size() == 19) {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t new_id = atoi(a_[i_ + 8].c_str());
					if (block_->id != new_id) {
						block_->id = new_id;
						update_ = true;
					}
					int new_gravity = atoi(a_[i_ + 10].c_str());
					if (new_gravity > 500) new_gravity = 500;
					if (new_gravity < -500) new_gravity = -500;
					if (block_->gravity != new_gravity) {
						block_->gravity = new_gravity;
						update_ = true;
					}
					if (not isdigit(a_[i_ + 12][0])) break;
					bool new_spin = atoi(a_[i_ + 12].c_str());
					if (block_->spin != new_spin) block_->spin = new_spin, update_ = true;
					if (not isdigit(a_[i_ + 14][0])) break;
					bool new_invert = atoi(a_[i_ + 14].c_str());
					if (block_->invert != new_invert) block_->invert = new_invert, update_ = true;
				}
				else if (block_->fg == 3832 and a_.size() == 17) {
					int new_gravity = atoi(a_[i_ + 8].c_str());
					if (new_gravity > 500) new_gravity = 500;
					if (new_gravity < -500) new_gravity = -500;
					if (block_->gravity != new_gravity) {
						block_->gravity = new_gravity;
						update_ = true;
					}
					if (not isdigit(a_[i_ + 10][0])) break;
					bool new_spin = atoi(a_[i_ + 10].c_str());
					if (block_->spin != new_spin) block_->spin = new_spin, update_ = true;
					if (not isdigit(a_[i_ + 12][0])) break;
					bool new_invert = atoi(a_[i_ + 12].c_str());
					if (block_->invert != new_invert) block_->invert = new_invert, update_ = true;
				}
				else {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t new_id = atoi(a_[i_ + 8].c_str());
					if (block_->fg == 5000 and items[new_id].blockType != BlockTypes::BACKGROUND) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("That's not a background!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						break;
					} if (block_->id != new_id) {
						block_->id = new_id;
						update_ = true;
					}
				}
				tile_update(p_, world_, block_, x_, y_);
				if (block_->enabled and update_) {
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					if (comet_dust) p.Insert(16);
					else p.Insert(world_->weather == 0 ? 80 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "itemaddedtosucker" or a_[i_] == "itemremovedfromsucker") {
			if (a_.size() != 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(p_)->tankIDName);
				bool magplant_access = false;
				if (to_lower(world_->owner_name) == to_lower(pInfo(p_)->tankIDName) or pInfo(p_)->dev) magplant_access = true;
				if (world_->world_settings & Gtps3::SETTINGS_10) {
					if (find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) != world_->admins.end()) magplant_access = true;
				}
				if (block_->locked) {
					WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
					if (to_lower(check_lock->owner_name) == to_lower(pInfo(p_)->tankIDName)) magplant_access = true;
				}
				if (items[block_->fg].blockType != BlockTypes::SUCKER or magplant_access == false) break;
				if (not isdigit(a_[i_ + 8][0])) break;
				if (t_ == 6948 and block_->pr >= 1500 and a_[i_] != "itemremovedfromsucker" or t_ == 6946 and block_->pr >= 1500 and a_[i_] != "itemremovedfromsucker" or t_ == 5638 and block_->pr >= 5000 and a_[i_] != "itemremovedfromsucker" or t_ == 9850 and block_->pr >= 15000 and a_[i_] != "itemremovedfromsucker" or t_ == 10266 and block_->pr >= 100000 and a_[i_] != "itemremovedfromsucker") break;
				int add_count = atoi(a_[i_ + 8].c_str());
				if (a_[i_] == "itemremovedfromsucker") {
					int has_count = (block_->fg == 6954 ? block_->c_ : block_->pr), block_id = block_->id;
					if (block_->fg == 6954) {
						block_id = block_->invert ? block_->id : block_->id -1 ;
					}
					if (add_count > has_count) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You are removing what you dont have.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You are removing what you dont have.");
							p.CreatePacket(p_);
						}
						break;
					}
					int c_ = 0;
					modify_inventory(p_, block_id, c_);
					add_count = (add_count + c_ > 200 ? (add_count > 200 ? 200 - c_ : (add_count > c_ ? 200 - add_count : 200 - c_)) : add_count);
					if (add_count > has_count or c_ + add_count > 200) break;
					int add_ = add_count;
					if (modify_inventory(p_, block_id, add_) == 0) {
						if (block_->fg == 6954)  block_->c_ -= add_count;
						else block_->pr -= add_count;
					}
				}
				else {
					int c_ = 0;
					modify_inventory(p_, block_->id, c_);
					if (c_ < add_count) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You dont have " + items[block_->id].name);
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You dont have " + items[block_->id].name);
							p.CreatePacket(p_);
						}
						break;
					}
					int remove_count = add_count * -1;
					if (modify_inventory(p_, block_->id, remove_count) == 0) {
						block_->pr += add_count;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("Items added.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Items added.");
							p.CreatePacket(p_);
						}
					}
				}
				bool found_ = false;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines* machine_ = &world_->machines[i_];
					if (machine_->x == x_ and machine_->y == y_) {
						machine_->enabled = block_->enabled;
						machine_->target_item = block_->id;
						found_ = true;
						break;
					}
				} if (not found_) {
					//cout << "created new world machine" << endl;
					WorldMachines new_machine;
					new_machine.enabled = block_->enabled;
					new_machine.x = x_, new_machine.y = y_;
					new_machine.id = block_->fg;
					new_machine.target_item = block_->id;
					world_->machines.push_back(new_machine);
					if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) {
						World_Stuff.t_worlds.push_back(world_->name);
					}
				}
				tile_update(p_, world_, block_, x_, y_);
			}
			break;
		}
		else if (a_[i_] == "itemsucker_block") {
			if (a_.size() != 13 and a_.size() != 16 and a_.size() != 14) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (block_access(p_, world_, block_) == false) break;
				if (items[t_].blockType != BlockTypes::SUCKER) break;
				if (a_.size() == 14 or a_[11] == "getplantationdevice") {
					if (block_->id != 0 and block_->fg == 5638 or block_->fg == 9850 or block_->fg == 10266) {
						int c_ = 0;
						modify_inventory(p_, 5640, c_);
						if (c_ != 0) modify_inventory(p_, 5640, c_ *= -1);
						c_ = 1;
						if (modify_inventory(p_, 5640, c_) == 0) {
							gamepacket_t p, p2, p3;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You received a " + items[5640].name + ".");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							p2.Insert("OnConsoleMessage");
							p2.Insert("You received a " + items[5640].name + ".");
							p2.CreatePacket(p_);
							pInfo(p_)->magnetron_id = block_->id;
							pInfo(p_)->magnetron_x = x_;
							pInfo(p_)->magnetron_y = y_;
							p3.Insert("OnPlanterActivated");
							p3.Insert(block_->id);
							p3.Insert(x_);
							p3.Insert(y_);
							p3.CreatePacket(p_);
						}
					}
					break;
				}
				if (a_.size() == 13 and a_[i_ + 7] == "selectitem") {
					if (not isdigit(a_[i_ + 8][0])) break;
					uint32_t putting_item = atoi(a_[i_ + 8].c_str());
					if (putting_item >= items.size() or putting_item < 0) break;
					if (t_ == 5638 || t_ == 9850 || t_ == 10266 || t_ == 6948 || t_ == 6946) {
						if (block_->pr != 0) break;
						if (t_ == 6948 && items[putting_item].blockType == BlockTypes::SEED or t_ == 6946 && items[putting_item].blockType != BlockTypes::SEED) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert((t_ == 6948 ? "You cannot store seeds in this machine." : "You can only store seeds in this machine."));
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert((t_ == 6948 ? "You cannot store seeds in this machine." : "You can only store seeds in this machine."));
								p.Insert("You cannot store seeds in this machine.");
								p.CreatePacket(p_);
							}
							break;
						}
						if (block_->pr != 0) break;
						if (items[putting_item].untradeable or items[putting_item].rarity == 999 or items[putting_item].blockType == BlockTypes::CLOTHING or items[putting_item].blockType == BlockTypes::CONSUMABLE or items[putting_item].blockType == BlockTypes::LOCK) {
							if (not items[putting_item].farmable || items[putting_item].blockType == BlockTypes::CLOTHING || items[putting_item].untradeable) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("This item is not compatible.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("This item is not compatible.");
									p.CreatePacket(p_);
								}
								break;
							}
						}
						if (items[putting_item].blockType == BlockTypes::SUCKER) putting_item = 0;
						if (items[putting_item].id == 6016) putting_item = 0;
						if (items[putting_item].id == 6952) putting_item = 0;
						block_->id = putting_item;
						block_->enabled = true;
					}
				}
				else {
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_] == "retrieveitem") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								if (c_ < 200) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|\nadd_textbox|`wHow many `2" + items[block_->id].name + "`` would you like to remove?``|left||\nadd_text_input|itemtoremove|Amount:|" + (block_->pr + c_ > 200 ? (block_->pr > 200 ? to_string(200 - c_) : (block_->pr > c_ ? to_string(200 - block_->pr) : to_string(200 - c_))) : to_string(block_->pr)) + "|20|\nend_dialog|itemremovedfromsucker|Close|Retrieve|\nadd_spacer|small|");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[b_] == "addstocks5000") {
							if (pInfo(p_)->give_role) {
								block_->pr += 50000;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("Added 5000 blocks to this machine!");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
							}
							break;
						}
						else if (a_[b_] == "additem") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								if (c_ != 0) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|\nadd_smalltext|You have " + to_string(c_) + " `2" + items[block_->id].name + "`` in your backpack.|left|\nadd_textbox|`wHow many `2" + items[block_->id].name + "`` would you like to add?``|left|\nadd_text_input|itemtoadd|Amount:|" + (block_->pr + c_ > (block_->fg == 5638 ? 5000 : block_->fg == 9850 ? 15000 : block_->fg == 10266 ? 100000 : 1500) ? to_string((block_->fg == 5638 ? 5000 : block_->fg == 9850 ? 15000 : block_->fg == 10266 ? 100000 : 1500) - block_->pr) : to_string(c_)) + "|20|\nend_dialog|itemaddedtosucker|Close|Add|\nadd_spacer|small|");
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[b_] == "clearitem") {
							if (block_->id != 0 and block_->pr == 0) {
								if ((block_->fg == 5638 || block_->fg == 9850 || block_->fg == 10266) and (pInfo(p_)->magnetron_id != 0 and pInfo(p_)->magnetron_x == x_ and pInfo(p_)->magnetron_y == y_)) {
									int c_ = 0;
									modify_inventory(p_, 5640, c_);
									if (c_ != 0) {
										c_ *= -1;
										modify_inventory(p_, 5640, c_);
										pInfo(p_)->magnetron_id = 0;
										pInfo(p_)->magnetron_x = 0;
										pInfo(p_)->magnetron_y = 0;
									}
								}
								block_->id = 0, block_->enabled = true;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_sucker(p_, world_, block_, x_, y_));
								p.CreatePacket(p_);
								break;
							}
							break;
						}
						else if (a_[b_].substr(0, 4) == "chk_") {
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "enablesucking") {
								block_->enabled = (a_[b_ + 1] == "1" and not block_->enabled ? true : (a_[b_ + 1] == "0" and block_->enabled ? false : false));
							}
						}
					}
				}
				bool found_ = false;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines* machine_ = &world_->machines[i_];
					if (machine_->x == x_ and machine_->y == y_) {
						machine_->enabled = block_->enabled;
						machine_->target_item = block_->id;
						found_ = true;
						break;
					}
				} if (not found_) {
					//cout << "created new world machine" << endl;
					WorldMachines new_machine;
					new_machine.enabled = block_->enabled;
					new_machine.x = x_, new_machine.y = y_;
					new_machine.id = block_->fg;
					new_machine.target_item = block_->id;
					world_->machines.push_back(new_machine);
					if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) {
						World_Stuff.t_worlds.push_back(world_->name);
					}
				}
				tile_update(p_, world_, block_, x_, y_);
			}
			break;
		}
		else if (a_[i_] == "autoactionblock") {
		if (a_.size() == 4) return;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0  or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(p_)->tankIDName);
				if (owner_name != user_name and not pInfo(p_)->dev) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else {
						break;
					}
				}
					if (items[t_].blockType == BlockTypes::AUTO_BLOCK or t_ == 6954) {
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_] == "removegems" && block_->pr > 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You have removed `4" + setGems(block_->pr) + "`` gems from this machine!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							OnSetGems(p_, block_->pr);
							block_->pr = 0;
						}
						else if (a_[b_] == "removeitems") {
							if (block_->c_ != 0) {
								int c_ = 0, id_ = (block_->invert ? block_->id : block_->id - 1);
								modify_inventory(p_, id_, c_);
								if (c_ < 200) {
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									p.Insert("set_default_color|`o\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|`2" + items[id_].name + "``|left|" + to_string(id_) + "|\nadd_textbox|`wHow many `2" + items[id_].name + "`` would you like to remove?``|left||\nadd_text_input|itemtoremove|Amount:|" + (block_->c_ + c_ > 200 ? (block_->c_ > 200 ? to_string(200 - c_) : (block_->c_ > c_ ? to_string(200 - block_->c_) : to_string(200 - c_))) : to_string(block_->c_)) + "|20|\nend_dialog|itemremovedfromsucker|Close|Retrieve|\nadd_spacer|small|");
									p.CreatePacket(p_);
								}
							}
						}
						else if (a_[b_] == "refillfuel" && block_->pr < 8000) {
							if (not isdigit(a_[b_ + 1][0])) return;
							int target_amount = atoi(a_[b_ + 1].c_str());
							if (target_amount > pInfo(p_)->gems) target_amount = pInfo(p_)->gems;
							if (target_amount == 0) continue;
							if (block_->pr + target_amount > 8000) {
								target_amount = 8000 - block_->pr;
							}
							OnSetGems(p_, target_amount * -1);
							block_->pr += target_amount;
						}
						else if (a_[b_] == "harvest_trees" && block_->c_ <= 0) {
							if (not isdigit(a_[b_ + 1][0])) return;
							int target_amount = atoi(a_[b_ + 1].c_str());
							block_->build_only = target_amount;
						}
						else if (a_[b_] == "collect_seeds" && block_->c_ <= 0) {
							if (not isdigit(a_[b_ + 1][0])) return;
							int target_amount = atoi(a_[b_ + 1].c_str());
							block_->invert = target_amount;
						}
						else if (a_[b_] == "selecttarget") {
							if (not isdigit(a_[b_ + 1][0])) return;
							uint32_t target_item = atoi(a_[b_ + 1].c_str());
							if (target_item <= 0 || target_item > items.size() || block_->c_ != 0) return;
							if (t_ == 6952) {
								if (items[target_item].blockType == BlockTypes::SEED) target_item--;
								if (items[target_item].untradeable || items[target_item].rarity < 0 || items[target_item].rarity == 999 || items[target_item].block_possible_put == false || target_item == 610 || target_item == 9385 || target_item == 9387 || target_item == 611 || target_item == 9380 || target_item == 9386 || target_item == 5136 || target_item == 9600 || items[target_item].untradeable || items[target_item].rarity == 999 || target_item == 9380 || target_item == 9386 || target_item == 9384 || target_item == 9902 || target_item == 10716 || target_item == 5136 || target_item == 9600 || target_item == 9381 || target_item == 9387 || target_item == 9385 || target_item == 5137 || target_item == 9601) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
										p.CreatePacket(p_);
									}
									return;
								} 
								if (items[target_item].blockType == BlockTypes::CLOTHING or items[target_item].properties & Property_Mod) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4NOPE!``");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`4NOPE!``");
										p.CreatePacket(p_);
									}
									return;
								}
							}
							else {
								if (items[target_item].blockType != BlockTypes::SEED) target_item++;
								if (target_item == 611 || items[target_item].rarity == 999 || target_item == 9380 || target_item == 9386 || target_item == 9384 || target_item == 9902|| target_item == 10716 || target_item == 5136 || target_item == 9600 || target_item == 9381 || target_item == 9387 || target_item == 9385 || target_item == 5137 || target_item == 9601) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Sorry that item is `4NOT`` allowed in this machine!");
										p.CreatePacket(p_);
									}
									return;
								}
								if (items[target_item].collisionType != 1 and items[target_item].blockType != BlockTypes::SEED) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4NOPE!``");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`4NOPE!``");
										p.CreatePacket(p_);
									}
									return;
								}
								if (t_ == 6954) {
									if (items[target_item].blockType == BlockTypes::CLOTHING or items[target_item].properties & Property_Mod) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("`4NOPE!``");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`4NOPE!``");
											p.CreatePacket(p_);
										}
										return;
									}
								}
							}
							block_->id = target_item;
						}
					}
					{
						bool found_ = false;
						for (int i_ = 0; i_ < world_->machines.size(); i_++) {
							WorldMachines* machine_ = &world_->machines[i_];
							if (machine_->x == x_ and machine_->y == y_) {
								machine_->enabled = block_->enabled;
								machine_->target_item = block_->id;
								found_ = true;
								break;
							}
						} if (not found_) {
							//cout << "created new world machine" << endl;
							WorldMachines new_machine;
							new_machine.enabled = block_->enabled;
							new_machine.x = x_, new_machine.y = y_;
							new_machine.id = block_->fg;
							new_machine.target_item = block_->id;
							world_->machines.push_back(new_machine);
							if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) {
								World_Stuff.t_worlds.push_back(world_->name);
							}
						}
					}
					tile_update(p_, world_, block_, x_, y_);
					break;
				}
			}
			break;
		}
		else if (a_[i_] == "blaster") {
		if (a_.size() != 17) break;
		if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0]) or not isdigit(a_[i_ + 8][0]) or not isdigit(a_[i_ + 10][0]) or not isdigit(a_[i_ + 12][0])) break;
		int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str()), often_ = atoi(a_[i_ + 8].c_str()), speed_ = atoi(a_[i_ + 10].c_str());
		if (x_ < 0 or y_ < 0 ) break;
		if (speed_ > 250) speed_ = 250;
		if (speed_ < 10) speed_ = 10;
		if (often_ > 20) often_ = 20;
		if (often_ < 2) often_ = 2;
		string name_ = pInfo(p_)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (y_ >= world_->max_y || x_ >= world_->max_x) break;
			WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
			uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
			if (block_access(p_, world_, block_) == false || items[t_].blockType != BlockTypes::TRICKSTER) break;
			block_->flags = (block_->flags & 0x00400000 and a_[i_ + 12] == "1" ? block_->flags ^ 0x00400000 : (a_[i_ + 12] == "0" ? block_->flags | 0x00400000 : block_->flags));
			bool found_ = false;
			block_->rate_of_fire = often_;
			block_->projectile_speed = speed_;
			for (int i_ = 0; i_ < world_->npc.size(); i_++) {
				WorldNPC* npc_ = &world_->npc[i_];
				if (npc_->x == x_ and npc_->y == y_) {
					npc_->enabled = (block_->flags & 0x00400000 ? true : false);
					npc_->rate_of_fire = often_;
					npc_->projectile_speed = speed_;
					npc_->kryptis = (block_->flags & 0x00200000 ? 180 : 0);
					found_ = true;
					break;
				}
			}
			if (not found_) {
				WorldNPC new_npc;
				new_npc.enabled = (block_->flags & 0x00400000 ? true : false);
				new_npc.x = x_, new_npc.y = y_;
				new_npc.id = block_->fg;
				new_npc.projectile_speed = speed_;
				new_npc.rate_of_fire = often_;
				new_npc.kryptis = (block_->flags & 0x00200000 ? 180 : 0);
				world_->npc.push_back(new_npc);
				if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) {
					World_Stuff.t_worlds.push_back(world_->name);
				}
			}
			block_->enabled = (block_->flags & 0x00400000 ? true : false);
			tile_update(p_, world_, block_, x_, y_);
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(p_)->netID);
			p.Insert("Settings updated!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(p_);
		}
		break;
			}
		else if (a_[i_] == "switcheroo_edit") {
		if (a_.size() < 13) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (block_access(p_, world_, block_) && items[t_].blockType == BlockTypes::GATEWAY or items[t_].can_be_changed_to_public) {
					block_->flags = (block_->flags & 0x00800000 and a_[i_ + 8] == "0" ? block_->flags ^ 0x00800000 : (a_[i_ + 8] == "1" ? block_->flags | 0x00800000 : block_->flags));
					if (a_.size() == 15) block_->flags = (block_->flags & 0x02000000 and a_[i_ + 10] == "0" ? block_->flags ^ 0x02000000 : (a_[i_ + 10] == "1" ? block_->flags | 0x02000000 : block_->flags));
					tile_update(p_, world_, block_, x_, y_);
				}
			}
			break;
		}
		else if (a_[i_] == "trade_item") {
			if (a_.size() != 10) break;
			if (not isdigit(a_[5][0]) or not isdigit(a_[8][0])) break;
			int item_id = atoi(a_[5].c_str()), item_count = atoi(a_[8].c_str()), c_ = 0;
			modify_inventory(p_, item_id, c_);
			if (c_ < item_count or c_ == 0) break;
			mod_trade(p_, atoi(a_[5].c_str()), atoi(a_[8].c_str()));
			break;
		}
		else if (a_[i_] == "door_edit") {
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				WorldBlock* block_ = &world_->blocks[pInfo(p_)->lastwrenchx + (pInfo(p_)->lastwrenchy * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::DOOR and items[t_].blockType != BlockTypes::PORTAL) break;
				if (block_access(p_, world_, block_) == false && !guild_access(p_, world_->guild_id)) break;
				if (a_.size() >= 8 && block_->fg == 10358) {
					string btn = a_[i_ + 8];
					if (btn == "withdraw_a") {
						if (block_->wl != 0) {
							int total_wl = block_->wl, c_ = 0, taken = 0;
							bool returned = false, collect = false;
							string collected_ = "";
							if (pInfo(p_)->tankIDName != world_->owner_name)
								send_logs("player: " + pInfo(p_)->tankIDName + " lvl: " + to_string(pInfo(p_)->level) + ", took " + to_string(total_wl) + " World Locks from Entry Booth in: [" + pInfo(p_)->world + "]", "Entry Booth (Steal)");
							if (total_wl >= 10000) {
								if (total_wl > 2000000) c_ = 200;
								else c_ = total_wl / 10000;
								total_wl -= c_ * 10000;
								block_->wl -= c_ * 10000;
								taken = c_;
								if (modify_inventory(p_, 7188, c_) == 0) {
									collected_ += to_string(taken) + " Blue Gem Locks";
									collect = true;
								}
								else pInfo(p_)->bp.push_back(make_pair(7188, c_)), returned = true;
								c_ = 0;
							}
							if (total_wl >= 100) {
								if (total_wl > 20000) c_ = 200;
								else c_ = total_wl / 100;
								total_wl -= c_ * 100;
								block_->wl -= c_ * 100;
								taken = c_;
								if (modify_inventory(p_, 1796, c_) == 0) {
									collected_ += (collected_.empty() ? "" : " and ") + to_string(taken) + " Diamond Locks";
									collect = true;
								}
								else pInfo(p_)->bp.push_back(make_pair(1796, c_)), returned = true;
								c_ = 0;
							}
							if (total_wl >= 1) {
								if (total_wl > 200) c_ = 200;
								else c_ = total_wl;
								total_wl -= c_;
								block_->wl -= c_;
								taken = c_;
								if (modify_inventory(p_, 242, c_) == 0) {
									collected_ += (collected_.empty() ? "" : " and ") + to_string(taken) + " World Locks";
									collect = true;
								}
								else pInfo(p_)->bp.push_back(make_pair(242, c_)), returned = true;
								c_ = 0;
							}
							if (returned) {
								gamepacket_t p, p2(1500);
								p.Insert("OnTextOverlay"), p.Insert("Some of the World Locks could not fit in your inventory!"), p.CreatePacket(p_);
								p2.Insert("OnTextOverlay"), p2.Insert("We have placed them in your Personal Backpack."), p2.CreatePacket(p_);
							}
							{
								gamepacket_t p, p2;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID);
								p.Insert((collect ? "You collected " + collected_ + "" : "You don't have room in your backpack!"));
								p.Insert(0), p.Insert(1), p.CreatePacket(p_);
								p2.Insert("OnConsoleMessage");
								p2.Insert((collect ? "You collected " + collected_ + "" : "You don't have room in your backpack!"));
								p2.CreatePacket(p_);
							}
						}
						return;
					}
				}
				if (a_.size() != 19 and a_.size() != 17) break;
				if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
				string door_name = a_[i_ + 8];
				string door_target = a_[i_ + 10];
				string door_id = a_[i_ + 12];
				if (block_->fg == 10358) {
					int entry_price = atoi(door_name.c_str());
					if (entry_price < 0 || entry_price > (pInfo(p_)->superdev == 0 ? 200 : 20000)) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("Minimum price is 0 and maximum is 200 World Locks!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						entry_price = block_->shelf_1;
					}
					else block_->shelf_1 = entry_price;
				}
				if (a_.size() == 19) {
					string checkbox_locked = a_[i_ + 14];
					block_->open = (checkbox_locked == "0" ? false : true);
				}
				if (door_name.size() > 100) break;
				if (door_target.size() > 24) break;
				if (door_id.size() > 11) break;
				transform(door_target.begin(), door_target.end(), door_target.begin(), ::toupper);
				transform(door_id.begin(), door_id.end(), door_id.begin(), ::toupper);
				block_->door_destination = door_target, block_->door_id = door_id;
				block_->txt = door_name;
				if (block_->fg == 10358) block_->txt = "`$[```4ENTRY PRICE```$]``: " + to_string(block_->shelf_1) + " ā";
				tile_update(p_, world_, block_, pInfo(p_)->lastwrenchx, pInfo(p_)->lastwrenchy);
			}
			break;
		}
		else if (a_[i_] == "vending") {
			if (a_.size() != 14 and a_.size() != 13 and a_.size() != 20 and a_.size() != 17 and a_.size() != 19 and a_.size() != 23) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			if (a_.size() == 13 and not isdigit(a_[i_ + 8][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::VENDING) break;
				bool access = block_access(p_, world_, block_, true);
				if ((abs(x_ * 32 - pInfo(p_)->x) > 15 || abs(y_ * 32 - pInfo(p_)->y) > 15) && access == false) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("Get closer!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(p_);
					break;
				}
				if (a_.size() == 19 or a_.size() == 23) {
					if (not isdigit(a_[i_ + 11][0])) break;
					int expectprice = atoi(a_[i_ + 8].c_str()), expectitem = atoi(a_[i_ + 11].c_str()), buycount = atoi(a_[i_ + 14].c_str());
					if (a_.size() == 23) {
						buycount = atoi(a_[i_ + 11].c_str()), expectprice = atoi(a_[i_ + 14].c_str()), expectitem = atoi(a_[i_ + 17].c_str());
					}
					if (expectprice != block_->pr) break;
					if (expectitem != block_->id) break;
					if (buycount < 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("NEGATIVE, DOES NOT COMPUTE");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						break;
					}
					if (buycount == 0) break;
					int normal_price = (block_->pr > 0 ? block_->pr : (block_->pr * -1));
					int actual_buy_count = (block_->pr > 0 ? buycount : (normal_price < buycount ? buycount / normal_price : normal_price / buycount) * (block_->pr * -1));
					if (actual_buy_count == 0 or actual_buy_count > block_->c_) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("There aren't enough available to fulfill your order!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("There aren't enough available to fulfill your order!");
							p.CreatePacket(p_);
						}
						break;
					}
					if (block_->pr < 0) {
						if (buycount < (block_->pr * -1)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You have to buy at least 1 World Lock's worth.");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("You have to buy at least 1 World Lock's worth.");
								p.CreatePacket(p_);
							}
							break;
						}
					}
					int my_wls = get_wls(p_, true);
					int cost_ = (block_->pr > 0 ? block_->pr * buycount : (normal_price < buycount ? buycount / normal_price : normal_price / buycount));
					if (cost_ > my_wls) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You can't afford that many!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You can't afford that many!");
							p.CreatePacket(p_);
						}
						break;
					}
					int has_alr = 0;
					modify_inventory(p_, block_->id, has_alr);
					if (has_alr + actual_buy_count > 200) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room in your backpack!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You don't have room in your backpack!");
							p.CreatePacket(p_);
						}
						break;
					}
					int free_slots = get_free_slots(pInfo(p_));
					if (free_slots == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room in your backpack!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("You don't have room in your backpack!");
							p.CreatePacket(p_);
						}
						break;
					}
					if (a_.size() == 19) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPurchase Confirmation``|left|1366|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|\nadd_textbox|`4You'll give:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(cost_) + "``) `8World Locks``|left|242|\nadd_spacer|small|\nadd_textbox|`2You'll get:``|left|\nadd_spacer|small|\nadd_label_with_icon|small|(`w" + to_string(actual_buy_count) + "``) `2" + items[block_->id].ori_name + "``|left|" + to_string(block_->id) + "|\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|Are you sure you want to make this purchase?|left|\nembed_data|verify|1\nembed_data|buycount|" + to_string(buycount) + "\nembed_data|expectprice|" + to_string(expectprice) + "\nembed_data|expectitem|" + to_string(expectitem) + "\nend_dialog|vending|Cancel|OK|");
						p.CreatePacket(p_);
						break;
					}


					int a_ = actual_buy_count;
					if (get_free_slots(pInfo(p_)) > 2) {
						if (modify_inventory(p_, block_->id, a_) == 0) {
							get_wls(p_, true, true, cost_);
							send_logs(pInfo(p_)->tankIDName + " buy " + to_string(actual_buy_count) + "x " + items[block_->id].ori_name + " for " + to_string(cost_) + " World Locks" + " in World: [" + pInfo(p_)->world + "]", "Vending Machine Buying");
							add_cctv(p_, "bought", "" + to_string(actual_buy_count) + " " + items[block_->id].ori_name + " for " + to_string(cost_) + " World Locks");
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`7[```9" + pInfo(p_)->tankIDName + " bought " + to_string(actual_buy_count) + " " + items[block_->id].ori_name + " for " + to_string(cost_) + " World Locks.```7]``");
							if (block_->pr > 0) add_item_price(block_->id, block_->pr);
							gamepacket_t p2(0, pInfo(p_)->netID);
							p2.Insert("OnPlayPositioned");
							p2.Insert("audio/cash_register.wav");
							PlayerMoving data_{};
							data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
							data_.packetType = 19, data_.plantingTree = 100;
							data_.punchX = block_->id, data_.punchY = pInfo(p_)->netID;
							int32_t to_netid = pInfo(p_)->netID;
							BYTE* raw = packPlayerMoving(&data_);
							raw[3] = 5;
							memcpy(raw + 8, &to_netid, 4);
							block_->c_ -= actual_buy_count, block_->wl += cost_;
							if (block_->c_ <= 0) {
								block_->id = 0, block_->pr = 0;
							}
							
							PlayerMoving data_vending{};
							data_vending.packetType = 5, data_vending.punchX = x_, data_vending.punchY = y_, data_vending.characterState = 0x8;
							BYTE* v_ = packPlayerMoving(&data_vending, 112 + alloc_(world_, block_));
							BYTE* blc = v_ + 56;
							form_visual(blc, *block_, *world_, p_, false);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									send_raw(currentPeer, 4, v_, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
									p.CreatePacket(currentPeer);
									p2.CreatePacket(currentPeer);
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]raw, v_, blc;
							if (block_->locked) {
								upd_lock(*block_, *world_, p_);
							}
							break;
						}
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You don't have room in your backpack!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You don't have room in your backpack!");
						p.CreatePacket(p_);
					}
					break;
				}
				if (access == false) break;
				bool update_ = false;
				if (cch.find("chk_peritem|1") != string::npos and cch.find("chk_perlock|1") != string::npos) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You can't have it both ways.");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
					{
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You can't have it both ways.");
						p.CreatePacket(p_);
					}
					break;
				} if (a_.size() == 20 or a_.size() == 17 or a_.size() == 14) {
					for (int b_ = 0; b_ < a_.size(); b_++) {
						if (a_[b_].substr(0, 4) == "chk_") {
							vector<string> target_ = explode("_", a_[b_]);
							if (target_[1] == "peritem") {
								if (block_->pr < 0 and a_[b_ + 1] == "1") {
									block_->pr *= -1, update_ = true;
								}
							}
							else if (target_[1] == "perlock") {
								if (block_->pr > 0 and a_[b_ + 1] == "1") {
									if (block_->pr > 200 or block_->pr > block_->c_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough in there for anyone to buy at that price!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have enough in there for anyone to buy at that price!");
											p.CreatePacket(p_);
										}
										update_ = false;
										break;
									}
									block_->pr = block_->pr * -1;
									update_ = true;
								}
							}
						}
						else if (a_[b_] == "setprice") {
							int price_ = atoi(a_[b_ + 1].c_str());
							if (price_ == 0 or not isdigit(a_[b_ + 1][0]) and price_ >= 0) {
								block_->pr = 0;
								update_ = true;
							}
							else if (price_ < 0 or price_ > 2000000) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("Well, that's a silly price.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								break;
							}
							else {
								if (block_->pr < 0) {
									if (price_ > block_->c_) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You don't have enough in there for anyone to buy at that price!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You don't have enough in there for anyone to buy at that price!");
											p.CreatePacket(p_);
										}
										update_ = false;
										break;
									} 
									if (price_ > 200) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("That price is so low, nobody can carry a World Lock worth of items!");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("That price is so low, nobody can carry a World Lock worth of items!");
											p.CreatePacket(p_);
										}
										break;
									}
								}
								block_->pr = (block_->pr < 0 ? price_ * -1 : price_);
								update_ = true;
							}
						}
						else if (a_[b_] == "addstocks") {
							if (block_->id != 0) {
								int c_ = 0;
								modify_inventory(p_, block_->id, c_);
								int has_ = c_;
								c_ *= -1;
								if (modify_inventory(p_, block_->id, c_) == 0) {
									block_->c_ += has_;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Added " + to_string(has_) + " items to the machine.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Added " + to_string(has_) + " items to the machine.");
										p.CreatePacket(p_);
									}
								}
							}
							update_ = false;
							break;
						}
						else if (a_[b_] == "addstocks5000") {
							if (block_->id != 0) {
								if (pInfo(p_)->give_role) block_->c_ += 5000;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(p_)->netID);
								p.Insert("Added 5000 items to the machine.");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Added 5000 items to the machine.");
									p.CreatePacket(p_);
								}
							}
							update_ = false;
							break;
						}
						else if (a_[b_] == "remove_stock") {
							if (block_->id != 0) {
								if (pInfo(p_)->give_role) {
									block_->c_ = 0;
									block_->wl = 0;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Removed World Locks/Stock from the machine.");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("Removed World Locks/Stock from the machine.");
										p.CreatePacket(p_);
									}
								}
							}
							update_ = false;
							break;
							}
						else if (a_[b_] == "withdraw") {
							if (access) {
								if (block_->wl != 0) {
									int total_wl = block_->wl, c_ = 0, taken = 0;
									bool returned = false, collect = false;
									string collected_ = "";
									if (pInfo(p_)->tankIDName != world_->owner_name)
										send_logs("player: " + pInfo(p_)->tankIDName + " lvl: " + to_string(pInfo(p_)->level) + ", took " + to_string(total_wl) + " World Locks from Vending Machine in: [" + pInfo(p_)->world + "]", "Vending Machine (Steal)");
									if (total_wl >= 10000) {
										if (total_wl > 2000000) c_ = 200;
										else c_ = total_wl / 10000;
										total_wl -= c_ * 10000;
										block_->wl -= c_ * 10000;
										taken = c_;
										if (modify_inventory(p_, 7188, c_) == 0) {
											collected_ += to_string(taken) + " Blue Gem Locks";
											collect = true;
										}
										else pInfo(p_)->bp.push_back(make_pair(7188, c_)), returned = true;
										c_ = 0;
									}
									if (total_wl >= 100) {
										if (total_wl > 20000) c_ = 200;
										else c_ = total_wl / 100;
										total_wl -= c_ * 100;
										block_->wl -= c_ * 100;
										taken = c_;
										if (modify_inventory(p_, 1796, c_) == 0) {
											collected_ += (collected_.empty() ? "" : " and ") + to_string(taken) + " Diamond Locks";
											collect = true;
										}
										else pInfo(p_)->bp.push_back(make_pair(1796, c_)), returned = true;
										c_ = 0;
									}
									if (total_wl >= 1) {
										if (total_wl > 200) c_ = 200;
										else c_ = total_wl;
										total_wl -= c_;
										block_->wl -= c_;
										taken = c_;
										if (modify_inventory(p_, 242, c_) == 0) {
											collected_ += (collected_.empty() ? "" : " and ") + to_string(taken) + " World Locks";
											collect = true;
										}
										else pInfo(p_)->bp.push_back(make_pair(242, c_)), returned = true;
										c_ = 0;
									}
									if (returned) {
										gamepacket_t p, p2(1500);
										p.Insert("OnTextOverlay"), p.Insert("Some of the World Locks could not fit in your inventory!"), p.CreatePacket(p_);
										p2.Insert("OnTextOverlay"), p2.Insert("We have placed them in your Personal Backpack."), p2.CreatePacket(p_);
									}
									{
										gamepacket_t p, p2;
										p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID);
										p.Insert((collect ? "You collected " + collected_ + "" : "You don't have room in your backpack!"));
										p.Insert(0), p.Insert(1), p.CreatePacket(p_);
										p2.Insert("OnConsoleMessage");
										p2.Insert((collect ? "You collected " + collected_ + "" : "You don't have room in your backpack!"));
										p2.CreatePacket(p_);
									}
								}
								update_ = false;
							}
							break;
						}
						else if (a_[b_] == "upgradedigital") {
							if (access) {
								gamepacket_t p;
								if (pInfo(p_)->gems >= 4000) {
									OnSetGems(p_, 4000 * -1);
									block_->fg = 9268;
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
									update_ = false;
								}
								else p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID), p.Insert("You don't have enough gems!."), p.Insert(0), p.Insert(1);
								p.CreatePacket(p_);
								break;
							}
						}
						else if (a_[b_] == "pullstocks") {
							if (access) {
								if (get_free_slots(pInfo(p_)) > 1) {
									int c_ = block_->c_;
									if (modify_inventory(p_, block_->id, c_) == 0) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You picked up " + to_string(block_->c_) + " " + items[block_->id].ori_name + ".");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You picked up " + to_string(block_->c_) + " " + items[block_->id].ori_name + ".");
											p.CreatePacket(p_);
										}
										block_->c_ = 0, block_->id = 0, block_->pr = 0;
									}
									else if (block_->c_ > 200) {
										int has_ = 0;
										modify_inventory(p_, block_->id, has_);
										int give_ = 200 - has_;
										block_->c_ -= give_;
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You picked up " + to_string(give_) + " " + items[block_->id].ori_name + ", leaving " + to_string(block_->c_) + " in the machine.");
										p.Insert(0), p.Insert(1);
										p.CreatePacket(p_);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("You picked up " + to_string(give_) + " " + items[block_->id].ori_name + ", leaving " + to_string(block_->c_) + " in the machine.");
											p.CreatePacket(p_);
										}
										modify_inventory(p_, block_->id, give_);
									}
									update_ = false;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You don't have room in your backpack!");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("You don't have room in your backpack!");
										p.CreatePacket(p_);
									}
								}
							}
							break;
						}
					}
				}
				else {
					if (access) {
						if (block_->id != 0) break;
						int item_id = atoi(a_[i_ + 8].c_str());
						int c_ = 0, am_ = 0;
						modify_inventory(p_, item_id, c_);
						if (c_ == 0) break;
						if (items[item_id].untradeable or item_id == 1424 or item_id == 5816 or item_id == 242 or item_id == 1796 or item_id == 7188 or items[item_id].blockType == BlockTypes::FISH) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert((items[item_id].blockType == BlockTypes::LOCK or item_id == 1424 or item_id == 5816 ? "No no no." : "Can't put that in a " + items[block_->fg].name + "."));
							p.Insert(0), p.Insert(1);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert((items[item_id].blockType == BlockTypes::LOCK or item_id == 1424 or item_id == 5816 ? "No no no." : "Can't put that in a " + items[block_->fg].name + "."));
								p.CreatePacket(p_);
							}
							break;
						}
						am_ = c_;
						c_ *= -1;
						if (modify_inventory(p_, item_id, c_) == 0) {
							block_->id = item_id;
							block_->c_ = am_;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("`7[``" + pInfo(p_)->tankIDName + " put `2" + items[item_id].ori_name + "`` in the " + items[block_->fg].name + ".`7]``");
							p.Insert(0), p.Insert(0);
							gamepacket_t p2;
							p2.Insert("OnConsoleMessage");
							p2.Insert("`7[``" + pInfo(p_)->tankIDName + " put `2" + items[item_id].ori_name + "`` in the " + items[block_->fg].name + ".`7]``");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									p.CreatePacket(currentPeer);
									p2.CreatePacket(currentPeer);
								}
							}
							{
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_vending(p_, world_, block_, x_, y_));
								p.CreatePacket(p_);
							}
						}
					}
				}
				if (update_) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert((block_->pr == 0 ? "`7[``" + pInfo(p_)->tankIDName + " disabled the Vending Machine.```7]``" : "`7[``" + pInfo(p_)->tankIDName + " changed the price of `2" + items[block_->id].ori_name + "`` to " + (block_->pr < 0 ? "`6" + to_string(block_->pr * -1) + " per World Lock.```7]``" : "`5" + to_string(block_->pr) + " World Locks each.```7]``")));
					p.Insert(0), p.Insert(0);
					gamepacket_t p2;
					p2.Insert("OnConsoleMessage");
					p2.Insert((block_->pr == 0 ? "`7[``" + pInfo(p_)->tankIDName + " disabled the Vending Machine.```7]``" : "`7[``" + pInfo(p_)->tankIDName + " changed the price of `2" + items[block_->id].ori_name + "`` to " + (block_->pr < 0 ? "`6" + to_string(block_->pr * -1) + " per World Lock.```7]``" : "`5" + to_string(block_->pr) + " World Locks each.```7]``")));
					PlayerMoving data_{};
					data_.packetType = 17;
					data_.netID = 44;
					data_.YSpeed = 44;
					data_.x = x_ * 32 + 16;
					data_.y = y_ * 32 + 16;
					BYTE* raw = packPlayerMoving(&data_);
					string t_ = "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0";
					BYTE* const d_ = new BYTE[5 + t_.length()];
					*(__int8*)(d_) = 3;
					memcpy(d_ + 4, t_.c_str(), t_.length());
					*(__int8*)(d_ + 4 + t_.length()) = 0;
					ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
							enet_peer_send(currentPeer, 0, p_m);
							send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[]d_;
					delete[] raw;
				}
				tile_update(p_, world_, block_, x_, y_);
			}
			break;
		}
		else if (a_[i_] == "displayblock") {
			if (a_.size() != 11) break;
			if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
			int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
			if (x_ < 0 or y_ < 0) break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (y_ >= world_->max_y || x_ >= world_->max_x) break;
				WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
				uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
				if (items[t_].blockType != BlockTypes::DISPLAY) break;
				string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(p_)->tankIDName);
				if (owner_name != user_name and not owner_name.empty() and not pInfo(p_)->dev) {
					if (block_->locked) {
						WorldBlock* check_lock = &world_->blocks[block_->lock_origin];
						if (check_lock->owner_name != pInfo(p_)->tankIDName) break;
					}
					else {
						break;
					}
				}
				if (a_.size() == 11) {
					int c_ = 1;
					if (modify_inventory(p_, block_->id, c_) == 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You removed `5" + items[block_->id].name + "`` from the " + items[block_->fg].name + ".");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
						block_->id = 0;
						tile_update(p_, world_, block_, x_, y_);
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("You don't have room to pick that up!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(p_);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "trade_confirm") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				cancel_trade(p_, true);
			}
			else if (a_[5] == "accept") {
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == pInfo(p_)->world) {
						if (pInfo(currentPeer)->netID == pInfo(p_)->trading_with and pInfo(p_)->netID == pInfo(currentPeer)->trading_with) {
							pInfo(p_)->accept_the_offer = true;
							if (pInfo(currentPeer)->accept_the_offer and pInfo(p_)->accept_the_offer) {
								string name_ = pInfo(p_)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									if (not trade_space_check(p_, currentPeer)) {
										cancel_trade(p_);
										return;
									}
									else if (not trade_space_check(currentPeer, p_)) {
										cancel_trade(p_);
										return;
									}
									bool c_ = false;
									for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
										if (c_) break;
										map<string, int>::iterator it;
										for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												{
													vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994 || a.fg == 10000; });
													if (p != world_->blocks.end()) {
														cancel_trade(p_);
														return;
													}
												}
												c_ = true;
												break;
											}
										}
									}
									c_ = false;
									for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
										if (c_) break;
										map<string, int>::iterator it;
										for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
											if (it->first == 1424 or it->first == 5816) {
												{
													vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994 || a.fg == 10000; });
													if (p != world_->blocks.end()) {
														cancel_trade(currentPeer);
														return;
													}
												}
												c_ = true;
												break;
											}
										}
									}
									vector<string> traded_p;
									int time_out = 0;
									for (int i_ = 0; i_ < pInfo(p_)->trade_items.size(); i_++) {
										map<string, int>::iterator it;
										for (auto it = pInfo(p_)->trade_items[i_].begin(); it != pInfo(p_)->trade_items[i_].end(); it++) {

											int c_ = it->second * -1;
											if (modify_inventory(p_, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, p_, currentPeer);
												}
												else {
													int c2_ = it->second;
													modify_inventory(currentPeer, it->first, c2_, true);
												}
												PlayerMoving data_{};
												time_out += 450;
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450, data_.netID = pInfo(currentPeer)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(p_)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												memcpy(raw + 8, &to_netid, 4);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												{
													gamepacket_t p((i_ + 1) * 450, pInfo(p_)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(p_);
												}
												{
													gamepacket_t p((i_ + 1) * 450, pInfo(currentPeer)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(currentPeer);
												}
											}
										}
									}
									string traded_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1)
												traded_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_)
												traded_ += traded_p[i_] + " and ";
											else
												traded_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded_ = "nothing";
									}
									traded_p.clear();
									for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
										map<string, int>::iterator it;
										for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {

											int c_ = it->second * -1;
											if (modify_inventory(currentPeer, it->first, c_, true) == 0) {
												traded_p.push_back(to_string(it->second) + " " + items[it->first].name);
												if (it->first == 1424 or it->first == 5816) {
													transfer_world(world_, currentPeer, p_);
												}
												else {
													int c2_ = it->second;
													modify_inventory(p_, it->first, c2_, true);
												}
												PlayerMoving data_{};
												data_.packetType = 19, data_.plantingTree = (i_ + 1) * 450 + time_out, data_.netID = pInfo(p_)->netID;
												data_.punchX = it->first, data_.punchY = it->first;
												int32_t to_netid = pInfo(currentPeer)->netID;
												BYTE* raw = packPlayerMoving(&data_);
												raw[3] = 3;
												memcpy(raw + 8, &to_netid, 4);
												for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
													if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL) continue;
													if (pInfo(currentPeer2)->world == world_->name) {
														send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[]raw;
												{
													gamepacket_t p((i_ + 1) * 450 + time_out, pInfo(p_)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(p_);
												}
												{
													gamepacket_t p((i_ + 1) * 450 + time_out, pInfo(currentPeer)->netID);
													p.Insert("OnPlayPositioned");
													p.Insert("audio/change_clothes.wav");
													p.CreatePacket(currentPeer);
												}
											}
										}
									}
									string traded2_ = "";
									if (traded_p.size() != 0) {
										for (int i_ = 0; i_ < traded_p.size(); i_++) {
											if (traded_p.size() == i_ + 1)
												traded2_ += traded_p[i_];
											else if (traded_p.size() - 2 == i_)
												traded2_ += traded_p[i_] + " and ";
											else
												traded2_ += traded_p[i_] + ", ";
										}
									}
									else {
										traded2_ = "nothing";
									}
									{
										if (pInfo(p_)->grow4good_trade < 10) daily_quest(p_, false, "trade", 1);
										if (pInfo(currentPeer)->grow4good_trade < 10) daily_quest(currentPeer, false, "trade", 1);
										struct tm newtime;
										time_t now = time(0);
										localtime_s(&newtime, &now);
										if (pInfo(p_)->trade_history.size() >= 10) pInfo(p_)->trade_history.erase(pInfo(p_)->trade_history.begin() + 0);
										if (pInfo(currentPeer)->trade_history.size() >= 10) pInfo(currentPeer)->trade_history.erase(pInfo(currentPeer)->trade_history.begin() + 0);
										pInfo(p_)->trade_history.push_back("`9You traded [" + traded_ + "] with `1" + get_player_nick(currentPeer) + "`` in `2" + pInfo(p_)->world + "`` " + (traded2_ == "nothing" ? "" : +"and received [" + traded2_ + "] ") + "`0at " + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : to_string(newtime.tm_hour)) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : to_string(newtime.tm_min)) + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + ".``");
										pInfo(currentPeer)->trade_history.push_back("`9You traded [" + traded2_ + "] with `1" + get_player_nick(p_) + "`` in `2" + pInfo(p_)->world + "`` " + (traded_ == "nothing" ? "" : +"and received [" + traded_ + "] ") + "`0at " + (newtime.tm_hour < 10 ? "0" + to_string(newtime.tm_hour) + "" : to_string(newtime.tm_hour)) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : to_string(newtime.tm_min)) + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + ".``");
										gamepacket_t p2;
										p2.Insert("OnConsoleMessage");
										p2.Insert("`1" + fixchar2(get_player_nick(currentPeer)) + " traded " + traded2_ + " to " + fixchar2(get_player_nick(p_)) + ".``");
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("`1" + fixchar2(get_player_nick(p_)) + " traded " + traded_ + " to " + fixchar2(get_player_nick(currentPeer)) + ".``");
										for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
											if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer2)->world != world_->name) continue;
											p.CreatePacket(currentPeer2);
											p2.CreatePacket(currentPeer2);
										}
									}
									{
										gamepacket_t p(1250, pInfo(currentPeer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/keypad_hit.wav");
										p.CreatePacket(currentPeer), p.CreatePacket(p_);
									}
									//if (not pInfo(currentPeer)->invalid_data) save_player(pInfo(currentPeer), (f_saving_ ? false : true));
									//if (not pInfo(p_)->invalid_data) save_player(pInfo(p_), (f_saving_ ? false : true));
									pInfo(currentPeer)->block_trade = false, pInfo(currentPeer)->accept_the_offer = false, pInfo(currentPeer)->trade_accept = false, pInfo(currentPeer)->trading_with = -1, pInfo(currentPeer)->trade_items.clear();
									pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
								}
								return;
							}
							for (int i_ = 0; i_ < pInfo(currentPeer)->trade_items.size(); i_++) {
								map<string, int>::iterator it;
								for (auto it = pInfo(currentPeer)->trade_items[i_].begin(); it != pInfo(currentPeer)->trade_items[i_].end(); it++) {
									if (it->first == 1424 or it->first == 5816) {
										pInfo(p_)->accept_the_offer = false;
										send_trade_confirm_dialog(p_, currentPeer, true);
										{
											gamepacket_t p;
											p.Insert("OnTextOverlay");
											p.Insert("`6[``you must wait for the other player to accept first`6]``");
											p.CreatePacket(p_);
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(currentPeer)->netID);
										p.Insert("`6[``You must accept first because you're selling a World Key`6]``");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(currentPeer);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`6[``You must accept first because you're selling a World Key`6]``");
											p.CreatePacket(currentPeer);
										}
										return;
									}
								}
							}
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("`6[``Trade accepted, waiting for other player to accept`6]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6[``Trade accepted, waiting for other player to accept`6]``");
								p.CreatePacket(p_);
							}
							{
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(currentPeer)->netID);
								p.Insert("`6[``Trade accepted by other player, waiting for you`6]``");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(currentPeer);
							}
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`6[``Trade accepted by other player, waiting for you`6]``");
								p.CreatePacket(currentPeer);
							}
							return;
						}
					}
				}
				gamepacket_t p;
				p.Insert("OnTextOverlay");
				p.Insert("The other person left the trade!");
				p.CreatePacket(p_);
				pInfo(p_)->block_trade = false, pInfo(p_)->trading_with = -1, pInfo(p_)->trade_accept = false, pInfo(p_)->accept_the_offer = false, pInfo(p_)->trade_items.clear();
			}
			break;
		}
		else if (a_[i_] == "friends_remove_finish") {
			send_friends(p_);
			break;
		}
		else if (a_[i_] == "friends_remove") {
			if (a_.size() != 11) break;
			if (a_[8] == "back") {
				send_info_friend(p_, a_[5]);
				break;
			}
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				remove_friend(p_, world_, a_[5]);
			}
			break;
		}
		else if (a_[i_] == "friends_ignore") {
		if (a_.size() != 11) break;
		if (a_[8] == "back") {
			send_friends(p_);
			break;
		}
		if (find(pInfo(p_)->ignored.begin(), pInfo(p_)->ignored.end(), to_lower(a_[5])) != pInfo(p_)->ignored.end()) {
			string name = to_lower(a_[5]);
			pInfo(p_)->ignored.erase(remove(pInfo(p_)->ignored.begin(), pInfo(p_)->ignored.end(), name), pInfo(p_)->ignored.end());
			gamepacket_t p;
			p.Insert("OnDialogRequest");
			p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Ignore removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`oOk, you will now be able to see chat from "+ name +".|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_remove_finish|||\nadd_quick_exit|");
			p.CreatePacket(p_);
		}
		break;
		}
		else if (a_[i_] == "mute_friend" or a_[i_] == "block_friend") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			else if (a_[i_] == "mute_friend" and a_[5] == "ok") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(pInfo(p_)->last_edit)) {
						if (pInfo(p_)->friends[c_].mute)
							pInfo(p_)->friends[c_].mute = false;
						else
							pInfo(p_)->friends[c_].mute = true;
					}
				}
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			else if (a_[i_] == "block_friend" and a_[5] == "ok") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(pInfo(p_)->last_edit)) {
						if (pInfo(p_)->friends[c_].block_trade)
							pInfo(p_)->friends[c_].block_trade = false;
						else
							pInfo(p_)->friends[c_].block_trade = true;
					}
				}
				send_info_friend(p_, pInfo(p_)->last_edit);
			}
			break;
		}
		else if (a_[i_] == "friends_message") {
			if (a_.size() != 13) break;
			if (a_[8] == "back") {
				send_info_friend(p_, a_[5]);
			}
			else if (a_[8] == "send") {
				string message = explode("\n", explode("|", cch)[11])[0].c_str();
				SendCmd(p_, "/msg " + pInfo(p_)->last_wrenched + " " + message, true);
			}
			break;
		}
		else if (a_[i_] == "friends_edit" || a_[i_] == "friends_message") {
			if (a_.size() != 11) break;
			if (a_[8] == "back") {
				send_friends(p_);
			}
			else if (a_[8] == "remove" or a_[8] == "back") {
				edit_friend(p_, a_[5], (a_[8] == "back" ? true : false));
			}
			else if (a_[8] == "goto") {
				if (has_playmod2(pInfo(p_), 139)) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(p_)->netID), p.Insert("Hmm, you can't do that while cursed."), p.Insert(0), p.Insert(0), p.CreatePacket(p_);
					return;
				}
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(a_[5])) {
						for (int c_ = 0; c_ < pInfo(currentPeer)->friends.size(); c_++) {
							if (to_lower(pInfo(currentPeer)->friends[c_].name) == to_lower(pInfo(p_)->tankIDName)) {
								if (pInfo(currentPeer)->show_location_) {
									if (pInfo(currentPeer)->world.empty()) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("Hmm, my friend isn't in a world right now.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									else if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									join_world(p_, pInfo(currentPeer)->world);
								}
								break;
							}
						}
					}
				}
			}
			else if (a_[8] == "msg") {
				pInfo(p_)->last_wrenched = a_[5];
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`5Message to ``" + a_[5] + "|left|660|\nadd_spacer|small|\nadd_text_input|text|||80|left|\nadd_spacer|small|\nembed_data|friendID|" + a_[5] + "\nadd_button|send|`5Send``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_message|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_[8] == "mute" or a_[8] == "trade_block") {
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(a_[5])) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						if (a_[8] == "mute") {
							if (not pInfo(p_)->friends[c_].mute)
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Mute`` " + a_[5] + "? You will not receive any messages from this player until you unmute, consider this /ignore a friend|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
							else
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Un Mute`` " + a_[5] + "? You will receive any messages from this player until you mute.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|mute_friend|||\nadd_quick_exit|");
						}
						else {
							if (not pInfo(p_)->friends[c_].block_trade)
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Disable Trade`` with " + a_[5] + "? You will not receive any trade request until you enable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
							else
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|Are you sure you want to `4Enable Trade`` with " + a_[5] + "? You will receive any trade request until you disable trading again.|left|\nadd_button|ok|OK|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|block_friend|||\nadd_quick_exit|");
						}
						p.CreatePacket(p_);
					}
				}
			}
			break;
		}
		else if (a_[i_] == "friends_options") {
		if (a_.size() != 12) break;
		if (a_[7] == "checkbox_public") pInfo(p_)->show_location_ = stoi(a_[8]);
		if (a_[9] == "checkbox_notifications") pInfo(p_)->show_friend_notifications_ = stoi(a_[10]);
		if (a_[5] == "back") {
			vector<string> friends_;
			for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
				friends_.push_back(pInfo(p_)->friends[c_].name);
			}
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (find(friends_.begin(), friends_.end(), to_lower(pInfo(currentPeer)->tankIDName)) != friends_.end()) {
					send_friends(p_, true);
					return;
				}
			}
			send_friends(p_);
		}
		break;
		}
		else if (a_[i_] == "send_mailbox") {
		if (a_.size() != 12) break;
		if (a_[5] == "back") {
			send_mail(p_);
			break;
		}
		string growid = "", text = "";
		if (a_[7] == "growid") growid = to_lower(a_[8]);
		if (a_[9] == "text") text = "\nadd_smalltext|'" + get_player_nick(p_) + "': " + a_[10] + "|left|";
		string path_ = "players/" + growid + "_.json";
		gamepacket_t pt;
		pt.Insert("OnTalkBubble");
		pt.Insert(pInfo(p_)->netID);
		if (a_[10].length() <= 3) {
			pt.Insert("That's not interesting enough to post.");
		}
		else if (_access_s(path_.c_str(), 0) != 0) {
			pt.Insert("That person does not exist.");
		}
		else if (growid == to_lower(pInfo(p_)->tankIDName)) {
			pt.Insert("Can not send mail to yourself.");
		}
		else {
			replace_str(text, "<CR>", "");
			string::difference_type count_of_symbol = 0;
			vector<pair<string, string>>::iterator paa = find_if(mails.begin(), mails.end(), [&](const pair<string, string>& a) { return a.first == growid; });
			if (paa != mails.end()) {
				count_of_symbol = std::count(mails[paa - mails.begin()].second.begin(), mails[paa - mails.begin()].second.end(), '\n');
				if (count_of_symbol <= 50) mails[paa - mails.begin()].second += text;
			}
			else mails.push_back(make_pair(growid, text));
			if (count_of_symbol <= 50) {
				pt.Insert("`2Mail was sent to " + growid + "``");
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (growid == to_lower(pInfo(currentPeer)->tankIDName)) {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("CP:0_PL:0_OID:_CT:[MSG]_>> `c>> from (```c`4@System```c) you have`` 1 `cnew message in your mailbox.``");
						p.CreatePacket(currentPeer);
						packet_(currentPeer, "action|play_sfx\nfile|audio/friend_logon.wav\ndelayMS|0");
					}
				}
			}
			else pt.Insert("That person mailbox is full!");
		}
		pt.Insert(0), pt.Insert(0);
		pt.CreatePacket(p_);
		break;
		}
		else if (a_[i_] == "mute_all_friends" or a_[i_] == "remove_all_friends" or a_[i_] == "block_all_friends") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_all_edit_friends(p_);
				break;
			}
			if (a_[5] == "close")
				break;
			string name_ = pInfo(p_)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					if (find(pInfo(p_)->last_friends_selection.begin(), pInfo(p_)->last_friends_selection.end(), c_) != pInfo(p_)->last_friends_selection.end()) {
						if (a_[i_] == "mute_all_friends") pInfo(p_)->friends[c_].mute = (pInfo(p_)->friends[c_].mute ? false : true);
						else if (a_[i_] == "block_all_friends") pInfo(p_)->friends[c_].block_trade = (pInfo(p_)->friends[c_].block_trade ? false : true);
						else if (a_[i_] == "remove_all_friends") remove_friend(p_, world_, pInfo(p_)->friends[c_].name, false);
					}
				}
				send_all_edit_friends(p_);
			}
			break;
		}
		else if (a_[i_] == "all_friends") {
			if (a_.size() < 10) break;
			if (a_[5] == "back") {
				vector<string> friends_;
				for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
					friends_.push_back(pInfo(p_)->friends[c_].name);
				} for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (find(friends_.begin(), friends_.end(), to_lower(pInfo(currentPeer)->tankIDName)) != friends_.end()) {
						send_friends(p_, true);
						return;
					}
				}
				send_friends(p_);
				break;
			}
			pInfo(p_)->last_friends_selection.clear();
			string action_ = a_[5];
			try {
				for (int b_ = 0; b_ < a_.size(); b_++) {
					if (a_.at(b_).substr(0, 3) == "cf_") {
						if (a_.at(b_ + 1) == "1")
							pInfo(p_)->last_friends_selection.push_back(atoi(explode("_", a_.at(b_)).at(1).c_str()));
					}
				}
			}
			catch (out_of_range) {
				break;
			}
			if (pInfo(p_)->last_friends_selection.size() == 0) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oYou have not selected any friends|left|\nadd_spacer|small|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|remove_all_friends|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (action_ == "mute_multi_friends")
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4mute`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|mute_all_friends|||\nadd_quick_exit|");
				else if (action_ == "block_multi_friends")
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4block trade`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|block_all_friends|||\nadd_quick_exit|");
				else
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wConfirm``|left|1366|\nadd_textbox|`oAre you sure you want to `4remove`` " + to_string(pInfo(p_)->last_friends_selection.size()) + " friends?|left|\nadd_spacer|small|\nadd_button|confirm|`wYes``|noflags|0|0|\nadd_button|back|`wBack``|noflags|0|0|\nadd_button|close|`wClose``|noflags|0|0|\nend_dialog|remove_all_friends|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "show_guild_logs") {
			if (a_.size() != 8) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string guild_info = get_guild_info(p_);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
				p.Insert(guild_info);
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guildpage") {
			if (a_.size() != 10) break;
			if (a_[5] == "changestatementsubmit") {
				string new_stat = a_[8];
				if (new_stat.size() < 6 or new_stat.size() > 24) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert(get_guild_statement_edit(p_, "`1You need to enter at least `$6 characters`` to add a guild statement!``"));
					p.CreatePacket(p_);
					break;
				}
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (new_stat == guild_information->guild_description) break;
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
							my_rank = member_search.role_id;
							break;
						}
					}
					if (my_rank <= 2) break;
					guild_information->guild_description = new_stat;
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					string guild_info = get_guild_info(p_);
					if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
					p.Insert(guild_info);
					p.CreatePacket(p_);
					create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wchanged guild statement to `$" + new_stat + "``", 658);
				}
			}
			break;
		}
		else if (a_[i_] == "guild_members_options") {
			if (a_.size() != 12) break;
			if (pInfo(p_)->guild_id == 0) break;
			string public_ = a_[8];
			if (public_ != "0" and public_ != "1") break;
			string notifications_ = a_[10];
			if (notifications_ != "0" and notifications_ != "1") break;
			uint32_t guild_id = pInfo(p_)->guild_id;
			vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
			if (p != guilds.end()) {
				Guild* guild_information = &guilds[p - guilds.begin()];
				guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
				guild_information->guild_settings |= Gtps3::SETTINGS_0;
				for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
					GuildMember* member_search = &guild_information->guild_members[i_];
					if (to_lower(member_search->member_name) == to_lower(pInfo(p_)->tankIDName)) {
						if (not member_search->public_location and public_ == "1") {
							member_search->public_location = true;
						}
						else if (member_search->public_location and public_ == "0") {
							member_search->public_location = false;
						}
						{
							if (not member_search->show_notifications and notifications_ == "1") {
								member_search->show_notifications = true;
							}
							else if (member_search->show_notifications and notifications_ == "0") {
								member_search->show_notifications = false;
							}
						}
						break;
					}
				}
			}
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string guild_info = get_guild_info(p_);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
				p.Insert(guild_info);
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guildmembers") {
			if (a_.size() != 8) break;
			if (pInfo(p_)->guild_id == 0) break;
			if (a_[5] == "guild_members_all") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string guild_info = get_guild_info(p_, true);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
				p.Insert(guild_info);
				p.CreatePacket(p_);
			}
			else if (a_[5] == "guild_members_options") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							string notify_ = (member_search.show_notifications ? "1" : "0");
							string public_ = (member_search.public_location ? "1" : "0");
							string guild_foreground = (guild_information->guild_mascot[0] == 0 ? "5814" : to_string(guild_information->guild_mascot[0]));
							string guild_background = (guild_information->guild_mascot[1] == 0 ? "0" : to_string(guild_information->guild_mascot[1]));
							p.Insert("set_default_color|`o\nadd_dual_layer_icon_label|big|`wGuild Member Options``|left|" + guild_background + "|" + guild_foreground + "|1.0|0|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to guild members|" + public_ + "\nadd_checkbox|checkbox_notifications|Show guild member notifications|" + notify_ + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_members_options|||\nadd_quick_exit|");
							p.CreatePacket(p_);
							break;
						}
					}
				}
			}
			else if (a_[5] == "changestatement") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(get_guild_statement_edit(p_));
				p.CreatePacket(p_);
			}
			else if (a_[5] == "guild_logs") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					vector<string> logs{};
					vector<vector<string>> sort_by_time;
					for (GuildLog log_ : guild_information->guild_logs) {
						sort_by_time.push_back({
							to_string(log_.date),
							log_.info,
							to_string(log_.display_id)
							});
					}
					sort(sort_by_time.begin(), sort_by_time.end(), [](const vector< string >& a, const vector< string >& b) {
						return atoi(a[1].c_str()) > atoi(b[1].c_str());
						});
					for (int i = sort_by_time.size() - 1; i >= 0; i--) {
						char* endptr = NULL;
						long long laikas_ = strtoll(sort_by_time[i][0].c_str(), &endptr, 10);
						const time_t* temp = &laikas_;
						string the_time = strtok(ctime(temp), "\n");
						logs.push_back("\nadd_label_with_icon|small|" + sort_by_time[i][1] + " `wat " + the_time + "|left|" + sort_by_time[i][2] + "|\nadd_spacer|small|");
					}
					if (logs.size() == 0) {
						logs.push_back("\nadd_label_with_icon|small|There are no logs at the moment!|left|8|\nadd_spacer|small|");
					}
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big| `w" + guild_information->guild_name + " Logs``|left|1436\nadd_spacer|small|" + join(logs, "") + "\nadd_button|back|`wBack``|noflags|0|0|\nend_dialog|show_guild_logs|||\nadd_quick_exit|");
					p.CreatePacket(p_);
				}
			}
			else if (a_[5] == "warphome") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					if (pInfo(p_)->world == guild_information->guild_world) {
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}

						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
						p.CreatePacket(p_);
						break;
					}
					gamepacket_t p;
					p.Insert("OnTextOverlay");
					p.Insert("Moving to guild home (`2" + guild_information->guild_world + "``) ...");
					p.CreatePacket(p_);
					join_world(p_, guild_information->guild_world);
				}
			}
			else if (a_[5] == "back") {
				send_social(p_);
			}
			else if (a_[5] == "leave_guild") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wLeave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4leave`` the guild?|left|\nadd_spacer|small|\nadd_button|leave_guild_confirmed|`4Leave Guild``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|leave_guild|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, to_lower(guild_member_name));
			}
			break;
		}
		else if (a_[i_] == "leave_guild") {
			if (a_[5] == "leave_guild_confirmed") {
				if (pInfo(p_)->guild_id == 0) break;
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					leave_guild(p_);
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Leave Guild``|left|1366|\nadd_spacer|small|\nadd_textbox|`o You are no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog||||\nadd_quick_exit|");
					p.CreatePacket(p_);
					if (guild_information->guild_world == pInfo(p_)->world) {
						string name_ = pInfo(p_)->world;
						vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
						if (p_w != worlds.end()) {
							World* world_ = &worlds[p_w - worlds.begin()];
							int x_ = 0, y_ = 0;
							int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
							{
								vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
								if (p != world_->blocks.end()) {
									int i_ = p - world_->blocks.begin();
									x_ = i_ % xSize;
									y_ = i_ / xSize;
								}
							}
							WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
							tile_update(p_, world_, block_, x_, y_);
						}
					}
				}
			}
			else {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, to_lower(guild_member_name));
			}
		}
		else if (a_[i_] == "guild_member_role_change_finish") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string guild_info = get_guild_info(p_);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
				p.Insert(guild_info);
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guild_member_role_change") {
			if (a_.size() != 14) break;
			if (a_[11] == "back") {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, to_lower(guild_member_name));
			}
			else if (a_[11] == "promote" or a_[11] == "demote") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
							my_rank = member_search.role_id;
							break;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (to_lower(member_search->member_name) == to_lower(a_[5])) {
							bool can_promote = false;
							bool can_demote = false;
							if (member_search->role_id != 3) {
								if (member_search->role_id == 1 and my_rank == 3) {
									can_promote = true;
									can_demote = true;
								}
								else if (member_search->role_id == 2 and my_rank == 3) {
									can_promote = false;
									can_demote = true;
								}
								else if (member_search->role_id != 3 and my_rank >= 2 and member_search->role_id != 2) {
									can_promote = true;
								}
							}
							if (can_promote and a_[11] == "promote") {
								guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
								guild_information->guild_settings |= Gtps3::SETTINGS_0;
								member_search->role_id++;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Promoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[8] + " is `2promoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` `2" + a_[8] + "`` has been `2promoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(a_[8])) {
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														{
															vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
															if (p != world_->blocks.end()) {
																int i_ = p - world_->blocks.begin();
																x_ = i_ % xSize;
																y_ = i_ / xSize;
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
														tile_update(currentPeer, world_, block_, x_, y_);
													}
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `2promoted `$" + a_[8] + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 484);
							}
							else if (can_demote and a_[11] == "demote") {
								member_search->role_id--;
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member Demoted``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[8] + " is `4demoted`` to " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_role_change_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` `2" + a_[8] + "`` has been `4demoted`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member") + "!");
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) {
											p.CreatePacket(currentPeer);
										}
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(a_[8])) {
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														{
															vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
															if (p != world_->blocks.end()) {
																int i_ = p - world_->blocks.begin();
																x_ = i_ % xSize;
																y_ = i_ / xSize;
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
														tile_update(currentPeer, world_, block_, x_, y_);
													}
												}
											}
										}
									}
								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `4demoted `$" + a_[8] + "`` `oto " + (member_search->role_id == 3 ? "Leader" : member_search->role_id == 2 ? "Co-Leader" : member_search->role_id == 1 ? "Elder" : "Member"), 486);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "guild_member_remove_finish") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string guild_info = get_guild_info(p_);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
				p.Insert(guild_info);
				p.CreatePacket(p_);
			}
			break;
		}
		else if (a_[i_] == "guild_member_remove") {
			if (a_.size() != 11) break;
			if (a_[8] == "remove") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					uint32_t my_rank = 0;
					for (GuildMember member_search : guild_information->guild_members) {
						if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
							my_rank = member_search.role_id;
							break;
						}
					}
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (to_lower(member_search->member_name) == to_lower(a_[5])) {
							bool can_kick = my_rank >= 1 and member_search->role_id < my_rank;
							if (can_kick) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGuild Member removed``|left|1366|\nadd_spacer|small|\nadd_textbox|`o" + a_[5] + " is no longer in the guild.|left|\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|guild_member_remove_finish|||\nadd_quick_exit|");
								p.CreatePacket(p_);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5[GUILD ALERT]`` " + a_[5] + " kicked from the guild by " + pInfo(p_)->tankIDName);
									bool on_ = false;
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->guild_id == guild_id) p.CreatePacket(currentPeer);
										if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(a_[5])) {
											on_ = true;
											pInfo(currentPeer)->guild_id = 0;
											update_clothes_value(currentPeer);
											update_clothes(currentPeer);
											string name_ = pInfo(currentPeer)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												update_guild_name(currentPeer, guild_information->guild_world, world_);
												if (not guild_access(currentPeer, guild_id) and pInfo(currentPeer)->world == guild_information->guild_world) {
													string name_ = pInfo(currentPeer)->world;
													vector<World>::iterator p_w = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
													if (p_w != worlds.end()) {
														World* world_ = &worlds[p_w - worlds.begin()];
														int x_ = 0, y_ = 0;
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														{
															vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
															if (p != world_->blocks.end()) {
																int i_ = p - world_->blocks.begin();
																x_ = i_ % xSize;
																y_ = i_ / xSize;
															}
														}
														WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
														tile_update(currentPeer, world_, block_, x_, y_);
													}
												}
											}
										}
									}
									if (not on_) {
										string path_ = "players/" + a_[5] + "_.json";
										if (_access_s(path_.c_str(), 0) == 0) {
											json r_;
											ifstream f_(path_, ifstream::binary);
											f_ >> r_;
											f_.close();
											r_[guild_name_player] = 0;
											{
												ofstream f_(path_, ifstream::binary);
												f_ << r_;
												f_.close();
											}
										}
									}

								}
								create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wkicked `$" + a_[5] + "`` from the guild", 6);
								guild_information->guild_members.erase(guild_information->guild_members.begin() + i_);
							}
							break;
						}
					}
				}
			}
			else if (a_[8] == "back") {
				string guild_member_name = a_[5];
				send_guild_member_info(p_, to_lower(guild_member_name));
			}
			break;
		}
		else if (a_[i_] == "guild_member_edit") {
			if (a_.size() != 14) break;
			if (a_[11] == "back") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string guild_info = get_guild_info(p_);
				if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
				p.Insert(guild_info);
				p.CreatePacket(p_);
			}
			else if (a_[11] == "promote" or a_[11] == "demote" or a_[11] == "goto" or a_[11] == "remove") {
				uint32_t guild_id = pInfo(p_)->guild_id;
				vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
				if (p != guilds.end()) {
					Guild* guild_information = &guilds[p - guilds.begin()];
					for (int i_ = 0; i_ < guild_information->guild_members.size(); i_++) {
						GuildMember* member_search = &guild_information->guild_members[i_];
						if (to_lower(member_search->member_name) == to_lower(a_[8])) {
							if (a_[11] == "remove") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wKick Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4kick`` " + a_[8] + " from the guild?|left|\nadd_spacer|small|\nadd_button|remove|`4Kick " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_remove|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							else if (a_[11] == "goto") {
								string world_name = "";
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(a_[8])) {
										world_name = pInfo(currentPeer)->world;
										break;
									}
								}
								if (world_name.empty()) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Hmm, my friend isn't in a world right now.");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									break;
								}
								else {
									if (world_name == pInfo(p_)->world) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("You want to warp to the same world you're in?  That's illogical, captain.");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("Moving to guild member location (`2" + world_name + "``) ...");
									p.CreatePacket(p_);
									join_world(p_, world_name);
								}
							}
							else if (a_[11] == "promote") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPromote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `2promote`` " + a_[8] + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "" : member_search->role_id == 1 ? "Co-Leader" : "Elder") + "?|left|\nadd_spacer|small|\nadd_button|promote|`wPromote " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nembed_data|guildmembername|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							else if (a_[11] == "demote") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDemote Guild Member``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to `4demote`` " + a_[8] + " to " + (member_search->role_id == 3 ? "" : member_search->role_id == 2 ? "Elder" : member_search->role_id == 1 ? "Member" : "") + "?|left|\nadd_spacer|small|\nadd_button|demote|`wDemote " + a_[8] + "``|noflags|0|0|\nembed_data|guildMemberID|" + a_[8] + "\nembed_data|guildmembername|" + a_[8] + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|guild_member_role_change|||\nadd_quick_exit|");
								p.CreatePacket(p_);
							}
							break;
						}
					}
				}
			}
			break;
		}
		else if (a_[i_] == "friends") {
			if (a_.size() != 8) break;
			if (a_[5] == "back") {
				send_social(p_);
			}
			else if (a_[5] == "all_friends") {
				send_all_edit_friends(p_);
			}
			else if (a_[5] == "friends_options") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wFriend Options``|left|1366|\nadd_spacer|small|\nadd_checkbox|checkbox_public|Show location to friends|" + to_string(pInfo(p_)->show_location_) + "\nadd_checkbox|checkbox_notifications|Show friend notifications|" + to_string(pInfo(p_)->show_friend_notifications_) + "\nadd_spacer|small|\nadd_button|back|OK|noflags|0|0|\nend_dialog|friends_options|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_[5] == "send_mailbox") {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSend mail``|left|1366|\nadd_spacer|small|\nadd_text_input|growid|GrowID:||18|\nadd_text_input|text|Message:||200|\nadd_spacer|small|\nadd_button|send_mailbox|Send mail|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nadd_button||Close|noflags|0|0|\nend_dialog|send_mailbox|||\nadd_quick_exit|");
				p.CreatePacket(p_);
			}
			else if (a_[5] == "empty") {
				string player_name = to_lower(pInfo(p_)->tankIDName);
				vector<pair<string, string>>::iterator paa = find_if(mails.begin(), mails.end(), [&](const pair<string, string>& a) { return a.first == player_name; });
				if (paa != mails.end()) {
					int i_ = paa - mails.begin();
					mails.erase(mails.begin() + i_);
					packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(p_)->netID);
						p.Insert("Emptied all of your mails.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(p_);
					}
				}
			}
			else if (a_[5] == "friend_all") {
				send_friends(p_, true);
			}
			else {

				if (find(pInfo(p_)->ignored.begin(), pInfo(p_)->ignored.end(), to_lower(a_[5])) != pInfo(p_)->ignored.end()) {
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Remove ignore``|left|1366|\nadd_spacer|small|\nadd_textbox|`oAre you sure you wish to stop ignoring " + to_lower(a_[5]) + "?|left|\nadd_spacer|small|\nadd_button|remove|`4Remove ignore``|noflags|0|0|\nembed_data|friendID|" + to_lower(a_[5]) + "\nadd_button|back|Back|noflags|0|0|\nend_dialog|friends_ignore|||\nadd_quick_exit|");
					p.CreatePacket(p_);
				}
				else send_info_friend(p_, a_[5]);
			}
			break;
		}
		else if (a_[i_] == "unaccess") {
		string name_ = pInfo(p_)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
			bool upd_ = false;
			for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
				if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
					WorldBlock* block_ = &world_->blocks[i_];
					if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
						if (find(block_->admins.begin(), block_->admins.end(), to_lower(pInfo(p_)->tankIDName)) != block_->admins.end()) {
							block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), to_lower(pInfo(p_)->tankIDName)), block_->admins.end());
							tile_update(p_, world_, block_, i_% xSize, i_ / xSize);
							upd_ = true;
						}
						//...
					}
					else {
						if (find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) != world_->admins.end()) {
							world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)), world_->admins.end());
							tile_update(p_, world_, block_, i_% xSize, i_ / xSize);
							upd_ = true;
							nick_update_2(p_, NULL);
						}
					}
				}
			} if (upd_) {
				packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("Removed your access from all locks.");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
				}
				{
					gamepacket_t p;
					p.Insert("OnConsoleMessage");
					p.Insert("Removed your access from all locks.");
					p.CreatePacket(p_);
				}

				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert(pInfo(p_)->tankIDName + " removed their own access from all locks.");
				pInfo(p_)->name_color = (pInfo(p_)->give_role ? "`8@" : pInfo(p_)->Staff ? "`4@" : pInfo(p_)->superdev ? "`8@" : pInfo(p_)->dev ? "`6@" : (pInfo(p_)->mod) ? "`#@" : (to_lower(pInfo(p_)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
				nick_update_2(p_, NULL);
			}
			else {
				{
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(p_)->netID);
					p.Insert("You didn't have access on any locks!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(p_);
				}
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				p.Insert("You didn't have access on any locks!");
				p.CreatePacket(p_);
			}
		}
		break;
			}
		else if (a_[i_] == "confirmguild") {
		if (a_.size() != 14) break;
		int price = guild_create_gem_requirement;
		if (pInfo(p_)->supp > 1) price /= 2;
		if (pInfo(p_)->gems >= price) {
			if (pInfo(p_)->guild_id == 0) {
				string name_ = pInfo(p_)->world;
				vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
				if (p != worlds.end()) {
					World* world_ = &worlds[p - worlds.begin()];
					string guild_name = a_[5];
					string guild_description = a_[8];
					bool bad_name = false, already_taken = false;
					string check_name = to_lower(guild_name);
					for (int i = 0; i < swear_words.size(); i++) {
						if (check_name.find(to_lower(swear_words[i])) != string::npos) {
							bad_name = true;
							break;
						}
					}
					for (Guild check_guild_name : guilds) {
						if (to_lower(check_guild_name.guild_name) == check_name) {
							already_taken = true;
							break;
						}
					}
					current_uid++;
					int guild_id = current_uid;
					ofstream oo("guilduid.txt");
					oo << current_uid << endl;
					oo.close();
					if (already_taken or bad_name or guild_name.size() < 3 or guild_name.size() > 15 or guild_description.size() < 6 or guild_description.size() > 24 or special_char(guild_name) or world_->owner_name != pInfo(p_)->tankIDName) break;
					Guild new_guild{};
					new_guild.guild_id = guild_id;
					new_guild.guild_name = guild_name;
					new_guild.guild_settings |= Gtps3::SETTINGS_0;
					new_guild.guild_description = guild_description;
					new_guild.guild_world = pInfo(p_)->world;
					GuildMember new_member{};
					new_member.member_name = pInfo(p_)->tankIDName;
					new_member.role_id = 3;
					new_member.last_online = time(NULL);
					new_guild.guild_members.push_back(new_member);
					guilds.push_back(new_guild);
					save_guilds();
					pInfo(p_)->guild_id = guild_id;
					{
						int x_ = 0, y_ = 0;
						int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;

						{
							vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return items[a.fg].blockType == BlockTypes::LOCK && a.fg != 202 && a.fg != 204 && a.fg != 206 && a.fg != 4994 && a.fg != 10000; });
							if (p != world_->blocks.end()) {
								int i_ = p - world_->blocks.begin();
								x_ = i_ % xSize;
								y_ = i_ / xSize;
							}
						}
						WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
						world_->guild_id = guild_id;
						world_->fresh_world = true;
						block_->fg = 5814;
						PlayerMoving data_{};
						data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
						data_.netID = name_to_number(to_lower(pInfo(p_)->tankIDName));
						data_.plantingTree = block_->fg;
						BYTE* raw = packPlayerMoving(&data_, 56);
						PlayerMoving data_2{};
						data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
						BYTE* raw2 = packPlayerMoving(&data_2, 112 + (world_->admins.size() * 4));
						BYTE* blc = raw2 + 56;
						form_visual(blc, *block_, *world_, p_, false);
						update_clothes_value(p_, true);
						update_clothes(p_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw2, 112 + (world_->admins.size() * 4), ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw, raw2, blc;
						OnSetGems(p_, price * -1);
						pInfo(p_)->gems -= price;
						{
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("Guild created");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
						}
					}
					save_player(pInfo(p_), false);
				}
			}
		}
		else {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(p_)->netID);
			p.Insert("You don't have enough gems!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(p_);
		}
		break;
		}
						else if (a_[i_] == "createguild") {
							if (a_.size() != 12) break;
							int price = 5000;
							if (pInfo(p_)->supp > 1) price = 2500;
							if (pInfo(p_)->gems >= price) {
								string name_ = pInfo(p_)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									string guild_name = a_[8];
									string guild_description = a_[10];
									gamepacket_t p;
									p.Insert("OnDialogRequest");
									bool bad_name = false, already_taken = false;
									string check_name = to_lower(guild_name);
									for (int i = 0; i < swear_words.size(); i++) {
										if (check_name.find(swear_words[i]) != string::npos) {
											bad_name = true;
											break;
										}
									} for (Guild check_guild_name : guilds) {
										if (to_lower(check_guild_name.guild_name) == check_name) {
											already_taken = true;
											break;
										}
									} if (already_taken)
										p.Insert(get_guild_create(p_, "`4The guild name is not available!``", guild_name, guild_description));
									else if (bad_name)
										p.Insert(get_guild_create(p_, "`4Oops!`` Guild name cannot contain `$swear words``.", guild_name, guild_description));
									else if (guild_name.size() < 3 or guild_name.size() > 15)
										p.Insert(get_guild_create(p_, "You'll need a name `$3 characters`` or longer to create a Guild - select cancel and enter a longer name.", guild_name, guild_description));
									else if (guild_description.size() < 6 or guild_description.size() > 24)
										p.Insert(get_guild_create(p_, "You need to enter at least `$6 characters`` to add a guild statement!", guild_name, guild_description));
									else if (special_char(guild_name))
										p.Insert(get_guild_create(p_, "`4Oops!`` You can only use letters and numbers in your `$Guild`` name.", guild_name, guild_description));
									else if (world_->owner_name != pInfo(p_)->tankIDName)
										p.Insert(get_guild_create(p_, "You can only create the guild inside a world which is owned by you!", guild_name, guild_description));
									else
										p.Insert(get_guild_create(p_, "", guild_name, guild_description, true));
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[i_] == "requestcreateguildpage") {
							if (a_.size() != 8) break;
							string b_ = a_[5];
							if (b_ == "back") {
								send_social(p_);
							}
							else if (b_ == "showcreateguild") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(get_guild_create(p_));
								p.CreatePacket(p_);
							}
							break;
						}
						else if (a_[i_] == "socialportal") {
							if (a_.size() != 8) break;
							string b_ = a_[5];
							if (b_ == "showfriend") {
								send_friends(p_);
							}
							if (b_ == "showmailbox") {
								send_mail(p_);
							}
							else if (b_ == "showguild") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								string guild_info = get_guild_info(p_);
								if (guild_info == "set_default_color|`o\nadd_label_with_icon|big|`wGrow Guild ``|left|5814|\nadd_textbox|Something went wrong!|left|\nend_dialog|guildalreadyjoined|Close||") set_Guilds(p_);
								p.Insert(guild_info);
								p.CreatePacket(p_);
							}
							break;
						}
						else if (a_[i_] == "acceptaccess") {
							if (pInfo(p_)->access_offers.size() == 0) break;
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(p_)->world) {
									if (pInfo(p_)->access_offers.find(pInfo(currentPeer)->netID) != pInfo(p_)->access_offers.end()) {
										string name_ = pInfo(p_)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											if (world_->admins.size() >= 26) {
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(p_)->netID);
												p.Insert("World has reached access limit!");
												p.Insert(0);
												p.Insert(0);
												p.CreatePacket(p_);
												continue;
											}
											string peer_name = to_lower(pInfo(p_)->tankIDName), owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(currentPeer)->tankIDName);
											//world_->admins.push_back(peer_name);
											int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
											int x_ = (pInfo(p_)->access_offers[pInfo(currentPeer)->netID]) % xSize, y_ = (pInfo(p_)->access_offers[pInfo(currentPeer)->netID]) / xSize;
											if (x_ < 0 or y_ < 0) break;
											if (y_ >= world_->max_y || x_ >= world_->max_x) break;
											WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
											if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
												if (to_lower(block_->owner_name) != user_name) break;
												if (block_->admins.size() >= 26) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("Lock has reached access limit!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
													continue;
												}
												block_->admins.push_back(to_lower(peer_name));
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert(get_player_nick(p_) + " was given access to a " + items[block_->fg].name + ".");
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || pInfo(p_)->world != pInfo(currentPeer)->world) continue;
													p.CreatePacket(currentPeer);
												}
												tile_update(p_, world_, block_, x_, y_);
											}
											else {
												if (owner_name != user_name) break;
												if (world_->admins.size() >= 26) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("World has reached access limit!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
													continue;
												}
												world_->admins.push_back(to_lower(peer_name));
												if (pInfo(p_)->name_color == "`0") pInfo(p_)->name_color = "`^";
												nick_update_2(p_, NULL);
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert(get_player_nick(p_) + " was given access to a " + items[block_->fg].name + ".");
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED || pInfo(p_)->world != pInfo(currentPeer)->world) continue;
													p.CreatePacket(currentPeer);
												}
												tile_update(p_, world_, block_, x_, y_);
											}
											packet_(p_, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
										}
										pInfo(p_)->access_offers.clear();
										return;
									}
								}
							}
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							p.Insert("The lock owner has left!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							pInfo(p_)->access_offers.clear();
							break;
						}
						else if (a_[i_] == "worlds_list") {
							if (a_.size() != 8 and a_.size() != 5) break;
							if (a_.size() == 5) {
								send_wrench_self(p_);
								break;
							} if (pInfo(p_)->home_world == a_[5]) {
								bool a___ = false;
								for (pair<string, long long int> p : Server_Security.home_timed) {
									if (p.first == pInfo(p_)->tankIDName) {
										if (p.second + HOME_TIME > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
											a___ = true;
											gamepacket_t no;
											no.Insert("OnTalkBubble");
											no.Insert(pInfo(p_)->netID);
											no.Insert("`4Cooldown active`` - You can use `5home warp`` in `5" + to_string(((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) - ((((p.second + HOME_TIME - (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) / 1000) / 60) * 60)) + " ``seconds.");
											no.Insert(0), no.Insert(0);
											no.CreatePacket(p_);
											break;
										}
									}
								}
								if (a___)
									break;
								Server_Security.home_timed.push_back(make_pair(pInfo(p_)->tankIDName, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
							}
							join_world(p_, a_[5]);
							break;
						}
						else if (a_[i_] == "popup") {
							if (a_.size() == 8 and a_[5] == "my_worlds") {
								string home_world_ = "";
								string worlds_owned_ = "";
								if (not pInfo(p_)->home_world.empty()) {
									home_world_ += "\nadd_textbox|Your home world|left|\nadd_button|" + pInfo(p_)->home_world + "|" + pInfo(p_)->home_world + "|noflags|0|0|\nadd_spacer|small|";
								} for (int w_ = 0; w_ < pInfo(p_)->worlds_owned.size(); w_++) {
									worlds_owned_ += "\nadd_button|" + pInfo(p_)->worlds_owned[w_] + "|" + pInfo(p_)->worlds_owned[w_] + "|noflags|0|0|";
								} if (worlds_owned_.empty()) {
									worlds_owned_ = "\nadd_textbox|You do not have any World-Locked worlds.``|left|";
								}
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label|big|Worlds Locked|right\nadd_spacer|small|" + home_world_ + "\nadd_textbox|Your locked worlds|left|\nadd_textbox|You must be a Supporter or Super Supporter to warp to these worlds.|left|" + worlds_owned_ + "\nadd_quick_exit|\nadd_spacer|small|\nend_dialog|worlds_list||Back|");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "bonus") {
								growpass_rewards(p_);
							}
							else if (a_.size() == 8 and a_[5] == "account_security") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0Account Security``|left|1424|\nadd_spacer|small|\nadd_textbox|`6Network Info``|left|\nadd_smalltext|Status: `2ONLINE``|left|\nadd_smalltext|Email: `5" + pInfo(p_)->email + "``|left|\nadd_smalltext|IP: `5" + pInfo(p_)->ip + "``|left|\nadd_smalltext|RID: `5" + pInfo(p_)->rid + "``|left|\nadd_smalltext|MAC Address: `5" + pInfo(p_)->mac + "``|left|\nadd_smalltext|Country Code: `5" + pInfo(p_)->country + "``|left|\nadd_spacer|small\nadd_textbox|`6Assets Info``|left|\nadd_smalltext|Level: `5" + to_string(pInfo(p_)->level) + "``|left|\nadd_smalltext|Gems: `5" + setGems(pInfo(p_)->gems) + "``|left|\nadd_smalltext|XP: `5" + setGems(pInfo(p_)->xp) + "``|left|\nadd_smalltext|" + (pInfo(p_)->level >= 250 ? "MAX LEVEL." : "You need " + setGems((50 * (pInfo(p_)->level * pInfo(p_)->level) + 2) - pInfo(p_)->xp) + " XP to be level " + to_string(pInfo(p_)->level + 1)) + "|left|\nadd_spacer|small|\nadd_smalltext|Type what do you want to `5change``? (email/password)|left|\nadd_text_input|change|||10|\nend_dialog|account_security|OK|Continue|\n");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "glory") glory_show(p_);
							else if (a_.size() == 8 and a_[5] == "set") set_tab(p_);
							else if (a_.size() == 8 and a_[5] == "cheats") 	cheats(p_);
							else if (a_.size() == 8 and a_[5] == "skills") 	send_wrench_self(p_, "skills");
							else if (a_.size() == 8 and a_[5] == "info") 	send_wrench_self(p_, "");
							else if (a_.size() == 8 and a_[5] == "alist") {
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								p.Insert("đ we are working on that!");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "emojis") {
								string emoji = "", first_emoji = "\nadd_spacer|small|", chest_title = "", chest_have = "", chest_dont_have = "";
								if (pInfo(p_)->level >= 5) first_emoji += "\nadd_smalltext_forced| (sigh) |left|\nadd_smalltext_forced| (mad) |left|\nadd_smalltext_forced| (smile) |left|\nadd_smalltext_forced| (tongue) |left|\nadd_smalltext_forced| (wow) |left|";
								if (pInfo(p_)->supp >= 1) first_emoji += "\nadd_smalltext_forced| (no) |left|\nadd_smalltext_forced| (shy) |left|\nadd_smalltext_forced| (wink) |left|\nadd_smalltext_forced| (music) |left|\nadd_smalltext_forced| (lol) |left|";
								if (pInfo(p_)->supp == 2) first_emoji += "\nadd_smalltext_forced| (yes) |left|\nadd_smalltext_forced| (love) |left|\nadd_smalltext_forced| (megaphone) |left|\nadd_smalltext_forced| (heart) |left|\nadd_smalltext_forced| (cool) |left|";
								if (pInfo(p_)->friends.size() >= 10)  first_emoji += "\nadd_smalltext_forced| (kiss) |left|";
								if (pInfo(p_)->friends.size() >= 20)  first_emoji += "\nadd_smalltext_forced| (agree) |left|";
								if (pInfo(p_)->friends.size() >= 30)  first_emoji += "\nadd_smalltext_forced| (see-no-evil) |left|";
								if (pInfo(p_)->friends.size() >= 40)  first_emoji += "\nadd_smalltext_forced| (dance) |left|";
								if (pInfo(p_)->friends.size() >= 50)  first_emoji += "\nadd_smalltext_forced| (build) |left|";
								string cch = pInfo(p_)->growmoji;
								vector<string> a_ = explode("(", replace_str(cch, ")", "|"));
								for (int i_ = 0; i_ < a_.size(); i_++) {
									string str = a_[i_];
									size_t i = 0;
									for (; i < str.length(); i++) { if (isdigit(str[i])) break; }
									str = str.substr(i, str.length() - i);
									int id = atoi(str.c_str());
									if (not a_[i_].empty()) {
										string emojied = fixchar3(a_[i_]);
										if (emojied == "oops" || emojied == "sleep" || emojied == "punch" || emojied == "bheart" || emojied == "cry" || emojied == "bunny" || emojied == "cactus" || emojied == "pine" || emojied == "peace" || emojied == "terror" || emojied == "troll" || emojied == "fireworks" || emojied == "party" || emojied == "song" || emojied == "ghost" || emojied == "nuke" || emojied == "halo" || emojied == "lucky" || emojied == "weary" || emojied == "moyai" || emojied == "plead" || emojied == "wl" || emojied == "grow" || emojied == "gems" || emojied == "gtoken" || emojied == "vend" || emojied == "football") {
											if (id) first_emoji += "\nadd_smalltext_forced| (" + emojied + ") |left|";
											else emoji += "\nadd_smalltext|`9This Growmoji can be found in a secret event.``|left|\nadd_smalltext_forced_alpha| (" + emojied + ") | 0.5|left|\nadd_spacer|small|";
										}
										else {
											if (id) {
												chest_have += "\nadd_smalltext_forced| (" + emojied + ") |left|";
											}
											else {
												chest_title = "\nadd_spacer|small|\nadd_smalltext|`9These Growmojis can be found in the Growmoji Chest sold by Locke the Traveling Salesman.``|left|";
												chest_dont_have += "\nadd_smalltext_forced_alpha| (" + emojied + ") |0.5|left|";
											}
										}
									}
								}
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|Growmojis|left|1366|" + a + first_emoji + chest_have + (pInfo(p_)->level >= 5 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be Level 5 to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (sigh) |0.5|left|\nadd_smalltext_forced_alpha| (mad) |0.5|left|\nadd_smalltext_forced_alpha| (smile) |0.5|left|\nadd_smalltext_forced_alpha| (tongue) |0.5|left|\nadd_smalltext_forced_alpha| (wow) |0.5|left|") + "" + (pInfo(p_)->supp >= 1 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be a Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (no) |0.5|left|\nadd_smalltext_forced_alpha| (shy) |0.5|left|\nadd_smalltext_forced_alpha| (wink) |0.5|left|\nadd_smalltext_forced_alpha| (music) |0.5|left|\nadd_smalltext_forced_alpha| (lol) |0.5|left|") + "" + (pInfo(p_)->supp == 2 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need to be a Super Supporter to get these Growmojis.``|left|\nadd_smalltext_forced_alpha| (yes) |0.5|left|\nadd_smalltext_forced_alpha| (love) |0.5|left|\nadd_smalltext_forced_alpha| (megaphone) |0.5|left|\nadd_smalltext_forced_alpha| (heart) |0.5|left|\nadd_smalltext_forced_alpha| (cool) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 10 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 10 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (kiss) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 20 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 20 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (agree) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 30 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 30 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (see-no-evil) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 40 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 40 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (dance) |0.5|left|") + "" + (pInfo(p_)->friends.size() >= 50 ? "" : "\nadd_spacer|small|\nadd_smalltext|`9You need 50 friends to get this Growmoji.``|left|\nadd_smalltext_forced_alpha| (build) |0.5|left|") + emoji + chest_title + chest_dont_have + "\nadd_spacer|small|\nend_dialog|worlds_list||Back|\nadd_quick_exit|\n");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "online_status") {
								gamepacket_t p;
								p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`wOnline Status``|left|1366|\nadd_spacer|small|\nadd_checkbox|checkbox_status_online|`wOnline``|" + a + (pInfo(p_)->p_status == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_status_busy|`wBusy``|" + (pInfo(p_)->p_status == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_status_away|`wAway``|" + (pInfo(p_)->p_status == 2 ? "1" : "0") + "\nadd_button|online_status|Ok|noflags|0|0|\nend_dialog|online_status|||\nadd_quick_exit|\n");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "alist2") backpack_show(p_);
							else if (a_.size() == 8 and a_[5] == "title_edit") {
								string titles = "";
								if (pInfo(p_)->drtitle) titles += "\nadd_checkbox|1|'Dr.'|" + to_string(pInfo(p_)->drt) + "|";
								if (pInfo(p_)->level >= 125) titles += "\nadd_checkbox|2|Level 125|" + to_string(pInfo(p_)->lvl125) + "|";
								if (pInfo(p_)->gp) titles += "\nadd_checkbox|3|'Grow4Good Title'|" + to_string(pInfo(p_)->donor) + "|\nadd_checkbox|4|'Mentor Title'|" + to_string(pInfo(p_)->master) + "|";
								if (pInfo(p_)->drlegend) titles += "\nadd_checkbox|5|'of Legend'|" + to_string(pInfo(p_)->is_legend) + "|";
								if (pInfo(p_)->level >= 250) titles += "\nadd_checkbox|6|Black Name|" + to_string(pInfo(p_)->black_color) + "|";
								//if (pInfo(p_)->ownership_role) titles += "\nadd_checkbox|7|Hamumu Flag|" + a + (pInfo(p_)->country == "ha" ? "1" : "0") + "|\nadd_checkbox|8|RTSoft Flag|" + (pInfo(p_)->country == "rt" ? "1" : "0") + "|";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert(a + "set_default_color|`o\nadd_label|big|" + (titles .empty() ? "No Titles Obtained" : "Select Title:") + "|right|" + titles + "\nadd_spacer|small|\nadd_button||OK|noflags|0|0|\nend_dialog|title_edit||\n");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and (a_[5] == "neck" or a_[5] == "feet" or a_[5] == "hand")) {
								int item = (a_[5] == "neck" ? pInfo(p_)->necklace : a_[5] == "feet" ? pInfo(p_)->feet : pInfo(p_)->hand);
								if (item <= 0 || item >= items.size()) break;
								if (inventory_contains(p_, item) == 0 && item != 256) break;
								pInfo(p_)->flagmay = (pInfo(p_)->flagmay == 1 ? 0 : 1);
								gamepacket_t p(0, pInfo(p_)->netID);
								p.Insert("OnFlagMay2019"), p.Insert(form_flagmay(pInfo(p_)));
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED || pInfo(p_)->world != pInfo(currentPeer)->world) continue;
									p.CreatePacket(currentPeer);
								}
							}
							else if (a_.size() == 8 and a_[5] == "Rift_Cape")  PSendRiftcapeDialog(p_);
							else if (a_.size() == 8 and a_[5] == "Rift_Wings")  PSendRiftwingsDialog(p_);
							else if (a_.size() == 8 and a_[5] == "open_personlize_profile") personalize_profile(p_);
							else if (a_.size() == 8 and a_[5] == "notebook_edit") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label|big|Notebook|left|0|\nadd_text_box_input|personal_note||" + pInfo(p_)->note + "|128|5|\nadd_spacer|small|\nadd_button|save|Save|noflags|0|0|\nadd_button|clear|Clear|noflags|0|0|\nadd_button|cancel|Cancel|noflags|0|0|\nend_dialog|notebook_edit||\nadd_quick_exit|\n");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "g4g_personal_dialog") daily_quest(p_, true, "tab_tasks", 0);
							else if (a_.size() == 8 and a_[5] == "piano_wings_edit") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMusical Wings``|left|10182|\nadd_spacer|small|\nadd_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(pInfo(p_)->musical_volume) + "|3|\nadd_text_input|text|Notes|" + pInfo(p_)->musical_note + "|50|\nadd_spacer|small|\nadd_button|resoterdefault|Restore to Default|noflags|0|0|\nend_dialog|pianowings|Cancel|Update|");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "billboard_edit") {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTrade Billboard``|left|8282|\nadd_spacer|small|" + (pInfo(p_)->b_i != 0 ? "\nadd_label_with_icon|small|`w" + items[pInfo(p_)->b_i].name + "``|left|" + to_string(pInfo(p_)->b_i) + "|" : "") + "\nadd_item_picker|billboard_item|`wSelect Billboard Item``|Choose an item to put on your billboard!|\nadd_spacer|small|\nadd_checkbox|billboard_toggle|`$Show Billboard``|" + (pInfo(p_)->b_bill.substr(0, 1)) + "\nadd_checkbox|billboard_buying_toggle|`$Is Buying``|" + (pInfo(p_)->b_bill.substr(2, 3)) + "\nadd_text_input|setprice|Price of item:|" + to_string(pInfo(p_)->b_p) + "|5|\nadd_checkbox|chk_peritem|World Locks per Item|" + (pInfo(p_)->b_w == 0 ? "0" : "1") + "\nadd_checkbox|chk_perlock|Items per World Lock|" + (pInfo(p_)->b_w == 0 ? "1" : "0") + "\nadd_spacer|small|\nend_dialog|billboard_edit|Close|Update|\n");
								p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "scarf_of_seasons_edit") {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wEquinox Scarf``|left|11818|\nadd_spacer|small|\nadd_textbox|Scarf Design|left|\nadd_spacer|small|\nadd_checkbox|checkbox_color_0|      Spring |" + (pInfo(p_)->i_11818_1 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_color_1|      Summer |" + (pInfo(p_)->i_11818_1 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_color_2|      Autumn |" + (pInfo(p_)->i_11818_1 == 2 ? "2" : "0") + "\nadd_checkbox|checkbox_color_3|      Winter |" + (pInfo(p_)->i_11818_1 == 3 ? "1" : "0") + "\nadd_textbox|Scarf Attack|left|\nadd_spacer|small|\nadd_checkbox|checkbox_punch_0|      Spring |" + (pInfo(p_)->i_11818_2 == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_1|      Summer |" + (pInfo(p_)->i_11818_2 == 1 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_2|      Autumn |" + (pInfo(p_)->i_11818_2 == 2 ? "1" : "0") + "\nadd_checkbox|checkbox_punch_3|      Winter |" + (pInfo(p_)->i_11818_2 == 3 ? "1" : "0") + "\nadd_spacer|small|\nadd_button|restore_default|Restore to Default|noflags|0|0|\nend_dialog|dialog_scarf_of_seasons|Cancel|Update|\nadd_quick_exit|");
							p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "eq_aura") {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wEQ Aura``|left|12634|\nadd_spacer|small|\nadd_textbox|Play music wherever you are with the EQ Aura! Choose a musical block from your inventory to play the song.|left|\nadd_spacer|small|\nadd_label_with_icon|small|" + (pInfo(p_)->eq_aura == 0 ? "None" : items[pInfo(p_)->eq_aura].ori_name) + "|left|"+to_string((pInfo(p_)->eq_aura == 0 ? 2946 : pInfo(p_)->eq_aura)) + "|\nadd_spacer|small|\nadd_item_picker|change_item|`wChange Block Item``|Choose an item to put on your EQ Aura!|"+(pInfo(p_)->eq_aura == 0 ? "" : "\nadd_button|remove_item|`wRemove Block Item``|noflags|0|0|") + "\nend_dialog|dialog_eqaura|Cancel|Update|\nadd_quick_exit|");
							p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "minokawa_wings") {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wMinokawa Wings``|left|12640|\nadd_spacer|small|\nadd_textbox|Choose which items you would like to appear. You can choose one item or two!|left|\nadd_spacer|small|\nadd_checkbox|c1|Minokawa Wings|" + (pInfo(p_)->minokawa_wings == 0 || pInfo(p_)->minokawa_wings == 2 ? "1" : "0") + "\nadd_checkbox|c2|Minokawa Pet|" + (pInfo(p_)->minokawa_wings == 1 || pInfo(p_)->minokawa_wings == 2 ? "1" : "0") + "\nend_dialog|dialog_minokawa|Cancel|Update|\nadd_quick_exit|");
							p.CreatePacket(p_);
							}
							else if (a_.size() == 8 and a_[5] == "panda_spirit") {
								if (pInfo(p_)->hair == 12872 || pInfo(p_)->hair == 12874) {
									pInfo(p_)->panda_spirit = (pInfo(p_)->panda_spirit == 1 ? 0 : 1);
									update_clothes_value(p_);
									update_clothes(p_);
								}
							}
							else if (a_.size() == 8 and a_[5] == "infinity_crown_edit") {
								SendDialogInfinityCrown(p_);
							}
							else if (a_.size() == 8 and a_[5] == "cernuous_mask_edit") {
								SendCernuousEdit(p_);
							}
							else if (a_.size() == 8 and a_[5] == "bannerbandolier") {
								SendBannerBandolier(p_);
							}
							else if (a_.size() == 8 and a_[5] == "goals") {
								daily_quest_info(p_);
							}
							else if (a_.size() == 14 and a_[11] == "trade" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								SendCmd(p_, "/trade " + pInfo(p_)->last_wrenched, true);
							}
							else if (a_.size() == 14 and a_[11] == "mute_player" and isdigit(a_[5][0]) and isdigit(a_[8][0]) or a_.size() == 14 and a_[11] == "unmute_player" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
										for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
											if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(pInfo(currentPeer)->tankIDName)) {
												if (a_[11] == "mute_player")
													pInfo(p_)->friends[c_].mute = true;
												else
													pInfo(p_)->friends[c_].mute = false;
												break;
											}
										}
										break;
									}
								}
							}
							else if (a_.size() == 14 and a_[11] == "worldban" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								SendCmd(p_, "/ban " + pInfo(p_)->last_wrenched, true);
							}
							else if (a_.size() == 14 and a_[11] == "pull" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								SendCmd(p_, "/pull " + pInfo(p_)->last_wrenched, true);
							}
							else if (a_.size() == 14 and a_[11] == "visit_home_world" and isdigit(a_[5][0]) and isdigit(a_[8][0])) join_world(p_, pInfo(p_)->last_home_world);
							else if (a_.size() == 14 and a_[11] == "kick" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								SendCmd(p_, "/kick " + pInfo(p_)->last_wrenched, true);
							}
							else if (a_.size() == 14 and a_[11] == "view_worn_clothes" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
										variants::OnDialogRequest(p_,
											"\nadd_label_with_icon|big|`w" + (not pInfo(currentPeer)->d_name.empty() ? pInfo(currentPeer)->d_name : pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName) + "`o's Clothes List|left|1420|"
											"\nadd_spacer|small|"
											+ (pInfo(currentPeer)->hair != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->hair].name + "|left|" + to_string(pInfo(currentPeer)->hair) + "|" : "") + a
											+ (pInfo(currentPeer)->face != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->face].name + "|left|" + to_string(pInfo(currentPeer)->face) + "|" : "") + a
											+ (pInfo(currentPeer)->necklace != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->necklace].name + "|left|" + to_string(pInfo(currentPeer)->necklace) + "|" : "") + a
											+ (pInfo(currentPeer)->shirt != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->shirt].name + "|left|" + to_string(pInfo(currentPeer)->shirt) + "|" : "") + a
											+ (pInfo(currentPeer)->back != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->back].name + "|left|" + to_string(pInfo(currentPeer)->back) + "|" : "") + a
											+ (pInfo(currentPeer)->hand != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->hand].name + "|left|" + to_string(pInfo(currentPeer)->hand) + "|" : "") + a
											+ (pInfo(currentPeer)->pants != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->pants].name + "|left|" + to_string(pInfo(currentPeer)->pants) + "|" : "") + a
											+ (pInfo(currentPeer)->feet != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->feet].name + "|left|" + to_string(pInfo(currentPeer)->feet) + "|" : "") + a
											+ (pInfo(currentPeer)->ances != 0 ? "\nadd_label_with_icon|small|`o" + items[pInfo(currentPeer)->ances].name + "|left|" + to_string(pInfo(currentPeer)->ances) + "|" : "") + a +
											"\nend_dialog|????|Close||"
										);
										break;
									}
								}
							}
							else if (a_.size() == 14 and a_[11] == "punish_view" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								if (pInfo(p_)->mod == 1 || pInfo(p_)->dev == 1) {
									SendCmd(p_, "/info " + pInfo(p_)->last_wrenched, true);
								}
							}
							else if (a_.size() == 14 and a_[11] == "start_surg" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								bool has_recovery = false;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world or pInfo(p_)->last_wrenched != pInfo(currentPeer)->tankIDName or pInfo(currentPeer)->hospital_bed == false) continue;
									if (has_playmod2(pInfo(currentPeer), 87)) has_recovery = true;
									if (has_recovery == false) {
										string name_ = pInfo(currentPeer)->world;
										vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
										if (p != worlds.end()) {
											World* world_ = &worlds[p - worlds.begin()];
											int x_ = (pInfo(currentPeer)->state == 16 ? (int)pInfo(currentPeer)->x / 32 : round((double)pInfo(currentPeer)->x / 32)), y_ = (int)pInfo(currentPeer)->y / 32;
											if (x_ < 0 or x_ >= world_->max_x or y_ < 0 or y_ >= world_->max_y) {
											}
											else {
												if (world_->blocks[x_ + (y_ * 100)].fg != 1256) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("Player is not standing on hospital bed.");
													p.Insert(0), p.Insert(0);
													p.CreatePacket(p_);
												}
												else {
													if (setstats(p_, pInfo(currentPeer)->surgery_type, pInfo(currentPeer)->tankIDName, pInfo(currentPeer)->name_color + pInfo(currentPeer)->tankIDName + "``")) {
														int seconds = 3600;
														if (pInfo(currentPeer)->necklace == 8954) seconds *= 0.75;
														add_playmod(currentPeer, 87, seconds);
														pInfo(currentPeer)->surgery_type = rand() % 31;
													}
												}
											}
										}
									}
								}
							}
							else if (a_.size() == 14 and a_[11] == "invitetoguild" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
								if (pInfo(p_)->guild_id == 0) break;
								uint32_t guild_id = pInfo(p_)->guild_id;
								vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
								if (p != guilds.end()) {
									Guild* guild_information = &guilds[p - guilds.begin()];
									for (GuildMember member_search : guild_information->guild_members) {
										if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
											if (member_search.role_id != 3 and member_search.role_id != 2 and member_search.role_id != 1) return;
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
													if (pInfo(currentPeer)->guild_id != 0) return;
													if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(p_)->netID);
														p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
														p.Insert(0), p.Insert(0);
														p.CreatePacket(p_);
														{
															gamepacket_t p;
															p.Insert("OnConsoleMessage");
															p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
															p.CreatePacket(p_);
														}
														return;
													}
													pInfo(currentPeer)->pending_guild = pInfo(p_)->guild_id;
													packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
													{
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(p_)->netID);
														p.Insert("`5[``Guild request sent to " + get_player_nick(currentPeer) + "`5]``");
														p.Insert(0), p.Insert(0);
														p.CreatePacket(p_);
													}
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("`5GUILD REQUEST:`` You've been invited to join `2" + guild_information->guild_name + " `` by " + get_player_nick(p_) + "! To accept, `wwrench yourself`` and then choose `2Join " + guild_information->guild_name + "``.");
													p.CreatePacket(currentPeer);
													create_guild_log(guild_information, "`$" + pInfo(currentPeer)->tankIDName + "`` `wwas invited by`` `$" + get_player_nick(p_) + "``", 6);
													return;
												}
											}
											break;
										}
									}
								}
								{
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Hmm, that person left.");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
								}
							}
							else if (a_.size() == 14 and a_[11] == "friend_add" and isdigit(a_[5][0]) and isdigit(a_[8][0])) {
								int my_netid_ = atoi(a_[5].c_str()), other_netid_ = atoi(a_[8].c_str());
								string name_ = pInfo(p_)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == pInfo(p_)->world and pInfo(currentPeer)->netID == other_netid_) {
											if (find(pInfo(currentPeer)->pending_friends.begin(), pInfo(currentPeer)->pending_friends.end(), pInfo(p_)->tankIDName) != pInfo(currentPeer)->pending_friends.end()) {
												packet_(p_, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
												long long time_t = time(NULL);
												Friends new_friend_;
												new_friend_.name = pInfo(currentPeer)->tankIDName;
												new_friend_.mute = false;
												new_friend_.block_trade = false;
												new_friend_.last_seen = time_t;
												pInfo(p_)->friends.push_back(new_friend_);
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("`3FRIEND ADDED:`` You're now friends with " + get_player_nick(currentPeer) + "!");
												p.CreatePacket(p_);
												{
													packet_(currentPeer, "action|play_sfx\nfile|audio/love_in.wav\ndelayMS|0");
													Friends new_friend_;
													new_friend_.name = pInfo(p_)->tankIDName;
													new_friend_.mute = false;
													new_friend_.block_trade = false;
													new_friend_.last_seen = time_t;
													pInfo(currentPeer)->friends.push_back(new_friend_);
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("`3FRIEND ADDED:`` You're now friends with " + get_player_nick(p_) + "!");
													p.CreatePacket(currentPeer);
													if (pInfo(p_)->friends.size() == 10 || pInfo(p_)->friends.size() == 20 || pInfo(p_)->friends.size() == 30 || pInfo(p_)->friends.size() == 40 || pInfo(p_)->friends.size() == 50) form_emoji(p_, true);
													if (pInfo(currentPeer)->friends.size() == 10 || pInfo(p_)->friends.size() == 20 || pInfo(p_)->friends.size() == 30 || pInfo(p_)->friends.size() == 40 || pInfo(p_)->friends.size() == 50) form_emoji(currentPeer, true);
												}
												pInfo(currentPeer)->pending_friends.erase(remove(pInfo(currentPeer)->pending_friends.begin(), pInfo(currentPeer)->pending_friends.end(), pInfo(p_)->tankIDName), pInfo(currentPeer)->pending_friends.end());
											}
											else {
												for (int c_ = 0; c_ < pInfo(p_)->friends.size(); c_++) {
													if (to_lower(pInfo(p_)->friends[c_].name) == to_lower(pInfo(currentPeer)->tankIDName)) {
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(p_)->netID);
														p.Insert("That's already my friend!");
														p.Insert(0), p.Insert(0);
														return;
													}
												}
												if (abs((pInfo(currentPeer)->x / 32) - (pInfo(p_)->x / 32)) >= 3) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("`5[```4Too far away`` `0- Stand closer to`` " + get_player_nick(currentPeer) + "`0 first!```5]``");
													p.Insert(0), p.Insert(0);
													p.CreatePacket(p_);
													return;
												}
												pInfo(p_)->pending_friends.push_back(pInfo(currentPeer)->tankIDName);
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(p_)->netID);
												p.Insert("`5[``Friend request sent to " + get_player_nick(currentPeer) + "`5]``");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(p_);
												{
													packet_(currentPeer, "action|play_sfx\nfile|audio/tip_start.wav\ndelayMS|0");
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert("`3FRIEND REQUEST:`` You've received a `wfriend request`` from " + get_player_nick(p_) + "! To accept, press the `wwrench by his/her name`` and then choose `wAdd as friend``.");
													p.CreatePacket(currentPeer);
												}
											}
											return;
										}
									}
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("Hmm, that person left.");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
								}
							}
							else if (a_.size() == 8 and a_[5] == "acceptguild") {
								if (pInfo(p_)->pending_guild == 0 or pInfo(p_)->guild_id != 0) break;
								string name_ = pInfo(p_)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									uint32_t guild_id = pInfo(p_)->pending_guild;
									vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
									if (p != guilds.end()) {
										Guild* guild_information = &guilds[p - guilds.begin()];
										if (guild_information->guild_members.size() >= guild_information->guild_level * 5) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(p_);
											{
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert("Guild is at maximum capacity of " + to_string(guild_information->guild_level * 5) + " peoples!");
												p.CreatePacket(p_);
											}
											break;
										}
										GuildMember new_member{};
										new_member.member_name = pInfo(p_)->tankIDName;
										new_member.role_id = 0;
										new_member.last_online = time(NULL);
										guild_information->guild_members.push_back(new_member);
										pInfo(p_)->pending_guild = 0;
										pInfo(p_)->guild_id = guild_information->guild_id;
										guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
										guild_information->guild_settings |= Gtps3::SETTINGS_0;
										save_player(pInfo(p_), false);
										{
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("You Succesfully joined " + guild_information->guild_name);
											p.Insert(0), p.Insert(0);
											p.CreatePacket(p_);
										}
										update_clothes_value(p_, true);
										update_clothes(p_);
													gamepacket_t p_2;
													p_2.Insert("OnConsoleMessage");
													p_2.Insert("`5[GUILD ALERT]`` " + get_player_nick(p_) + " joined the guild!");
													if (pInfo(p_)->world == guild_information->guild_world and guild_access(p_, guild_id)) {
														int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
														{
															vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
															if (p != world_->blocks.end()) {
																int i_ = p - world_->blocks.begin();
																int x_ = i_ % xSize;
																int y_ = i_ / xSize;
																WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
																PlayerMoving data_2{};
																data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
																BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
																BYTE* blc = raw2 + 56;
																form_visual(blc, *block_, *world_, p_, false);
																nick_update_2(p_, NULL);
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																	if (pInfo(currentPeer)->world == pInfo(p_)->world) {
																		p_2.CreatePacket(currentPeer);
																		send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
																	}
																}
																delete[] raw2, blc;
															}
														}
													}
													else {
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->guild_id == pInfo(p_)->guild_id) {
																p_2.CreatePacket(currentPeer);
															}
														}
													}
													create_guild_log(guild_information, "`$" + pInfo(p_)->tankIDName + "`` `wjoined the guild", 5948);
												}
											}
										}
							else if (a_.size() == 8 and a_[5] == "acceptlock") {
								if (pInfo(p_)->access_offers.size() == 0) break;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == pInfo(p_)->world) {
										if (pInfo(p_)->access_offers.find(pInfo(currentPeer)->netID) != pInfo(p_)->access_offers.end()) {
											string name_ = pInfo(p_)->world;
											vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
											if (p != worlds.end()) {
												World* world_ = &worlds[p - worlds.begin()];
												string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(currentPeer)->tankIDName);
												int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
												int x_ = (pInfo(p_)->access_offers[pInfo(currentPeer)->netID]) % xSize, y_ = (pInfo(p_)->access_offers[pInfo(currentPeer)->netID]) / xSize;
												WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
												if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) owner_name = to_lower(block_->owner_name);
												if (owner_name != user_name and not pInfo(p_)->dev) break;
												if (x_ < 0 or x_ >= world_->max_x or y_ < 0 or y_ >= world_->max_y) break;
												if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
													if (to_lower(block_->owner_name) != user_name) break;
												}
												else {
													if (owner_name != user_name) break;
												}
												gamepacket_t p;
												p.Insert("OnDialogRequest");
												p.Insert("set_default_color|`o\nadd_label_with_icon|small|Accept Access To World|left|242|\nadd_smalltext|When you have access to a world, you are responsible for anything the world's owners or other admins do.|left|\nadd_smalltext|Don't accept access to a world unless it is from people you trust.|left|\nadd_smalltext|You can remove your access later by either wrenching the lock, or typing `2/unaccess`` to remove yourself from all locks in the world.|left|\nadd_spacer|small|\nadd_textbox|Are you sure you want to be added to this " + items[block_->fg].name + "?|left|\nend_dialog|acceptaccess|No|Yes|");
												p.CreatePacket(p_);
											}
											break;
										}
									}
								}
							}
							break;
						}
						else if (a_[i_] == "lock_edit" or a_[i_] == "editguildlock") {
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								/*if (a_.size() != 23 and a_.size() != 25 and a_.size() != 26 and a_.size() != 11) break;
								if (not isdigit(a_[i_+2][0]) and a_.size() != 11 or not isdigit(a_[i_+5][0]) and a_.size() != 11) break;*/
								int x_ = 0, y_ = 0;

								try {
									x_ = atoi(a_.at(i_ + 2).c_str()), y_ = atoi(a_.at(i_ + 5).c_str());
								}
								catch (out_of_range) {
									return;
								}
								if (x_ < 0 or x_ >= world_->max_x or y_ < 0 or y_ >= world_->max_y) break;
								if (p != worlds.end()) {
									WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
									uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
									if (items[t_].blockType != BlockTypes::LOCK) break;
									string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(p_)->tankIDName);
									if (a_.size() == 11) { // remove my access
										if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
											if (find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
												block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), user_name), block_->admins.end());
												packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
												gamepacket_t p;
												p.Insert("OnConsoleMessage");
												p.Insert(user_name + " removed their access from a " + items[t_].name);
												PlayerMoving data_{};
												data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
												int alloc = alloc_(world_, block_);
												BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
												BYTE* blc = raw + 56;
												form_visual(blc, *block_, *world_, p_, false);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(currentPeer)->world == world_->name) {
														p.CreatePacket(currentPeer);
														send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
													} if (pInfo(currentPeer)->world == world_->name and to_lower(pInfo(currentPeer)->tankIDName) == to_lower(user_name)) {
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(p_)->netID);
														p.Insert("I've removed my access!");
														p.Insert(0), p.Insert(0);
														p.CreatePacket(currentPeer);
													}
												}
												delete[] raw, blc;
												if (block_->locked) {
													upd_lock(*block_, *world_, p_);
												}
											}
										}
										else if (find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
											world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), user_name), world_->admins.end());
											packet_(p_, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(user_name + " removed their access from a " + items[t_].name);
											pInfo(p_)->name_color = (pInfo(p_)->give_role ? "`8@" : pInfo(p_)->Staff ? "`4@" : pInfo(p_)->superdev ? "`8@" : pInfo(p_)->dev ? "`6@" :  (pInfo(p_)->mod) ? "`#@" : (to_lower(pInfo(p_)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
											nick_update_2(p_, NULL);
											PlayerMoving data_{};
											data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
											int alloc = alloc_(world_, block_);
											BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
											BYTE* blc = raw + 56;
											form_visual(blc, *block_, *world_, p_, false);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													p.CreatePacket(currentPeer);
													send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
												} if (pInfo(currentPeer)->world == world_->name and to_lower(pInfo(currentPeer)->tankIDName) == to_lower(user_name)) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("I've removed my access!");
													p.Insert(0), p.Insert(0);
													p.CreatePacket(currentPeer);
												}
											}
											delete[] raw, blc;
											if (block_->locked) {
												upd_lock(*block_, *world_, p_);
											}
										}
										break;
									}
									if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
										if (to_lower(block_->owner_name) != user_name and not pInfo(p_)->dev) break;
									}
									else {
										if (owner_name != user_name and not pInfo(p_)->dev) break;
									}
									bool reapply = false;
									for (int b_ = 0; b_ < a_.size(); b_++) {
										bool upd_ = false;
										if (a_[b_] == "getKey") {
											if (to_lower(pInfo(p_)->tankIDName) != to_lower(world_->owner_name)) break;
											if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) break;
											int key_ = 1424;
											if (block_->fg == 5814) {
												key_ = 5816;
												gamepacket_t p;
												p.Insert("OnDialogRequest");
												p.Insert("add_label_with_icon|big|`wGet " + items[key_].name + " ``|left|" + to_string(key_) + "|\nadd_spacer|small|\nadd_textbox|The key to this lock can be used to transfer leadership of the guild to another guild Member.|left|\nadd_textbox|Use it like a `5World Lock Key``, but you can only give it to another Member of your guild!|left|\nadd_spacer|small|\nadd_textbox|`4Warning!`` By giving the `5Guild Key`` to another Member, you are effectively `rpromoting`` them to Guild Leader and `4demoting`` yourself at the same time!|left|\nadd_textbox|Are you sure you want to take the `5" + items[key_].name + "`` from the " + items[block_->fg].name + "?|left|\nend_dialog|confirmguildlockkey|Cancel|OK|\nadd_quick_exit|");
												p.CreatePacket(p_);
												return;
											}
											int c_ = 0;
											if (to_lower(pInfo(p_)->tankIDName) == to_lower(world_->owner_name)) modify_inventory(p_, 1424, c_);
											if (c_ != 0) break;
											/*
											for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
												if (world_->drop_new[i_][3] == -1 or world_->drop_new[i_][0] == 0) continue;
												WorldBlock* block_ = &world_->blocks[(world_->drop_new[i_][3] / 32) + ((world_->drop_new[i_][4] / 32) * 100)];
												if (items[block_->fg].collisionType != 1) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("`4Oops!... Can't trade a world with floating items that are unblocked or in treasure chests!``");
													p.Insert(0), p.Insert(0);
													p.CreatePacket(p_);
													return;
												}
											}*/
											vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 4516 || a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994 || a.fg == 10000; });
											if (p != world_->blocks.end()) {
												WorldBlock* block__ = &world_->blocks[p - world_->blocks.begin()];
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(p_)->netID);
												if (block__->fg == 4516) p.Insert("`4To trade a world, you will need to remove Untrade-a-Box!``");
												else p.Insert("To trade a world, you can only have one lock on it, the `5World Lock``.  Remove the rest!");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(p_);
												return;
											}
											if (world_->admins.size() != 0) {
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(p_)->netID);
												p.Insert("You'll first need to remove all players with access to your " + items[block_->fg].name + " to get a " + items[key_].name + ".");
												p.Insert(0), p.Insert(1);
												p.CreatePacket(p_);
												return;
											}
											c_ = 1;
											if (modify_inventory(p_, key_, c_) == 0) {
												packet_(p_, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(p_)->netID);
												p.Insert("You got a `#" + items[key_].name + "``! You can now trade this world to other players.");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(p_);
											}

										}
										else if (a_[b_] == "sessionlength_dialog") {
											if (pInfo(p_)->tankIDName != world_->owner_name) break;
											if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994) break;
											gamepacket_t p;
											p.Insert("OnDialogRequest");
											p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSet World Timer``|left|1482|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|\nadd_textbox|Select a time limit for how long guests can stay in your world.|left|\nadd_checkbox|checkbox_0|None|" + (world_->World_Time == 0 ? "1" : "0") + "\nadd_checkbox|checkbox_5|5 minutes|" + (world_->World_Time == 5 ? "1" : "0") + "\nadd_checkbox|checkbox_10|10 minutes|" + (world_->World_Time == 10 ? "1" : "0") + "\nadd_checkbox|checkbox_20|20 minutes|" + (world_->World_Time == 20 ? "1" : "0") + "\nadd_checkbox|checkbox_30|30 minutes|" + (world_->World_Time == 30 ? "1" : "0") + "\nadd_checkbox|checkbox_40|40 minutes|" + (world_->World_Time == 40 ? "1" : "0") + "\nadd_checkbox|checkbox_50|50 minutes|" + (world_->World_Time == 50 ? "1" : "0") + "\nadd_checkbox|checkbox_60|60 minutes|" + (world_->World_Time == 60 ? "1" : "0") + "\nend_dialog|sessionlength_edit|Nevermind|Set Time Limit|");
											p.CreatePacket(p_);
										}
										else if (a_[b_] == "changecat") {
											if (to_lower(pInfo(p_)->tankIDName) != to_lower(world_->owner_name)) break;
											string types = "";
											for (int i = 1; i < world_rate_types.size(); i++) types += "\nadd_button|"+to_string(i) + "|" + (world_category(i)) + "|noflags|0|0|";
											gamepacket_t p;
											p.Insert("OnDialogRequest");
											p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSet World Category``|left|3802|\nadd_textbox|Select a category for your world.|left|\nadd_button|0|None|noflags|0|0|"+ types +"\nadd_smalltext|Worlds in the category \"None\" can't be rated by players, and they are only listed on the normal World Select screen.|left|\nadd_smalltext|`4Warning:`` Changing your category will delete all ratings on your world.|left|\nend_dialog|worldcategory|Nevermind||");
											p.CreatePacket(p_);
										}
										else if (a_[b_] == "minimum_entry_level" and isdigit(a_[b_ + 1][0])) {
											if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) break;
											int new_entry_level_ = atoi(a_[b_ + 1].c_str());
											if (world_->entry_level != new_entry_level_) {
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(p_)->netID);
												if (new_entry_level_ < 1) {
													p.Insert("Minimum entry level can't be lower than 1.");
													p.CreatePacket(p_);
													continue;
												}
												if (new_entry_level_ > 250) {
													p.Insert("Minimum entry level can't be higher than 250.");
													p.CreatePacket(p_);
													continue;
												}
												world_->entry_level = new_entry_level_;
												p.Insert("Minimum entry level for this world is set to `2Level " + to_string(new_entry_level_) + "``.");
												p.Insert(0), p.Insert(0);
												p.CreatePacket(p_);
											}
										}
										else if (a_[b_] == "tempo" and isdigit(a_[b_ + 1][0])) {
											if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) break;
											uint32_t new_bpm_ = atoi(a_[b_ + 1].c_str());
											if (world_->music_bpm != new_bpm_) {
												if (new_bpm_ < 20 or new_bpm_ > 200) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("Tempo must be from 20-200 BPM.");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
													continue;
												}
												world_->music_bpm = new_bpm_, upd_ = true;
											}
										}
										//recalcLock
										else if (a_[b_] == "recalcLock") {
											if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
												reapply = true;
											}
											//break;
										}
										else if (a_[b_] == "abondonguildconfirm") {
										if (block_->fg == 5814) {
											uint32_t guild_id = world_->guild_id;
											vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
											if (p != guilds.end()) {
												Guild* guild_information = &guilds[p - guilds.begin()];
												if (guild_information->guild_members.size() != 1) {
													gamepacket_t p;
													p.Insert("OnDialogRequest");
													p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`1You need to kick all guild members before you can abandon the guild! `` |left|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
													p.CreatePacket(p_);
													break;
												}
												gamepacket_t p;
												p.Insert("OnDialogRequest");
												p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_spacer|small|\nadd_item_picker|selectworldlock|`wSelect a World Lock``|Choose a World Lock to replace the Guild Lock|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
												p.CreatePacket(p_);
											}
											break;
										}
										}
										else if (a_[b_] == "create_guild_mascot") {
											if (block_->fg == 5814) guild_flag_dialog(p_);
											break;
										}
										else if (a_[b_] == "upgrade_guild") {
											if (block_->fg == 5814) {
												uint32_t guild_id = pInfo(p_)->guild_id;
												if (guild_id == 0) return;
												vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
												if (p != guilds.end()) {
													Guild* guild_information = &guilds[p - guilds.begin()];
													if (guild_information->guild_level < guild_lvl.size()) {
														for (GuildMember member_search : guild_information->guild_members) {
															if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
																if (member_search.role_id == 3) {
																	gamepacket_t p;
																	p.Insert("OnDialogRequest");
																	p.Insert("add_label_with_icon|big|`wGuild Upgrade``|left|5814|\nadd_textbox|Are you sure you want to upgrade the guild for `2" + to_string(guild_lvl[guild_information->guild_level - 1][1]) + " Gems``?|left|\nadd_spacer|small|\nadd_button|upgrade_guild|`wUpgrade Guild``|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|upgrading_guild|||");
																	p.CreatePacket(p_);
																}
															}
														}
													}
												}
											}
											break;
										}
										else if (a_[b_].substr(0, 9) == "checkbox_") {
											// checkboxes
											vector<string> target_ = explode("_", a_[b_]);
											if (target_[1] == "disable") {
												if (target_.size() == 4 and target_[2] == "music" and target_[3] == "render") {
													if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) break;


													if (a_[b_ + 1] == "1") world_->world_settings |= Gtps3::SETTINGS_6;
													else world_->world_settings &= ~Gtps3::SETTINGS_6;
													upd_ = true;
												}
												else if (target_[2] == "music") {
													if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) break;
													// music disable
													if (a_[b_ + 1] == "1") world_->world_settings |= Gtps3::SETTINGS_5;
													else world_->world_settings &= ~Gtps3::SETTINGS_5;
													upd_ = true;
												}
											}
											else if (target_.size() == 5 and target_[4] == "world") {
												if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) break;
												// set as home world
												if (pInfo(p_)->home_world != world_->name and a_[b_ + 1] == "1") {
													pInfo(p_)->home_world = world_->name;
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert(world_->name + " has been set as your home world!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
												}
												else if (pInfo(p_)->home_world == world_->name and a_[b_ + 1] == "0") {
													pInfo(p_)->home_world = "";
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert(world_->name + " has been removed as your home world!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
												}
											}
											else if (target_[1] == "member") {
												if (block_->fg == 5814) {
													uint32_t guild_id = world_->guild_id;
													vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
													if (p != guilds.end()) {
														Guild* guild_information = &guilds[p - guilds.begin()];
														if (a_[b_ + 1] == "1") guild_information->guild_settings |= Gtps3::SETTINGS_1;
														else guild_information->guild_settings &= ~Gtps3::SETTINGS_1;
														upd_ = true;
													}
												}
											}
											else if (target_[1] == "elder") {
												if (block_->fg == 5814) {
													uint32_t guild_id = world_->guild_id;
													vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
													if (p != guilds.end()) {
														Guild* guild_information = &guilds[p - guilds.begin()];
														if (a_[b_ + 1] == "1") guild_information->guild_settings |= Gtps3::SETTINGS_2;
														else guild_information->guild_settings &= ~Gtps3::SETTINGS_2;
														upd_ = true;
													}
												}
											}
											else if (target_[1] == "coleader") {
												if (block_->fg == 5814) {
													uint32_t guild_id = world_->guild_id;
													vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
													if (p != guilds.end()) {
														Guild* guild_information = &guilds[p - guilds.begin()];
														if (a_[b_ + 1] == "1") guild_information->guild_settings |= Gtps3::SETTINGS_3;
														else guild_information->guild_settings &= ~Gtps3::SETTINGS_3;
														upd_ = true;
													}
												}
											}
											else if (target_[1] == "displaymascot") {
												if (block_->fg == 5814) {
													uint32_t guild_id = world_->guild_id;
													vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
													if (p != guilds.end()) {
														Guild* guild_information = &guilds[p - guilds.begin()];
														if (a_[b_ + 1] == "1") guild_information->guild_settings |= Gtps3::SETTINGS_4;
														else guild_information->guild_settings &= ~Gtps3::SETTINGS_4;
														upd_ = true;
													}
												}
											}
											else if (target_[1] == "ignore") {
												if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
													block_->invert = stoi(a_[b_ + 1]);
												}
											}
											else if (target_[1] == "buildonly") {
												if (block_->fg == 4994) block_->build_only = stoi(a_[b_ + 1]);
											}
											else if (target_[1] == "admins") {
												if (block_->fg == 4994) block_->limit_admins = stoi(a_[b_ + 1]);
											}
											else if (target_[1] == "silence") {
												if (block_->fg == 4802) {
													if (stoi(a_[b_ + 1])) world_->world_settings |= Gtps3::SETTINGS_8;
													else world_->world_settings &= ~Gtps3::SETTINGS_8;
												}
											}
											else if (target_[1] == "rainbows") {
												if (block_->fg == 4802) {
													if (stoi(a_[b_ + 1])) world_->world_settings |= Gtps3::SETTINGS_7;
													else world_->world_settings &= ~Gtps3::SETTINGS_7;
													upd_ = true;
												}
											}
											else if (target_[1] == "public") {
												if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
													block_->spin = stoi(a_[b_ + 1]);
													upd_ = true;
												}
												else {
													bool upda = false;

													if (world_->world_settings & Gtps3::SETTINGS_4) {
														if (a_[b_ + 1] == "0") {
															world_->world_settings &= ~Gtps3::SETTINGS_4;
															upda = true;
														}
													}
													else {
														if (a_[b_ + 1] == "1") {
															world_->world_settings |= Gtps3::SETTINGS_4;
															upda = true;
														}
													}
													if (upda) {
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
														p.Insert(get_player_nick(p_) + " has set the `$World Lock`` to " + (world_->world_settings & Gtps3::SETTINGS_4 ? "`$PUBLIC" : "`4PRIVATE") + "");
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->world == world_->name) {
																p.CreatePacket(currentPeer);
															}
														}
													}

												}
											}
											else if (target_[1] == "drop") {
											if (stoi(a_[b_ + 1]))world_->world_settings |= Gtps3::SETTINGS_2;
											else world_->world_settings &= ~Gtps3::SETTINGS_2;
											upd_ = true;
											}
											else if (target_[1] == "magplant") {
												if (stoi(a_[b_ + 1]))world_->world_settings |= Gtps3::SETTINGS_10;
												else world_->world_settings &= ~Gtps3::SETTINGS_10;
												upd_ = true;
											}
											else if (target_[1] == "cheater") {
												if (stoi(a_[b_ + 1]))world_->world_settings |= Gtps3::SETTINGS_12;
												else world_->world_settings &= ~Gtps3::SETTINGS_12;
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
													if (to_lower(pInfo(currentPeer)->tankIDName) != to_lower(world_->owner_name)) {
														pInfo(currentPeer)->disable_cheater = world_->world_settings & Gtps3::SETTINGS_12;
													}
												}
												upd_ = true;
											}
											else if (target_[1] == "vending") {
												if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
												}
												else {
													bool upda = false;
													if (world_->world_settings & Gtps3::SETTINGS_3) {
														if (a_[b_ + 1] == "0") {
															world_->world_settings &= ~Gtps3::SETTINGS_3;
															upda = true;
														}
													}
													else {
														if (a_[b_ + 1] == "1") {
															world_->world_settings |= Gtps3::SETTINGS_3;
															upda = true;
														}
													}
													if (upda) {
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
														p.Insert(get_player_nick(p_) + " has set the `$Vending`` to " + (world_->world_settings & Gtps3::SETTINGS_3 ? "`$PUBLIC" : "`4PRIVATE") + "");
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->world == world_->name) {
																p.CreatePacket(currentPeer);
															}
														}
													}
												}
											}
											else if (target_.size() == 2 and a_[b_ + 1] == "0") {
												string user_name = target_[1].erase(0, 1);
												if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
													if (find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
														block_->admins.erase(remove(block_->admins.begin(), block_->admins.end(), user_name), block_->admins.end());
														gamepacket_t p;
														p.Insert("OnConsoleMessage");
														p.Insert(user_name + " was removed from a " + items[block_->fg].name + ".");
														tile_update(p_, world_, block_, x_, y_);
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->world == world_->name) {
																p.CreatePacket(currentPeer);
															}
															if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(user_name)) {
																packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
																gamepacket_t p;
																p.Insert("OnTalkBubble");
																p.Insert(pInfo(currentPeer)->netID);
																if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
																p.Insert(get_player_nick(p_) + " has `4removed`` your access from a lock on world `w" + world_->name + "``.");
																p.Insert(0), p.Insert(0);
																p.CreatePacket(currentPeer);
															}
														}
													}
												}
												else if (find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
													world_->admins.erase(remove(world_->admins.begin(), world_->admins.end(), user_name), world_->admins.end());
													gamepacket_t p;
													p.Insert("OnConsoleMessage");
													p.Insert(user_name + " was removed from a " + items[block_->fg].name + ".");
													tile_update(p_, world_, block_, x_, y_);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == world_->name) {
															p.CreatePacket(currentPeer);
														}
														if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(user_name)) {
															packet_(currentPeer, "action|play_sfx\nfile|audio/dialog_cancel.wav\ndelayMS|0");
															gamepacket_t p;
															p.Insert("OnTalkBubble");
															p.Insert(pInfo(currentPeer)->netID);
															if (pInfo(p_)->mod == 0 && pInfo(p_)->dev == 0)pInfo(p_)->name_color = "`2";
															p.Insert(get_player_nick(p_) + " has `4removed`` your access from a lock on world `w" + world_->name + "``.");
															p.Insert(0), p.Insert(0);
															p.CreatePacket(currentPeer);
															pInfo(currentPeer)->name_color = (pInfo(currentPeer)->give_role ? "`8@" : pInfo(currentPeer)->Staff ? "`4@" : pInfo(currentPeer)->superdev ? "`8@" : pInfo(currentPeer)->dev ? "`6@" : (pInfo(currentPeer)->mod) ? "`#@" : (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");

															nick_update_2(currentPeer, NULL);
														}
													}
												}
											}
										}
										else if (a_[b_] == "playerNetID" and isdigit(a_[b_ + 1][0])) { // access kazka
											if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
												if (block_->admins.size() >= 26) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("Lock has reached access limit!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
													continue;
												}
												size_t id_ = atoi(a_[b_ + 1].c_str());
												if (id_ == pInfo(p_)->netID) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("I already have access!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
													continue;
												}
												/*---- end debug print ----
												0: OnTalkBubble
												1: 3
												2: `wG2W`` already has access to the lock.
												3: 0
												4: 0*/
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(currentPeer)->netID == id_ and pInfo(currentPeer)->world == world_->name) {
														if (pInfo(currentPeer)->access_offers.find(pInfo(p_)->netID) != pInfo(currentPeer)->access_offers.end()) break;
														string user_name = to_lower(pInfo(currentPeer)->tankIDName);
														if (user_name == to_lower(block_->owner_name) or find(block_->admins.begin(), block_->admins.end(), user_name) != block_->admins.end()) {
															gamepacket_t p;
															p.Insert("OnTalkBubble");
															p.Insert(pInfo(p_)->netID);
															p.Insert(get_player_nick(currentPeer) + " already has access to the lock.");
															p.Insert(0);
															p.Insert(0);
															p.CreatePacket(p_);
															break;
														}
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(p_)->netID);
														p.Insert("Offered " + get_player_nick(currentPeer) + " access to lock.");
														p.Insert(0);
														p.Insert(0);
														p.CreatePacket(p_);
														{
															pInfo(currentPeer)->access_offers.insert({ pInfo(p_)->netID, (x_ + (y_ * 100)) });
															packet_(currentPeer, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
															gamepacket_t p;
															p.Insert("OnConsoleMessage");
															p.Insert(get_player_nick(p_) + " wants to add you to a " + items[block_->fg].name + ". Wrench yourself to accept.");
															p.CreatePacket(currentPeer);
														}
														break;
													}
												}
											}
											else {
												if (world_->admins.size() >= 26) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("World has reached access limit!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
													continue;
												}
												size_t id_ = atoi(a_[b_ + 1].c_str());
												if (id_ == pInfo(p_)->netID) {
													gamepacket_t p;
													p.Insert("OnTalkBubble");
													p.Insert(pInfo(p_)->netID);
													p.Insert("I already have access!");
													p.Insert(0);
													p.Insert(0);
													p.CreatePacket(p_);
													continue;
												}
												/*---- end debug print ----
												0: OnTalkBubble
												1: 3
												2: `wG2W`` already has access to the lock.
												3: 0
												4: 0*/
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(currentPeer)->netID == id_ and pInfo(currentPeer)->world == world_->name) {
														if (pInfo(currentPeer)->access_offers.find(pInfo(p_)->netID) != pInfo(currentPeer)->access_offers.end()) break;
														string user_name = to_lower(pInfo(currentPeer)->tankIDName);
														if (user_name == to_lower(world_->owner_name) or find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
															gamepacket_t p;
															p.Insert("OnTalkBubble");
															p.Insert(pInfo(p_)->netID);
															p.Insert(get_player_nick(currentPeer) + " already has access to the lock.");
															p.Insert(0);
															p.Insert(0);
															p.CreatePacket(p_);
															break;
														}
														gamepacket_t p;
														p.Insert("OnTalkBubble");
														p.Insert(pInfo(p_)->netID);
														p.Insert("Offered " + get_player_nick(currentPeer) + " access to lock.");
														p.Insert(0);
														p.Insert(0);
														p.CreatePacket(p_);
														{
															pInfo(currentPeer)->access_offers.insert({ pInfo(p_)->netID, (x_ + (y_ * 100)) });
															packet_(currentPeer, "action|play_sfx\nfile|audio/secret.wav\ndelayMS|0");
															gamepacket_t p;
															p.Insert("OnConsoleMessage");
															p.Insert(get_player_nick(p_) + " wants to add you to a " + items[block_->fg].name + ". Wrench yourself to accept.");
															p.CreatePacket(currentPeer);
														}
														break;
													}
													//break;
												}
											}
											break;
										}
										if (upd_) {
											if (block_->fg == 5814) {
												uint32_t guild_id = world_->guild_id;
												vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
												if (p != guilds.end()) {
													Guild* guild_information = &guilds[p - guilds.begin()];
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == world_->name) {
															if (pInfo(currentPeer)->guild_id == guild_information->guild_id) {
																if (guild_access(currentPeer, guild_id)) {
																	nick_update_2(currentPeer, NULL);
																}
																else if (find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(currentPeer)->tankIDName)) == world_->admins.end()) {
																	if (to_lower(pInfo(currentPeer)->tankIDName) != to_lower(world_->owner_name)) {
																		nick_update_2(currentPeer, NULL);
																	}
																}
															}
														}
													}
												}
											}
											tile_update(p_, world_, block_, x_, y_);
										}
									}
									if (reapply) {
										//remove lock from current
										{
											vector<int> new_tiles{};
											vector<WorldBlock> shadow_copy_2 = world_->blocks;
											new_tiles.push_back(x_ + (y_ * 100));
											int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
											for (int i2 = 0; i2 < new_tiles.size(); i2++) {
												int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
												if (s_x_ <( world_->max_x -1 ) and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
													if (not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned) {
														shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned = true;
														new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
														world_->blocks[s_x_ + 1 + (s_y_ * 100)].locked = false;
														world_->blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin = -1;
													}
												} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
													if (not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned) {
														shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned = true;
														new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
														world_->blocks[s_x_ - 1 + (s_y_ * 100)].locked = false;
														world_->blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin = -1;
													}
												} if (s_y_ <( world_->max_y -1 ) and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
													if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned) {
														shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
														new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
														world_->blocks[s_x_ + ((s_y_ + 1) * 100)].locked = false;
														world_->blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin = -1;
													}
												} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
													if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned) {
														shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
														new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
														world_->blocks[s_x_ + ((s_y_ - 1) * 100)].locked = false;
														world_->blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin = -1;
													}
												}
											}
										}
										int lock_size = block_->fg == 202 ? 10 : (block_->fg == 204 || block_->fg == 10000 ? 48 : (block_->fg == 202 ? 200 : 200));
										if (not block_->invert) {
											{
												//apply new without empty air
												vector<vector<int>> tiles_ = lock_tiles(world_, x_, y_, lock_size);
												lock_size = tiles_.size();
												PlayerMoving data_{};
												data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
												data_.netID = name_to_number(to_lower(pInfo(p_)->tankIDName));
												data_.plantingTree = block_->fg;
												BYTE* raw;
												if (tiles_.size() != 0) {
													int alloc = alloc_(world_, block_);
													raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc);
													int lalala = 8;
													memcpy(raw + 8, &lock_size, 2);
													memcpy(raw + 12, &lalala, 2);
													BYTE* blc = raw + 56;
													for (int i_ = 0; i_ < tiles_.size(); i_++) {
														vector<int> update_tiles = tiles_[i_];
														int x = update_tiles[0];
														int y = update_tiles[1];
														int sq_ = x + (y * 100);
														WorldBlock* block_ = &world_->blocks[sq_];
														if (block_->locked) {
															//continue;
														}
														else {
															block_->locked = true;
															block_->lock_origin = x_ + (y_ * 100);
															memcpy(blc + (i_ * 2), &sq_, 2);
														}
													}
													string t_ = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0";
													BYTE* const d_ = new BYTE[5 + t_.length()];
													*(__int8*)(d_) = 3;
													memcpy(d_ + 4, t_.c_str(), t_.length());
													*(__int8*)(d_ + 4 + t_.length()) = 0;
													ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == name_) {
															enet_peer_send(currentPeer, 0, p_m);
															send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc, ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[]d_;
													delete[] raw, blc;
												}
												else {
													raw = packPlayerMoving(&data_, 56);
													string t_ = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0";
													BYTE* const d_ = new BYTE[5 + t_.length()];
													*(__int8*)(d_) = 3;
													memcpy(d_ + 4, t_.c_str(), t_.length());
													*(__int8*)(d_ + 4 + t_.length()) = 0;
													ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
													for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
														if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
														if (pInfo(currentPeer)->world == name_) {
															enet_peer_send(currentPeer, 0, p_m);
															send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														}
													}
													delete[]d_;
													delete[] raw;
												}
											}
										}
										else {
											vector<int> new_tiles{};
											vector<int> lock_tiles{};
											vector<WorldBlock> shadow_copy_2 = world_->blocks;
											new_tiles.push_back(x_ + (y_ * 100));
											int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
											for (int i2 = 0; i2 < new_tiles.size(); i2++) {
												if (lock_tiles.size() >= lock_size) break;
												int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
												if (s_x_ < (world_->max_x -1) and not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ + 1 + (s_y_ * 100)], s_x_ + 1 + (s_y_ * 100), world_->blocks.size()) or s_x_ < (world_->max_x -1) and not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].bg != 0 and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].fg == 0) {
													if (not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned) {
														shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned = true;
														new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
														lock_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
														world_->blocks[s_x_ + 1 + (s_y_ * 100)].locked = true;
														world_->blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin = x_ + (y_ * 100);
													}
												} if (s_x_ > 0 and not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ - 1 + (s_y_ * 100)], s_x_ - 1 + (s_y_ * 100), world_->blocks.size()) or s_x_ > 0 and not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].bg != 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].fg == 0) {
													if (not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned) {
														shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned = true;
														new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
														lock_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
														world_->blocks[s_x_ - 1 + (s_y_ * 100)].locked = true;
														world_->blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin = x_ + (y_ * 100);
													}
												} if (s_y_ < (world_->max_y -1) and not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)], s_x_ + ((s_y_ + 1) * 100), world_->blocks.size()) or s_y_ < (world_->max_y - 1) and not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].bg != 0 and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].fg == 0) {
													if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned) {
														shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
														new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
														lock_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
														world_->blocks[s_x_ + ((s_y_ + 1) * 100)].locked = true;
														world_->blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin = x_ + (y_ * 100);
													}
												} if (s_y_ > 0 and not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].fg != 0 and not_mod(shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)], s_x_ + ((s_y_ - 1) * 100), world_->blocks.size()) or s_y_ > 0 and not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].bg != 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].fg == 0) {
													if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned) {
														shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
														new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
														lock_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
														world_->blocks[s_x_ + ((s_y_ - 1) * 100)].locked = true;
														world_->blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin = x_ + (y_ * 100);
													}
												}
											}

											//upd_lock(*block_, *world_, p_);
											lock_size = lock_tiles.size();
											if (lock_tiles.size() > 0) {
												PlayerMoving data_{};
												data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
												data_.netID = to_lower(block_->owner_name) == to_lower(pInfo(p_)->tankIDName) ? name_to_number(to_lower(pInfo(p_)->tankIDName)) : -1;
												data_.plantingTree = block_->fg;
												BYTE* raw;
												int alloc = alloc_(world_, block_);
												raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc);
												int lalala = 8;
												memcpy(raw + 8, &lock_size, 2);
												memcpy(raw + 12, &lalala, 2);
												BYTE* blc = raw + 56;
												for (int i_ = 0; i_ < lock_tiles.size(); i_++) memcpy(blc + (i_ * 2), &lock_tiles[i_], 2);
												PlayerMoving data_2{};
												data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
												BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
												BYTE* blc2 = raw2 + 56;
												form_visual(blc2, *block_, *world_, p_, false);
												string t_ = "action|play_sfx\nfile|audio/friend_logoff.wav\ndelayMS|0";
												BYTE* const d_ = new BYTE[5 + t_.length()];
												*(__int8*)(d_) = 3;
												memcpy(d_ + 4, t_.c_str(), t_.length());
												*(__int8*)(d_ + 4 + t_.length()) = 0;
												ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (pInfo(currentPeer)->world == world_->name) {
														enet_peer_send(currentPeer, 0, p_m);
														send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc, ENET_PACKET_FLAG_RELIABLE);
														send_raw(currentPeer, 4, raw2, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
													}
												}
												delete[] raw, blc, raw2, blc2;
												delete[]d_;
											}
											else {
												PlayerMoving data_{};
												data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
												data_.netID = to_lower(block_->owner_name) == to_lower(pInfo(p_)->tankIDName) ? name_to_number(to_lower(pInfo(p_)->tankIDName)) : -1;
												data_.plantingTree = block_->fg;
												BYTE* raw = packPlayerMoving(&data_, 56);
												string t_ = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0";
												BYTE* const d_ = new BYTE[5 + t_.length()];
												*(__int8*)(d_) = 3;
												memcpy(d_ + 4, t_.c_str(), t_.length());
												*(__int8*)(d_ + 4 + t_.length()) = 0;
												ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (world_->name == pInfo(currentPeer)->world) {
														send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
														PlayerMoving data_2{};
														data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
														int alloc = alloc_(world_, block_);
														BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc);
														BYTE* blc2 = raw2 + 56;
														form_visual(blc2, *block_, *world_, currentPeer, false);
														enet_peer_send(currentPeer, 0, p_m);
														send_raw(currentPeer, 4, raw2, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
														delete[] raw2, blc2;
													}
												}
												delete[]d_;
												delete[] raw;
											}
										}
									}
								}
							}
							break;
						}
						else if (a_[i_] == "upgrading_guild") {
						if (a_.size() != 7 and a_.size() != 8 and a_.size() != 11) break;
						string button_clicked = a_.size() == 8 ? a_[5] : a_[8];
						if (button_clicked == "back") {
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								int x_ = 0, y_ = 0;
								int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
								{
									vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
									if (p != world_->blocks.end()) {
										int i_ = p - world_->blocks.begin();
										x_ = i_ % xSize;
										y_ = i_ / xSize;
									}
								}
								WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
								send_edit_lock(p_, world_, block_->fg, x_, y_);
							}
						}
						else if (button_clicked == "upgrade_guild") {
							uint32_t guild_id = pInfo(p_)->guild_id;
							if (guild_id == 0) return;
							vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
							if (p != guilds.end()) {
								Guild* guild_information = &guilds[p - guilds.begin()];
								guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
								guild_information->guild_settings |= Gtps3::SETTINGS_0;
								if (guild_information->guild_level > guild_lvl.size()) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`0Your guild is already max level!``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
								}
								else {
									if (guild_information->guild_xp >= guild_lvl[guild_information->guild_level - 1][0]) {
										if (pInfo(p_)->gems < guild_lvl[guild_information->guild_level - 1][1]) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(p_)->netID);
											p.Insert("`0You don't have enough gems!``");
											p.Insert(0), p.Insert(0);
											p.CreatePacket(p_);
										}
										else {
											for (GuildMember member_search : guild_information->guild_members) {
												if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
													if (member_search.role_id == 3) {
														OnSetGems(p_, guild_lvl[guild_information->guild_level - 1][1] * -1);
														guild_information->guild_level++;
														guild_information->guild_xp = 0;
														{
															gamepacket_t p_leave;
															p_leave.Insert("OnConsoleMessage");
															p_leave.Insert("`5[GUILD ALERT]`` " + pInfo(p_)->tankIDName + " Upgraded Guild to Level " + to_string(guild_information->guild_level) + "!");
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																if (pInfo(currentPeer)->guild_id == guild_id) {
																	p_leave.CreatePacket(currentPeer);
																}
															}
														}
														gamepacket_t p;
														p.Insert("OnAddNotification");
														p.Insert("interface/large/guild_levelup.rttex");
														p.Insert("`wAwesome! You reached Guild Level " + to_string(guild_information->guild_level) + "``");
														p.Insert("audio/hub_open.wav");
														p.Insert(0);
														p.CreatePacket(p_);
													}
												}
											}
										}
									}
								}
							}
						}
						break;
						}
						else if (a_[i_] == "create_guild_mascot") {
						if (a_.size() < 7) break;
						string button_clicked = a_[5], button_name = a_[4];
						if (button_name == "select_bg" || button_name == "select_fg") {
							int item = atoi(a_[5].c_str());
							if (item <= 0 && item > items.size()) break;
							string error = "";
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(p_)->netID);
							if (items[item].blockType == BlockTypes::SEED) {
								p.Insert("`wYou can't set the Guild Mascot to seed!``");
								error = "Seeds are not valid Guild Mascot elements! Please choose something else.";
							}
							if (items[item].blockType == BlockTypes::BACKGROUND) {
								pInfo(p_)->set_guild_bg = item;
								p.Insert("`wYou set Guild Background to " + items[item].ori_name + "``");
							}
							else {
								pInfo(p_)->set_guild_fg = item;
								p.Insert("`wYou set Guild Foreground to " + items[item].ori_name + "``");
							}
							p.Insert(0), p.Insert(0);
							p.CreatePacket(p_);
							guild_flag_dialog(p_, error);
						}
						else {
							if (button_clicked == "create") {
								bool taken_ = false;
								if (pInfo(p_)->set_guild_fg + pInfo(p_)->set_guild_bg != 0) {
									for (Guild check_guild_name : guilds) {
										if (check_guild_name.guild_mascot[0] == pInfo(p_)->set_guild_fg && check_guild_name.guild_mascot[1] == pInfo(p_)->set_guild_bg) {
											taken_ = true;
											break;
										}
									}
									if (taken_ == false) {
										int price = 100000;
										uint32_t guild_id = pInfo(p_)->guild_id;
										vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
										if (p != guilds.end()) {
											Guild* guild_information = &guilds[p - guilds.begin()];
											for (GuildMember member_search : guild_information->guild_members) {
												if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
													if (member_search.role_id == 3) {
														if (guild_information->guild_mascot[0] == 0 && guild_information->guild_mascot[1] == 0) price = -100000;
														else price = -250000;
														if (pInfo(p_)->gems >= abs(price)) {
															OnSetGems(p_, price);
															gamepacket_t p;
															p.Insert("OnTalkBubble");
															p.Insert(pInfo(p_)->netID);
															p.Insert("`wYou have "+a + (price == -250000 ? "changed" : "created") + " Guild Flag!``");
															p.Insert(0), p.Insert(0), p.CreatePacket(p_);
															guild_information->guild_mascot[0] = pInfo(p_)->set_guild_fg;
															guild_information->guild_mascot[1] = pInfo(p_)->set_guild_bg;
															gamepacket_t p_leave;
															p_leave.Insert("OnConsoleMessage");
															p_leave.Insert("`5[GUILD ALERT]`` " + pInfo(p_)->tankIDName + " " + (price == -250000 ? "changed" : "created") + " Guild Flag!");
															for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																if (pInfo(currentPeer)->guild_id == guild_id) {
																	update_clothes_value(currentPeer, true);
																	update_clothes(currentPeer);
																	p_leave.CreatePacket(currentPeer);
																}
															}
														}
														else {
															gamepacket_t p;
															p.Insert("OnTalkBubble");
															p.Insert(pInfo(p_)->netID);
															p.Insert("`wYou don't have that much gems!``");
															p.Insert(0), p.Insert(0), p.CreatePacket(p_);
														}
														break;
													}
												}
											}
										}
									}
								}
							}
						}
						break;
						}
						else if (a_[i_] == "worldcategory") {
						if (a_.size() != 7 and a_.size() != 8 and a_.size() != 11) break;
						if (a_.size() == 8 or a_.size() == 11) {
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								if (to_lower(world_->owner_name) == to_lower(pInfo(p_)->tankIDName)) {
									string button_clicked = a_.size() == 8 ? a_[5] : a_[8];
									int world_rateds = atoi(button_clicked.c_str());
									world_->category = world_category(world_rateds);
								}
							}
						}
						}
						else if (a_[i_] == "abondonguild") {
							if (a_.size() != 7 and a_.size() != 8 and a_.size() != 11) break;
							if (pInfo(p_)->guild_id == 0) break;
							if (a_.size() == 8 or a_.size() == 11) {
								string button_clicked = a_.size() == 8 ? a_[5] : a_[8];
								if (button_clicked == "back") {
									string name_ = pInfo(p_)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										int x_ = 0, y_ = 0;
										int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
										{
											vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
											if (p != world_->blocks.end()) {
												int i_ = p - world_->blocks.begin();
												x_ = i_ % xSize;
												y_ = i_ / xSize;
											}
										}
										WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
										send_edit_lock(p_, world_, block_->fg, x_, y_);
									}
								}
								else if (button_clicked == "abondonguild") {
									if (not isdigit(a_[5][0])) break;
									int planting_id_ = atoi(a_[5].c_str());
									if (planting_id_ >= items.size() or planting_id_ < 0) break;
									if (items[planting_id_].blockType != LOCK or planting_id_ == 202 or planting_id_ == 204 or planting_id_ == 206 or planting_id_ == 4994 or planting_id_ == 10000) {
										break;
									}
									string name_ = pInfo(p_)->world;
									vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
									if (p != worlds.end()) {
										World* world_ = &worlds[p - worlds.begin()];
										uint32_t guild_id = world_->guild_id;
										vector<Guild>::iterator p = find_if(guilds.begin(), guilds.end(), [guild_id](const Guild& a) { return a.guild_id == guild_id; });
										if (p != guilds.end()) {
											Guild* guild_information = &guilds[p - guilds.begin()];
											for (GuildMember member_search : guild_information->guild_members) {
												if (to_lower(member_search.member_name) == to_lower(pInfo(p_)->tankIDName)) {
													if (member_search.role_id != 3) break;
													int ySize = (int)world_->blocks.size() / 100, xSize = (int)world_->blocks.size() / ySize;
													{
														vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 5814; });
														if (p != world_->blocks.end()) {
															int i_ = p - world_->blocks.begin();
															int x_ = i_ % xSize;
															int y_ = i_ / xSize;
															WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
															int c_ = -1;
															if (modify_inventory(p_, planting_id_, c_) == 0) {
																leave_guild(p_);
																block_->fg = planting_id_;
																world_->guild_id = 0;
																PlayerMoving data_{};
																data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
																data_.netID = name_to_number(to_lower(pInfo(p_)->tankIDName));
																data_.plantingTree = block_->fg;
																BYTE* raw = packPlayerMoving(&data_, 56);
																PlayerMoving data_2{};
																data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
																BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc_(world_, block_));
																BYTE* blc = raw2 + 56;
																form_visual(blc, *block_, *world_, p_, false);
																for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																	if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																	if (pInfo(currentPeer)->world == world_->name) {
																		send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
																		send_raw(currentPeer, 4, raw2, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
																	}
																}
																delete[] raw, raw2, blc;
																gamepacket_t p;
																p.Insert("OnConsoleMessage");
																p.Insert("`5[GUILD ALERT]`` Guild Abandoned!");
																p.CreatePacket(p_);

																vector<pair<long long int, string>>::iterator pz = find_if(top_guild.begin(), top_guild.end(), [&](const pair < long long int, string>& element) { return element.second == to_string(pInfo(p_)->guild_id); });
																if (pz != top_guild.end()) top_guild.erase(pz);

																guild_information->guild_settings &= ~Gtps3::SETTINGS_0;
																guild_information->guild_settings |= Gtps3::SETTINGS_0;
																guild_information->guild_name = "";
															}
														}
													}
													break;
												}
											}
										}
									}
								}
								break;
							}
							if (not isdigit(a_[5][0])) break;
							int planting_id_ = atoi(a_[5].c_str());
							if (planting_id_ >= items.size() or planting_id_ < 0) break;
							if (items[planting_id_].blockType != LOCK or planting_id_ == 202 or planting_id_ == 204 or planting_id_ == 206 or planting_id_ == 4994 or planting_id_ == 10000) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`4You need to select a World Lock!|left||\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
								p.CreatePacket(p_);
								break;
							}
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("add_label_with_icon|big|`wAbandon Guild ``|left|5814|\nadd_textbox|`1Are you sure you want to abandon the guild?``|left|\nadd_textbox|`4BEWARE:``|left|\nadd_spacer|small|\nadd_textbox|`8- The Guild Lock will NOT return to your inventory!``|left|\nadd_textbox|`8- If you purchased a Guild Mascot this will be lost and will be made available to other guilds to buy!``|left|\nadd_textbox|`8- You will not get back any of the Gems you invested in the Guild!``|left|\nadd_textbox|`8- You will lose all Guild XP and levels the guild accomplished!``|left|\nadd_textbox|`8- When the Guild is abandoned it cannot be recovered!``|left|\nembed_data|worldlockId|" + to_string(planting_id_) + "\nadd_spacer|small|\nadd_button|abondonguild|Abandon Guild|noflags|0|0|\nadd_button|back|Back|noflags|0|0|\nend_dialog|abondonguild|||");
							p.CreatePacket(p_);
							break;
						}
						else if (a_[i_] == "confirmguildlockkey") {
							if (a_.size() != 5) break;
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								if (to_lower(world_->owner_name) != to_lower(pInfo(p_)->tankIDName)) break;
								int c_ = 0;
								modify_inventory(p_, 5816, c_);
								if (c_ != 0) break;
								/*
								for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
									if (world_->drop_new[i_][3] == -1 or world_->drop_new[i_][0] == 0) continue;
									WorldBlock* block_ = &world_->blocks[(world_->drop_new[i_][3] / 32) + ((world_->drop_new[i_][4] / 32) * 100)];
									if (items[block_->fg].collisionType != 1) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("`4Oops!... Can't trade a world with floating items that are unblocked or in treasure chests!``");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										return;
									}
								}*/
								vector<WorldBlock>::iterator pf = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994  || a.fg == 10000; });
								if (pf != world_->blocks.end()) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("To trade a world, you can only have one lock on it, the `5World Lock``.  Remove the rest!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
								vector<WorldBlock>::iterator pz = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return a.fg == 4516; });
								if (pz != world_->blocks.end()) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("`4To trade a world, you will need to remove Untrade-a-Box!``");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
									return;
								}
								if (world_->admins.size() != 0) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You'll first need to remove all players with access to your " + items[242].name + " to get a " + items[5816].name + ".");
									p.Insert(0), p.Insert(1);
									p.CreatePacket(p_);
									return;
								}
								c_ = 1;
								if (modify_inventory(p_, 5816, c_) == 0) {
									packet_(p_, "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0");
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(p_)->netID);
									p.Insert("You got a `#" + items[5816].name + "``! You can now transfer leadership of the guild!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(p_);
								}
							}
							break;
						}
						else if (a_[i_] == "sign_edit") {
							if (a_.size() != 13) break;
							if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
							int x_ = atoi(a_[i_ + 2].c_str()), y_ = atoi(a_[i_ + 5].c_str());
							if (x_ < 0 or y_ < 0) break;
							if (abs(pInfo(p_)->x / 32 - x_) > 5 || abs(pInfo(p_)->y / 32 - y_) > 5) break;
							string tekstas = a_[i_ + 8];
							if (tekstas.size() > 128) break;
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								if (x_ >= world_->max_x || y_ >= world_->max_y) break;
								WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
								if (block_->txt == tekstas or block_->fg == 0 or items[block_->fg].blockType != BlockTypes::SIGN) break;
								if (block_access(p_, world_, block_)) {
									if (items[block_->fg].path_marker) {
										transform(tekstas.begin(), tekstas.end(), tekstas.begin(), ::toupper);
										block_->door_id = tekstas;
									}
									else {
										block_->txt = tekstas;
										tile_update(p_, world_, block_, x_, y_);
									}
								}
							}
							break;
						}
						else if (a_[i_] == "trash_item" or a_[i_] == "drop_item" or a_[i_] == "trash_item2") {
							if (a_.size() != 10 and a_[i_] != "trash_item2") break;
							if (a_[i_] == "trash_item2" and a_.size() != 11) break;
							if (not isdigit(a_[i_ + 2][0]) or not isdigit(a_[i_ + 5][0])) break;
							int id_ = atoi(a_[i_ + 2].c_str()), c_ = atoi(a_[i_ + 5].c_str());
							int count = 0;
							int drop_fish = 0;
							if (items[id_].blockType == BlockTypes::FISH) {
								for (int i_ = 0, remove = 0; i_ < pInfo(p_)->inv.size(); i_++) if (pInfo(p_)->inv[i_].first == id_) drop_fish = pInfo(p_)->inv[i_].second, c_ = pInfo(p_)->inv[i_].second;
							}
							if (id_ >= items.size() or id_ == 18 or id_ == 32 or id_ == 6336) break;
							string name_ = pInfo(p_)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								c_ = c_ * -1;
								if (a_[i_] == "trash_item" or a_[i_] == "trash_item2") {
									if (a_[i_] == "trash_item" and items[id_].untradeable) {
										int has_ = 0;
										modify_inventory(p_, id_, has_);
										if (has_ < c_) break;
										gamepacket_t p;
										p.Insert("OnDialogRequest");
										p.Insert("set_default_color|`o\nadd_label_with_icon|big|`4Recycle`` " + to_string(c_ * -1) + " `w" + items[id_].name + "``|left|" + to_string(id_) + "|\nembed_data|itemID|" + to_string(id_) + "\nembed_data|count|" + to_string(c_ * -1) + "\nadd_textbox|You are recycling an `9UNTRADEABLE`` item. Are you absolutely sure you want to do this? There is no way to get the item back if you select yes.|left|\nend_dialog|trash_item2|NO!|Yes, I am sure|");
										p.CreatePacket(p_);
										break;
									}
									if (modify_inventory(p_, id_, c_) == 0) {
										packet_(p_, "action|play_sfx\nfile|audio/trash.wav\ndelayMS|0");
										a_[i_ + 5].erase(0, min(a_[i_ + 5].find_first_not_of('0'), a_[i_ + 5].size() - 1));
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										if (pInfo(p_)->supp != 0 && domain != "https://gold-ps.com/") {
											int item = id_, maxgems = 0, receivegems = 0;
											int count = atoi(a_[i_ + 5].c_str());
											if (id_ % 2 != 0) item -= 1;
											maxgems = items[item].max_gems2;
											if (items[item].max_gems2 != 0) if (maxgems != 0) for (int i = 0; i < count; i++) receivegems += rand() % maxgems;
											if (items[item].max_gems3 != 0) receivegems = count * items[item].max_gems3;
											if (receivegems != 0) OnSetGems(p_, receivegems);
											p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : a_[i_ + 5]) + " `w" + items[id_].ori_name + "`` recycled, `0" + setGems(receivegems) + "`` gems earned.");
										}
										else p.Insert((items[id_].blockType == BlockTypes::FISH ? (to_string(abs(c_))) + "lb." : a_[i_ + 5]) + " `w" + items[id_].ori_name + "`` trashed.");
										p.CreatePacket(p_);
										break;
									}
									break;
								}
								if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 4758) != world_->active_jammers.end()) {
									if (to_lower(world_->owner_name) == to_lower(pInfo(p_)->tankIDName) || find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) != world_->admins.end()) {

									}
									else {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(p_)->netID);
										p.Insert("The Mini-Mod says no dropping items in this world!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(p_);
										break;
									}
								}
								if (items[id_].untradeable or id_ == 1424 or id_ == 5816) {
									gamepacket_t p;
									p.Insert("OnTextOverlay");
									p.Insert("You can't drop that.");
									p.CreatePacket(p_);
									break;
								}
								string name_ = pInfo(p_)->world;
								vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
								if (p != worlds.end()) {
									World* world_ = &worlds[p - worlds.begin()];
									WorldDrop drop_{};
									drop_.id = id_;
									if (drop_fish == 0) drop_.count = atoi(a_[i_ + 5].c_str());
									else drop_.count = drop_fish;
									int a_ = rand() % 12;
									drop_.x = (pInfo(p_)->state == 16 ? pInfo(p_)->x - (a_ + 20) : (pInfo(p_)->x + 20) + a_);
									drop_.y = pInfo(p_)->y + rand() % 16;
									if (drop_.x / 32 < 0 or drop_.x / 32 >= world_->max_x or drop_.y / 32 < 0 or drop_.y / 32 >= world_->max_y) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert("You can't drop that here, face somewhere with open space.");
										p.CreatePacket(p_);
										break;
									}
									BlockTypes type_ = FOREGROUND;
									int as_ = rand() % 12;
									int x = (pInfo(p_)->state == 16 ? pInfo(p_)->x - (a_ + 20) : (pInfo(p_)->x + 20) + as_);
									int y = pInfo(p_)->y + rand() % 16;
									//BlockTypes type_ = FOREGROUND;
									int where_ = (pInfo(p_)->state == 16 ? x / 32 : round((double)x / 32)) + (y / 32 * 100);
									WorldBlock* block_ = &world_->blocks[(pInfo(p_)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * 100)];
									int xy = (pInfo(p_)->state == 16 ? drop_.x / 32 : round((double)drop_.x / 32)) + (drop_.y / 32 * 100);
									if (items[block_->fg].collisionType == 1 || block_->fg == 6 || items[block_->fg].blockType == BlockTypes::GATEWAY || items[block_->fg].toggleable and is_false_state(world_->blocks[(pInfo(p_)->state == 16 ? x / 32 : round((double)x / 32)) + (y / 32 * 100)], 0x00400000)) {
										gamepacket_t p;
										p.Insert("OnTextOverlay");
										p.Insert(items[block_->fg].blockType == BlockTypes::MAIN_DOOR ? "You can't drop items on the white door." : "You can't drop that here, face somewhere with open space.");
										p.CreatePacket(p_);
										break;
									}
									int count_ = 0;
									bool dublicated = false;
									world_->fresh_world = true;
									for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
										if (abs(world_->drop_new[i_][4] - drop_.y) <= 16 and abs(world_->drop_new[i_][3] - drop_.x) <= 16) {
											count_ += 1;
										}
										if (world_->drop_new[i_][0] == id_) if (world_->drop_new[i_][1] + drop_.count < 200) dublicated = true;
									}
									if (!dublicated) {
										if (count_ > 20) {
											gamepacket_t p;
											p.Insert("OnTextOverlay");
											p.Insert("You can't drop that here, find an emptier spot!");
											p.CreatePacket(p_);
											break;
										}
									}

									int dropped = c_;
									if (modify_inventory(p_, id_, c_) == 0) {
										bool droppeds = false;
										
										if (world_->name == "GROWGANOTH" and Growganoth) {
											if (drop_.x / 32 == 47 || drop_.x / 32 == 48 || drop_.x / 32 == 49 || drop_.x / 32 == 50 || drop_.x / 32 == 51) {
												if (drop_.y / 32 == 14 || drop_.y / 32 == 15) {
													int give_ = abs(dropped), give_back = abs(dropped);
													int itemid = (items[id_].consume_prize.size() == 0 ? 0 : items[id_].consume_prize[rand() % items[id_].consume_prize.size()]);
													bool consume = false;
													if (itemid != 0 && items[id_].consume_needed == 0) droppeds = true, consume = true;
													else if ((id_ == 10328 && abs(dropped) == 1) or items[id_].rarity != 0) {
														give_ = 1;
														int prize = 0;
														switch (id_) {
															case 1950: prize = 4152;  break;
															case 2722: prize = 3114;  break;
															case 910: prize = 1250;  break;
															case 11046: prize = 11314;  break;
															case 94: case 604: case 2636: case 2908: prize = 3108;  break;
															case 274: case 276: prize = 1956;  break;
															case 10730: prize = 11332;  break;
															case 10732: prize = 11334;  break;
															case 10734: prize = 11336;  break;
															case 6176: prize = 9042;  break;
															case 3040: prize = 3100;  break;
															case 11666: prize = 12414;  break;
															case 6144: prize = 7104;  break;
															case 7998: prize = 9048;  break;
															case 1162: prize = 3126;  break;
															case 9322: prize = 10184;  break;
															case 7696: prize = 10186;  break;
															case 1474: prize = 1990;  break;
															case 1506: prize = 1968;  break;
															case 2386: prize = 4166;  break;
															case 9364: prize = 10206;  break;
															case 10576: prize = 11322;  break;
															case 4960: prize = 5208;  break;
															case 6196: prize = 9056;  break;
															case 4326: prize = 7122;  break;
															case 2860: case 2268: prize = 4172;  break;
															case 1114: prize = 4156;  break;
															case 362: prize = 1234;  break;
															case 11574: prize = 12772;  break;
															case 4334: prize = 5250;  break;
															case 1408: prize = 5254;  break;
															case 4338: prize = 5252;  break;
															case 3288: prize = 4138;  break;
															case 3296: prize = 4146;  break;
															case 3290: prize = 4140;  break;
															case 3292: prize = 4142;  break;
															case 3298: prize = 4148;  break;
															case 3294: prize = 4144;  break;
															case 900: case 7754: case 7136: case 1576: case 7752: case 1378: case 7758: case 7760: case 7748:  prize = 2000;  break;
															case 1746: prize = 1960;  break;
															case 5018: prize = 5210;  break;
															case 1252: prize = 1948;  break;
															case 1190: prize = 1214;  break;
															case 2868: prize = 7100;  break;
															case 11638: prize = 12780;  break;
															case 11534: prize = 12416;  break;
															case 1830: prize = 1966;  break;
															case 920: case 914: case 918: case 916: case 924: case 922: case 2206: case 4444: case 2038: prize = 1962;  break;
															case 3556: { vector<int>random_prize = { 4186,4188 }; prize = random_prize[rand() % random_prize.size()];  } break;
															case 762: prize = 4190;  break;
															case 3818: prize = 10192;  break;
															case 366: prize = 4136;  break;
															case 9262: prize = 10212;  break;
															case 1294: prize = 5236;  break;
															case 1242: prize = 5216;  break;
															case 1244: prize = 5218;  break;
															case 1246: prize = 5220;  break;
															case 1248: prize = 5214;  break;
															case 7028: case 7030: case 7026: prize = 12396;  break;
															case 3016: case 5528: case 3018: case 5526: prize = 4248;  break;
															case 242: prize = 1212;  break;
															case 2972: prize = 4182;  break;
															case 3014: case 3012: case 2914: prize = 4246;  break;
															case 1460: prize = 1970;  break;
															case 2392: prize = 9114;  break;
															case 3218: case 3020: prize = 3098;  break;
															case 3792: prize = 5244;  break;
															case 1198: prize = 5256;  break;
															case 8468: prize = 10232;  break;
															case 2984: prize = 3118;  break;
															case 4360: prize = 10194;  break;
															case 10148: prize = 12418;  break;
															case 5012: case 1018: case 592: prize = 1178;  break;
															case 10406: prize = 11316;  break;
															case 10652: prize = 12420;  break;
															case 882: prize = 1232;  break;
															case 1934: prize = 3124;  break;
															case 10626: prize = 11312;  break;
															case 6160: prize = 9040;  break;
															case 3794: prize = 10190;  break;
															case 8018: prize = 9034;  break;
															case 2390: prize = 3122;  break;
															case 5246: { vector<int>random_prize = { 9050,9052,9054 }; prize = random_prize[rand() % random_prize.size()];  } break;
															case 6798: prize = 7126;  break;
															case 9722: case 9724: prize = 10200;  break;
															case 9388: prize = 10234;  break;
															case 4732: prize = 7124;  break;
															case 10804: prize = 11320;  break;
															default: prize = 0;
														}
														if (prize == 0 and items[id_].rarity < 367) {
															vector<int> growganoth, rare_growganoth;
															if (items[id_].rarity >= 1) growganoth.push_back(1208);
															if (items[id_].rarity >= 5) growganoth.insert(growganoth.end(), { 1992,5256,11348 });
															if (items[id_].rarity >= 10) growganoth.insert(growganoth.end(), { 1198,1222,11342,12786 });
															if (items[id_].rarity >= 15) growganoth.insert(growganoth.end(), { 1982,1200 });
															if (items[id_].rarity >= 20) growganoth.insert(growganoth.end(), { 1220,4160,10198 });
															if (items[id_].rarity >= 25) growganoth.insert(growganoth.end(), { 1202,5240 });
															if (items[id_].rarity >= 30) growganoth.insert(growganoth.end(), { 1238,4162,5238,7116,10196,10316 });
															if (items[id_].rarity >= 35) growganoth.insert(growganoth.end(), { 1168,9044 });
															if (items[id_].rarity >= 40) growganoth.insert(growganoth.end(), { 1172,3116,4164,12788 });
															if (items[id_].rarity >= 45) growganoth.push_back(1230);
															if (items[id_].rarity >= 50)  growganoth.insert(growganoth.end(), { 1192,1194,4164,10202,11340 });
															if (items[id_].rarity >= 55)  growganoth.insert(growganoth.end(), { 1226,7108 });
															if (items[id_].rarity >= 60)  growganoth.insert(growganoth.end(), { 1196,12784 });
															if (items[id_].rarity >= 65)  growganoth.insert(growganoth.end(), { 1236,9046 });
															if (items[id_].rarity >= 70)  growganoth.insert(growganoth.end(), { 1182,1184,1186,1188,1972,1980,1994,7110,11330 });
															if (items[id_].rarity >= 73)  growganoth.insert(growganoth.end(), { 3102,4154,5222,5224,5232,10204 });
															if (items[id_].rarity >= 75)  growganoth.push_back(1988);
															if (items[id_].rarity >= 80)  rare_growganoth.insert(rare_growganoth.end(), { 1170,4158,7128,12790 });
															if (items[id_].rarity >= 85)  rare_growganoth.push_back(1984);
															if (items[id_].rarity >= 90)  rare_growganoth.insert(rare_growganoth.end(), { 1216,1218,5248,7112,7114,10322 });
															if (items[id_].rarity >= 97)  rare_growganoth.push_back(3106);
															if (items[id_].rarity >= 100)  rare_growganoth.push_back(7130);
															if (items[id_].rarity >= 101)  rare_growganoth.push_back(3110);
															if (id_ == 10328) {
																growganoth = { 3110, 7130, 3106,1216,1218,5248,7114,10322,7112, 12772, 12396, 10236,4152  , 3114  , 1250  , 11314  , 3108  , 1956  , 11332  , 11336  , 11334  , 9042  ,9048  , 3126  , 10186  , 1990  , 1968   , 5208  , 9056  , 7122  , 4172  , 4156  , 1234  , 5250  , 5254  , 5252  , 4138  , 4146  , 4140  , 4142  , 4148  , 4144  , 2000  , 1960  , 5210  , 1948  , 1214  , 7100  , 1966  , 1962  , 4188  , 4186  , 4190  , 10192  , 4136  , 10212  , 5236  , 5216  , 5218  , 5220  , 5214  , 4248  , 4182  , 4246  , 3098  , 5244  , 5256  , 10232  , 3118  , 10194  , 4192  , 1178  , 11316  , 1232  , 3124  , 11312  , 9040  , 10190  , 9034  , 3122  , 9050  , 9054  , 9052  , 7126  , 10200  , 10234  , 7124  , 11320  , 1210 };
																if (rand() % 270 < 1) growganoth = { 4166, 12418, 12416, 12780, 12420, 12414, 1970,9114, 11322 ,7104, 10206, 11318, 10184 ,3100 , 7102 };

															}
															else {
																if (items[id_].rarity >= 80 && rand() % 440 - give_back - items[id_].rarity < 1) itemid = rare_growganoth[rand() % rare_growganoth.size()];
															}
															if (itemid == 0) itemid = growganoth[rand() % growganoth.size()];
														}
														else itemid = prize;
														droppeds = true;
													}
													else {
														droppeds = true;
														SendRespawn(p_, true, 0, 1);
														itemid = 0;
													}
													if (droppeds) {
														gamepacket_t p3, p4;
														p3.Insert("OnTalkBubble"), p3.Insert(pInfo(p_)->netID);
														p4.Insert("OnConsoleMessage");
														if (itemid != 0) {
															if (items[id_].consume_prize.size() == 0) {
																if (itemid == 4166 || itemid == 12418 || itemid == 12416|| itemid == 12780 || itemid == 12420|| itemid == 12414||itemid == 1970 || itemid == 9114 || itemid == 11322 || itemid == 7104 || itemid == 10206 || itemid == 11318 || itemid == 10184 || itemid == 3100 || itemid == 7102) {
																	gamepacket_t p;
																	p.Insert("OnConsoleMessage"), p.Insert("`4Growganoth`` honors " + pInfo(p_)->name_color + pInfo(p_)->tankIDName + "`` with a `5Rare " + items[itemid].name + "`` for their " + items[id_].ori_name + "!");
																	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
																		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
																		p.CreatePacket(currentPeer);
																	}
																}
															}
															
															gamepacket_t p, p2;
															if (consume) p3.Insert("`4Growganoth turns your " + items[id_].ori_name + " into an " + items[itemid].ori_name + " and hatches it with evil!``"), p4.Insert("`4Growganoth turns your " + items[id_].ori_name + " into an " + items[itemid].ori_name + " and hatches it with evil!``"), p4.CreatePacket(p_);
															else  p3.Insert("`4Growganoth is pleased by your offering and grants a reward! Also, he eats you.``"), p4.Insert("`4Growganoth is pleased by your offering and grants a reward! Also, he eats you.``"), p4.CreatePacket(p_);
															p.Insert("OnConsoleMessage"), p.Insert("`2" + items[id_].ori_name + "`` was devoured by Growganoth!"), p.CreatePacket(p_);
															p2.Insert("OnConsoleMessage");
															if (modify_inventory(p_, itemid, give_) == 0) p2.Insert("A `2" + items[itemid].ori_name + "`` was bestowed upon you!");
															else {
																modify_inventory(p_, id_, give_back);
																p2.Insert("No inventory space.");
															}
															p2.CreatePacket(p_);
														}
														else {
															p3.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), p4.Insert("`4Growganoth rejects your puny offering and eats you instead!``"), p4.CreatePacket(p_);
															modify_inventory(p_, id_, give_back);
														}
														p3.CreatePacket(p_);
														SendRespawn(p_, true, 0, 1);
													}
												}
											}
										}

										if (droppeds == false) {
											if (id_ == 611 && block_->fg == 610 && block_access(p_, world_, block_)) {
												int x_ = xy % 100, y_ = xy / 100;
												add_magic_egg(p_, world_, block_, x_, y_, abs(dropped));
											}
											else {
												add_cctv(p_, "dropped", to_string(abs(dropped)) + " " + items[id_].name);
												dropas_(world_, drop_, pInfo(p_)->netID);
											}
										}
									}
								}
							}
							break;
						}
						else if (a_[i_] == "growid_apply") {
							if (a_.size() != 17) break;
							string gender = ((a_[i_ + 2] == "1") ? "man" : (a_[i_ + 4] == "1") ? "woman" : (a_[i_ + 2] == "1") && (a_[i_ + 4] == "1") ? "both" : "");
							string user_ = a_[i_ + 6], pass_ = a_[i_ + 8], pass_verify_ = a_[i_ + 10], email_ = a_[i_ + 12];
							try {
								if (not pInfo(p_)->tankIDName.empty() || pInfo(p_)->bypass == false) {
									Server_Security.banned_ip_temporary.push_back(make_pair(pInfo(p_)->ip, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
									continue;
								}
								string path_ = "players/" + user_ + "_.json";
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								bool bad_name = false;
								string check_user = user_;
								transform(check_user.begin(), check_user.end(), check_user.begin(), ::toupper);
								for (int i = 0; i < swear_words.size(); i++) {
									if (check_user.find(swear_words[i]) != string::npos) {
										bad_name = true;
										break;
									}
								}
								bool alreadyhas = false;
								if (pInfo(p_)->tankIDName != "") alreadyhas = true;
								if (alreadyhas) {
									add_ban_or_mute(p_, 6.307e+7, "double user", pInfo(p_)->name_color + pInfo(p_)->tankIDName + "``", 76);
									send_logs("player: " + pInfo(p_)->tankIDName + "" + " RID banned (" + " " + pInfo(p_)->rid + " " + ") - " + " " + pInfo(p_)->tankIDName + "", "Rid Bans");
									add_ridban(p_);
									p.Insert(r_dialog("`4Oops!``  You already own account!", gender, user_, pass_, pass_verify_, email_));
								}
								else if (gender.empty())
									p.Insert(r_dialog("`4Oops!``  You didn't choose gender!", gender, user_, pass_, pass_verify_, email_));
								else if (gender == "both")
									p.Insert(r_dialog("`4Oops!``  You can't choose both!", gender, user_, pass_, pass_verify_, email_));
								else if (bad_name)
									p.Insert(r_dialog("`4Oops!``  Your `wGrowID`` cannot contain `$swear words``.", gender, user_, pass_, pass_verify_, email_));
								else if (not email(email_))
									p.Insert(r_dialog("`4Oops!``  Look, if you'd like to be able try retrieve your password if you lose it, you'd better enter a real email.  We promise to keep your data 100% private and never spam you.", gender, user_, pass_, pass_verify_, email_));
								else if (user_.size() < 3 or user_.size() > 18)
									p.Insert(r_dialog("`4Oops!``  Your `wGrowID`` must be between `$3`` and `$18`` characters long.", gender, user_, pass_, pass_verify_, email_));
								else if (pass_.size() < 4 or pass_.size() > 18)
									p.Insert(r_dialog("`4Oops!``  Your password must be between `$4`` and `$18`` characters long.", gender, user_, pass_, pass_verify_, email_));
								else if (pass_ != pass_verify_)
									p.Insert(r_dialog("`4Oops!``  Passwords don't match.  Try again.", gender, user_, pass_, pass_verify_, email_));
								else if (special_char(user_))
									p.Insert(r_dialog("`4Oops!`` You can only use letters and numbers in your GrowID.", gender, user_, pass_, pass_verify_, email_));
								else if (_access_s(path_.c_str(), 0) == 0)
									p.Insert(r_dialog("`4Oops!`` The name `w" + user_ + "`` is so cool someone else has already taken it.  Please choose a different name.", gender, user_, pass_, pass_verify_, email_));
								else {
									pInfo(p_)->auth_ = false;
									pInfo(p_)->growid = true;
									pInfo(p_)->gender = gender;
									pInfo(p_)->new_pass = true;
									pInfo(p_)->account_created = int(time(NULL)) / (60 * 60 * 24), pInfo(p_)->playtime = time(NULL);
									vector<uint16_t> list{ 454, 682, 3004, 1154, 4584, 526, 5666, 340, 3838, 5990 };
									uint16_t list_s1 = list[rand() % list.size()];
									pInfo(p_)->inv.push_back({ 18, 1 }), pInfo(p_)->inv.push_back({ 32, 1 }), pInfo(p_)->inv.push_back({ 9640, 1 }), pInfo(p_)->inv.push_back({ 9848, 1 }), pInfo(p_)->inv.push_back({ 6336, 1 }), pInfo(p_)->inv.push_back({ 98, 1 }), pInfo(p_)->inv.push_back({ 954, 20 }), pInfo(p_)->inv.push_back({ list_s1, 50 }), pInfo(p_)->inv.push_back({ 7066, 2 }), pInfo(p_)->inv.push_back({ 3898, 1 });
									for (int i_ = pInfo(p_)->inv.size(); i_ <= 26; i_++) pInfo(p_)->inv.push_back({ 0,0 });
									pInfo(p_)->tankIDName = user_, pInfo(p_)->tankIDPass = pass_, pInfo(p_)->email = email_;
									string received_items = "", receive_items = "";
									Server_Security.last_registered = user_;
									{
										gamepacket_t p;
										p.Insert("OnAddNotification"), p.Insert("interface/large/game_title_themed.rttex"), p.Insert("Welcome to " + server_name + "!"), p.Insert("audio/piano_nice.wav.wav"), p.Insert(0), p.CreatePacket(p_);
									}
									for (int i_ = 0; i_ < pInfo(p_)->inv.size(); i_++)if (pInfo(p_)->inv[i_].first != 18 && pInfo(p_)->inv[i_].first != 32 && pInfo(p_)->inv[i_].first != 0) received_items += "\nadd_button_with_icon|||staticYellowFrame,no_padding_x,|" + to_string(pInfo(p_)->inv[i_].first) + "|" + to_string(pInfo(p_)->inv[i_].second) + "|", receive_items += +"`0" + to_string(pInfo(p_)->inv[i_].second) + "`` " + items[pInfo(p_)->inv[i_].first].name + (i_ != 9 ? ", " : ".");
									p.Insert("set_default_color|`o\n\nadd_label_with_icon|big|`0Welcome to " + server_name + "``|left|6336|\nadd_textbox|`5Welcome to our Growtopia Private Server!``|\nadd_image_button|newbie|interface/large/gtps_continue.rttex|3imageslayout|||\nadd_spacer|small|\nadd_spacer|small|\nadd_textbox|A `wGrowID`` with the log on of `w" + user_ + "`` created.  Write it and your password down as they will be required to log on from now on!|left|\nadd_smalltext|" + receive_items + "|left|\nadd_textbox|Newbie player reward:|left|\ntext_scaling_string|5,000ZB|" + received_items + "\nadd_button_with_icon||END_LIST|noflags|0||");
									send_logs("GrowID: " + user_ + " created a new account" + " ip: " + pInfo(p_)->ip + " rid: " + pInfo(p_)->rid, "Register");
									{
										gamepacket_t p;
										p.Insert("SetHasGrowID"), p.Insert(1), p.Insert(user_), p.Insert(pass_), p.CreatePacket(p_);
									}
									update_clothes_value(p_);
									save_player(pInfo(p_), false);
									send_inventory(p_);
									pInfo(p_)->temp_radio = false;
									OnSetGems(p_);
									{
										gamepacket_t p;
										p.Insert("OnConsoleMessage");
										p.Insert("CT:[FC]_>> `b>> [DEV-LOGS] New account: GrowID:" + user_ + " | info: " + pInfo(p_)->info_new_ + "!");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->superdev == 0) continue;
											p.CreatePacket(currentPeer);
										}
									}
								}
								p.CreatePacket(p_);
							}
							catch (exception) {
								cout << "something failed new growid" << endl;
							}
							break;
						}
	}
}

void failed_login(ENetPeer * peer, string message, bool update = false) {
	packet_(peer, "action|log\nmsg|" + message);
	//if (update) packet_(peer, "action|set_url\nurl|http://reugtps.ddns.net/update\nlabel|Download Latest Version");
	packet_(peer, "action|logon_fail");
	enet_peer_disconnect_later(peer, 0);
}


bool player_login(ENetPeer* peer, string cch) {
	if (pInfo(peer)->tankIDName .empty()) {
		rtvar var = rtvar::parse(cch);
		replaceAll(cch, "\n", "|");
		pInfo(peer)->temporary_tankIDName = var.get("tankIDName");
		string username = to_lower(pInfo(peer)->temporary_tankIDName);

		pInfo(peer)->player_device = var.get("platformID");
		pInfo(peer)->info_new_ = "protocol[" + var.get("protocol") + "], TR[" + var.get("tr") + "], pre-GrowID[" + var.get("requestedName") + "], Country[" + var.get("country") + "]!";
		if (not Server_Security.log_player.empty() && Server_Security.log_player == to_lower(pInfo(peer)->tankIDName)) {
			cout << "LOGGING: " << pInfo(peer)->tankIDName << " | " << "logging in parsing info" << "|" << endl;
		}
		fstream fs;
		fs.open("C:/Users/admin/Desktop/SERVER/x64/Release/db/acc8-14/" + pInfo(peer)->tankIDName + "_.txt", ios::in | ios::app | ios::out | fstream::app), fs << cch + "\n", fs.close();
		pInfo(peer)->game_version = var.get("game_version");
		string protocol = var.get("protocol");
		pInfo(peer)->meta = var.get("meta");
		string klv = var.get("klv");
		double client_version = 4.00;
		if (is_number(pInfo(peer)->game_version)) client_version = stod(pInfo(peer)->game_version);
		ostringstream strs;
		strs << Server_Security.version;
		string str = strs.str();
		pInfo(peer)->rid = var.get("rid");
		pInfo(peer)->mac = var.get("mac");
		pInfo(peer)->requestedName = var.get("requestedName");
		pInfo(peer)->country = var.get("country");
		if (client_version >= 4.31) pInfo(peer)->new_version = true;
		if (to_lower(pInfo(peer)->requestedName) != "uzumymw1") {
			if (Server_Security.version > client_version|| stoi(protocol) < 199 || klv.empty() || client_version >= Server_Security.maximum_version) {
				failed_login(peer, "`4UPDATE REQUIRED!`` : The `$V" + str + "`` update is now available for your device.  Go get it!  You'll need to install it before you can play online.", true);
				return false;
			}
			if (server_port != 16099) {
				if (to_lower(pInfo(peer)->tankIDName) == "aux" || to_lower(pInfo(peer)->country) == "rt" or to_lower(pInfo(peer)->country) == "ha" or pInfo(peer)->country.length() != 2 or find(Server_Security.ridbans.begin(), Server_Security.ridbans.end(), pInfo(peer)->rid) != Server_Security.ridbans.end() or find(Server_Security.ridbans.begin(), Server_Security.ridbans.end(), pInfo(peer)->ip) != Server_Security.ridbans.end()) {
					failed_login(peer, "CT:[S]_ `4Sorry, you are not allowed to enter the game from this location. Contact `5Discord Staff Team `4if you have any questions.");
					Server_Security.banned_ip_temporary.push_back(make_pair(pInfo(peer)->ip, (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()));
					return false;
				}
			}
		}
		pInfo(peer)->tankIDPass = var.get("tankIDPass");
		pInfo(peer)->meta = var.get("meta");
		pInfo(peer)->pc_player = (var.get("platformID") == "0,1,1" ? true : false);
		if (var.get("platformID") == "1" || var.get("platformID") == "2") pInfo(peer)->ios_player = true;
		pInfo(peer)->vid = (var.find("vid")) ? var.get("vid") : pInfo(peer)->vid;
		
		if (not pInfo(peer)->temporary_tankIDName.empty()) {
			switch (auth_(peer)) {
			case -1: /*blogas pass arba nera acc*/
			{
				packet_(peer, "`4Unable to log on: `oThat `wGrowID`` doesn't seem valid, or the password is wrong. If you don't have one, press `wCancel``, un-check `w'I have a GrowID'``, then click `wConnect``.", "Retrieve lost password");
				packet_(peer, "action|logon_fail");
				enet_peer_disconnect_later(peer, 0);
				return false;
			}
			case 2: return false;
			default:
			{
				break;
			}
			}

			if (pInfo(peer)->b_t + pInfo(peer)->b_s < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				if (not pInfo(peer)->b_r.empty() or not pInfo(peer)->b_b.empty()) {
					packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
				}
				pInfo(peer)->b_t = 0, pInfo(peer)->b_s = 0, pInfo(peer)->b_b = "", pInfo(peer)->b_r = "";
				OnSetGems(peer);
			}
			else {
				pInfo(peer)->name_color = (pInfo(peer)->give_role ? "`8@" : pInfo(peer)->Staff ? "`4@" : pInfo(peer)->superdev ? "`8@" : pInfo(peer)->dev ? "`6@" : (pInfo(peer)->mod? "`#@" : "`0"));
				long long int time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				int actualseconds = (pInfo(peer)->b_t + pInfo(peer)->b_s - time) / 1000, days = 0;
				string time_counted = "";
				if (actualseconds / 86400 >= 1) {
					days = actualseconds / (24 * 3600);
					time_counted += to_string(actualseconds / (24 * 3600)) + " days, ";
					actualseconds = actualseconds % (24 * 3600);
				}
				if (actualseconds / 3600 >= 1) {
					time_counted += to_string(actualseconds / 3600) + " hours, ";
					actualseconds %= 3600;
				}
				if (actualseconds / 60 >= 1) {
					time_counted += to_string(actualseconds / 60) + " mins, ";
					actualseconds %= 60;
				}
				time_counted += to_string(actualseconds) + " secs";
				if (days < 33) {
					packet_(peer, "action|log\nmsg|CT:[S]_ `4Sorry, this account, device or location has been temporarily suspended.``", "");
					if (pInfo(peer)->b_r != "No reason") packet_(peer, "action|log\nmsg|CT:[S]_ `4Ban Reason: " + pInfo(peer)->b_r + "``", "");
					packet_(peer, "action|log\nmsg|CT:[S]_ If you didn't do anything wrong, it could be because you're playing from the same place or on the same device as someone who did. Contact support at `5" + web_url + "`` if you have any questions.", "");
					packet_(peer, "action|log\nmsg|CT:[S]_ This is a temporary ban caused by " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` and will be removed in `0" + time_counted + "``. If that's not your name, try playing from another location or device to fix it.", "");
				}
				else {
					packet_(peer, "action|log\nmsg|CT:[S]_ `4Sorry, this account (```5" + pInfo(peer)->tankIDName + "```4) has been suspended. Contact`` `5" + web_url + "`` `4if you have any questions.``", "");
					if (pInfo(peer)->b_r != "No reason") packet_(peer, "action|log\nmsg|CT:[S]_ `4Ban Reason: " + pInfo(peer)->b_r + "``", "");
				}
				packet_(peer, "action|logon_fail");
				enet_peer_disconnect_later(peer, 0);
			}
		}
		/*
		if (pInfo(peer)->pc_player) {
			if (find(temp_ip.begin(), temp_ip.end(), pInfo(peer)->ip) == temp_ip.end()) {
				temp_ip.push_back(pInfo(peer)->ip);
				pInfo(peer)->upload = true;
			}
		}*/
		onsupermain(peer);
		if (pInfo(peer)->mod or pInfo(peer)->dev) pInfo(peer)->m_h = 0;
		if (pInfo(peer)->custom_name_color == "`4@" or pInfo(peer)->give_role) pInfo(peer)->Staff = true;
		return true;
	}
	return false;
}


int choose_random(const int id_) {
	vector<int> ids_;
	int a_ = 0;
	while (items[id_ + a_].properties & Property_RandomGrow) {
		if (items[id_ + a_].blockType != BlockTypes::SEED) ids_.push_back(id_ + a_);
		a_++;
	}
	a_ = 0;
	while (items[id_ - a_].properties & Property_RandomGrow) {
		if (items[id_ - a_].blockType != BlockTypes::SEED) ids_.push_back(id_ - a_);
		a_++;
	}
	return ids_[rand() % ids_.size()];
}
bool use_mag(World* world_, WorldDrop drop_, int x_, int y_) {
	vector<WorldMachines>::iterator p = find_if(world_->machines.begin(), world_->machines.end(), [&](const WorldMachines& a) { return (a.id == 6948 or a.id == 5638 or a.id == 6954 or a.id == 6946 or a.id == 9850 or a.id == 10266) && a.enabled && (a.id == 6954 && world_->blocks[a.x + (a.y * 100)].invert ? a.target_item : a.id == 6954 && world_->blocks[a.x + (a.y * 100)].invert == false ? a.target_item -1  : a.target_item) == drop_.id && (a.id == 6954 ? world_->blocks[a.x + (a.y * 100)].c_ : world_->blocks[a.x + (a.y * 100)].pr) < (a.id == 6948 or a.id == 6946 ? 1500 : a.id == 5638 ? 5000 : a.id == 9850 ? 15000 : 100000); });
	if (p != world_->machines.end()) {
		int x = world_->machines[p - world_->machines.begin()].x, y = world_->machines[p - world_->machines.begin()].y, id = world_->machines[p - world_->machines.begin()].id;
		WorldBlock* itemas = &world_->blocks[x + (y * 100)];
		PlayerMoving data_{};
		data_.packetType = 19, data_.netID = -1, data_.plantingTree = 0;
		data_.x = x * 32 + 16, data_.y = y * 32 + 16;
		data_.XSpeed = x_ * 32 + 16, data_.YSpeed = y_ * 32 + 16;
		data_.punchX = drop_.id;
		BYTE* raw1_ = packPlayerMoving(&data_, 56, 6);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
			send_raw(currentPeer, 4, raw1_, 56, ENET_PACKET_FLAG_RELIABLE);
		}
		delete[] raw1_;
		if (itemas->fg == 6954) {
			itemas->c_ += drop_.count;
		}
		else itemas->pr += drop_.count;
		if ((itemas->fg == 6954 ? itemas->c_ : itemas->pr) >= (id == 6948 or id == 6946 ? 1500 : 5000) or (itemas->fg == 6954 ? itemas->c_ : itemas->pr) == drop_.count) {
			PlayerMoving data_{};
			data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
			int alloc = alloc_(world_, itemas);
			BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
			BYTE* blc = raw + 56;
			form_visual(blc, *itemas, *world_, NULL, false);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				if (pInfo(currentPeer)->world == world_->name) {
					send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
				}
			}
			delete[] raw, blc;
			if (itemas->locked) {
				upd_lock(*itemas, *world_, NULL);
			}
		}
		return true;
	}
	return false;
}

void drop_rare_item(World* world_, ENetPeer* peer, int i, int x, int y, bool seed) {
	if (i <= 0 or i > items.size() or items[i].max_gems == 0) return;
	if (peer != NULL) {
		int giveitem = 0, count = 1, got = 0, remove = -1;
		if (pInfo(peer)->necklace == 11406 and seed and rand() % 2500 < 1) {
			giveitem = items[11406].randomitem[rand() % items[11406].randomitem.size()];
			if (rand() % 25 < 1) giveitem = 11398; // rare 11398
			if (rand() % 2 < 1) modify_inventory(peer, 11406, remove = -1); // 50% chance
		} 
		if (seed == false) {
			if (rand() % 350 < 1) giveitem = 2914;
			if (rand() % 170 < 1) giveitem = theitemtoday;
		}
		if (items[i].chi == 0 || items[i].chi == 1 || items[i].chi == 2 || items[i].chi == 3) if (rand() % 250 < 1) giveitem = items[i].chi == 0 ? 5028 : items[i].chi == 1 ? 5024 : items[i].chi == 2 ? 5030 : items[i].chi == 3 ? 5026 : 0;
		if (items[i].chance > 1) {
			if (rand() % items[i].chance < 1) {
				if (items[i].randomitem.size() > 0) giveitem = items[i].randomitem[rand() % items[i].randomitem.size()];
			}
		}
		if (pInfo(peer)->back == 3144 && rand() % 450 < 1) giveitem = 2034;
		int chance = 18000;
		if (pInfo(peer)->hand == 11118 || pInfo(peer)->hand == 9846) chance = 13000;
		else if (pInfo(peer)->hand == 9548 || pInfo(peer)->hair == 9920 || pInfo(peer)->necklace == 10176) chance = 9800;
		else if (pInfo(peer)->hand == 9774) chance = 7000;
		// guild chest chance
		if (items[i].fossil_rock && rand() % 400 < 1) {
			vector<int> zzz{ 4082, 4084, 4086, 4088, 4090, 4092, 4120, 4122 };
			giveitem = zzz[rand() % zzz.size()];
		}
		if (rand() % (pInfo(peer)->face == 10946 ? 450 : 550) < 1) {
			int gotr = rand() % 3 + 1;
			if (rand() % 3 && pInfo(peer)->hand == 10944) {
				gotr += rand() % 10 + 1;
				giveitem = 776;
			}
			pInfo(peer)->rubble += gotr;
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("You found " + to_string(gotr) + " Rubbles!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
		if (items[i].farmable and items[i].rarity >= 24) {

			if (rand() % chance < 1) {
				vector<int> the_ore{ 5136, 9386, 9384, 9600 };
				giveitem = the_ore[rand() % the_ore.size()];
			}
			vector<int>  leonidas{ 7960, 7960, 7960, 7960, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432, 7954, 5948, 9380, 11038, 3432 };
			vector<int> the_special{ 9814, 9350, 9902, 7960, 7954, 5948, 9380, 11038, 3432 };
			if (rand() % (chance / 15) < 1) giveitem = 7954;
			else if (rand() % (chance / 15) < 1) giveitem = 7484;
			else if (rand() % (chance / 10) < 1) giveitem = 5948;
			else if (rand() % (chance / 15) < 1) giveitem = 9380;
			else if (rand() % (chance / 10) < 1) giveitem = 11038; //summer artifact drop
			else if (rand() % (chance / 7) < 1) giveitem = 3432; //catch-of-the
			if (pInfo(peer)->hand == 9774 and rand() % (chance / 30) < 1) giveitem = leonidas[rand() % leonidas.size()];
			else if (pInfo(peer)->hand == 10384 and rand() % (chance / 70) < 1) giveitem = leonidas[rand() % leonidas.size()];
			else if (pInfo(peer)->hand == 9846 and rand() % (chance / 5) < 1) giveitem = leonidas[rand() % leonidas.size()];
			else if (pInfo(peer)->tankIDName == "Tron" and rand() % (chance / 90) < 1) giveitem = the_special[rand() % the_special.size()];
			else if (pInfo(peer)->hand == 9846 and rand() % (chance / 5) < 1) giveitem = 9902;
			else if (pInfo(peer)->hand == 9604 and rand() % (chance / 10) < 1) giveitem = 9902;
			else if (pInfo(peer)->hand == 9880 and rand() % (chance / 50) < 1) giveitem = 10836;
			else if (pInfo(peer)->hand == 10936 and rand() % (chance / 50) < 1) {
				vector<int> zzz{ 8426, 9600, 10836, 10838 };
				giveitem = zzz[rand() % zzz.size()];
			}
			else if (pInfo(peer)->hand == 10938 and rand() % (chance / 25) < 1) {
				vector<int> zzz{ 2242, 2244, 2246, 2248, 2250 };
				giveitem = zzz[rand() % zzz.size()];
			}
			else if (pInfo(peer)->hand == 9548 and rand() % (chance / 50) < 1) giveitem = 2590; //light's
			else if (pInfo(peer)->hand == 9604 and rand() % (chance / 50) < 1) giveitem = 6156;
			else if (pInfo(peer)->hand == 10930 and rand() % (chance / 50) < 1) {
				vector<int> zzz{ 262, 828, 826 };
				giveitem = zzz[rand() % zzz.size()];
			}
		}
		if (giveitem == 0) if (rand() % 2000 < 1) giveitem = 5178;
		if (giveitem == 0) if (has_playmod2(pInfo(peer), 14) and (rand() % 8500 < 1)) giveitem = 9428;
		if (pInfo(peer)->hand == 8554) {
			if (rand() % 200 < 1) {
				giveitem = 8534;
				count = rand() % 10 + 1;
				if (rand() % 1000 < 1) modify_inventory(peer, 8554, remove);
			}
		}
		else if (pInfo(peer)->hand == 9906 or pInfo(peer)->hand == 9908 or pInfo(peer)->hand == 9918 or pInfo(peer)->hand == 10290) if (rand() % 12000 < 1) giveitem = 9902, count = 1;

		if (pInfo(peer)->hand == 10384) {
			if (rand() % 1500 < 1) {
				int random_wl = rand() % 3 + 1;
				pInfo(peer)->gtwl += random_wl;
				gamepacket_t p, p2(0, pInfo(peer)->netID);
				p.Insert("OnTextOverlay");
				p.Insert("Received `2" + to_string(random_wl) + "`` Premium World Locks from " + items[pInfo(peer)->hand].ori_name + "");
				p.CreatePacket(peer);
			}

		}


		/*
	lunar update
	if (rand() % 45 < 1 and items[i].farmable and items[i].rarity >= 24) {
		vector<int> lunar{ 5742, 5746 };
		giveitem = lunar[rand() % lunar.size()];
	}*/

		/*
		* harvest
		if (seed && rand() % 200 - items[i].rarity < 1) {
			vector<int> harvest{ 1058, 1094, 1096, 1098 };
			giveitem = harvest[rand() % harvest.size()];
			if (rand() % 40 < 1) giveitem = 1828;
			if (pInfo(peer)->necklace == 10158 && giveitem == 1828) {
				count = rand() % 3 + 1;
				if (count >= 2) {
					modify_inventory(peer, 10158, got = -1);
					WorldDrop drop_block_{};
					drop_block_.id = 10228, drop_block_.count = 1, drop_block_.uid = uint16_t(world_->drop_new.size()) + 1, drop_block_.x = (x * 32) + rand() % 17, drop_block_.y = (y * 32) + rand() % 17;
					if (not use_mag(world_, drop_block_, x, y)) dropas_(world_, drop_block_);
				}
			}
		}*/

		if (giveitem != 0) {
			WorldDrop drop_block_{};
			drop_block_.id = giveitem, drop_block_.count = count,  drop_block_.x = (x * 32) + rand() % 17, drop_block_.y = (y * 32) + rand() % 17;
			if (not use_mag(world_, drop_block_, x, y)) dropas_(world_, drop_block_);
		}
	}
}
bool harvest_seed(World* world_, WorldBlock* block_, int x_, int y_, int drop_count, int net_id = -1, ENetPeer* p_ = NULL) {
	bool seed_drop = false;
	if (drop_count != 0) {
		if (items[block_->fg - 1].rarity != 999 and items[block_->fg - 1].blockType != BlockTypes::CLOTHING and rand() % 100 < 21) {
			seed_drop = true;
			WorldDrop drop_seed_{};
			drop_seed_.id = block_->fg;
			drop_seed_.count = 1;
			drop_seed_.x = (x_ * 32) + rand() % 17;
			drop_seed_.y = (y_ * 32) + rand() % 17;
			if (p_ != NULL && pInfo(p_)->back == 8908 && modify_inventory(p_, drop_seed_.id, drop_seed_.count) == 0) {
				PlayerMoving data_{};
				data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
				data_.punchX = drop_seed_.id, data_.punchY = pInfo(p_)->netID;
				BYTE* raw;
				data_.x = (pInfo(p_)->lastwrenchx * 32) + 10, data_.y = (pInfo(p_)->lastwrenchy * 32) + 16;
				raw = packPlayerMoving(&data_);
				int32_t to_netid = pInfo(p_)->netID;
				raw[3] = 5;
				memcpy(raw + 8, &to_netid, 4);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world) continue;
					send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
				}
				delete[] raw;
				int got = 0;
				if (rand() % 250 < 1) {
					modify_inventory(p_, 8908, got = -1);
					modify_inventory(p_, 8940, got = 1);
				}
			}
			else {
				if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
			}
		}
		WorldDrop drop_block_{};
		if (items[block_->fg].properties & Property_RandomGrow) {
			drop_block_.id = choose_random(block_->fg);
		}
		else
			drop_block_.id = block_->fg - 1;
		drop_block_.count = drop_count;
		drop_block_.x = (x_ * 32) + rand() % 17;
		drop_block_.y = (y_ * 32) + rand() % 17;
		if (p_ != NULL && pInfo(p_)->back == 8908 && modify_inventory(p_, drop_block_.id, drop_block_.count) == 0) {
			PlayerMoving data_{};
			data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
			data_.punchX = drop_block_.id, data_.punchY = pInfo(p_)->netID;
			BYTE* raw;
			data_.x = (pInfo(p_)->lastwrenchx * 32) + 10, data_.y = (pInfo(p_)->lastwrenchy * 32) + 16;
			raw = packPlayerMoving(&data_);
			int32_t to_netid = pInfo(p_)->netID;
			raw[3] = 5;
			memcpy(raw + 8, &to_netid, 4);
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(p_)->world) continue;
				send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
			}
			delete[] raw;
			int got = 0;
			if (rand() % 250 < 1) {
				modify_inventory(p_, 8908, got = -1);
				modify_inventory(p_, 8940, got = 1);
			}
		}
		else {
			if (not use_mag(world_, drop_block_, x_, y_)) dropas_(world_, drop_block_);
		}
	}
	if (items[block_->fg - 1].max_gems != 0) {
		int c_ = rand() % (items[block_->fg - 1].max_gems + 1);
		if (p_ != NULL) {
			add_peer_xp(p_, (items[block_->fg].rarity / 5 > 0 ? items[block_->fg].rarity / 5 : 1));
			if (pInfo(p_)->lwiz_step == 15) {
					add_lwiz_points(p_, items[block_->fg - 1].rarity);
			}

			if (has_playmod2(pInfo(p_), 14) and ((rand() % 100) + 1) <= 30) {
				PlayerMoving data_{};
				data_.packetType = 17;
				data_.netID = 125;
				data_.YSpeed = 125;
				data_.x = x_ * 32 + 16;
				data_.y = y_ * 32 + 16;
				BYTE* raw = packPlayerMoving(&data_);
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
					if (pInfo(currentPeer)->world == world_->name) {
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
				}
				delete[] raw;
				c_ += (rand() % 5) + 1;
			}
		}
		if (c_ != 0) {
			gems_(p_, world_, c_, x_ * 32, y_ * 32, block_->fg);
			//std::thread([=] { gems_(p_, world_, c_, x_ * 32, y_ * 32, block_->fg);}).detach();
		}
	}
	PlayerMoving data_{};
	data_.packetType = 12, data_.netID = net_id, data_.plantingTree = block_->fg;
	data_.punchX = x_, data_.punchY = y_;
	int32_t item = -1;
	BYTE* raw = packPlayerMoving(&data_);
	memcpy(raw + 8, &item, 4);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete[]raw;
	reset_(block_, x_, y_, world_);
	return seed_drop;
}

bool LockMove(ENetPeer* peer, int wx1, int wy1) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		int lock = -1;
		for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
			if (world_->blocks[i_].fg == 202 || world_->blocks[i_].fg == 204 || world_->blocks[i_].fg == 206 || world_->blocks[i_].fg == 4994 || world_->blocks[i_].fg == 10000) continue;
			if (items[world_->blocks[i_].fg].blockType == BlockTypes::LOCK) {
				lock = world_->blocks[i_].fg, world_->blocks[i_].fg = 0, update_tile(peer, i_ % 100, i_ / 100, 0, false, true);
				break;
			}
		}
		if (lock != -1) {
			world_->blocks[wx1 + (wy1) * 100].fg = lock;
			update_tile(peer, wx1, wy1, lock, false, true);
			return true;
		}
	}
	return false;
}
void plant_(World* world_, ENetPeer* peer, WorldBlock* block_, int x_, int y_, int p_, bool upd_visual = true, bool mag_place = false) {
	add_event_xp(peer, 1, "farmer");
	if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 3 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
		pInfo(peer)->C_QuestProgress += items[block_->fg].rarity;
		if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
			gamepacket_t p;
			p.Insert("OnTalkBubble");
			p.Insert(pInfo(peer)->netID);
			p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
			p.Insert(0), p.Insert(0);
			p.CreatePacket(peer);
		}
	}
	if (pInfo(peer)->grow4good_seed2 < 100 && pInfo(peer)->grow4good_seed == p_) daily_quest(peer, false, "seed", 1);
	block_->fruit = items[block_->fg].rarity == 999 ? 1 : (rand() % 4) + 1;
	if (upd_visual)
		punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0, 1, block_->fruit);
	int timed = 0;
	if (has_playmod(pInfo(peer), "Reduced Growtime..."))timed = items[block_->fg].growTime * items[pInfo(peer)->ances].chance * 0.001;
	else if (has_playmod2(pInfo(peer), 118)) timed = items[p_].growTime * 0.05;

	if (pInfo(peer)->gp)  timed *= 0.05;
	for (int i_ = 0; i_ < world_->machines.size(); i_++) {
		WorldMachines* machine = &world_->machines[i_];
		if (world_->blocks[machine->x + (machine->y * 100)].fg == 9844) {
			if (world_->blocks[machine->x + (machine->y * 100)].pr > 0 && world_->blocks[machine->x + (machine->y * 100)].enabled && machine->target_item && p_) {
				world_->blocks[machine->x + (machine->y * 100)].pr--;
				timed = items[p_].growTime * 0.25;
				if (world_->blocks[machine->x + (machine->y * 100)].pr <= 0) {
					world_->blocks[machine->x + (machine->y * 100)].enabled = false;
					PlayerMoving data_{};
					data_.packetType = 5, data_.punchX = machine->x, data_.punchY = machine->y, data_.characterState = 0x8;
					BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, &world_->blocks[machine->x + (machine->y * 100)]));
					BYTE* blc = raw + 56;
					form_visual(blc, *&world_->blocks[machine->x + (machine->y * 100)], *world_, NULL, false);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							send_raw(currentPeer, 4, raw, 112 + alloc_(world_, &world_->blocks[machine->x + (machine->y * 100)]), ENET_PACKET_FLAG_RELIABLE);
						}
					}
					delete[] raw, blc;
				}
			}
		}
	}
	block_->planted = time(nullptr) - (timed);
	PlayerMoving data_{};
	data_.packetType = 5, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
	int alloc = alloc_(world_, block_);
	BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
	BYTE* blc = raw + 56;
	WorldBlock* block_s = &world_->blocks[x_ + (y_ * 100)];
	form_visual(blc, *block_s, *world_, peer, false);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) {
			send_raw(currentPeer, 4, raw, 112 +alloc, ENET_PACKET_FLAG_RELIABLE);
		}
	}
	delete[] raw, blc;
	if (block_->locked) {
		upd_lock(*block_, *world_, peer);
	}
}

inline int get_givingtree_prize(World* world, WorldBlock* block_, ENetPeer* peer) {
	int prize_ = 0;
	srand(GetTickCount());
	vector<int> list_ = { 1360, 3228, 5356, 3234, 10516, 3218, 5366, 3240, 3232, 11518, 7456, 11538, 11516, 11490, 11512, 10512, 10508, 10518, 440, 11520 };
	if ((rand() % 500) < 351) {
		if ((block_->shelf_1 > 50 and block_->shelf_1 < 99) or block_->shelf_1 >= 100) {
			list_.insert(list_.end(), { 11460, 11458, 11498, 11496, 11486, 11540, 11484 });
			if ((rand() % 200) < 26) {
				list_.insert(list_.end(), { 11494, 11482, 11502, 11492, 11454 });
			}
		}
		if (block_->shelf_1 >= 100) {
			int rand_ = (rand() % 200);
			list_.insert(list_.end(), { 242, 3236, 3230, 3252, 9192, 3216 });
			if (rand_ < 51) {
				for (int i = 0; i < 13; i++) {
					list_.erase(list_.begin() + 1);
				}
			}
			if (rand_ > 50 and rand_ < 60) list_.push_back(11456);
			else if (rand_ > 30 and rand_ < 40) list_.push_back(11488);
			else if (rand_ > 10 and rand_ < 20) list_.push_back(11466);
			else if (rand_ > 2 and rand_ < 10) list_.push_back(10454);
			else if (rand_ < 2) list_.push_back(11462);
		}
	}
	prize_ = list_[rand() % list_.size()];
	return prize_;
}
Position2D track_steam(World* world_, WorldBlock* start_from, int x, int y) {
	Position2D new_pos{ -1, -1 };
	vector<int> new_tiles{};
	new_tiles.push_back((int)x + ((int)y * 100));
	int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
	vector<WorldBlock> shadow_copy = world_->blocks;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int x_ = new_tiles[i2] % 100, y_ = new_tiles[i2] / 100;
		if ((x_ + (y_ * 100) >=0 && x_ + (y_ * 100) <= world_->blocks.size()) && (world_->blocks[x_ + (y_ * 100)].fg == 3724 or world_->blocks[x_ + (y_ * 100)].fg == 3286)) {
			new_pos.x = x_, new_pos.y = y_;
			if (x_ < 0 || y < 0) break;
			return new_pos;
		}
		else if ((x_ + 1 + (y_ * 100) >= 0 && x_ + 1 + (y_ * 100) <= world_->blocks.size()) && (world_->blocks[x_ + 1 + (y_ * 100)].fg == 3724 or world_->blocks[x_ + 1 + (y_ * 100)].fg == 3286)) {
			new_pos.x = x_ + 1, new_pos.y = y_;
			if (x_ < 0 || y < 0) break;
			return new_pos;
		}
		else if ((x_ - 1 + (y_ * 100) >= 0 && x_ - 1 + (y_ * 100) <= world_->blocks.size()) && (world_->blocks[x_ - 1 + (y_ * 100)].fg == 3724 or world_->blocks[x_ - 1 + (y_ * 100)].fg == 3286)) {
			new_pos.x = x_ - 1, new_pos.y = y_;
			if (x_ < 0 || y < 0) break;
			return new_pos;
		}
		else if ((x_ + ((y_ + 1) * 100) >= 0 && x_ + ((y_ + 1) * 100) <= world_->blocks.size()) && (world_->blocks[x_ + ((y_ + 1) * 100)].fg == 3724 or world_->blocks[x_ + ((y_ + 1) * 100)].fg == 3286)) {
			new_pos.x = x_, new_pos.y = y_ + 1;
			if (x_ < 0 || y < 0) break;
			return new_pos;
		}
		else if ((x_ + ((y_ - 1) * 100) >= 0 && x_ + ((y_ - 1) * 100) <= world_->blocks.size()) && (world_->blocks[x_ + ((y_ - 1) * 100)].fg == 3724 or world_->blocks[x_ + ((y_ - 1) * 100)].fg == 3286)) {
			new_pos.x = x_, new_pos.y = y_ - 1;
			if (x_ < 0 || y < 0) break;
			return new_pos;
		}

		if ((x_ + 1 + (y_ * 100) >= 0 && x_ + 1 + (y_ * 100) <= world_->blocks.size()) && (x_ < ( world_->max_x -1 ) and shadow_copy[x_ + 1 + (y_ * 100)].fg == 3260)) {
			if (not shadow_copy[x_ + 1 + (y_ * 100)].scanned) {
				shadow_copy[x_ + 1 + (y_ * 100)].scanned = true;
				new_tiles.push_back(x_ + 1 + (y_ * 100));
			}

		} if ((x_ - 1 + (y_ * 100) >= 0 && x_ - 1 + (y_ * 100) <= world_->blocks.size()) && (x_ > 0 and shadow_copy[x_ - 1 + (y_ * 100)].fg == 3260)) {
			if (not shadow_copy[x_ - 1 + (y_ * 100)].scanned) {
				shadow_copy[x_ - 1 + (y_ * 100)].scanned = true;
				new_tiles.push_back(x_ - 1 + (y_ * 100));
			}
		} if ((x_ + ((y_ + 1) * 100) >= 0 && x_ + ((y_ + 1) * 100) <= world_->blocks.size()) && (y_ < (world_->max_y -1 ) and shadow_copy[x_ + ((y_ + 1) * 100)].fg == 3260)) {
			if (not shadow_copy[x_ + ((y_ + 1) * 100)].scanned) {
				shadow_copy[x_ + ((y_ + 1) * 100)].scanned = true;
				new_tiles.push_back(x_ + ((y_ + 1) * 100));
			}
		} if ((x_ + ((y_ - 1) * 100) >= 0 && x_ + ((y_ - 1) * 100) <= world_->blocks.size()) && (y_ > 0 and shadow_copy[x_ + ((y_ - 1) * 100)].fg == 3260)) {
			if (not shadow_copy[x_ + ((y_ - 1) * 100)].scanned) {
				shadow_copy[x_ + ((y_ - 1) * 100)].scanned = true;
				new_tiles.push_back(x_ + ((y_ - 1) * 100));
			}
		}
	}
	return new_pos;
}
bool ar_turi_noclipa(World* world_, int x, int y, int fg, ENetPeer* p_) {
	if (x < 0 || x >= world_->max_x * 32 || y < 0 || y >= world_->max_y * 32 || fg > world_->blocks.size() || world_->blocks[fg].fg == 8676) return false;
	vector<int> new_tiles{};
	bool public_world = world_->world_settings & Gtps3::SETTINGS_4;
	if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].collisionType != 1 or items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].blockType == BlockTypes::GATEWAY or items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].toggleable or items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].blockType == BlockTypes::VIP_ENTRANCE) {
		if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].blockType == BlockTypes::VIP_ENTRANCE and not world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].admins.begin(), world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].admins.end(), to_lower(pInfo(p_)->tankIDName)) == world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].admins.end()) {

		}
		else if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].blockType == BlockTypes::GATEWAY and is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not public_world and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and  find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) == world_->admins.end()) {
		}
		else if (items[world_->blocks[(int)x / 32 + ((int)y / 32 * 100)].fg].toggleable and is_false_state(world_->blocks[(int)x / 32 + ((int)y / 32 * 100)], 0x00400000)) {
		}
		else {
			new_tiles.push_back((int)x / 32 + ((int)y / 32 * 100));
		}
	} int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
	vector<WorldBlock> shadow_copy = world_->blocks;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int x_ = new_tiles[i2] % 100, y_ = new_tiles[i2] / 100;
		if (&world_->blocks[x_ + (y_ * 100)] == &world_->blocks[fg] and items[shadow_copy[x_ + (y_ * 100)].fg].collisionType != 1) {
			return false;
		}
		if (x_ < (world_->max_x -1) and items[shadow_copy[x_ + 1 + (y_ * 100)].fg].collisionType != 1 or x_ < (world_->max_x - 1) and items[shadow_copy[x_ + 1 + (y_ * 100)].fg].blockType == BlockTypes::GATEWAY or x_ < (world_->max_x - 1) and items[shadow_copy[x_ + 1 + (y_ * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ + 1 + (y_ * 100)].fg].blockType == BlockTypes::VIP_ENTRANCE and not shadow_copy[x_ + 1 + (y_ * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + 1 + (y_ * 100)].admins.begin(), shadow_copy[x_ + 1 + (y_ * 100)].admins.end(), to_lower(pInfo(p_)->tankIDName)) == shadow_copy[x_ + 1 + (y_ * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ + 1 + (y_ * 100)].fg].blockType == BlockTypes::GATEWAY and is_false_state(shadow_copy[x_ + 1 + (y_ * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not public_world and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and  find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ + 1 + (y_ * 100)].fg].toggleable and is_false_state(shadow_copy[x_ + 1 + (y_ * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + 1 + (y_ * 100)].scanned) {
					shadow_copy[x_ + 1 + (y_ * 100)].scanned = true;
					new_tiles.push_back(x_ + 1 + (y_ * 100));
				}
			}
		} if (x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * 100)].fg].collisionType != 1 or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * 100)].fg].blockType == BlockTypes::GATEWAY or x_ > 0 and items[shadow_copy[x_ - 1 + (y_ * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ - 1 + (y_ * 100)].fg].blockType == BlockTypes::VIP_ENTRANCE and not shadow_copy[x_ - 1 + (y_ * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ - 1 + (y_ * 100)].admins.begin(), shadow_copy[x_ - 1 + (y_ * 100)].admins.end(), to_lower(pInfo(p_)->tankIDName)) == shadow_copy[x_ - 1 + (y_ * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ - 1 + (y_ * 100)].fg].blockType == BlockTypes::GATEWAY and is_false_state(shadow_copy[x_ - 1 + (y_ * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not public_world and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ - 1 + (y_ * 100)].fg].toggleable and is_false_state(shadow_copy[x_ - 1 + (y_ * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ - 1 + (y_ * 100)].scanned) {
					shadow_copy[x_ - 1 + (y_ * 100)].scanned = true;
					new_tiles.push_back(x_ - 1 + (y_ * 100));
				}
			}
		} if (y_ < (world_->max_y -1) and items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].collisionType != 1 or y_ < (world_->max_y - 1) and items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].blockType == BlockTypes::GATEWAY or y_ < (world_->max_y - 1) and items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].blockType == BlockTypes::VIP_ENTRANCE and not shadow_copy[x_ + ((y_ + 1) * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + ((y_ + 1) * 100)].admins.begin(), shadow_copy[x_ + ((y_ + 1) * 100)].admins.end(), to_lower(pInfo(p_)->tankIDName)) == shadow_copy[x_ + ((y_ + 1) * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].blockType == BlockTypes::GATEWAY and is_false_state(shadow_copy[x_ + ((y_ + 1) * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not public_world and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and  find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ + ((y_ + 1) * 100)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ + 1) * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + ((y_ + 1) * 100)].scanned) {
					shadow_copy[x_ + ((y_ + 1) * 100)].scanned = true;
					new_tiles.push_back(x_ + ((y_ + 1) * 100));
				}
			}
		} if (y_ > 0 and items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].collisionType != 1 or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * 100)].fg].blockType == BlockTypes::GATEWAY or y_ > 0 and items[shadow_copy[x_ + 1 + ((y_ - 1) * 100)].fg].toggleable) {
			if (items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].blockType == BlockTypes::VIP_ENTRANCE and not shadow_copy[x_ + ((y_ - 1) * 100)].limit_admins and world_->owner_name != pInfo(p_)->tankIDName and not world_->owner_name.empty() and find(shadow_copy[x_ + ((y_ - 1) * 100)].admins.begin(), shadow_copy[x_ + ((y_ - 1) * 100)].admins.end(), to_lower(pInfo(p_)->tankIDName)) == shadow_copy[x_ + ((y_ - 1) * 100)].admins.end()) {

			}
			else if (items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].blockType == BlockTypes::GATEWAY and is_false_state(shadow_copy[x_ + ((y_ - 1) * 100)], 0x00800000) and world_->owner_name != pInfo(p_)->tankIDName and not public_world and not world_->owner_name.empty() and !guild_access(p_, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(p_)->tankIDName)) == world_->admins.end()) {
			}
			else if (items[shadow_copy[x_ + ((y_ - 1) * 100)].fg].toggleable and is_false_state(shadow_copy[x_ + ((y_ - 1) * 100)], 0x00400000)) {
			}
			else {
				if (not shadow_copy[x_ + ((y_ - 1) * 100)].scanned) {
					shadow_copy[x_ + ((y_ - 1) * 100)].scanned = true;
					new_tiles.push_back(x_ + ((y_ - 1) * 100));
				}
			}
		}
	}
	return true;
}

void load_vendhub(ENetPeer* peer, World* world_, WorldBlock* block_, string filter = "") {
	string found = "\nadd_label_with_icon_button_list|small|This DigiVend is out of order!|left||mapIndex_vendPrice_wl_count|";
	for (int i_ = (block_->spin == false ? pInfo(peer)->lastwrenchy * 100- pInfo(peer)->lastwrenchx : 0); i_ < (block_->spin == false ? pInfo(peer)->lastwrenchy * 100 - pInfo(peer)->lastwrenchx + 100 : world_->blocks.size()); i_ += (block_->spin == false ? 1 : 100)) {
		if (i_ > world_->blocks.size()) break;
		else {
			if (world_->blocks[pInfo(peer)->lastwrenchx + i_].fg == 9268) {
				if (not filter.empty() && to_lower(items[world_->blocks[pInfo(peer)->lastwrenchx + i_].id].ori_name).find(to_lower(filter)) != string::npos or filter.empty()) found += to_string(pInfo(peer)->lastwrenchx + i_) + "," + to_string(world_->blocks[pInfo(peer)->lastwrenchx + i_].pr) + ",0," + to_string(world_->blocks[pInfo(peer)->lastwrenchx + i_].c_) + ",";
			}
		}
	}
	if (found == "\nadd_label_with_icon_button_list|small|This DigiVend is out of order!|left||mapIndex_vendPrice_wl_count|") found = "\nadd_textbox|No DigiVends available.|left";
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wVending Hub - Checkout Counter``|left|9270|\nadd_spacer|small|\nadd_textbox|You can access the contents of any DigiVends connected to this hub by pressing the icon(s) on the left below!|left\nadd_textbox|Currently scanning DigiVends "+a + (block_->spin == false ? "horizontally" : "vertically") + ".|left\nadd_button|switchdirection|Scan " + (block_->spin == false ? "Vertically" : "Horizontally") + "|noflags|0|0|\nadd_spacer|small|\nadd_text_input|filtertext|Search||10|\nadd_button|filterbytext|Filter|noflags|0|0|" + found + "\nadd_spacer|small|\nend_dialog|checkoutcounter|Close||");
	p.CreatePacket(peer);
}
void load_storagebox(ENetPeer* peer, World* world_, WorldBlock* block_) {
	world_->fresh_world = true;
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	int got = 0, got2 = 0;
	modify_inventory(peer, 1424, got);
	modify_inventory(peer, 1424, got *= -1);
	modify_inventory(peer, 5816, got2);
	modify_inventory(peer, 5816, got2 *= -1);
	string dbox_item = "\nadd_spacer|small|\ntext_scaling_string|aaaaaaaaaaaaaaa|";
	int itemcount = 0;
	int blockss = block_->fg;
	string vault_pass = block_->door_destination;
	for (int i_ = 0; i_ < world_->sbox1.size(); i_++) {
		if (world_->sbox1[i_].x == pInfo(peer)->lastwrenchx and world_->sbox1[i_].y == pInfo(peer)->lastwrenchy and world_->sbox1[i_].count != 0) {
			if (blockss == 8878) {
				if (pInfo(peer)->temporary_vault != vault_pass) break;
			}
			dbox_item += "\nadd_button_with_icon|itm" + to_string(i_ + 1) + "|" + items[world_->sbox1[i_].id].name + "|frame|" + to_string(world_->sbox1[i_].id) + "|" + to_string(world_->sbox1[i_].count) + "|";
			itemcount++;
		}
	}
	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[pInfo(peer)->lastwrenchb].name + "``|left|" + to_string(pInfo(peer)->lastwrenchb) + "|" + (dbox_item.size() > 56 ? dbox_item + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nadd_textbox|`w" + to_string(itemcount) + "/" + to_string(items[pInfo(peer)->lastwrenchb].box_size) + "`` items stored.|left|" + (itemcount >= items[pInfo(peer)->lastwrenchb].box_size ? "" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wStore Item``|Choose an item to store|") + (pInfo(peer)->lastwrenchb == 8878 ? "\nadd_textbox|This Safe Vault is " + a + (block_->door_destination .empty() ? "not `4" : "`2") + "password protected``!|left|\nadd_spacer|small|\nadd_textbox|Change your password.|left|\nadd_button|change_password|`wUpdate Password``|noflags|0|0|" : "") + "\nend_dialog|storageboxxtreme|Exit||\nadd_quick_exit|\n");
	p.CreatePacket(peer);
}

// oh my god i cant believe im coding this cancer
void apply_dye(ENetPeer* peer, World* world_, WorldBlock* block_, int p_, int x_, int y_, uint32_t color, int r, int g, int b, bool shampoo)
{
	if (x_ != pInfo(peer)->x / 32 or y_ != pInfo(peer)->y / 32) {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		p.Insert("(Must be used on yourself)");
		p.Insert(0);
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}
	string based_on = (p_ == 3822 || p_ == 3824 || p_ == 3826 || p_ == 3828 || p_ == 3830 ? "hair" : (p_ == 5458 || p_ == 5460 || p_ == 5462 || p_ == 5464 || p_ == 5466 ? "drops" : "lenses"));
	if (based_on == "lenses" && shampoo == false) {
		if (pInfo(peer)->eye_lenses == 0xFFFFFFFF) r *= 9, g *= 9, b *= 9;
	}
	if (((block_->fg != 230 && block_->fg != 6158) && based_on == "hair") or ((block_->fg != 5468 && block_->fg != 7740) && based_on == "drops") or ((block_->fg != 5468 && block_->fg != 7740) && based_on == "lenses")) {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		if (based_on == "hair") p.Insert("You'll make a huge mess if you do that outside the Bathtub!");
		else p.Insert("You'd better do that in front of a bathroom mirror or you'll poke your eye out!");
		p.Insert(0);
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}
	if ((based_on == "hair" && pInfo(peer)->hair_color == color) or (based_on == "drops" && pInfo(peer)->eye_drop == color) or (based_on == "lenses" && pInfo(peer)->eye_lenses == color)) {
		gamepacket_t p;
		p.Insert("OnTalkBubble");
		p.Insert(pInfo(peer)->netID);
		if (based_on == "hair") {
			if (shampoo) p.Insert("Your hair is already clean!");
			else p.Insert("Your hair is already that color!");
		}
		else if (based_on == "drops") {
			if (shampoo) p.Insert("Your eyes are already clean!");
			else p.Insert("Your eyes are already that color!");
		}
		else if (based_on == "lenses") {
			if (shampoo) p.Insert("Your lenses are already clean!");
			else p.Insert("Your pupils are already that color!");
		}
		p.Insert(0);
		p.Insert(1);
		p.CreatePacket(peer);
		return;
	}

	uint8_t* cancer = (uint8_t*)(&(based_on == "hair" ? pInfo(peer)->hair_color : (based_on == "drops" ? pInfo(peer)->eye_drop : pInfo(peer)->eye_lenses)));
	cancer[1] = std::clamp(cancer[1] + r, 0, 255);
	cancer[2] = std::clamp(cancer[2] + g, 0, 255);
	cancer[3] = std::clamp(cancer[3] + b, 0, 255);

	if (rand() % 100 < (items[p_].newdropchance + 5)) {
		WorldDrop drop_seed_{};
		drop_seed_.id = p_ + 1, drop_seed_.count = 1,drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
		if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
	}
	else if (rand() % 10 < 4) {
		gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_);
		//std::thread([=] {gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_); }).detach();
	}
	gamepacket_t p;
	p.Insert("OnTalkBubble");
	p.Insert(pInfo(peer)->netID);
	if (based_on == "hair") {
		if (shampoo) {
			if (rand() % 250 < 1) {
				WorldDrop drop_seed_{};
				drop_seed_.id = 12510, drop_seed_.count = 1,  drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
				if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
			}
			p.Insert("Your hair got cleaner!");
		}
		else p.Insert("You dyed your hair!");
	}
	else if (based_on == "drops") {
		if (shampoo) p.Insert("Your eyes got cleaner!");
		else p.Insert("You used eye drops!");
	}
	else {
		if (shampoo) p.Insert("Your lenses got cleaner!");
		else p.Insert("You put in some contact lenses!");
	}
	if (based_on == "hair") {
		gamepacket_t p2(0, pInfo(peer)->netID);
		p2.Insert("OnAction");
		p2.Insert("/shower");
		p.Insert(0), p.Insert(0);
		p.CreatePacket(peer);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == pInfo(peer)->world) p2.CreatePacket(currentPeer);
		}
	}
	int got = 0;
	modify_inventory(peer, p_, got = -1);
	update_clothes(peer, true);
}

string get_balloon_type(int balloon) {
	if (balloon >= 250000) return "\nadd_textbox|`8Melt Down Imminent!``|left|\n";
	else if (balloon >= 120000) return "\nadd_textbox|`6Overheating! High chance of Melt Down!``|left|\n";
	else if (balloon >= 65600) return "\nadd_textbox|`9Overheating!``|left|\n";
	else return "\n";
}


void apply_tile_visual(World* world_, WorldBlock* block_, int x, int y, int add_state, bool remove = false) {
	if (x < 0 || x >= world_->max_x || y < 0 || y >= world_->max_y) return;
	bool block = false;
	if (remove) {
		if (block_->flags & add_state) {
			if (add_state == 0x10000000) world_->total_fires -= 1, block_->applied_fire = false;
			block_->flags ^= add_state;
		}
	}
	else {
		if (block_->flags & add_state) {

		}
		else {
			if (add_state == 0x04000000 && block_->flags & 0x10000000) block_->flags ^= 0x10000000, world_->total_fires -= 1, block_->applied_fire = false;
			if (add_state == 0x10000000) {
				if (block_->flags & 0x04000000) block_->flags ^= 0x04000000;
				if (world_->total_fires >= 150 || block_->fg == 0 || block_->fg == 6 || block_->fg == 12258 || block_->flags & 0x10000000 || block_->fg == 6 || block_->fg == 8) block = true;
				else world_->total_fires++, block_->applied_fire = false;
			}
			if (block == false) block_->flags |= add_state;
		}
	}
	if (block == false) {
		PlayerMoving data_{};
		data_.packetType = 5, data_.punchX = x, data_.punchY = y, data_.characterState = 0x8;
		int alloc = alloc_(world_, block_);
		BYTE* raw = packPlayerMoving(&data_, 112 + alloc);
		BYTE* blc = raw + 56;
		form_visual(blc, *block_, *world_, NULL, false);
		for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
			if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
			if (pInfo(currentPeer)->world == world_->name) {
				send_raw(currentPeer, 4, raw, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
			}
		}
		delete[] raw, blc;
		if (block_->locked) upd_lock(*block_, *world_, NULL);
	}
}

void drop_valentine_box(ENetPeer* peer, World* world_, WorldBlock* block_, int x_, int y_, bool extra_chance = false, int add_ = 1) {
	WorldDrop drop_block_{};
	if (block_->fg == 3402 || block_->fg == 10656) {
		if (add_ > 0) {
			pInfo(peer)->booty_broken += add_;
			// valentine
			/*
			{
				gamepacket_t p;
				p.Insert("OnProgressUISet"), p.Insert(1), p.Insert(3402), p.Insert(pInfo(peer)->booty_broken), p.Insert(100), p.Insert(""), p.Insert(1);
				p.CreatePacket(peer);
			}*/
			/*
				gamepacket_t p;
				p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->booty_broken), p.Insert(0);
				p.CreatePacket(peer);*/
		}
	}
	vector<int> list{ 13122,13146,13150,13152,13144,13132,13130, 11702, 11696,11692,11690,11688,11686,11684,11682,11680,11678, 11694, 5652, 3398, 386, 4422, 364, 9342, 9340, 9334, 9332, 9336, 9338, 4400, 7808, 7810, 4416, 7818, 7820, 7822, 7824, 5644, 390, 7826, 7830, 9324, 5658, 3396, 2384, 5660, 10654, 3400, 4418, 388, 3408, 1470, 3404, 3406, 10662, 2390, 5656, 5648, 2396, 384, 5664, 4424, 366 };
	if (block_->fg != 9976) {
		if (block_->fg == 9350)  list.insert(list.end(), { 13124,13116,13126,13128,13114 });
		if ((block_->fg == 9350 || extra_chance || pInfo(peer)->valentine ? rand() % 350 : (has_playmod2(pInfo(peer), 9) || pInfo(peer)->hand == 9874 ? rand() % 450 : rand() % 800)) < 1) list = { 13120, 13142, 13154, 11668, 11670, 11672, 11664, 362, 362, 362,362,362, 2388, 10652, 4412, 10632, 10626, 13140 };

		if ((block_->fg == 9350 ? rand() % 5000 : (has_playmod2(pInfo(peer), 9) || pInfo(peer)->hand == 9874 ? rand() % 4500 : rand() % 5000)) < 1) list = { 11702,362 };
		if (add_ == 0 && extra_chance && rand() % 1400 < 1)  list = { 1458, 11672, 13140, 362 };
	}
		int item = list[rand() % list.size()];
		if (extra_chance && item != 1458 && add_ == 0) item = 10660;
		if (pInfo(peer)->ghc) item = 1458;
		if (item == 1458) {
			string texts = "`4The Power of Love! `2" + get_player_nick(peer) + "`` found a `5Golden Heart Crystal`` in a `5" + items[block_->fg].name + "``!";
			gamepacket_t p;
			p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
			for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
				if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
				p.CreatePacket(currentPeer);
			}
		}
	drop_block_.id = item, drop_block_.count = (item == 11694 || item == 11696 || item == 7810 || item == 7808 || item == 4400 || item == 390 || item == 3408 || item == 4422 || item == 3404 ? 5 : (item == 4418 || item == 5660 ? 2 : 1)), drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
	dropas_(world_, drop_block_);
}
void remove_lock_broken(World* world_, WorldBlock* block_, int x_, int y_) {
	block_->admins.clear();
	block_->owner_name = "";
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
		if (pInfo(currentPeer)->world == world_->name) pInfo(currentPeer)->access_offers.clear();
	}
	vector<int> new_tiles{};
	vector<WorldBlock> shadow_copy_2 = world_->blocks;
	new_tiles.push_back(x_ + (y_ * 100));
	int ySize = world_->blocks.size() / 100, xSize = world_->blocks.size() / ySize;
	for (int i2 = 0; i2 < new_tiles.size(); i2++) {
		int s_x_ = new_tiles[i2] % 100, s_y_ = new_tiles[i2] / 100;
		if (s_x_ < (world_->max_x -1 ) and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
			if (not shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned) {
				shadow_copy_2[s_x_ + 1 + (s_y_ * 100)].scanned = true;
				new_tiles.push_back(s_x_ + 1 + (s_y_ * 100));
				world_->blocks[s_x_ + 1 + (s_y_ * 100)].locked = false;
				world_->blocks[s_x_ + 1 + (s_y_ * 100)].lock_origin = -1;
			}
		} if (s_x_ > 0 and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].locked and shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].lock_origin == (x_ + (y_ * 100))) {
			if (not shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned) {
				shadow_copy_2[s_x_ - 1 + (s_y_ * 100)].scanned = true;
				new_tiles.push_back(s_x_ - 1 + (s_y_ * 100));
				world_->blocks[s_x_ - 1 + (s_y_ * 100)].locked = false;
				world_->blocks[s_x_ - 1 + (s_y_ * 100)].lock_origin = -1;
			}
		} if (s_y_ < (world_->max_y -1 ) and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
			if (not shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned) {
				shadow_copy_2[s_x_ + ((s_y_ + 1) * 100)].scanned = true;
				new_tiles.push_back(s_x_ + ((s_y_ + 1) * 100));
				world_->blocks[s_x_ + ((s_y_ + 1) * 100)].locked = false;
				world_->blocks[s_x_ + ((s_y_ + 1) * 100)].lock_origin = -1;
			}
		} if (s_y_ > 0 and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].locked and shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].lock_origin == (x_ + (y_ * 100))) {
			if (not shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned) {
				shadow_copy_2[s_x_ + ((s_y_ - 1) * 100)].scanned = true;
				new_tiles.push_back(s_x_ + ((s_y_ - 1) * 100));
				world_->blocks[s_x_ + ((s_y_ - 1) * 100)].locked = false;
				world_->blocks[s_x_ + ((s_y_ - 1) * 100)].lock_origin = -1;
			}
		}
	}
}

void growscan_load(ENetPeer* peer, World* world_, WorldBlock* block_) {
	bool world_public = block_->spin, floating_public = block_->invert, access = block_access(peer, world_, block_);
	gamepacket_t p;
	p.Insert("OnDialogRequest");
	if (access or pInfo(peer)->cheater_ or has_playmod2(pInfo(peer), 143) or has_playmod2(pInfo(peer), 153)) {
		p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|left\nadd_button|worldBlocks|World Blocks|noflags|0|0|\nadd_button|floatingItems|Floating Items|noflags|0|0|"+ (access ? "\nadd_spacer|small|\nadd_textbox|`wYou can set the stats to be usable by the public.|left\nadd_checkbox|isStatsWorldBlockUsableByPublic|World blocks is usable by public|" + a + (world_public == false ? "0" : "1") + "\nadd_checkbox|isStatsFloatingItemsUsableByPublic|Floating items is usable by public|" + (floating_public == false ? "0" : "1") :"") + "\nadd_spacer|small|\nend_dialog|statsblock|Cancel|Apply|\n");

	}
	else  p.Insert(a + "set_default_color|`o\nadd_label_with_icon|big|`wWorld Stats``|left|6016|\nadd_spacer|small|" + (floating_public == false and world_public == false ? "\nadd_textbox|`wYou don't have access to this block.|left" : "\nadd_textbox|`wThis amazing block can show the stats for the whole world!|left\nadd_spacer|small|\nadd_textbox|`wWhich stats would you like to view?|left") + "" + (world_public == true ? "\nadd_button|worldBlocks|World Blocks|noflags|0|0|" : "") + "" + (floating_public == true ? "\nadd_button|floatingItems|Floating Items|noflags|0|0|" : "") + "\nadd_spacer|small|\nend_dialog|statsblock|Cancel||\n");
	p.CreatePacket(peer);
}

inline void SendDNAProcessor(ENetPeer* peer, int x, int y, bool Erorr, bool Analisa, bool RemoveDNA, int IDDNARemove, bool MasukinDNA, bool Invalid) {
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		WorldBlock* block_ = &world_->blocks[pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100)];
		if (not block_access(peer, world_, block_)) return;
		string Dialog;
		Dialog += "set_default_color|`o\nadd_label_with_icon|big|`wDNA Processor``|left|4080|";
		Dialog += "\nadd_spacer|small|\nembed_data|tilex|" + to_string(x) + "\nembed_data|tiley|" + to_string(y);
		if (Erorr) {
			Dialog += "\nadd_textbox|`4ERROR:`` That's not a DNA sample.|left|\nadd_spacer|small|";
		}
		if (Analisa) {
			Dialog += "\nadd_textbox|`2DNA analyzed.``|left|\nadd_spacer|small|";
		}
		if (RemoveDNA) {
			Dialog += "\nadd_textbox|`2" + items[IDDNARemove].name + " removed.``|left|\nadd_spacer|small|";
		}
		if (MasukinDNA) {
			if (block_->shelf_4 == 1) {
				Dialog += "\nadd_smalltext|[`2DNA sequence 33% complete``]|left|";
			}
			else if (block_->shelf_4 == 2) {
				Dialog += "\nadd_smalltext|[`2DNA sequence 66% complete``]|left|";
			}
			else if (block_->shelf_4 == 3) {
				Dialog += "\nadd_smalltext|[`2DNA sequence 100% complete``]|left|";
			}
		}
		if (block_->shelf_1 != 0) {
			Dialog += "\nadd_button_with_icon|remove0|`9" + items[block_->shelf_1].name + "``|noflags|" + to_string(block_->shelf_1) + "||";
		}
		if (block_->shelf_2 != 0) {
			Dialog += "\nadd_button_with_icon|remove1|`9" + items[block_->shelf_2].name + "``|noflags|" + to_string(block_->shelf_2) + "||";
		}
		if (block_->shelf_3 != 0) {
			Dialog += "\nadd_button_with_icon|remove2|`9" + items[block_->shelf_3].name + "``|noflags|" + to_string(block_->shelf_3) + "||";
		}
		if (block_->shelf_4 > 0) {
			Dialog += "\nadd_button_with_icon||END_LIST|noflags|0||";
		}
		if (block_->shelf_4 == 3) {
			if (Invalid) {
				Dialog += "\nadd_smalltext|`4DNA SEQUENCE INVALID``|left|";
			}
			else {
				Dialog += "\nadd_button|combine|`2Combine DNA sequence``|noflags|0|0|";
			}
		}
		else {
			if (block_->shelf_4 == 0) {
				Dialog += "\nadd_textbox|DNA Processing ready. Please insert DNA strand.|left|";
			}
			Dialog += "\nadd_item_picker|choose|Insert DNA Here|Select a DNA Strand|";
		}
		Dialog += "\nend_dialog|dnaproc|Exit||";
		gamepacket_t p;
		p.Insert("OnDialogRequest");
		p.Insert(Dialog);
		p.CreatePacket(peer);
	}
}



bool edit_tile(ENetPeer* peer, int x_, int y_, int p_, bool mag_place = false, bool place_punch = false, int have = 0) {
 	if (x_ < 0 or y_ < 0 or p_ < 0 or p_ >= items.size() || items[p_].blocked_place) return false;
	string name_ = pInfo(peer)->world;
	vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
	if (p != worlds.end()) {
		World* world_ = &worlds[p - worlds.begin()];
		if (x_ >= world_->max_x || y_ >= world_->max_y) return false;
		if (pInfo(peer)->lastwrenchx != x_ || pInfo(peer)->lastwrenchy != y_) pInfo(peer)->random_fossil = rand() % 3 + 4;
		pInfo(peer)->lastwrenchx = x_, pInfo(peer)->lastwrenchy = y_;
		world_->fresh_world = true;
		WorldBlock* block_ = &world_->blocks[x_ + (y_ * 100)];
		uint16_t t_ = (block_->fg ? block_->fg : block_->bg);
		bool magplant_access = false;

		if (t_ == 6950 || t_ == 6952 || t_ == 9844 || t_ == 5638 || t_ == 10266 || t_ == 9850 || t_ == 6948 || t_ == 6946 || t_ == 6954) {
			if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) magplant_access = true;
			if (items[t_].blockType == BlockTypes::AUTO_BLOCK or items[t_].blockType == BlockTypes::SUCKER or t_ == 6954) {
				if (world_->world_settings & Gtps3::SETTINGS_10) {
					if (find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_->admins.end()) magplant_access = true;
				}
			}
		}
		if (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_0 && pInfo(peer)->last_used_block != 0 && items[p_].blockType != BlockTypes::CONSUMABLE) {
			if (pInfo(peer)->disable_cheater) autofarm_status(peer);
			if (place_punch) p_ = 18;
			if (pInfo(peer)->autofarm_x != -1 && pInfo(peer)->autofarm_y != 0) {
				if (mag_place == false) {
					if ((p_ != 0 && p_ != pInfo(peer)->last_used_block) or (p_ == 0 && p_ != pInfo(peer)->last_used_block)) {
						autofarm_status(peer);
						return false;
					}
				}
				if (pInfo(peer)->last_used_block != 32 && pInfo(peer)->last_used_block != 18 && t_ != 0) p_ = 18;
			}
			else {
				gamepacket_t p;
				p.Insert("OnParticleEffect"), p.Insert(88), p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16), p.CreatePacket(peer);
			}
			if (pInfo(peer)->autofarm_x == -1) {
				if (pInfo(peer)->last_used_block != 0) console_msg(peer, "`oCheat Enabled: Autofarm (`$Cheat Active: Autofarm (cool) -> " + items[pInfo(peer)->last_used_block].ori_name + " ``mod added)");
				pInfo(peer)->autofarm_x = x_, pInfo(peer)->autofarm_y = y_;
				if (pInfo(peer)->state == 16)  pInfo(peer)->backwards = true;
				else pInfo(peer)->backwards = false;
			}
		}
		else if (place_punch) return false;
		else if (t_ == 12258) {
			if (beach_party_game) {
				join_beach_party(peer);
			}
			else {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Beach Party Game is over!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
			}
			return false;
		}
		switch (p_) {
		case 18:
		{
			if (pInfo(peer)->hand == 3066 || pInfo(peer)->hand == 6086) {
				if (block_->flags & 0x10000000 && pInfo(peer)->hand == 3066) {
					pInfo(peer)->fires++;
					if (pInfo(peer)->fires >= 100) {
						pInfo(peer)->fires = 0;
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("I'm so good at fighting fires, I rescued this `2Highly Combustible Box``!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						PlayerMoving data_{};
						data_.x = pInfo(peer)->lastwrenchx * 32 + 16, data_.y = pInfo(peer)->lastwrenchy * 32 + 16;
						data_.packetType = 19, data_.plantingTree = 500;
						data_.punchX = 3090, data_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 5;
						memcpy(raw + 8, &to_netid, 4);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == pInfo(peer)->world) send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
						}
						delete[] raw;
						int give_ = 1;
						if (modify_inventory(peer, 3090, give_) == 0) {

						}
						else {
							WorldDrop drop_block_{};
							drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17, drop_block_.id = 3090, drop_block_.count = 1;
							dropas_(world_, drop_block_);
						}
					}
					apply_tile_visual(world_, block_, x_, y_, 0x10000000, true);
				}
				if (t_ != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(""), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
					break;
				}
			}
			if (t_ == 0) {
				break;
			}
			if (items[t_].properties & Property_Mod) {
				if (not pInfo(peer)->dev || pInfo(peer)->cheater_settings & Gtps3::SETTINGS_0) {
					packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
					{
						gamepacket_t p;
						p.Insert("OnParticleEffectV2"), p.Insert(368), p.Insert((float)(x_ * 32) + 16, (float)(y_ * 32) + 16);
						p.CreatePacket(peer);
					}
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert(items[t_].blockType == BlockTypes::MAIN_DOOR ? "(stand over and punch to use)" : "It's too strong to break.");
					p.Insert(0);
					p.Insert(1);
					p.CreatePacket(peer);
					break;
				}
			}
			else if (t_ == 3470) {
				if (pInfo(peer)->hand == 3466 || pInfo(peer)->hand == 4506) {
					WorldDrop drop_block_{};
					drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
						if (world_->drop_new[i_][0] == 0) continue;
						if (x_ == world_->drop_new[i_][3] / 32 && y_ == world_->drop_new[i_][4] / 32) {
							if (items[world_->drop_new[i_][0]].blockType == BlockTypes::FISH || world_->drop_new[i_][0] == 866 || world_->drop_new[i_][0] == 872 || world_->drop_new[i_][0] == 7050) {
								if (world_->drop_new[i_][0] == 3032 && world_->drop_new[i_][1] == 90 && rand() % 100 < 5) {
									drop_block_.id = 5486, drop_block_.count = 1;
									dropas_(world_, drop_block_);
								}
								else if (world_->drop_new[i_][0] == 5450 && world_->drop_new[i_][1] == 50 && rand() % 100 < 10) {
									drop_block_.id = 6806, drop_block_.count = 1;
									dropas_(world_, drop_block_);
								}
								PlayerMoving data_{};
								data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop_new[i_][2];
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);

								}
								delete[]raw;
								if (items[world_->drop_new[i_][0]].blockType == BlockTypes::FISH && world_->drop_new[i_][1] <= 9 && rand() % 100 < 40) {
									PlayerMoving data_{};
									data_.packetType = 17, data_.netID = 45, data_.YSpeed = 45, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
									BYTE* raw = packPlayerMoving(&data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[] raw;
									world_->drop_new.erase(world_->drop_new.begin() + i_);
									break;
								}
								int drop_count = 1;
								if (items[world_->drop_new[i_][0]].blockType == BlockTypes::FISH && world_->drop_new[i_][1] > 9) drop_count = world_->drop_new[i_][1] / 10;
								if (world_->drop_new[i_][0] == 866 || world_->drop_new[i_][0] == 872 || world_->drop_new[i_][0] == 7050) drop_count = world_->drop_new[i_][1];
								drop_block_.id = world_->drop_new[i_][0] == 866 ? 4578 : world_->drop_new[i_][0] == 872 ? 4588 : world_->drop_new[i_][0] == 7050 ? 7052 : 3468, drop_block_.count = drop_count;
								dropas_(world_, drop_block_);
								world_->drop_new.erase(world_->drop_new.begin() + i_);
							}
						}
					}
				}
			}
			else if (t_ == 758 || t_ == 756) {
				if (pInfo(peer)->i758 + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
					pInfo(peer)->i758 = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
					int get37 = 0;
					string wheel = "";
					gamepacket_t p(2000), p2(2000), p3(2000);
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					p2.Insert("OnConsoleMessage");
					PlayerMoving data_{};
					BYTE* raw = packPlayerMoving(&data_);
					if (t_ == 758) {
						get37 = rand() % 37;
						if (pInfo(peer)->csn != -1 && pInfo(peer)->csn < 37) get37 = pInfo(peer)->csn;
						string color = "";
						if (get37 == 36 || get37 == 34 || get37 == 32 || get37 == 30 || get37 == 27 || get37 == 25 || get37 == 23 || get37 == 21 || get37 == 19 || get37 == 18 || get37 == 16 || get37 == 12 || get37 == 9 || get37 == 7 || get37 == 5 || get37 == 3 || get37 == 1) color = "`4";
						else if (get37 == 0) color = "`2";
						else color = "`b";
						wheel = "`7[``" + get_player_nick(peer) +" spun the wheel and got " + color + to_string(get37) + "!`7]``";
					}
					else {
						get37 = rand() % 10;
						if (get37 == 1) data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
						wheel = "`7[``" + get_player_nick(peer) + " " + (get37 == 1 ? "`2wins at slots!`" : "`4loses at slots.`") + "``7]``";
						p3.Insert("OnPlayPositioned");
						p3.Insert(get37 == 1 ? "audio/slot_win.wav" : "audio/slot_lose.wav");
					}
					p.Insert(wheel);
					p.Insert(0), p.Insert(0);
					p2.Insert(wheel);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == pInfo(peer)->world) {
							p.CreatePacket(currentPeer);
							p2.CreatePacket(currentPeer);
							if (t_ == 756) {
								p3.CreatePacket(currentPeer);
								if (get37 == 1) send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
					}
					if (get37 == 1)delete[] raw;
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0);
				}
			}
			else if (t_ == 1482 || t_ == 2252 || t_ == 7864 || t_ == 11434) {
				struct tm newtime;
				time_t now = time(0);
				localtime_s(&newtime, &now);
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("It's " + to_string(newtime.tm_hour) + ":" + (newtime.tm_min < 10 ? "0" + to_string(newtime.tm_min) + "" : "" + to_string(newtime.tm_min) + "") + " " + (newtime.tm_hour >= 12 ? "PM" : "AM") + " on " + to_string(newtime.tm_mon + 1) + "/" + to_string(newtime.tm_mday) + "");
				p.Insert(0);
				p.Insert(1);
				p.CreatePacket(peer);
			}

			// nuo cia non access negales nieko padaryt:
			if (items[t_].properties & Property_Public) { /*cout << "public block break" << endl;*/ }
			else {
				if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
					if (to_lower(block_->owner_name) != to_lower(pInfo(peer)->tankIDName)) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							string lock_ago = "";
							bool delete_lock = false;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							string owner_name = block_->owner_name;
							if (block_->owner_named != "") {
								if (block_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + block_->owner_name;
								else owner_name = block_->owner_named;
							}
							if (owner_name.empty()) owner_name = "`w" + world_->owner_name;
								int expiry = 0, days2_ = 0;
								lock_ago = (block_->block_day.empty() ? return_last_online(block_->owner_name) : block_->block_day);
								block_->block_day = lock_ago;
								if (lock_ago == "today") days2_ = 1;
								else {
									days2_ = atoi(lock_ago.c_str());
								}
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) 	expiry = 45;
								else expiry = 60;
								if (expiry - days2_ <= 0) {
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("`5INACTIVELOCK:`` " + owner_name + "'s```` lock `4disintegrates`` due to last playing `5" + lock_ago + "`` days ago!");
									p.CreatePacket(peer);
									lock_ago = " `5INACTIVELOCK:`` " + owner_name + "'s```` lock `4disintegrates`` due to last playing `5" + lock_ago + "`` days ago!";
									if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) remove_lock_broken(world_, block_, x_, y_);
									else world_->owner_name = "", world_->owner_named = "", world_->entry_level = 1, world_->admins.clear(), block_->fg = 0;
									block_->fg = 0;
									block_->block_day = "today";
									delete_lock = true;
									update_tile(peer, x_, y_, 0, false, true);
								}
								else lock_ago = " (Last played `w" + (lock_ago == "today" ? lock_ago : lock_ago + " days ago") + "``)";
							if (delete_lock == false) {
								if (block_->spin)
									p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wOpen to public``)" + lock_ago);
								else if (find(block_->admins.begin(), block_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != block_->admins.end())
									p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wAccess granted``)" + lock_ago);
								else
									p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`4No access``)" + lock_ago);
							}
							else p.Insert(lock_ago);
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
							if (not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									p.CreatePacket(peer);
								}
								return true;
							}
						}
					}
				}
				else if (block_->locked) {
					if (world_->blocks[block_->lock_origin].fg == 242 || items[world_->blocks[block_->lock_origin].fg].blockType != BlockTypes::LOCK) {
						int xa_ = block_->lock_origin % 100, ya_ = block_->lock_origin / 100;
						remove_lock_broken(world_, &world_->blocks[block_->lock_origin], xa_, ya_);
					}
					else {
						WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
						string owner_name = to_lower(block2_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
						if (owner_name != user_name and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
							if (block2_->fg == 4994 or not block2_->spin and find(block2_->admins.begin(), block2_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == block2_->admins.end()) {
								if (block2_->fg == 4994) {
									if (not block2_->spin) {
										gamepacket_t p(0, pInfo(peer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/punch_locked.wav");
										p.CreatePacket(peer);
										return true;
									}
									if (block2_->build_only and block2_->spin) {
										if (not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
											gamepacket_t p(0, pInfo(peer)->netID);
											p.Insert("OnPlayPositioned");
											p.Insert("audio/punch_locked.wav");
											p.CreatePacket(peer);
											{
												gamepacket_t p;
												p.Insert("OnTalkBubble");
												p.Insert(pInfo(peer)->netID);
												p.Insert("This lock allows building only!");
												p.Insert(0);
												p.Insert(1);
												p.CreatePacket(peer);
											}
											return true;
										}
									}
								}
								else {
									if (not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
										gamepacket_t p(0, pInfo(peer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/punch_locked.wav");
										p.CreatePacket(peer);
										return true;
									}
								}
							}
						}
					}
				}
				else if (not world_->owner_name.empty()) {
					string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
					if (owner_name != user_name) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							bool delete_lock = false;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							string owner_name = "";
							if (world_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + world_->owner_name;
							else owner_name = world_->owner_named;
							if (owner_name.empty()) owner_name = "`w" + world_->owner_name;

							string lock_ago = "";
							int expiry = 0, days2_ = 0;
							lock_ago = (block_->block_day.empty() ? return_last_online(world_->owner_name) : block_->block_day);
							block_->block_day = lock_ago;
							if (lock_ago == "today") days2_ = 1;
							else {
								days2_ = atoi(lock_ago.c_str());
							}
							if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) 	expiry = 45;
							else expiry = 60;
							if (expiry - days2_ <= 0) {
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("`5INACTIVELOCK:`` " + owner_name + "'s```` lock `4disintegrates`` due to last playing `5" + lock_ago + "`` days ago!");
								p.CreatePacket(peer);
								lock_ago = " `5INACTIVELOCK:`` " + owner_name + "'s```` lock `4disintegrates`` due to last playing `5" + lock_ago + "`` days ago!";
								if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) remove_lock_broken(world_, block_, x_, y_);
								else world_->owner_name = "", world_->owner_named = "", world_->entry_level = 1, world_->admins.clear(), block_->fg = 0;
								block_->fg = 0;
								block_->block_day = "today";
								delete_lock = true;
								update_tile(peer, x_, y_, 0, false, true);
							}
							else lock_ago = " (Last played `w" + (lock_ago == "today" ? lock_ago : lock_ago + " days ago") + "``)";
							if (delete_lock == false) {
								if (world_->world_settings & Gtps3::SETTINGS_4)
									p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wOpen to public``)" + lock_ago);
								else if (guild_access(peer, world_->guild_id) or find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end())
									p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`wAccess granted``)" + lock_ago);
								else
									p.Insert("" + owner_name + "``'s `$" + items[t_].name + "``. (`4No access``)" + lock_ago);
							}
							else p.Insert(lock_ago);
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
							if (not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									p.CreatePacket(peer);
								}
								return true;
							}
						}
						if (block_access(peer, world_, block_) == false) {
							if (not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								p.CreatePacket(peer);
								return true;
							}
						}
					}
				}
			}
			if (t_ == 3918 || t_ == 3922 || t_ == 3926 || t_ == 3928 || t_ == 3924 || t_ == 3920) {
				if (pInfo(peer)->hand == 3932) {
					pInfo(peer)->random_fossil -= 1;
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
					if (pInfo(peer)->random_fossil < 0 or block_->fg & items[block_->fg].block_flag) {
						pInfo(peer)->random_fossil = rand() % 3 + 4;
						p.Insert("`4I smashed a Fossil!``");
						apply_tile_visual(world_, block_, x_, y_, items[block_->fg].block_flag, true);
						update_tile(peer, x_, y_, block_->fg = items[block_->fg].fossil_rock2, true);
					}
					else {
						if (pInfo(peer)->random_fossil == 0) {
							p.Insert("`2I unearthed a Fossil!`` I better be careful getting it out...");
							apply_tile_visual(world_, block_, x_, y_, items[block_->fg].block_flag);
						}
					}
					p.Insert(0), p.Insert(1), p.CreatePacket(peer);
				}
			}
			if (items[t_].toggleable or items[t_].blockType == BlockTypes::CHEMICAL_COMBINER) {
				block_->flags = (block_->flags & 0x00400000 ? block_->flags ^ 0x00400000 : block_->flags | 0x00400000);
				gamepacket_t p;
				p.Insert("OnConsoleMessage");
				if (t_ == 226) {
					if (block_->flags & 0x00400000) p.Insert("Signal jammer enabled. This world is now `4hidden`` from the universe.");
					else p.Insert("Signal jammer disabled. This world is `2visible`` to the universe.");
				}
				else if (t_ == 4992) {
					if (block_->flags & 0x00400000) p.Insert("`3Antigravity was enabled.``");
					else p.Insert("`4Antigravity was disabled.``");
				}
				else if (t_ == 4992 || t_ == 226) p.CreatePacket(peer);
				if (t_ == 226 or t_ == 3616 or t_ == 1276 or t_ == 1278 or t_ == 4758 or t_ == 3750 or t_ == 4992 or t_ == 3072 or t_ == 4884) {
					if (block_->flags & 0x00400000) world_->active_jammers.push_back(t_);
					else world_->active_jammers.erase(remove(world_->active_jammers.begin(), world_->active_jammers.end(), t_), world_->active_jammers.end());
				}
				else if (items[t_].blockType == BlockTypes::CHEMICAL_COMBINER) {
					if (block_->flags & 0x00400000) {

					}
					else {
						vector<vector<int>> comb;
						bool combined = false;
						for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
							if (world_->drop_new[i_][0] == 0) continue;
							if (x_ == (world_->drop_new[i_][3] / 32) && y_ == (world_->drop_new[i_][4] / 32)) {
								comb.push_back({ world_->drop_new[i_][0], world_->drop_new[i_][1] });
							}
						}
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						if (comb.size() < 3) p.Insert("I need 3 ingredients!");
						if (comb.size() > 3) p.Insert("It won't mix more than 3 items at once!");
						if (comb.size() == 3) {
							for (vector<vector<int>>recipe : receptai) {
								uint32_t result_item_id = recipe[3][0];
								uint32_t result_gives_per_recipe = recipe[3][1];
								vector<int> compare1, compare2;
								vector<vector<vector<int>>> info{ {}, {} };
								for (int i_ = 0; i_ < 3; i_++) {
									compare1.push_back(recipe[i_][0]);
									info[0].push_back({ recipe[i_][0], recipe[i_][1] });
								} for (vector<int>item_id : comb) {
									compare2.push_back(item_id[0]);
									info[1].push_back({ item_id[0], item_id[1] });
								} sort(compare1.begin(), compare1.end()), sort(compare2.begin(), compare2.end());
								if (compare1 == compare2) {
									sort(info[0].begin(), info[0].end()), sort(info[1].begin(), info[1].end());
									bool no = false;
									for (int i_ = 0; i_ < info[0].size(); i_++) {
										if (info[0][i_][1] > info[1][i_][1]) {
											no = true;
											break;
										}
									} if (no) break;
									uint32_t result_item_count = 0;
									uint32_t times_ = 0;
									for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
										if (no) break;
										if (world_->drop_new[i_][0] == 0) continue;
										if (x_ == (world_->drop_new[i_][3] / 32) && y_ == (world_->drop_new[i_][4] / 32)) {
											for (int i_2 = 0; i_2 < info[0].size(); i_2++) {
												if (info[0][i_2][0] == world_->drop_new[i_][0]) {
													if (info[0][i_2][1] > info[1][i_2][1]) {
														break;
													}
													world_->drop_new[i_][1] -= info[0][i_2][1];
													info[1][i_2][1] = world_->drop_new[i_][1];
													times_++;
													if (world_->drop_new[i_][1] <= 0) {
														PlayerMoving data_{};
														data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop_new[i_][2];
														BYTE* raw = packPlayerMoving(&data_);
														int32_t item = -1;
														memcpy(raw + 8, &item, 4);
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->world == name_) {
																send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
															}
														}
														world_->drop_new.erase(world_->drop_new.begin() + i_);
														i_--;
														delete[] raw;
													}
													else {
														PlayerMoving data_{};
														data_.packetType = 14, data_.netID = -2, data_.plantingTree = world_->drop_new[i_][2];
														BYTE* raw = packPlayerMoving(&data_);
														int32_t item = -1;
														memcpy(raw + 8, &item, 4);
														for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
															if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
															if (pInfo(currentPeer)->world == name_) {
																send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
															}
														}
														delete[] raw;
														WorldDrop drop_{};
														drop_.id = world_->drop_new[i_][0];
														drop_.count = world_->drop_new[i_][1];
														drop_.x = world_->drop_new[i_][3];
														drop_.y = world_->drop_new[i_][4];
														world_->drop_new.erase(world_->drop_new.begin() + i_);
														i_--;
														dropas_(world_, drop_);
													}
													if (times_ == 3) {
														times_ = 0;
														result_item_count += result_gives_per_recipe;
														if (result_item_count + result_gives_per_recipe > 200) no = true;
														for (int i_ = 0; i_ < info[0].size(); i_++) {
															if (info[0][i_][1] > info[1][i_][1]) {
																no = true;
																break;
															}
														}
													}
													break;
												}
											}
										}
									}
									if (result_item_count != 0) {
										combined = true;
										WorldDrop drop_block_{};
										drop_block_.id = result_item_id, drop_block_.count = result_item_count, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
										dropas_(world_, drop_block_);
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 44, data_.YSpeed = 44, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
										BYTE* raw = packPlayerMoving(&data_);
										string t_ = "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0";
										BYTE* const d_ = new BYTE[5 + t_.length()];
										*(__int8*)(d_) = 3;
										memcpy(d_ + 4, t_.c_str(), t_.length());
										*(__int8*)(d_ + 4 + t_.length()) = 0;
										ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												enet_peer_send(currentPeer, 0, p_m);
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[]d_;
										delete[]raw;
										p.Insert("SCIENCE!");
										if (pInfo(peer)->grow4good_combine < 6) daily_quest(peer, false, "combine", 1);
									}
									break;
								}
							}
						}
						if (not combined) p.Insert("Those items don't seem to combine!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
			}
			else if (items[t_].blockType == BlockTypes::AUTO_BLOCK or t_ == 6954) {
				bool w_public = world_->world_settings & Gtps3::SETTINGS_4;
				if (magplant_access == false && w_public == false) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Only the `9World Owner`` can activate this!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					return true;
				}
				else {
					if (items[t_].blockType == BlockTypes::AUTO_BLOCK or t_ == 6954) {
						if (block_->id != 0) {
							block_->enabled = (block_->enabled ? false : true);
							bool found_ = false;
							for (int i_ = 0; i_ < world_->machines.size(); i_++) {
								WorldMachines* machine_ = &world_->machines[i_];
								if (machine_->x == x_ and machine_->y == y_) {
									machine_->enabled = block_->enabled;
									machine_->target_item = block_->id;
									found_ = true;
									break;
								}
							}
							if (not found_) {
								WorldMachines new_machine;
								new_machine.enabled = block_->enabled;
								new_machine.x = x_, new_machine.y = y_;
								new_machine.id = block_->fg;
								new_machine.target_item = block_->id;
								world_->machines.push_back(new_machine);
								if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) {
									World_Stuff.t_worlds.push_back(world_->name);
								}
							}
							tile_update(peer, world_, block_, x_, y_);
						}
					}
				}
			}
			else if (items[t_].blockType == BlockTypes::WEATHER) {
				int weather_id_ = items[t_].base_weather;
				long long current_time = time(nullptr);
				if (block_->planted - current_time <= 0) {
					world_->weather = (weather_id_ != world_->weather ? weather_id_ : 0);
					block_->enabled = (world_->weather != 0 ? true : false);
					block_->planted = current_time + 1.5;
					if (world_->weather == 0) {
						if (pInfo(peer)->lock == 11550)world_->weather = 54;
						if (pInfo(peer)->lock == 11586)world_->weather = 55;
						if (pInfo(peer)->lock == 10410)world_->weather = 53;
						if (pInfo(peer)->lock == 11902)world_->weather = 58;
						if (pInfo(peer)->lock == 12654)world_->weather = 63;
						if (pInfo(peer)->lock == 13200)world_->weather = 67;
						world_->weather = world_->d_weather;
					}
					if (block_->fg == 5958 && block_->enabled) {
						bool found_ = false;
						block_->pr = 1;
						for (int i_ = 0; i_ < world_->machines.size(); i_++) {
							WorldMachines* machine_ = &world_->machines[i_];
							if (machine_->x == x_ and machine_->y == y_) {
								machine_->enabled = block_->enabled;
								machine_->target_item = block_->shelf_4;
								found_ = true;
								break;
							}
						}
						if (not found_) {
							WorldMachines new_machine;
							new_machine.enabled = block_->enabled;
							new_machine.x = x_, new_machine.y = y_;
							new_machine.id = block_->fg;
							new_machine.target_item = block_->shelf_4;
							world_->machines.push_back(new_machine);
							if (find(World_Stuff.t_worlds.begin(), World_Stuff.t_worlds.end(), world_->name) == World_Stuff.t_worlds.end()) {
								World_Stuff.t_worlds.push_back(world_->name);
							}
						}
					}
					gamepacket_t p;
					p.Insert("OnSetCurrentWeather");
					if (comet_dust) p.Insert(16);
					else p.Insert(world_->weather == 0 ? 80 : world_->weather);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == name_) {
							p.CreatePacket(currentPeer);
						}
					}
				}
			}
			else if (block_->fg == 5638 || block_->fg == 9850 || block_->fg == 10266) {
				if (magplant_access or pInfo(peer)->dev) {
					long long current_time = time(nullptr);
					if (block_->pr > 0 or (items[t_].dropChance) < (current_time - block_->lp)) {
						if (block_->id == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Cannot activate the " + items[block_->fg].name + ", you need to set the item first.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("Cannot activate the " + items[block_->fg].name + ", you need to set the item first.");
								p.CreatePacket(peer);
							}
						}
						else {
							if (items[block_->id].collisionType != 1 and items[block_->id].blockType != BACKGROUND and items[block_->id].blockType != SEED and not items[block_->id].farmable and items[t_].blockType == BlockTypes::LOCK) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Cannot activate the " + items[block_->fg].name + ", the current item cannot be placed.");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("Cannot activate the " + items[block_->fg].name + ", the current item cannot be placed.");
									p.CreatePacket(peer);
								}
							}
							else {
								block_->spin = (block_->spin ? false : true);
								int c_ = 0;
								modify_inventory(peer, 5640, c_);
								if (c_ != 0) modify_inventory(peer, 5640, c_ *= -1);
								c_ = 1;
								if (modify_inventory(peer, 5640, c_) == 0) {
									gamepacket_t p, p2;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("You received a " + items[5640].name + ".");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
									p2.Insert("OnConsoleMessage");
									p2.Insert("You received a " + items[5640].name + ".");
									p2.CreatePacket(peer);
								}
								gamepacket_t p;
								p.Insert("OnPlanterActivated");
								p.Insert(block_->id);
								p.Insert(x_);
								p.Insert(y_);
								p.CreatePacket(peer);
								pInfo(peer)->magnetron_id = block_->id;
								pInfo(peer)->magnetron_x = x_;
								pInfo(peer)->magnetron_y = y_;
								tile_update(peer, world_, block_, x_, y_);
							}
						}
					}
				}
			}
			else if (items[block_->fg].blockType == BlockTypes::MANNEQUIN) {
				bool s = false;
				int c_ = 1;
				if (block_->mannequin.c_head != 0) {
					if (modify_inventory(peer, block_->mannequin.c_head, c_) == 0) {
						block_->mannequin.c_head = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_shirt != 0) {
					if (modify_inventory(peer, block_->mannequin.c_shirt, c_) == 0) {
						block_->mannequin.c_shirt = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_pants != 0) {
					if (modify_inventory(peer, block_->mannequin.c_pants, c_) == 0) {
						block_->mannequin.c_pants = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_feet != 0) {
					if (modify_inventory(peer, block_->mannequin.c_feet, c_) == 0) {
						block_->mannequin.c_feet = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_mask != 0) {
					if (modify_inventory(peer, block_->mannequin.c_mask, c_) == 0) {
						block_->mannequin.c_mask = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_hand != 0) {
					if (modify_inventory(peer, block_->mannequin.c_hand, c_) == 0) {
						block_->mannequin.c_hand = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_back != 0) {
					if (modify_inventory(peer, block_->mannequin.c_back, c_) == 0) {
						block_->mannequin.c_back = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_hair != 0) {
					if (modify_inventory(peer, block_->mannequin.c_hair, c_) == 0) {
						block_->mannequin.c_hair = 0;
					}
					s = true;
				}
				else if (block_->mannequin.c_neck != 0) {
					if (modify_inventory(peer, block_->mannequin.c_neck, c_) == 0) {
						block_->mannequin.c_neck = 0;
					}
					s = true;
				} if (s) {
					tile_update(peer, world_, block_, x_, y_);
					return true;
				}
			}
			else if (items[block_->fg].blockType == BlockTypes::GEIGER_CHARGER) {
				if (block_->id != 0) {
					long long current_time = time(nullptr);
					if (block_->planted - current_time > 0) {
						if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That's not done charging!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					else {
						int give_back_item = 2204;

						int c_ = 1;
						if (modify_inventory(peer, give_back_item, c_) == 0) {

							PlayerMoving data_effect_{};
							data_effect_.packetType = 19;
							data_effect_.punchX = give_back_item;
							data_effect_.punchY = pInfo(peer)->netID;
							data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
							BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
							raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 5;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							block_->flags = (block_->flags & 0x00400000 ? block_->flags ^ 0x00400000 : block_->flags);
							form_visual(blc, *block_, *world_, peer, false, true);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
							block_->id = 0, block_->planted = 0;
						}
						else {
							if (block_->hp == -1 or (items[t_].dropChance) < (current_time - block_->lp)) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("No room to pick it up!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
							}
						}
					}
				}
			}
			else if (t_ == 5814) {
				if (world_->guild_id != pInfo(peer)->guild_id && to_lower(pInfo(peer)->tankIDName) == to_lower(world_->owner_name)) {
				}
				else {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("You can't smash a " + items[t_].name + ", the only way to destroy it is to abandon the guild!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					return true;
				}
			}
			else if (items[t_].blockType == BlockTypes::VIP_ENTRANCE) {
				if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) && not pInfo(peer)->dev) {
					if (not pInfo(peer)->dev) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Only the block's owner can break it!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						return true;
					}
				}
			}
			else if (items[t_].blockType == BlockTypes::DISPLAY) {
				if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) and not world_->owner_name.empty() and not pInfo(peer)->dev) {
					if (block_->id != 0) {
						if (not pInfo(peer)->dev) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Only the block's owner can break it!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							return true;
						}
					}
				}
			}
			else if (items[t_].blockType == BlockTypes::SEED and uint32_t((time(nullptr) - block_->planted <= items[block_->fg].growTime ? time(nullptr) - block_->planted : items[block_->fg].growTime)) == items[block_->fg].growTime) {
				if (t_ == 1791) {
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 48, data_.YSpeed = 48, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					world_->blocks[x_ + (y_) * 100].fg = 1790;
					update_tile(peer, x_, y_, 1790, false, true);
					return false;
				}
				if (t_ == 13317 || t_ == 13319) {
					int random = rand() % items[t_].noob_item.size(), itemid = items[t_].noob_item[random].first, got = items[t_].noob_item[random].second, set = 13316;
					if (items[t_].newdropchance != 0 && (rand() % items[t_].newdropchance) < 1 && items[t_].rare_item.size() != 0)  random = (rand() % items[t_].rare_item.size()), itemid = items[t_].rare_item[random].first, got = items[t_].rare_item[random].second;
					WorldDrop drop_seed_{};
					drop_seed_.id = itemid, drop_seed_.count = got, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_seed_);
					if (t_ == 13319) set = 13318;
					world_->blocks[x_ + (y_) * 100].fg = set;
					update_tile(peer, x_, y_, set, false, true);
					return false;
				}
				add_event_xp(peer, 1, "farmer");
				if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 2 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
					pInfo(peer)->C_QuestProgress += items[block_->fg].rarity;
					if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
				if (event_item == 6244) add_points(peer, pInfo(peer)->hand);
				int drop_count = items[block_->fg - 1].rarity == 1 ? (items[block_->fg - 1].farmable ? (rand() % 6) + 5 : (rand() % block_->fruit) + 1) : items[block_->fg - 1].farmable ? (rand() % 6) + 4 : (rand() % block_->fruit) + 1;
				if (thedaytoday == 1 and rand() % 50 < 1) drop_count++;
				if (pInfo(peer)->back == 1746 && pInfo(peer)->feet == 1830 || pInfo(peer)->feet == 1966) { // fuel pack
					if (items[block_->fg - 1].rarity < 100) {// pagal real gt jei rarity virs 100 neduoda double
						int c1746 = 1746, countofitem = 0, removepack = -1;
						modify_inventory(peer, c1746, countofitem);
						if (countofitem >= 1) {
							if (rand() % 100 < 8) { // pagal real gt 10% chance
								modify_inventory(peer, c1746, removepack);
								drop_count *= 2; // pagal real gt double drop count
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = pInfo(peer)->feet == 1966 ? 106 : 50, data_.YSpeed = pInfo(peer)->feet == 1966 ? 106 : 50, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
						}
					}
				}
				if (rand() % 100 < 2 and pInfo(peer)->hand == 6840) {
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 58, data_.YSpeed = 58, data_.x = pInfo(peer)->x + 16, data_.y = pInfo(peer)->y + 16;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					drop_count++;
				}
				if (pInfo(peer)->hand == 1068 && items[block_->fg].rarity < 100) {
					vector<int> list{ 5090, 3088, 5198 };
					if (rand() % 5 < 1) list = { 3086, 3074, 5200, 8910, 7034, 11248, 10132 };
					int item = list[rand() % list.size()], got = 0;
					gamepacket_t p;
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(items[item].hand_scythe_text), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = item == 5198 ? 2 : 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					drop_count = 0;
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 50, data_.YSpeed = 50, data_.x = x_ * 32, data_.y = y_ * 32;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					int chance = 0;
					if (has_playmod2(pInfo(peer), 35)) chance = 5;
					if (rand() % 100 < (80 - chance)) modify_inventory(peer, 1068, got = -1);
				}
				if (harvest_seed(world_, block_, x_, y_, drop_count, pInfo(peer)->netID, peer)) {
					if (drop_count != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("A `w" + items[t_].name + "`` falls out!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
					}
				}
				else if (world_->weather == 8 and rand() % 300 < 2) {
					WorldDrop drop_block_{};
					drop_block_.id = 3722, drop_block_.count = 1, drop_block_.x = x_ * 32 + rand() % 17, drop_block_.y = y_ * 32 + rand() % 17;
					dropas_(world_, drop_block_);
					PlayerMoving data_2{};
					data_2.packetType = 0x11, data_2.x = drop_block_.x, data_2.y = drop_block_.y, data_2.YSpeed = 108;
					BYTE* raw2 = packPlayerMoving(&data_2);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
						send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw2;
				}
				if (drop_count != 0) drop_rare_item(world_, peer, t_ - 1, x_, y_, true);
				return true;
			}
			if (block_->hp == -1 or (items[t_].dropChance) < (time(nullptr) - block_->lp)) {
				bool brokenz = false;
				if (items[t_].blockType != BlockTypes::LOCK && items[t_].blockType != BlockTypes::AUTO_BLOCK && items[t_].blockType != BlockTypes::SUCKER) {
					if (((pInfo(peer)->hand == 9522 or pInfo(peer)->hand == 9520) && items[t_].rarity <= 11) or (pInfo(peer)->necklace == 9376 && (t_ == 3556 or t_ == 9380 or t_ == 9382 or t_ == 3564 or t_ == 9380 or t_ == 9382)) or (pInfo(peer)->hand == 2952 && (t_ == 2 or t_ == 14)) or (pInfo(peer)->hand == 7434 && (t_ == 1536 or t_ == 850 or t_ == 442)) or pInfo(peer)->hit1 || pInfo(peer)->hand == 9914 || pInfo(peer)->hand == 10384 || pInfo(peer)->hand == 10126 || pInfo(peer)->hand == 9846 || pInfo(peer)->hair == 9920 || pInfo(peer)->hair == 10122 || pInfo(peer)->necklace == 10176 || pInfo(peer)->hand == 9974 || pInfo(peer)->hand == 10020 || pInfo(peer)->hand == 9770 || pInfo(peer)->hand == 9772 || pInfo(peer)->hand == 9906 || pInfo(peer)->hand == 9908 || pInfo(peer)->hand == 9916 || pInfo(peer)->hand == 9918 || pInfo(peer)->hand == 10290 || pInfo(peer)->hand == 13702 || pInfo(peer)->hand == 13700 || pInfo(peer)->hand == 13704) brokenz = true;
				}
				if (brokenz) {
					PlayerMoving data_{};
					data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.x = x_ * 32 + 16, data_.plantingTree = 300, data_.y = y_ * 32 + 16, data_.XSpeed = t_;
					BYTE* raw = packPlayerMoving(&data_);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
					}
					delete[] raw;
					block_->hp = 1;
				}
				else {
					int breakhits = items[t_].breakHits;
					if (pInfo(peer)->punch_decrease) breakhits *= 1.2;
					if (pInfo(peer)->xenonite & Gtps3::XENONITE_FORCE_STRONG_PUNCH or (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_9 && pInfo(peer)->disable_cheater == 0)) block_->hp = breakhits - items[t_].breakHits / 4;
					else if (pInfo(peer)->xenonite & Gtps3::XENONITE_BLOCK_STRONG_PUNCH) block_->hp = breakhits;
					else {
						if (pInfo(peer)->punch_modifier >= 1) {
 							block_->hp = breakhits - (breakhits / 4);
							if (pInfo(peer)->punch_modifier >= 2) block_->hp = breakhits - (breakhits / 4);
						}
						else block_->hp = breakhits;
					}
					if (pInfo(peer)->hair == 9554 or pInfo(peer)->hand == 8440 or pInfo(peer)->hand == 9548 or pInfo(peer)->hand == 9812 or pInfo(peer)->hand == 9878) block_->hp = 3;
					else if (pInfo(peer)->hand == 9874 or pInfo(peer)->hand == 9880)  block_->hp = 2;
					else if (pInfo(peer)->hand == 3932 || pInfo(peer)->hand == 3934) block_->hp += 7;
					if (t_ == 9568 || t_ == 9566) block_->hp = (pInfo(peer)->hand == 3932 ? 30 : 9000);
					if (pInfo(peer)->hand == 8440) block_->hp = 3;
				}
				if (pInfo(peer)->hand == 9522) {
					int got = 0;
					if (rand() % 100 < (30)) modify_inventory(peer, 9522, got = -1);
				}
				block_->lp = time(nullptr);
			}
			block_->hp -= 1;
			if (block_->hp == 0) { /*isgriove*/
				bool ignore_reset = false;
				if (t_ == 1618 and pInfo(peer)->ONGame) {
					bool gamefound = false;
					int gamex = 0, gamey = 0;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == 1660 and world_->blocks[i_].enabled) {
							gamex = i_ % 100; gamey = i_ / 100;
							gamefound = true;
							break;
						}
					}
				}
				if (items[t_].blockType == BlockTypes::MAGIC_EGG) drop_from_magic_egg(peer, world_, block_, x_, y_);
				else if ((items[t_].blockType == BlockTypes::VENDING && block_->c_ + block_->wl != 0) or (t_ == 6954 && block_->c_ != 0) or (t_ == 10358 && block_->wl != 0) or (items[t_].blockType == BlockTypes::SUCKER && block_->pr > 0) or (items[t_].blockType == BlockTypes::DONATION && block_->donates.size() != 0) or (items[t_].blockType == BlockTypes::Display_Shelf && (block_->shelf_1 + block_->shelf_2 + block_->shelf_3 + block_->shelf_4 != 0))) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Empty the " + items[t_].name + " before breaking it!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
					return true;
				}
				else if (t_ == 392 || t_ == 3402 || t_ == 9350 || t_ == 9976) drop_valentine_box(peer, world_, block_, x_, y_);
				else if (t_ == 9572) { // minecraft tnt
				tnt:
					vector<int> random_xy{ 2, 1, 0, -1, -2 };
					update_tile(peer, x_, y_, 0, false, true);
					for (int i = 0; i < 8; i++) {
						int randomx = random_xy[rand() % random_xy.size()] + x_, randomy = random_xy[rand() % random_xy.size()] + y_;
						if (randomx >= 0 && randomx < world_->max_x && randomy > 0 && randomy < world_->max_y) {
							WorldBlock* dropx = &world_->blocks[randomx + (randomy * 100)];
							if (dropx->fg == 9560 || dropx->fg == 9562 || dropx->fg == 9564 || dropx->fg == 9580 || dropx->fg == 9558) {
								gamepacket_t p_t;
								p_t.Insert("OnParticleEffectV2"), p_t.Insert(8), p_t.Insert((float)(randomx * 32) + 16, (float)(randomy * 32) + 16);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
									p_t.CreatePacket(currentPeer);
									update_tile(currentPeer, x_, y_, 0, false, false);
									update_tile(currentPeer, randomx, randomy, 0, false, false);
									if (abs((pInfo(currentPeer)->x / 32) - randomx) <= 1 && abs((pInfo(currentPeer)->y / 32) - randomy) <= 1) SendRespawn(currentPeer, true, 0, 1);
								}
								dropx->fg = 0;
							}
							else if (dropx->fg == 9572) {
								update_tile(peer, randomx, randomy, 0, false, true);
								dropx->fg = 0;
								x_ = randomx;
								y_ = randomy;
								goto tnt;
							}
						}
					}
				}
				else if (items[block_->fg].fossil_rock2) { // fossil rock broken
					if (pInfo(peer)->hand == 3934 && block_->flags & items[t_].block_flag) {
						WorldDrop drop_block_{};
						drop_block_.id = 3936, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 720) { // pinata
					vector<pair<int, int>> receivingitems;
					vector<int> random_xy{ 2, 1, 0, -1, -2 };
					for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
						if (x_ == (world_->drop_new[i_][3] / 32) && y_ == (world_->drop_new[i_][4] / 32)) {
							receivingitems.push_back(make_pair(world_->drop_new[i_][0], world_->drop_new[i_][1]));
							PlayerMoving data_{};
							data_.packetType = 14, data_.netID = 0;
							data_.plantingTree = world_->drop_new[i_][2];
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							world_->drop_new.erase(world_->drop_new.begin() + i_);
						}
					}
					for (int i = 0; i < receivingitems.size(); i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)];
						if (dropx->fg != 0) drop_block_.id = receivingitems[i].first, drop_block_.count = receivingitems[i].second, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = receivingitems[i].first, drop_block_.count = receivingitems[i].second, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 836) { // summer suprise
					pInfo(peer)->summer_total++;
						if (pInfo(peer)->summer_surprise < 20) {
							pInfo(peer)->summer_surprise++;
							gamepacket_t p;
							p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->summer_surprise), p.Insert(0);
							p.CreatePacket(peer);
						}
					vector<int> list{ 12202, 6308, 846, 3702, 8602, 8600, 11068, 832, 2860, 6328, 6324, 6330, 834, 2862, 8612, 4810, 6326, 9744, 3700, 9756, 842, 9748, 11066, 11062, 11064, 840, 850, 3704, 8592, 8594, 3698, 3740, 442, 846, 4804, 3742, 8610, 2856, 844, 11058, 2858, 11040, 822, 838, 4812 }, rare_list{ 1680, 11040, 12192, 12194, 12196, 12198, 12200, 12202, 13626, 13614, 13620, 13618 }, random_xy{ 1, 0, -1 };
					for (int i = 0; i < 3; i++) {
						int item = list[rand() % list.size()];
						WorldDrop drop_block_{};
						if (rand() % 700 < 1) item = rare_list[rand() % rare_list.size()];
						drop_block_.id = item, drop_block_.count = (item == 850 || item == 442 || item == 822 || item == 832 || item == 846 ? 10 : (item == 834 ? 5 : 1));
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
						if (randomx + x_ > 0 && randomx + x_ < world_->max_x && randomy + y_ > 0 && randomy + y_ < world_->max_y) {
							if (world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)].fg != 0) drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
							else drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						}
						else drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 10294) { // organic turkey
					vector<int> list{ 10254, 10280, 9128,9134, 7348, 9132, 10292,10250,11360, 11364, 11362, 12900, 12896 }, rare_list{ 12842, 11352,7350,  10286, 10260, 10252, 11356,  10284, 10274,  10320 , 10258 , 7358 , 10256 , 10282 , }, random_xy{ 1, 0, -1 };
					for (int i = 0; i < 2; i++) {
						int item = list[rand() % list.size()];
						WorldDrop drop_block_{};
						if (rand() % 100 < 1) item = rare_list[rand() % rare_list.size()];
						drop_block_.id = item, drop_block_.count = 1;
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()];
						if (randomx + x_ > 0 && randomx + x_ < world_->max_x && randomy + y_ > 0 && randomy + y_ < world_->max_y) {
							if (world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)].fg != 0) drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
							else drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						}
						else drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 8522 || t_ == 10836 || t_ == 10838 || t_ == 10840 || t_ == 10834 || t_ == 10842 || t_ == 12678) { // Surgery Supply Crate, Fishing Supply Crate, Cooking Supply Crate, Startopia Supply Crate, Superhero Supply Crate
					WorldDrop drop_block_{};
					for (int i = 0; i < items[t_].noob_item.size(); i++) {
						drop_block_.id = items[t_].noob_item[i].first, drop_block_.count = items[t_].noob_item[i].second, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 1618 and pInfo(peer)->ONGame) {
					bool gamefound = false;
					int gamex = 0, gamey = 0;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == 1660 and world_->blocks[i_].enabled) {
							gamex = i_ % 100; gamey = i_ / 100;
							gamefound = true;
							break;
						}
					}
					if (gamefound and pInfo(peer)->ONGame) {
						int Team_Data = (pInfo(peer)->Game_Team == "Red Rabbits" ? 0 : (pInfo(peer)->Game_Team == "Blue Bombers" ? 1 : (pInfo(peer)->Game_Team == "Yellow Yaks" ? 2 : (pInfo(peer)->Game_Team == "Purple Penguins" ? 3 : 4))));
						WorldBlock* gamegen_ = &world_->blocks.at(gamex + (gamey * 100));
						bool Fail = false;
						if (!gamegen_->GameGen.Smash1 and !gamegen_->GameGen.Smash2) Fail = true;
						else if (gamegen_->GameGen.Smash2 and block_->id != Team_Data) Fail = true;
						else if (gamegen_->GameGen.Smash1 and block_->id == Team_Data) Fail = true;
						if (Fail) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == pInfo(peer)->world) p.CreatePacket(currentPeer);
							}
							break;
						}
					}
				}
				else if (t_ == 10716) { /*Easter Mission Item*/
					vector<int> clothes_;
					string color = "`2";
					bool legendary = false;
					bool untradeable = false;
					for (int i = 0; i < items.size(); i++) {
						if (items[i].blockType != CLOTHING) continue;
						clothes_.push_back(i);
					}
					uint32_t reward = clothes_[rand() % clothes_.size()];
					if (items[reward].untradeable) untradeable = true;
					if (reward == 1780 or reward == 1782 or reward == 1784 or reward == 2592 or reward == 6026 or reward == 7734 or reward == 8306 or reward == 11140 or reward == 11142) legendary = true;
					if (untradeable) color = "`#";
					if (legendary) color = "`9";
					gamepacket_t p;
					p.Insert("OnParticleEffect");
					p.Insert((legendary ? 90 : 182));
					p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (legendary) {
							variants::OnConsoleMessage(currentPeer, (!pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`o: The power of abies dropped " + color + items[reward].name + "``!");
							variants::OnPlaySound(currentPeer, "audio/double_chance.wav");
						}
						if (pInfo(currentPeer)->world == world_->name) {
							variants::OnConsoleMessage(currentPeer, (!pInfo(peer)->d_name.empty() ? pInfo(peer)->d_name : pInfo(peer)->name_color + pInfo(peer)->tankIDName) + "`o: The power of abies dropped " + color + items[reward].name + "``!");
							variants::OnTalkBubble(currentPeer, pInfo(peer)->netID, "The power of abies dropped " + color + items[reward].name + "``!", 2, true);
							p.CreatePacket(currentPeer);
						}
					}
					WorldDrop drop_block_{};
					drop_block_.id = reward, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 7628 || t_ == 5136 || t_ == 9386 || t_ == 9384 || t_ == 9902 || t_ == 9380 || t_ == 11156 || t_ == 9600 || t_ == 13160 || t_ == 9814) {
					WorldDrop drop_block_{};
					drop_block_.id = items[t_].randomitem[rand() % items[t_].randomitem.size()], drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (t_ == 5136 || t_ == 9386 || t_ == 9384 || t_ == 9902 || t_ == 9380 || t_ == 9600 || t_ == 9814) {
						if (pInfo(peer)->ghc && t_ == 9902) {
							drop_block_.id = 9906;
						}
						if (t_ == 9814 && (drop_block_.id == 5480 or drop_block_.id == 5638)) {
							gamepacket_t p;
							p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` `4The Power of IOTM Mystery Box! `2" + get_player_nick(peer) + "`` found a `5" + items[drop_block_.id].name + "`` in a `5" + items[t_].name + "``!``");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								p.CreatePacket(currentPeer);
							}
						}
						gamepacket_t p;
						p.Insert("OnParticleEffect");
						p.Insert(182);
						p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) p.CreatePacket(currentPeer);
						}
					}
				}
				else if (t_ == 8426) { // easter crate
					vector<int> list{ 2544, 2548, 2550, 2552, 2546,2544, 2548, 2550, 2552, 2546, 9460, 5960 };
					WorldDrop drop_block_{};
					drop_block_.id = 611, drop_block_.count = rand() % 20 + 20, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if (rand() % 100 < 40) {
						drop_block_.id = list[rand() % list.size()], drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					if (rand() % 100 < 80) {
						if (rand() % 500 < 1) list = { 2554 };
						drop_block_.id = list[rand() % list.size()], drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 13550) { // tropical fruit crate
					WorldDrop drop_block_{};
					drop_block_.id = 2734, drop_block_.count = rand() % 40 + 15, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					drop_block_.id = 13542, drop_block_.count = rand() % 11 + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					drop_block_.id = 13540, drop_block_.count = rand() % 11 + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					drop_block_.id = 13538, drop_block_.count = rand() % 11 + 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					drop_block_.id = 13544, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 542) { // pot o gold duoda 1-200 gems arba ride o gold
					if (rand() % 200 < 1) {
						WorldDrop drop_block_{};
						drop_block_.id = 2574, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					else {
						gems_(peer, world_, rand() % (100 + 1), x_ * 32, y_ * 32, t_);
						//std::thread([=] {gems_(peer, world_, rand() % (200 + 1), x_ * 32, y_ * 32, t_); }).detach();
					}
				}
				else if (t_ == 12260) { // clam chest
					if (rand() % 50 < 1) {
						WorldDrop drop_block_{};
						drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						drop_block_.id = 12262;
						dropas_(world_, drop_block_);
					}
					else add_pearl(peer, rand() % 10 + 1);
				}
				else if (t_ == 12252) { // clam chest
					if (rand() % 10 < 1) {
						update_tile(peer, x_, y_, block_->fg = 12254, false, true);
						ignore_reset = true;
					}
					if (rand() % 15 < 1 && ignore_reset == false)add_pearl(peer, rand() % 10 + 1);
					if (rand() % 16 < 1 && ignore_reset == false) {
						update_tile(peer, x_, y_, block_->fg = 12260, false, false);
						ignore_reset = true;
					}
				}
				else if (t_ == 9566 || t_ == 9568) { // gold ore
					if (rand() % 650 < 1) {
						vector<int> list{};
						if (t_ == 9566) list = { 9912, 9558, 9560, 9562,9564, 9572,9578, 9582,9580, 9584, 9586, 9588, 128, 260,604,1822,1978,2262,2722,3402,9350,9578 };
						else list = { 9912, 2002,  9558, 9560, 9562,9564, 9572,9578, 9582,9580, 9584, 9586, 9588, 128, 260,604,1822,1978,2262,2722,3402,9350,9578 ,9558, 9560, 9562,9564, 9572,9578, 9582,9580, 9584, 9586, 9588, 9576, 9578,9536,318,1466,1796,1836,1938,1940,1944,2450,2714,3424,4746 };
						WorldDrop drop_block_{};
						drop_block_.id = list[rand() % list.size()], drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
					else {
						gems_(peer, world_, rand() % ((9566 ? 250 : 750) + 1), x_ * 32, y_ * 32, t_);
						//std::thread([=] {gems_(peer, world_, rand() % ((9566 ? 500 : 1500) + 1), x_ * 32, y_ * 32, t_); }).detach();
					}
				}
				else if (t_ == 3604) { // gold treasure
					vector<int> list{ 112, 3582, 262, 826, 828, 2812, 3606, 3574, 10102, 11228 ,3604 };
					vector<int> rare{ 12280, 12284, 12290, 112, 3582, 262, 826, 828, 2812, 3606, 3574, 10102, 11228, 3604, 2002, 12308 };
					if (rand() % 500 < 1) list = { 12280, 12284, 12290, 112, 3582, 262, 826, 828, 2812, 3606, 3574, 10102, 11228, 3604, 2002 };
					int item = list[rand() % list.size()];
					if (item == 112) {
						gems_(peer, world_, rand() % (300 + 100), x_ * 32, y_ * 32, t_);
						//std::thread([=] { gems_(peer, world_, rand() % (500 + 100), x_ * 32, y_ * 32, t_); }).detach();
					}
					else {
						WorldDrop drop_block_{};
						drop_block_.id = item, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (t_ == 10004) { // super summer suprise
					vector<int> list{ 12352, 3704, 3698, 9754, 842, 3700, 9750, 3702, 3702, 9750, 9746, 3700, 842, 9754, 3698, 1670, 1680, 3704, 3764, 4822, 2874, 8614, 12192, 12194, 12196, 12198, 12200, 12202 };
					int item = list[rand() % list.size()];
					if (rand() % 850 < 1) {
						list = { 9758, 3764, 11012, 9730, 1670, 1680, 4822, 12188, 12186, 13572, 13610, 13608, 13566 };
						item = list[rand() % list.size()];
						string texts = "A `4" + items[t_].ori_name + "`` rewards `2" + get_player_nick(peer) + "`` with a `5Rare " + items[item].ori_name + "``.";
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							p.CreatePacket(currentPeer);
						}
					}
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 11038) { //summer artifacts
					vector<int> list{ 12352, 3764, 3702, 9746, 9750, 3700, 842, 9754, 2874, 8614, 3698, 1670, 11040, 11042, 8616, 8618, 1676, 8590, 9732, 9732, 2868, 4822, 1668, 11046, 1678, 1664, 844, 2864, 3764, 6308, 6310, 6306, 6322, 1670, 4816, 4818, 2870, 2872, 2874, 2802, 1666, 4814 };
					WorldDrop drop_block_{};
					if (phoenix_items_all.size() != 0) {
						if (rand() % 50 < 1) {
							drop_block_.id = phoenix_items_all[rand() % phoenix_items_all.size()];
							phoenix_items_all.erase(remove(phoenix_items_all.begin(), phoenix_items_all.end(), drop_block_.id), phoenix_items_all.end());
							string texts = "A `4" + items[t_].ori_name + "`` rewards `2" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` with a `5Rare " + items[drop_block_.id].ori_name + "``.";
							gamepacket_t p;
							p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								p.CreatePacket(currentPeer);
							}
						}
					}
					if (rand() % 50 < 1) {
						list = { 10004 , 1680 };
						drop_block_.id = list[rand() % list.size()];
					}
					drop_block_.count = 1, drop_block_.id = (drop_block_.id == 0 ? list[rand() % list.size()] : drop_block_.id), drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 9530) { //tiktok
					vector<int> list{ 412, 414, 416, 418, 420, 422, 424, 426, 4192, 4634, 4636, 4638, 4640, 4642, 5370, 5726, 5728, 5730, 6030, 6032, 6034, 6808, 6810, 6812, 7218, 7220, 7222, 7224, 10528, 10530, 10532, 10828, 10830, 10832 };
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (rand() % 3000 < 1) {
						list = { 412, 414, };
					}
					drop_block_.count = 50, drop_block_.id = list[rand() % list.size()], drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 10826) { // lava pinata
					vector<int> list{ 6042, 10818, 2640, 9610, 2638, 9634, 9632, 10800, 10804, 1570, 9608, 11876 };
					if (rand() % 35 < 1) {
						list = { 10168 , 11288, 13454, 13456 , 13422, 13440, 13426, 13420, 13444 , 13450 , 13448 }; // chance of receiving rare item
						/*
						if (Cinco_De_Mayo.volcanic_wings < 48) {
							list.push_back(11870);
							list.push_back(13434);
						}
						if (Cinco_De_Mayo.volcanic_cape < 48) {
							list.push_back(10806);
							list.push_back(13432);
						}
						if (Cinco_De_Mayo.volcanic_pauldrons < 48) {
							list.push_back(13428);
							list.push_back(13430);
						}*/
					}
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()], drop_block_.count = (drop_block_.id == 10818 ? 20 : 1), drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
					if ( drop_block_.id == 13434 || drop_block_.id == 13432 || drop_block_.id == 13430 ||drop_block_.id == 10168 || drop_block_.id == 11288 || drop_block_.id == 10806 || drop_block_.id == 11870) {
						/*
						if (drop_block_.id == 11870 || drop_block_.id == 13434) Cinco_De_Mayo.volcanic_wings++;
						if (drop_block_.id == 10806 || drop_block_.id == 13432) Cinco_De_Mayo.volcanic_cape++;
						if (drop_block_.id == 13428 || drop_block_.id == 13430) Cinco_De_Mayo.volcanic_pauldrons++;*/
						gamepacket_t p;
						p.Insert("OnConsoleMessage"), p.Insert("The `4Lava Pinata`` rewards " + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` with a `5Rare " + items[drop_block_.id].ori_name + ".``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							p.CreatePacket(currentPeer);
						}
					}
				}
				else if (t_ == 718) { // ultra pinata
					
					if (pInfo(peer)->pinata_claimed == false && pInfo(peer)->pinata_prize == false) {
						pInfo(peer)->pinata_claimed = true;
						gamepacket_t p;
						p.Insert("OnProgressUIUpdateValue"), p.Insert(pInfo(peer)->pinata_claimed ? 1 : 0), p.Insert(pInfo(peer)->pinata_prize ? 1 : 0), p.CreatePacket(peer);
					}
					vector<int> list{ 11900,13442, 13438, 4672, 9614 , 10812 , 9634 , 9632 , 9608 , 704 , 6058 , 3598 , 9624 , 9626 , 706 , 10818 , 6052 , 712 , 708 ,4736, 1568, 4724, 4728, 4726, 2634, 714, 10816, 720, 2632, 702, 8316, 8320, 8322, 8318, 10828, 700, 700, 2630, 11892, 11898, 11896 };
					if (pInfo(peer)->hair == 1568) list.insert(list.end(), { 1580, 8324, 6042, 2638,9622,9630, 8326, 10808, 10802, 2640, 10882 });
					if (rand() % 25 < 1) {
						list = { 10826,  8314 }; // chance of receiving rare item
						if (pInfo(peer)->hair == 1568)  list.insert(list.end(), { 13424, 8310,4664,3594, 1570, 9610,10814, 1584, 11874 });
					}
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (drop_block_.id == 3598) drop_block_.count = rand() % 2 + 3;
					else if (drop_block_.id == 9624) drop_block_.count = rand() % 3 + 1;
					else if (drop_block_.id == 2632 || drop_block_.id == 8322) drop_block_.count = rand() % 3 + 2;
					else if (drop_block_.id == 8316) drop_block_.count = rand() % 2 + 2;
					else if (drop_block_.id == 8320) drop_block_.count = 2;
					else if (drop_block_.id == 13438 || drop_block_.id == 13436) drop_block_.count = 5;
					else if (drop_block_.id == 8318) drop_block_.count = rand() % 4 + 1;
					else if (drop_block_.id == 10828) drop_block_.count = 10;
					else if (drop_block_.id == 2630) drop_block_.count = rand() % 2 + 1;
					else if (drop_block_.id == 11892) drop_block_.count = 4;
					else if (drop_block_.id == 11896) drop_block_.count = 3;
					else drop_block_.count = 1;
					drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 9616) { // block de mayo
					vector<int> list{ 11900, 13452, 11900, 716, 11890,9628,6054, 10804, 716, 11890,9628,6054, 10804,  704, 6058, 1568, 1572 , 1580, 10822 };
					if (rand() % 1000 < 1) list = { 9618,  8314, 9612 }; // chance of receiving rare item
					WorldDrop drop_block_{};
					drop_block_.id = list[rand() % list.size()];
					if (drop_block_.id == 716 || drop_block_.id == 1572) drop_block_.count = 6;
					else if (drop_block_.id == 11890) drop_block_.count = 3;
					else drop_block_.count = 1;
					drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 1584) { // mystery pinata
					vector<pair<int, int>> receivingitems;
					vector<int> random_xy{ 2, 1, 0, -1, -2 };
					for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
						if (world_->drop_new[i_][0] == 0) continue;
						if (x_ == (world_->drop_new[i_][3] / 32) && y_ == (world_->drop_new[i_][4] / 32)) {
							receivingitems.push_back(make_pair(world_->drop_new[i_][0], world_->drop_new[i_][1]));
							PlayerMoving data_{};
							data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop_new[i_][2];
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[]raw;
							world_->drop_new.erase(world_->drop_new.begin() + i_);
						}
					}
					for (int i = 0; i < receivingitems.size(); i++) {
						int randomx = random_xy[rand() % random_xy.size()], randomy = random_xy[rand() % random_xy.size()], item = receivingitems[i].first;
						if (item == 1584) item = 3596;
						if (item == 2634) item = 3602;
						if (item == 1580) item = 1586;
						if (item == 3274) item = 4660;
						if (item == 1568) item = 710;
						if (item == 678) item = 1574;
						if (item == 330) item = 1578;
						if (item == 604 || item == 802 || item == 804 || item == 806 || item == 808 || item == 810 || item == 812) item = 2636;
						if (item == 900 || item == 1378) item = 1576;
						if (item == 2160 || item == 2164 || item == 2162 || item == 2158 || item == 2168 || item == 2166) item = 2642;
						if (item == 2614 || item == 2616 || item == 2618) item = 2620;
						if (item == 2606 || item == 2608 || item == 2610) item = 2612;
						if (item == 2598 || item == 2600 || item == 2602) item = 2604;
						if (item == 1570) item = 6044;
						if (item == 414) item = 6030;
						if (item == 2624) item = 6056;
						if (item == 8310) item = 8312;
						WorldDrop drop_block_{};
						WorldBlock* dropx = &world_->blocks[(x_ + randomx) + ((y_ + randomy) * 100)];
						if (dropx->fg != 0) drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
						else drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.x = ((x_ + randomx) * 32) + rand() % 17, drop_block_.y = ((y_ + randomy) * 32) + rand() % 17;
						dropas_(world_, drop_block_);
					}
				}
				else if (block_->fg == 7960) { /*Dark Stone*/
					gamepacket_t p;
					p.Insert("OnParticleEffect");
					p.Insert(182);
					p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16);
					uint32_t reward = dstone[rand() % dstone.size()];
					gamepacket_t p2;
					p2.Insert("OnTalkBubble");
					p2.Insert(pInfo(peer)->netID);
					p2.Insert("The power of The Dark Stone dropped " + items[reward].name + "!");
					p2.Insert(0), p2.Insert(1);
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
						if (pInfo(currentPeer)->world == world_->name) {
							p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
						}
					}
					WorldDrop drop_block_{};
					drop_block_.id = reward, drop_block_.count = 1;
					drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (t_ == 2478) { // locke mystery box
					vector<int> list{ 2472,2470,2474,2466,2468,10116,3758,11222, 12496 };
					vector<int> clothes{ 370, 372, 374, 42, 68, 40, 130, 270, 234, 142, 694, 10034, 140, 76, 48, 44, 34, 36, 122, 238, 66, 38, 90, 208, 272, 144, 2938, 354, 138, 214, 11202, 342, 1846, 210, 234, 250, 1716, 82, 78, 94, 662, 754, 146, 356, 72, 46, 124, 1720, 92, 1122, 212, 84, 1722, 1844, 2718, 70, 4966, 288, 232, 788, 148, 96, 3932, 448, 98, 134, 50, 74, 1504, 494, 266, 852, 132, 2954, 3934, 3060, 3056, 1800, 88, 2960, 1022, 2578, 3164, 86, 302, 1332, 304, 1116, 6788, 894, 492, 1690, 316, 1850, 1718, 1838, 1032, 1860, 1026, 3048, 352, 724, 1590, 798, 488, 1342, 794, 268, 1502, 8884, 1858, 594, 3466, 1314, 1688, 1312, 3590, 446, 1856, 1854, 1516, 1316, 2700, 4968, 4964, 6796, 1862, 310, 290, 296, 6674, 1864, 4954, 1476, 896, 1848, 496, 136, 158, 2958, 2576, 1954, 152, 1126, 796, 1524, 2928, 80, 2934, 150, 1120, 1142, 1478, 154, 9356, 452, 258, 2882, 156, 1140, 3530, 312, 1124, 890, 1330, 3052, 294, 1650, 1652, 348, 1736, 576, 5016, 1708, 292, 1146, 1028, 1762, 600, 11204 };
					vector<int> block{ 231,487,483,2019,427,1757,2009,281,781,329,459,1041,421,2787,2789,1043,2797,181,613,65,4983,283,553,425,4635,987,627,2017,989,61,4639,973,3523,331,265,859,433,253,339,1105,439,4567,333,677,5673,1427,5603,183,10533,5731,7223,10833,6035,6813,1113,1047,653,2811,4703,1429,847,665,485,1613,833,2025,1775,3931,429,3831,423,437,1773,4767,1299,361,667,2815,3473,301,4637,5683,2709,415,955,461,861,9389,5467,2791,2815,1803,419,2027,685,555,741,10531,5729,7221,10831,6033,6811,621,6401,1107,359,3471,855,309,1685,1449,1309,441,1111,221,1431,3065,9307,1257,1501,1109,4641,3587,1103,417,743,431,3823,2949,1131,3825,727,5379,729,187,787,5459,4785,3261,3521,2293,2309,2321,2333,5461,3721,327,247,63,3479,445,4783,299,863,8935,1451,261,1871,1499,455,9391,683,1159,551,1745,411,3005,557,687,4799,559,4643,3899,1605,9309,567,565,1155,3827,1327,1767,993,1157,563,4721,115,1423,10515,1329,6545,287,669,777,5463,1655,1599,561,4585,3413,4745,1771,2011,1161,1729,3757,3753,321,3265,3263,623,775,6397,129,4667,759,3767,1529,6543,4707,3835,1435,651,8929,569,527,3287,1595,6063,2795,1003,1731,4943,4963,597,4669,1531,1523,625,4297,599,657,571,873,3755,2969,1725,4603,1447,3267,5375,1683,3567, 13, 57, 17, 381, 1139, 21, 101, 379, 117, 27, 23, 581, 195, 105, 191, 377, 1307, 697, 881, 167, 185, 1323, 165, 3783, 369, 25, 171, 53, 103, 179, 29, 249, 177, 1325, 337, 189, 169, 55, 223, 175, 885, 119, 3573, 199, 549, 681, 655, 107, 163, 31, 671, 889, 887, 193, 127, 1433, 173, 7631, 413, 3571, 3569, 2809, 9393, 225, 111, 109, 201, 59, 607, 285, 2029, 2013, 2015, 1611, 995, 997, 963, 1481, 219, 197, 2023, 2021, 9331, 1305, 823, 1039, 231, 487, 483, 2019, 427, 1757, 2009, 281, 781, 329, 459, 1041, 421, 2787, 2789, 1043, 2797, 181, 613, 65, 4983, 283, 553, 425, 4635, 987, 627, 2017, 989, 61, 4639, 973, 3523, 331, 265, 859, 433, 253, 339, 1105, 439, 4567, 333, 677, 5673, 1427, 5603, 183, 10533, 5731, 7223, 10833, 6035, 6813, 1113, 1047, 653, 2811, 4703, 1429, 847, 665 };
					int item = block[rand() % block.size()];
					if ((rand() % 2) + 1 == 2) item = clothes[rand() % clothes.size()];
					else {
						if ((rand() % 2) + 1 == 2) item = block[rand() % block.size()] - 1;
						else item = block[rand() % block.size()];
					}
					if (rand() % 25 < 1) item = list[rand() % list.size()];
					WorldDrop drop_block_{};
					drop_block_.id = item, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				else if (items[t_].properties & Property_AutoPickup) {
					if (t_ == 9948) t_ = 9946;
					if (t_ == 5814) t_ = 242;
					int c_ = 1;
					if (items[t_].blockType == BlockTypes::LOCK and t_ != 202 && t_ != 204 && t_ != 206 && t_ != 4994 && t_ != 10000) {
						if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) && pInfo(peer)->superdev == 0) return true;
						int id = 4516;
						vector<WorldBlock>::iterator p = find_if(world_->blocks.begin(), world_->blocks.end(), [id](const WorldBlock& a) { return a.fg == id; });
						if (p != world_->blocks.end()) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`4Remove Untrade-a-Box before removing lock!``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
					}
					else if (items[t_].blockType == BlockTypes::STORAGE) {
						vector<WorldSBOX1>::iterator p = find_if(world_->sbox1.begin(), world_->sbox1.end(), [&](const WorldSBOX1& a) { return a.x == pInfo(peer)->lastwrenchx && a.y == pInfo(peer)->lastwrenchy; });
						if (p != world_->sbox1.end()) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Empty the " + items[t_].name + " before breaking it!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
					}
					else if (items[t_].blockType == BlockTypes::SUCKER) {
						if (block_->pr > 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Empty this " + items[t_].name + " before breaking!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							return true;
						}
					}
					else if (items[t_].blockType == BlockTypes::WEATHER) {
						if (world_->weather != 0) {
							world_->weather = 0;
							if (pInfo(peer)->lock == 11550)world_->weather = 54;
							else if (pInfo(peer)->lock == 11586)world_->weather = 55;
							else if (pInfo(peer)->lock == 10410)world_->weather = 53;
							else if (pInfo(peer)->lock == 11902)world_->weather = 58;
							else if (pInfo(peer)->lock == 12654)world_->weather = 63;
							else if (pInfo(peer)->lock == 13200)world_->weather = 67;
							if (world_->d_weather != 0) world_->weather = world_->d_weather;
							gamepacket_t p;
							p.Insert("OnSetCurrentWeather");
							if (comet_dust) p.Insert(16);
							else p.Insert(world_->weather == 0 ? 80 : world_->weather);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									p.CreatePacket(currentPeer);
								}
							}
						}
					}
					else if ((items[t_].blockType == BlockTypes::AUTO_BLOCK or t_ == 6954) && block_->pr > 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`4Be careful``, if you return this to your backpack you will `4lose ALL`` Gems stored within! Use them up first!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`4Be careful``, if you return this to your backpack you will `4lose ALL`` Gems stored within! Use them up first!");
							p.CreatePacket(peer);
						}
						return true;
					}
					if (modify_inventory(peer, t_, c_, false) == 0) {
					 if (items[t_].blockType == BlockTypes::LOCK) {
						if (t_ == 202 or t_ == 204 or t_ == 206 or t_ == 4994 or t_ == 10000) remove_lock_broken(world_, block_, x_, y_);
						else {
							if (to_lower(pInfo(peer)->tankIDName) == to_lower(world_->owner_name)) {
								pInfo(peer)->worlds_owned.erase(remove(pInfo(peer)->worlds_owned.begin(), pInfo(peer)->worlds_owned.end(), world_->name), pInfo(peer)->worlds_owned.end());
							}
							else {
								bool on_ = false;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(world_->owner_name)) {
										pInfo(currentPeer)->worlds_owned.erase(remove(pInfo(currentPeer)->worlds_owned.begin(), pInfo(currentPeer)->worlds_owned.end(), world_->name), pInfo(currentPeer)->worlds_owned.end());
										on_ = true;
										break;
									}
								}
							}
							if (t_ == 11902 || t_ == 11550 || t_ == 13200 || t_ == 11586 || t_ == 10410 || t_ == 12654) {
								world_->weather = 0;
								if (world_->d_weather != 0) world_->weather = world_->d_weather;
							}
							int got = 0, got2 = 0;
							modify_inventory(peer, 1424, got);
							modify_inventory(peer, 1424, got *= -1);
							modify_inventory(peer, 5816, got2);
							modify_inventory(peer, 5816, got2 *= -1);
							world_->owner_name = "", world_->owner_named = "", world_->entry_level = 1, world_->music_bpm = 100;
							world_->world_settings = 0;
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("`5[```w" + world_->name + "`` has had its `$World Lock`` removed!`5]``");
							if (pInfo(peer)->superdev) {
								send_logs(pInfo(peer)->tankIDName + " broke lock " + " in World: [" + pInfo(peer)->world + "]", "Sdev Break LOCK");
							}
							pInfo(peer)->name_color = (pInfo(peer)->give_role ? "`8@" : pInfo(peer)->Staff ? "`4@" : pInfo(peer)->superdev ? "`8@" : pInfo(peer)->dev ? "`6@" : (pInfo(peer)->mod) ? "`#@" : (to_lower(pInfo(peer)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
							nick_update_2(peer, NULL);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									pInfo(currentPeer)->disable_cheater = world_->world_settings & Gtps3::SETTINGS_12;
									if (t_ == 11902 || t_ == 11550 || t_ == 13200 || t_ == 11586 || t_ == 10410 || t_ == 12654) {
										gamepacket_t p21;
										p21.Insert("OnSetCurrentWeather");
										if (comet_dust) p21.Insert(16);
										else p21.Insert(world_->weather == 0 ? 80 : world_->weather);
										p21.CreatePacket(currentPeer);
									}
									pInfo(currentPeer)->world_owner.clear();
									pInfo(currentPeer)->access_offers.clear();
									p.CreatePacket(currentPeer);
									pInfo(currentPeer)->name_color = (pInfo(currentPeer)->give_role ? "`8@" : pInfo(currentPeer)->Staff ? "`4@" : pInfo(currentPeer)->superdev ? "`8@" : pInfo(currentPeer)->dev ? "`6@" : (pInfo(currentPeer)->mod) ? "`#@" : (to_lower(pInfo(currentPeer)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
									if (find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(currentPeer)->tankIDName)) != world_->admins.end()) {
										nick_update_2(currentPeer, NULL);
									}
								}
							}
							world_->admins.clear();
						}
					}
					 world_->active_jammers.erase(remove(world_->active_jammers.begin(), world_->active_jammers.end(), t_), world_->active_jammers.end());
						int give_back = t_;
						if (t_ == 9640) give_back = 9640;
						PlayerMoving data_{};
						data_.packetType = 14, data_.netID = -1, data_.plantingTree = give_back;
						data_.x = float(x_) * 32, data_.y = float(y_) * 32;
						int32_t item = -1;
						float val = 1.00;
						BYTE* raw = packPlayerMoving(&data_);
						memcpy(raw + 8, &item, 4);
						memcpy(raw + 16, &val, 4);
						data_.netID = pInfo(peer)->netID;
						world_->total_drop_uid += 1;
						data_.plantingTree = world_->total_drop_uid;
						data_.x = 0, data_.y = 0;
						BYTE* raw2 = packPlayerMoving(&data_);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw, raw2;
						gamepacket_t p(1);
						p.Insert("OnConsoleMessage");
						p.Insert("Collected `w1 " + items[give_back].name + "``.``");
						p.CreatePacket(peer);
					}
					else {
						return true;
					}
				}
				else if (items[t_].max_gems != 0) {
					if (t_ == 2946) {
						if (block_->id != 0) {
							int give_count = 1;
							if (modify_inventory(peer, block_->id, give_count) == 0) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("You picked up 1 " + items[block_->id].ori_name + ".");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(peer);

								{
									gamepacket_t p;
									p.Insert("OnConsoleMessage");
									p.Insert("You picked up 1 " + items[block_->id].ori_name + ".");
									p.CreatePacket(peer);
								}
								PlayerMoving data_effect_{};
								data_effect_.packetType = 19;
								data_effect_.punchX = block_->id;
								data_effect_.punchY = pInfo(peer)->netID;
								data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
								BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
								raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 5;
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]raw_effect;
							}
							else {
								WorldDrop drop_block_{};
								drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17, drop_block_.id = block_->id, drop_block_.count = 1;
								dropas_(world_, drop_block_);
							}
							if (pInfo(peer)->dev) send_logs(pInfo(peer)->tankIDName + " stole " + items[block_->id].ori_name + " in(" + pInfo(peer)->world + ") from Display Block", "Display Block");
						}
					}
				if (pInfo(peer)->grow4good_break < 1000 && pInfo(peer)->grow4good_break != -1) daily_quest(peer, false, "break", 1);
				if (pInfo(peer)->lwiz_step == 3) add_lwiz_points(peer, 1);
				else if (pInfo(peer)->lwiz_step == 11) add_lwiz_points(peer, items[t_].rarity);
					if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 4 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress++;
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					if (pInfo(peer)->C_QuestActive && pInfo(peer)->C_QuestKind == 5 && pInfo(peer)->C_QuestProgress < pInfo(peer)->C_ProgressNeeded) {
						pInfo(peer)->C_QuestProgress += items[t_].rarity;
						if (pInfo(peer)->C_QuestProgress >= pInfo(peer)->C_ProgressNeeded) {
							pInfo(peer)->C_QuestProgress = pInfo(peer)->C_ProgressNeeded;
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`9Ring Quest task complete! Go tell the Ringmaster!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
					}
					if (event_item == 6238) add_points(peer, pInfo(peer)->hand);
					add_peer_xp(peer, (items[t_].rarity / 5 > 0 ? items[t_].rarity / 5 : 1));
					int maxgems = items[t_].max_gems;
					if (t_ == 120) maxgems = 50;
					int c_ = rand() % (maxgems + 1);
					if (c_ != 0) {
						if ((items[t_].properties & Property_Dropless or items[t_].rarity == 999) && (items[t_].max_gems == 0)) {

						}
						else {
							bool no_seed = false, no_gems = false, no_block = false;
							if (t_ == 12254 or t_ == 12252 or t_ == 2242 or t_ == 2244 or t_ == 2246 or t_ == 2248 or t_ == 2250 or t_ == 542 or items[t_].unobtainable or t_ == 5136 || t_ == 9386 || t_ == 9400 || t_ == 9384 || t_ == 9902 || t_ == 9600) no_seed = true, no_block = true, no_gems = true;
							else {
								for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
									if (abs(world_->drop_new[i_][4] - y_ * 32) <= 16 and abs(world_->drop_new[i_][3] - x_ * 32) <= 16) {
										if (world_->drop_new[i_][0] == 112 and items[t_].rarity < 8) {
											no_gems = true;
										}
										else {
											no_seed = true, no_block = true;
										}
									}
								}
							}
							if (items[t_].blockType == BlockTypes::MAGIC_EGG || t_ == 8 || t_ == 6 || t_ == 7372) no_seed = true, no_block = true, no_gems = true;
							int chanced = 0;
							if (thedaytoday == 2) chanced = 5;
							if (t_ != 610 && t_ != 611) {
								if (rand() % 100 < 8) {
									if (pInfo(peer)->hand == 9604 || pInfo(peer)->mask == 8192 || pInfo(peer)->ances == 5144 || pInfo(peer)->ances == 5146 || pInfo(peer)->ances == 5148 || pInfo(peer)->ances == 5150 || pInfo(peer)->ances == 5152 || pInfo(peer)->ances == 5080 && rand() % 250 - (items[pInfo(peer)->ances].chance * items[pInfo(peer)->ances].chance) < 1) {
										WorldDrop drop_block_{};
										drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17, drop_block_.id = t_, drop_block_.count = 1;
										if (not use_mag(world_, drop_block_, x_, y_) and not no_block) dropas_(world_, drop_block_);
									}
									WorldDrop drop_block_{};
									drop_block_.id = t_, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
									if (not use_mag(world_, drop_block_, x_, y_) and not no_block) dropas_(world_, drop_block_);
								}
								else if (rand() % 100 < items[t_].newdropchance + chanced) {
									WorldDrop drop_seed_{};
									drop_seed_.id = t_ + 1, drop_seed_.count = 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
									if (not use_mag(world_, drop_seed_, x_, y_) and not no_seed) dropas_(world_, drop_seed_);
								}
								else if (not no_gems) {
									if (t_ == 8 || t_ == 6 || t_ == 7372) break;
									if (has_playmod2(pInfo(peer), 14) and ((rand() % 100) + 1) <= 30) {
										PlayerMoving data_{};
										data_.packetType = 17, data_.netID = 125, data_.YSpeed = 125, data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw;
										c_ += (rand() % 5) + 1;
									}
									drop_rare_item(world_, peer, t_, x_, y_, false);
									gems_(peer, world_, c_, x_ * 32, y_ * 32, t_);
									//std::thread([=] { gems_(peer, world_, c_, x_ * 32, y_ * 32, t_); }).detach();
								}
								if (t_ == 776) { // toxic waste
									vector<int> random_xy{ 1, 0, -1 };
									for (int i = 0; i < 3; i++) {
										int randomx = random_xy[rand() % random_xy.size()] + x_, randomy = random_xy[rand() % random_xy.size()] + y_;
										if (randomx > 0 && randomx < world_->max_x && randomy > 0 && randomy < world_->max_y) {
											WorldBlock* dropx = &world_->blocks[randomx + (randomy * 100)];
											if (dropx->fg == 0) dropx->fg = 778, update_tile(peer, randomx, randomy, 778, false, true);
										}
									}
									int gotr = rand() % 3 + 1;
									if (rand() % 3 && pInfo(peer)->hand == 10944) {
										gotr += rand() % 3 + 1;
									}
									pInfo(peer)->rubble += gotr;
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("You found " + to_string(gotr) + " Rubbles!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
								}
								else if (t_ == 726) {
									if (rand() % 100 < 40) {
										int gotr = rand() % 3 + 1;
										if (rand() % 3 && pInfo(peer)->hand == 10944) {
											gotr += rand() % 3 + 1;
										}
										pInfo(peer)->rubble += gotr;
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("You found " + to_string(gotr) + " Rubbles!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
						}
					}
				}
				else if (items[t_].blockType == BlockTypes::SEED && block_->invert == 0) {
					if (items[t_ - 1].properties & Property_Dropless or items[t_ - 1].rarity == 999) {

					}
					else {
						//kai isgriauni seed
						if (rand() % 2 < 1) {
							WorldDrop drop_seed_{};
							drop_seed_.id = t_, drop_seed_.count = 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
						}
					}
				}
				else if ((block_->fg == 5638 || block_->fg == 9850 || block_->fg == 10266) and (pInfo(peer)->magnetron_id != 0 and pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_)) {
					int c_ = 0;
					modify_inventory(peer, 5640, c_);
					if (c_ != 0) {
						c_ *= -1;
						modify_inventory(peer, 5640, c_);
						pInfo(peer)->magnetron_id = 0;
						pInfo(peer)->magnetron_x = 0;
						pInfo(peer)->magnetron_y = 0;
					}
				}
				else if (items[block_->fg].blockType == BlockTypes::GEIGER_CHARGER and block_->id != 0) {
					WorldDrop drop_block_{};
					drop_block_.id = 2286, drop_block_.count = 1;
					if (block_->planted - time(nullptr) <= 0) {
						drop_block_.id = 2204;
					}
					drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
					dropas_(world_, drop_block_);
				}
				if (ignore_reset == false) {
					punch_tile(peer, x_, y_, 0x3, p_, pInfo(peer)->netID, 0x0);
					reset_(block_, x_, y_, world_);
				}
			}
			else { /*-1 hp*/
				block_->lp = time(nullptr);
				if (items[block_->fg].blockType == BlockTypes::PROVIDER) {
					uint32_t laikas = uint32_t((time(nullptr) - block_->planted <= items[block_->fg].growTime ? time(nullptr) - block_->planted : items[block_->fg].growTime));
					if (laikas == items[block_->fg].growTime) {
						add_event_xp(peer, 1, "provider");
						vector<double> ids; // svarbu: id.max_kiekis <!= 5 if size after decimal point == 2 then count fixed
						int extra_count = 0;
						if (block_->fg == 866) { // cow
							ids = { 868.2 };
						}
						else if (block_->fg == 872) { // chicken
							ids = { 874.2 };
						}
						else if (block_->fg == 1044) { // buffalo
							ids = { 868.2 };
						}
						else if (block_->fg == 3888) { // sheep
							ids = { 3890.3 };
						}
						else if (block_->fg == 1632) { // coffee maker
							ids = { 1634 };
						}
						else if (block_->fg == 5116) { // tea set
							ids = { 5114 };
						}
						else if (block_->fg == 2798) { // well
							ids = { 822.2 };
						}
						else if (block_->fg == 10450) { // diamond builder
							//daily_quest_winterfest(peer, false, "22", 1);
							ids = { 12942, 12944, 12946, 12948, 12950.5, 12952.3, 12954.3, 10454, 10458.50, 10458.50, 10462.20, 10464.30, 10466.30, 10468.50, 10470.30, 10472.20, 10474.30, 10476.20, 10478.20, 10480.30, 10482, 10484.30, 10460 };
						}
						else if (block_->fg == 8196) { // building blocks machine
							ids = { 13628.2, 13602.2,  578.1, 1174.1, 3006.1, 5494.1, 8004.1, 10010.1, 10022.1, 10572.1, 11590.1, 6390.1, 6544.5, 6394.1, 6396.1, 6400.1, 6402.1, 6404.1, 6392.1, 6406.1, 6408.1, 390.1, 392.1, 1514.1, 5384.1, 5386.1, 5388.1, 5390.1, 5392.1,1196.1, 716.1, 1356.1, 7452.1, 1358.1,1362.1, 10056.1, 7942.1, 5470.1, 5472.1, 5474.1, 5476.1, 5478.1,4376.1, 5520.1, 7658.1, 9240.1, 10544.1, 11564.1, 12998.1, 9740.1, 12006.1, 13350.1, 11738.1, 8984.1, 8986.1, 8222.1, 11056.1, 11278.1, 5476.1, 5472.1, 5478.1, 5470.1, 5474.1, 3146.1, 4206.1,  8824.1, 8826.1, 8828.1, 10376.5, 10018.1, 9994.5, 9992.5, 9990.5, 9988.10, 13384.1, 12532.5, 12530.5, 12534.5, 11732, 4920.3, 4878, 7524.3, 7528.5, 7526.3, 4922.3, 7522.10, 7520.10, 2280.5, 4372.5, 716.3, 1572.3, 11898.5, 2596.3, 714, 2632.3, 2630.2, 6180.5, 6182.5, 6184.5, 7846.10, 7848.10, 7272.5, 7284.5, 334.5, 4630, 4632, 8214.10, 8206.10, 8228.10, 4944.10, 8236.10, 4942.10, 8238.10, 8234.10, 8232.10, 8216.10, 8220.5, 8218.10, 8230.10, 8210.10, 952, 1110.5, 2708.3, 1112.5, 264.5, 8208.10, 414.5, 426.5, 420.5, 4634.5, 848.3, 2860.5, 6324.5, 2862.5, 8994.5, 8990.5, 11192.3, 8200.10, 10060.1, 8202.10, 8204.5, 8992.10, 8224.3, 8832.3, 8226.3, 11194.5, 8212.5, 8988.10 }; // ne visi
						}
						else if (block_->fg == 8172) { // Item-O-Matic
							ids = { 8174, 8176, 8178, 8180, 8182 };
						}
						else if (block_->fg == 8160) { // Item-O-Matic
							ids = { 8162, 8164, 8166, 8168, 8170 };
						}
						else if (block_->fg == 8148) { // Item-O-Matic
							ids = { 8150, 8152, 8154, 8156, 8158 };
						}
						else if (block_->fg == 8136) { // Item-O-Matic
							ids = { 8138, 8140, 8142, 8144, 8146 };
						}
						else if (block_->fg == 8124) { // Item-O-Matic
							ids = { 8126, 8128, 8130, 8132, 8134 };
						}
						else if (block_->fg == 8112) { // Item-O-Matic
							ids = { 8114, 8116, 8118, 8120, 8122 };
						}
						else if (block_->fg == 8100) { // Item-O-Matic
							ids = { 8102, 8104, 8106, 8108, 8110 };
						}
						else if (block_->fg == 8088) { // Item-O-Matic
							ids = { 8090, 8092, 8094, 8096, 8098 };
						}
						else if (block_->fg == 8076) { // Item-O-Matic
							ids = { 8078, 8080, 8082, 8084, 8086 };
						}
						else if (block_->fg == 7766) { // hatching stone egg
							ids = { 7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7780,7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7780 , 7752, 7748, 7754, 7758, 7760, 12296 };
						}
						else if (block_->fg == 7770) { // hatching ghost egg
							ids = { 7750, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760 };
						}
						else if (block_->fg == 7774) { // hatching water egg
							ids = { 7756, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760 };
						}
						else if (block_->fg == 7778) { // hatching void egg
							ids = { 7762, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760 };
						}
						else if (block_->fg == 8050) { // Hatching Easter Egg
							ids = { 8046, 11788,  7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760 };
						}
						else if (block_->fg == 9302) { //Hatching Euphoric Dragon Egg
							ids = { 9254, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760, 7752, 7748, 7754, 7758, 7760 };
						}
						else if (block_->fg == 4858) { // balloon machine
							ids = { 4844, 4844, 4844, 4844,4844, 4846, 4846, 4848 };
						}
						else if (block_->fg == 11472) { // winterfest 2021 calendar
							ids = { 8802.5, 8800.5, 5428.1, 5430.1, 5432.1, 5434.1, 6956.5, 5446.1, 3584.5, 6414.1, 8480.1, 8554.1, 8210.5, 8534.5, 8664.5, 8262.5, 8976.1, 8278.1, 8280.1, 262.1, 263.1, 8728.1, 8556.1, 1368.10, 8246.1, 5382.2, 9202.1, 6986.1, 1360.5, 1384.1, 7006.1, 2564.5, 8980.1, 6970.1, 3676.1, 8254.5, 5376.1, 5792.1, 8546.1, 8712.5, 7864.1, 8984.1, 7490.1, 7496.1, 7498.1, 10486.1, 10488.1, 10444.1, 10220.1, 10258.1, 7758.1, 9356.10, 7080.1, 7082.1, 7084.1, 7086.1, 7088.1, 7090.1, 7092.1, 7094.1, 7096.1, 10032.1, 5780.1, 8722.1, 9692.1, 7760.1, 7418.1, 7420.1, 7422.1, 8948.1, 8960.1, 10036.1, 10038.1, 10040.1, 10042.1, 10440.1, 9184.1, 7718.1, 6384.1, 11514.1, 11520.1, 11202.1, 11192.1 };
							/*
							struct tm newtime;
							time_t now = time(0);
							localtime_s(&newtime, &now);
							if (today_day == 24) ids = { 11500 };
							if (today_day == 25) ids = { 802, 1758, 8468, 263, 812, 10442, 9370, 8474, 5018, 7752, 8556, 9182, 9184 };*/
						}
						else if (block_->fg == 12986) { // winterfest 2022 calendar
							ids = get_winterfest_calendar(block_->shelf_1);
							block_->shelf_1++;
						//	daily_quest_winterfest(peer, false, "11", 1);
						}
						else if (block_->fg == 1008 or block_->fg == 5196) { // atm machine and 3000
							int c_ = (rand() % 250) + 1;
							if (block_->fg == 5196) c_ = (rand() % 500) + 1;
							if (c_ == 250 or c_ == 500) {
								PlayerMoving data_{};
								data_.packetType = 17, data_.netID = 29, data_.YSpeed = 29, data_.x = (x_ * 32) + 16, data_.y = (y_ * 32) + 16;
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw;
							}
							gems_(peer, world_, c_, x_ * 32, y_ * 32, block_->fg);
						}
						else if (block_->fg == 9948) {
							{
								vector<pair<int, int>>::iterator p = find_if(items_washing.begin(), items_washing.end(), [&](const pair < int, int>& element) { return abs(element.first - items[block_->shelf_1].rarity) < 5 && rand() % 10 < 1; });
								if (p != items_washing.end()) {
									ids.push_back(items_washing[p - items_washing.begin()].second);
								}
							}
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							if (ids.size() == 0) {
								ids.push_back(block_->shelf_1);
								p.Insert("Could not wash this..");
							}
							else p.Insert("Washing is completed");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							extra_count = block_->shelf_2;
							block_->shelf_1 = 0, block_->shelf_2 = 0, block_->fg = 9946;
							packet_(peer, "action|play_sfx\nfile|audio/bubble_boil.wav\ndelayMS|0");
						}
						else if (block_->fg == 10656) {
							if (block_->shelf_1 >= 200) {
								drop_valentine_box(peer, world_, block_, x_, y_, true, 0);
								gamepacket_t p;
								p.Insert("OnParticleEffect"), p.Insert(46), p.Insert((float)(x_ * 32) + 16, (float)(y_ * 32) + 16);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									p.CreatePacket(currentPeer);
								}
								block_->shelf_1 = 0, block_->fg = 10658;
							}
						}
						else if (block_->fg == 9962) {
							if (block_->shelf_1 != 0) {
								ids = { 3948 , 3948 , 3948 , 3948 , 3948 , 3946 , 3942 ,3950, 3942 , 3942 , 3944 , 10584 , 4236 ,3948 , 3948 , 3948 , 3948 , 3948 , 3946 , 3942 ,3950, 3942 , 3942 , 3944 , 10584 , 4236 ,3948 , 3948 , 3948 , 3948 , 3948 , 3946 , 3942 ,3950, 3942 , 3942 , 3944 , 10584 , 4236 ,3948 , 3948 , 3948 , 3948 , 3948 , 3946 , 3942 ,3950, 3942 , 3942 , 3944 , 10584 , 4236 ,3948 , 3948 , 3948 , 3948 , 3948 , 3946 , 3942 ,3950, 3942 , 3942 , 3944 , 10584 , 4236 ,3948 , 3948 , 3948 , 3948 , 3948 , 3946 , 3942 ,3950, 3942 , 3942 , 3944 , 10584 , 4236 , 10220 , 4126 ,6800 };
								if (block_->shelf_1 == 3936)  ids.insert(ids.end(), { 3940,11220 });
								block_->shelf_1 = 0, block_->fg = 9960;
							}
						}
						else if (block_->fg == 12680) { // wonder Provider
							ids = { 12686.5, 12688.10, 12690.10, 12692.10, 12694.2, 12696.2, 12698.10, 12700.10, 12702.2, 12704.10, 12706.10, 12708.10, 12710.10, 12712.10, 12714.10, 12716.10, 12718.10, 12720.2, 12722.1, 12724.10,12686.5, 12688.10, 12690.10, 12692.10, 12694.2, 12696.2, 12698.10, 12700.10, 12702.2, 12704.10, 12706.10, 12708.10, 12710.10, 12712.10, 12714.10, 12716.10, 12718.10, 12720.2, 12722.1, 12724.10, 12686.5, 12688.10, 12690.10, 12692.10, 12694.2, 12696.2, 12698.10, 12700.10, 12702.2, 12704.10, 12706.10, 12708.10, 12710.10, 12712.10, 12714.10, 12716.10, 12718.10, 12720.2, 12722.1, 12724.10, 12686.5, 12688.10, 12690.10, 12692.10, 12694.2, 12696.2, 12698.10, 12700.10, 12702.2, 12704.10, 12706.10, 12708.10, 12710.10, 12712.10, 12714.10, 12716.10, 12718.10, 12720.2, 12722.1, 12724.10, 12734, 12736, 12730, 12728, 12732, 12738 };
							block_->shelf_1++;
						}
						else if (block_->fg == 1636) { // Awkward Friendly Unicorn
							ids = { 728, 360, 308, 306, 2966, 1646, 3170, 1644, 1642, 3524, 1640, 1638, 2582, 3198, 8838, 6794, 10110, 12286 };
						}
						else if (block_->fg == 3044) { // Tackle box
							ids = { 2914, 3012,2914, 3012,2914, 3012, 3014,3014, 3016, 3016, 3018,2914, 3012,2914, 3012,2914, 3012, 3014,3014, 3016, 3016, 3018, 5528, 5526, 3020,3432,3098,4248,4246,3218 };
						}
						else if (block_->fg == 6212) { // Surgical Tool Bag
							ids = { 1258, 1260, 1262, 1264, 1266, 1268, 1270, 4308, 4310, 4312, 4314, 4316, 4318 };
						}
						else if (block_->fg == 6414) { // Star Tool Droid
							ids = { 6520, 6538, 6522, 6528, 6540, 6518, 6530, 6524, 6536, 6534, 6532, 6526, 6416 };
						}
						else if (block_->fg == 928) { // Science station
							ids = { 914,914,914,914,914,924,916,916,916,916,924, 918,918,918, 920,920, 924 };
						} if (ids.size() != 0) {
							double rand_item = ids[rand() % ids.size()];
							int count_ = 1;
							bool do_rand = true;
							if (to_string(rand_item).find(".") != string::npos) {
								string asd_ = explode(".", to_string(rand_item))[1];
								string s(1, asd_[0]);
								int c_ = atoi(s.c_str());
								if (c_ != 0) {
									if (asd_.size() == 2) {
										do_rand = false;
										c_ /= 10;
									}
									count_ = c_;
								}
							}
							if (count_ > 1 and do_rand)
								count_ = (rand() % count_) + 1;
							int rand_item2 = (int)rand_item;
							if (extra_count != 0) count_ = extra_count;
							WorldDrop new_drop_{};
							new_drop_.id = rand_item2, new_drop_.count = count_, new_drop_.x = (x_ * 32) + rand() % 17, new_drop_.y = (y_ * 32) + rand() % 17;
							if (not use_mag(world_, new_drop_, x_, y_)) dropas_(world_, new_drop_);
						}
						if (pInfo(peer)->grow4good_provider < pInfo(peer)->grow4good_provider2 && pInfo(peer)->grow4good_provider != -1) daily_quest(peer, false, "provider", 1);
						int timed = 0;
						if (has_playmod(pInfo(peer), "Provider Time Reduced..."))timed = items[block_->fg].growTime * items[pInfo(peer)->ances].chance * 0.001;
						block_->planted = time(nullptr) - (timed);
						if (block_->fg == 9946) block_->planted = 0;
						if ((block_->fg == 12680 && block_->shelf_1 > 7) || (block_->fg == 12986 && block_->shelf_1 >= 25 )|| block_->fg == 7766 || block_->fg == 8050 || block_->fg == 7770 || block_->fg == 7774 || block_->fg == 7778 || block_->fg == 9302) {
							if ((block_->fg == 12680 && block_->shelf_1 > 7)) {
								WorldDrop new_drop_{};
								new_drop_.id = 12682, new_drop_.count = 1, new_drop_.x = (x_ * 32) + rand() % 17, new_drop_.y = (y_ * 32) + rand() % 17;
								dropas_(world_, new_drop_);
								block_->shelf_1 = 0;
							}
							if ((block_->fg == 12986 && block_->shelf_1 >= 25)) {
								WorldDrop new_drop_{};
								new_drop_.id = 12988, new_drop_.count = 1, new_drop_.x = (x_ * 32) + rand() % 17, new_drop_.y = (y_ * 32) + rand() % 17;
								dropas_(world_, new_drop_);
								block_->shelf_1 = 0;
							}
							PlayerMoving data_{};
							data_.packetType = 17, data_.netID = 97, data_.YSpeed = 97, data_.x = x_ * 32 + 16, data_.plantingTree = 150, data_.y = y_ * 32 + 16, data_.XSpeed = block_->fg;
							BYTE* raw = packPlayerMoving(&data_);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw;
							block_->fg = 0;
						}
						if (pInfo(peer)->necklace == 8046) add_peer_xp(peer, 3, true);
						if (pInfo(peer)->lwiz_step == 13) {
							if (pInfo(peer)->lwiz_quest != 5 && pInfo(peer)->lwiz_quest != 6 && pInfo(peer)->lwiz_quest != 7 && pInfo(peer)->lwiz_quest != 8) {
								add_lwiz_points(peer, 1);
							}
						}
						tile_update(peer, world_, block_, x_, y_);
					}
				}
				else if (items[block_->fg].blockType == BlockTypes::RANDOM_BLOCK) {
					block_->roll = (rand() % 6);
					punch_tile(peer, x_, y_, 0x8, 0, pInfo(peer)->netID, 0x0, true, block_->roll);
				}
				else if (items[block_->fg].blockType == BlockTypes::GIVING_TREE) { /*harvest gtree*/
					if (block_->planted - time(nullptr) <= 0) {
						int prize_ = get_givingtree_prize(world_, block_, peer);
						if (block_->shelf_1 <= 5) prize_ = 1360;
						if (prize_ <= 0 or block_->shelf_1 > 100) break;
						int c_ = 1;
						if (modify_inventory(peer, prize_, c_) == 0) {
							console_msg(peer, "I found a `2" + items[prize_].ori_name + "`o under the tree!");
							talk_bubble(peer, pInfo(peer)->netID, "I found a `2" + items[prize_].ori_name + "`w under the tree!", 0, false);
							block_->planted = time(nullptr) + 1800;
							block_->shelf_1 = 0;
							tile_update(peer, world_, block_, x_, y_);
						}
					}
				}
				punch_tile(peer, x_, y_, 0x8, 6, pInfo(peer)->netID, 0x0, (block_->roll != 0 ? true : false), (block_->roll != 0 ? block_->roll : 0));
			}
			break;
		}
		case 32:
		{
			if (items[t_].wrench_by_public == false) {
				if (block_->fg == 202 or block_->fg == 204 or block_->fg == 206 or block_->fg == 4994 or block_->fg == 10000) {
					string owner_name = to_lower(block_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
					if (owner_name != user_name and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							if (find(block_->admins.begin(), block_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != block_->admins.end()) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label|small|This lock is owned by `w" + block_->owner_name + "``, but I have access on it.|left\nend_dialog|lock_edit|Cancel|Remove My Access|");
								p.CreatePacket(peer);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("I'm `4unable`` to pick the lock.");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
							packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
							return true;
						}
					}
				}
				else if (block_->locked and items[p_].blockType != BlockTypes::CONSUMABLE) {
					if (world_->blocks[block_->lock_origin].fg == 242 || items[world_->blocks[block_->lock_origin].fg].blockType != BlockTypes::LOCK) {
						int xa_ = block_->lock_origin % 100, ya_ = block_->lock_origin / 100;
						remove_lock_broken(world_, &world_->blocks[block_->lock_origin], xa_, ya_);
					}
					else {
						WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
						string owner_name = to_lower(block2_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
						if (owner_name != user_name and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
							if (find(block2_->admins.begin(), block2_->admins.end(), user_name) == block2_->admins.end() and not block2_->spin and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								p.CreatePacket(peer);
								{
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("That area is owned by " + block2_->owner_name);
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
								}
								return true;
							}
							if (items[p_].blockType == BlockTypes::LOCK) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("`w" + block2_->owner_named + "`` allows public building here, but no locks.");
								p.Insert(0);
								p.Insert(0);
								p.CreatePacket(peer);
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									p.CreatePacket(peer);
								}
								return true;
							}
						}
					}
				}
				else if (not world_->owner_name.empty() and items[p_].blockType != BlockTypes::CONSUMABLE) {
					string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
					if (owner_name != user_name and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
						if (items[t_].blockType == BlockTypes::LOCK) {
							if (find(world_->admins.begin(), world_->admins.end(), user_name) != world_->admins.end()) {
								gamepacket_t p;
								p.Insert("OnDialogRequest");
								p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label|small|This lock is owned by `w" + world_->owner_name + "``, but I have access on it.|left\nend_dialog|lock_edit|Cancel|Remove My Access|");
								p.CreatePacket(peer);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("I'm `4unable`` to pick the lock.");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
							packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
							return true;
						}
						bool publica = world_->world_settings & Gtps3::SETTINGS_4;
						if (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), user_name) == world_->admins.end() and not publica and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							p.CreatePacket(peer);
							{
								string owner_name = world_->owner_name;
								if (world_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + world_->owner_name;
								if (not world_->owner_named.empty()) owner_name = world_->owner_named;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("That area is owned by " + owner_name + "``");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
							return true;
						}
						if (items[p_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`w" + world_->owner_named + "`` allows public building here, but no locks.");
							p.Insert(0);
							p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								p.CreatePacket(peer);
							}
							return true;
						}
					}
				}
			}
			if (items[t_].blockType == BlockTypes::KRANKEN) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(
					"set_default_color|`o\n"
					"add_label_with_icon|big|`wKranken's Galactic Block``|left|10962|\n"
					"add_spacer|small|\n"
					"add_custom_textbox|`wAdjust the color of your block here, by including 0-255 of Red, Green and Blue.`|size:medium|\n"
					"add_text_input|kranken_r|Red|" + to_string(block_->r) + "|3|\n"
					"add_text_input|kranken_g|Green|" + to_string(block_->g) + "|3|\n"
					"add_text_input|kranken_b|Blue|" + to_string(block_->b) + "|3|\n"
					"add_spacer|small|\n"
					"add_custom_textbox|`wPick one of the available patterns for your block.`|size:medium|\n"
					"add_button_with_icon|kranken_block_pattern|||" + to_string(kranken_pattern::get_pattern(block_->kranken_pattern).second) + "||\n"
					"add_button_with_icon||END_LIST|noflags|0||\n"
					"add_checkbox|kranken_world_save|Set this color as the default for this world.|0\n"
					"end_dialog|kranken_edit|Cancel|Save|\n"
					"add_quick_exit|\n"
					"embed_data|tilex|" + to_string(x_) + "|\n"
					"embed_data|tiley|" + to_string(y_) + "|\n"
					"embed_data|pattern|" + to_string(block_->kranken_pattern) + "|"
				);
				p.CreatePacket(peer);
			}
			else if (t_ == 9922) janeway(peer);
			else if (t_ == 13548) {

			}
			if (items[t_].audio_rack) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].ori_name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_button|manual|Instructions|noflags|0|0|\nadd_spacer|small|\nadd_text_input|volume|Volume|" + to_string(block_->pr) + "|3|\nadd_text_input|text|Notes|" + block_->txt + "|20|\nend_dialog|supermusic|Cancel|Update|\n");
				p.CreatePacket(peer);
			}
			else if (t_ == 5086) {
				string gaylols = "\nadd_textbox|`$You must wear ances";
				if (pInfo(peer)->ances != 0) {
					if (ancesupgradeto(peer, pInfo(peer)->ances) == 0)  gaylols = "\nadd_textbox|`$Your ances is already at the max level!|";
					else gaylols = "\nadd_textbox|Choose an upgrade|\nadd_button|ancientdialog|`0Upgrade to " + items[ancesupgradeto(peer, pInfo(peer)->ances)].name;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`$\nadd_label_with_icon|big|`9Ancient Goddess|left|5086|\nadd_textbox|`$Greetings, mortal! it seems you have ancient thing I|\nadd_textbox|can enhance through magic old. Tell me: Which would|\nadd_textbox|you like to mold? Choose wisely, for once i work my|\nadd_textbox|wonders, it will bound to you for eternity...|\nadd_spacer|small|" + gaylols + "|\nadd_spacer|small|\nadd_quick_exit|\nend_dialog||Return||");
				p.CreatePacket(peer);
			}
			else if (t_ == 5958) {
				if (block_->shelf_4 == 0) block_->shelf_4 = 10;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEpoch Machine``|left|5958|\nadd_spacer|small|\nadd_textbox|Select your doom:|left|\nadd_checkbox|1|Ice Age|" + to_string(block_->shelf_1) + "\nadd_checkbox|2|Volcano|" + to_string(block_->shelf_2) + "\nadd_checkbox|3|Floating Islands|" + to_string(block_->shelf_3) + "\nadd_text_input|cycle|Cycle time (minutes):|" + to_string(block_->shelf_4) + "|5|\nend_dialog|" + to_string(t_) + "|Cancel|Okay|");
				p.CreatePacket(peer);
			}
			else if (t_ == 10656) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWell of Love``|left|10656|\nadd_spacer|small|\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|2|`wLove: " + to_string(block_->shelf_1) + "/200|" + to_string(block_->shelf_1) + "|200``|relative|1|0.95|0|1000|64|0.01\nadd_spacer|small|\nadd_textbox|Give 5 Golden Booty Chests to receive the `2ONE best prize``, and to fill up the well. Once the well is full it will provide one reward with a `53.25% chance`` of getting one of these `5Epic`` items:|left|\nadd_label_with_icon|small| - `5Golden Heart Crystal``|left|1458|\nadd_label_with_icon|small| - `6EXCLUSIVE`` `5Stained Glass Crown``|left|11672|\nadd_label_with_icon|small| - `6EXCLUSIVE`` `5Cotton Candy Cape``|left|13140|\nadd_spacer|small|\nadd_textbox|... or a `5Pure Love Essence`` that doubles the chance of getting a Golden Heart Crystal when opening Golden Booty Chests, Super Golden Booty Chests and Heartstones.|left|\nadd_spacer|small|\nend_dialog|wishing_well|Thanks for the info!||");
				p.CreatePacket(peer);
			}
			else if (t_ == 9828) {
				gamepacket_t p;
				string care = "";
				get_wl_value(peer, care);
				p.Insert("OnDialogRequest"), p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9GTPS Salesman``|left|9828|\nadd_spacer|small|\nadd_image_button||interface/large/salesman_open.rttex||||\nadd_smalltext|Ho there, friend! Locke's my name, and locks are my game. I Love 'em all, Diamond, Huge.. even Small! If you can part with some locks, I'll give you something special in return. Whaddya say?|left|\nadd_spacer|small|" + care + "\nadd_spacer|small|" + shop_list2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
				p.CreatePacket(peer);
			}
			else if (t_ == 12256) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wPearls Shop``|left|12260|\nadd_spacer|small|\nadd_smalltext|Welcome to my bar! Take a seat. I'll pour you a drink show you my wares! If it's pearls you've got, I'll take them in exchange for one of these lovely pearl chests! What might be inside? It's a pearly mystery!|left|\nadd_spacer|small|\ntext_scaling_string|10,000BZ|\nadd_button_with_icon|beachparty_store_item_open_purchase_0|60|noflags|13598||\nadd_button_with_icon|beachparty_store_item_open_purchase_1|300|noflags|12262||\nadd_button_with_icon|beachparty_store_item_open_purchase_2|2,000|noflags|12264||\nadd_button_with_icon||END_LIST|noflags|0||\nend_dialog|handleBeachPartyShopPopup|OK|\nadd_quick_exit|");
				p.CreatePacket(peer);
			}
			else if (t_ == 10992) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wRubbles Shop``|left|10992|\nadd_image_button||interface/large/rubble_banner.rttex|bannerlayout|||\nadd_spacer|small|\nadd_smalltext|Hey there growtopian! you can exchange your rubbles with me for toxic waste and perhaps some rare items! Take a look..|left|\nadd_smalltext|`9You currently have "+setGems(pInfo(peer)->rubble) + " Rubbles``.|left|\nadd_spacer|small|\ntext_scaling_string|10,000BZ|\nadd_button_with_icon|beachparty_store_item_open_purchase_0|500|noflags|11402||\nadd_button_with_icon|beachparty_store_item_open_purchase_1|2500|noflags|11404||\nadd_button_with_icon||END_LIST|noflags|0||\nend_dialog|handleRubblePartyShopPopup|OK|\nadd_quick_exit|");
				p.CreatePacket(peer);
			}
			else if (t_ == 12986) {
				string rewards = "";
				for (int i = 1; i < 26; i++) rewards += "\nadd_button_with_icon|calendarSystem_" + to_string(i) + "|`$Day " + to_string(i) + "``|" + (block_->shelf_1 >= i ? "noflags|6292" : "frame|" + a + (i == 15 || i == 25 ? "9202" : "10486")) + "||";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWinterfest Calendar - 2022``|left|12986|\nadd_textbox|Tap on a button below to view the `2rewards`` available on that day.|left|\nadd_spacer|small|\ntext_scaling_string|Defibrillators|" + rewards + "\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nadd_button|cancel|Close|noflags|0|0|\nend_dialog|wfcalendar_dailyrewards|||\nadd_quick_exit|");
				p.CreatePacket(peer);
			}
			else if (t_ == 4856) {
				/*
				struct tm newtime;
				time_t now = time(0);
				localtime_s(&newtime, &now);
				int day = 310;*/
				string claim_prize = "";
				{
					string find = pInfo(peer)->tankIDName;
					vector<pair<int, string>>::iterator p = find_if(Balloon_Warz.top_balloon_winners.begin(), Balloon_Warz.top_balloon_winners.end(), [find](const pair < int, string>& element) { return element.second == find; });
					if (p != Balloon_Warz.top_balloon_winners.end()) claim_prize = "\nadd_smalltext|`2Thanks for participating, you were top #" + to_string(Balloon_Warz.top_balloon_winners[p - Balloon_Warz.top_balloon_winners.begin()].first) + ":``|\nadd_button|claim_event|`0Claim reward``|noflags|0|0|\nadd_spacer|";

				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBalloon Warz``|left|4856|\nadd_spacer|small|\nadd_label|small|`wLast Balloon Warz winners:``|left\nadd_label|small|" + Balloon_Warz.balloon_leaderboard + "|left\nadd_spacer|small|\nadd_label|small|You had a score of `w" + setGems(pInfo(peer)->balloon_score) + "``.|left\nadd_label|small|You are on Team `" + get_balloon_team(pInfo(peer)->balloon_faction) + "``.|left\nadd_spacer|small|\nadd_label|small|`wLast leaderboard positions``|left\nadd_label|small|" + Balloon_Warz.top_balloon_list + "|left\nadd_spacer|small|"/*"\nadd_label|small|`wTime left in war: `2" + to_string(day - newtime.tm_yday + 7) + " days, " + to_string(24 - newtime.tm_hour) + "hours, " + (60 - newtime.tm_min != 0 ? "" + to_string(60 - newtime.tm_min) + " mins," : "") + " " + to_string(abs(60 - newtime.tm_sec)) + "secs``|left"*/"\nadd_button|event_rewards|`0Event Rewards``|noflags|0|0|" + claim_prize + "\nend_dialog|popup|Thanks for the info!||");
				//p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBalloon Warz````|left|4856|\nadd_spacer|small|\nadd_label|small|`wBalloon Warz Leaderboard:``|left\nadd_label|small|" + Balloon_Warz.balloon_leaderboard + "|left|\nadd_label|small|`wLast leaderboard positions``|left\nadd_label|small|" + Balloon_Warz.top_balloon_list + "|left\nadd_spacer|small|\nadd_button|event_rewards|`0Event Rewards``|noflags|0|0|"+ claim_prize +"\nend_dialog|popup|Thanks for the info!||");
				p.CreatePacket(peer);

			}
			/*
			else if (t_ == 12826) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wShady Salesman``|left|12826|\nadd_spacer|small|\nadd_smalltext|Welcome Stranger! Complete your Trick or Treat Tasks to earn some sweet candy. You can get your tasks by scaring my good old pal Crazy Jim while wearing `5" + items[halloween_quest].ori_name + "`` item today and doing his tasks. In case you forgot, dial 12345 on a phone to call him. In return for candy I can trade you these spooky boxes!|left|\nadd_spacer|small|\ntext_scaling_string|10,000BZ|\nadd_button_with_icon|halloween_store_item_open_purchase_0|20|noflags|12830||\nadd_button_with_icon|halloween_store_item_open_purchase_1|100|noflags|12832||\nadd_button_with_icon||END_LIST|noflags|0||\nend_dialog|handleHalloweenShopPopup|OK|\nadd_quick_exit|");
				p.CreatePacket(peer);
			}*/
			/*
			if (t_ == 4264) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wStuff-4-Toys Box``|left|4264|\nadd_spacer|small|\nadd_textbox|Welcome to the `9Stuff-4-Toys Program``! You can drop off any unwanted items here (as long as they have rarity!), and for every 250,000 rarity donated, our specially trained `2Present Goblins`` will give away a holiday toy to a needy Growtopian. 'Tis the season for giving!|left|\nadd_smalltext|To donate an item, select it in your inventory, then use it on the Stuff-4-Toys Box. Don't use the Drop button!|left|\nadd_spacer|small|\nadd_smalltext|Total rarity donated: " + setGems(winterfest_rarity) + "|left|\nadd_smalltext|Total toys given away: " + setGems(winterfest_total_toys) + "|left|\nadd_spacer|small|\nadd_smalltext|You have personally donated " + setGems(pInfo(peer)->winterfest_stuff4toys) + " rarity.|left|\nend_dialog|stuff4toys|Exit||");
				p.CreatePacket(peer);
				break;
			}*/
			else if (t_ == 3898) {
				string user_name = pInfo(peer)->tankIDName;
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTelephone``|left|3898|\nadd_textbox|Dial a number to call somebody in Growtopia. Phone numbers have 5 digits, like 12345 (try it - you'd be crazy not to!). Most numbers are not in service!|left|\nadd_text_input|buttonClicked|Phone #||5|\nend_dialog|" + to_string(t_) + "|Hang Up|Dial|\n");
				p.CreatePacket(peer);
			}
			else if (t_ == 12598) {
				if (block_->shelf_1 != 0) offering_table(peer, block_, "reroll");
				else offering_table(peer, block_);
			}
			else if (t_ == 10374) {
				pInfo(peer)->lastwrenchb = 10374;
				string trsh_list = "";
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
					if (items[pInfo(peer)->inv[i_].first].untradeable == 0) {
						trsh_list += "\nadd_label_with_icon|small|" + to_string(pInfo(peer)->inv[i_].second) + "x " + items[pInfo(peer)->inv[i_].first].ori_name + "|left|"+to_string(pInfo(peer)->inv[i_].first) + "|\nadd_checkbox|" + to_string(pInfo(peer)->inv[i_].first) + "||0";
					}
				}
				if (trsh_list.empty()) trsh_list = "\nadd_textbox|You don't have any tradeable items to trash!|left|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wRecycling Machine``|left|10374|\nadd_spacer|small|"+ trsh_list +"\nend_dialog|recycle_machine|OK|Recycle|");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::CRYSTAL) {
				vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
				string mix_with = "";
				for (int i = 0; i < block_->crystals.size(); i++) {
					vector<int> c_ = block_->crystals[i];
					for (int a = 0; a < current_.size(); a++) {
						if (current_[a][0] == c_[0]) {
							current_[a][1] = block_->crystals[i][1];
							break;
						}
					}
				} vector<string> reply{};
				for (int i = 0; i < current_.size(); i++) {
					reply.push_back(to_string(current_[i][1]) + "x `$" + mix_with + (current_[i][0] == 2242 ? "R" : (current_[i][0] == 2244 ? "G" : (current_[i][0] == 2246 ? "B" : (current_[i][0] == 2248 ? "W" : "B")))) + "``");
				}
				vector<string> available_recipes{};
				for (vector<vector<int>> a_ : crystal_receptai) {
					bool can_ = true;
					for (vector<int> b_ : a_) {
						for (int i = 0; i < current_.size(); i++) {
							if (current_[i][0] == b_[0] and current_[i][1] < b_[1]) {
								can_ = false;
								break;
							}
						} if (not can_) {
							break;
						}
					} if (can_) {
						available_recipes.push_back("\nadd_button|" + to_string(a_[5][0]) + "|`$Craft " + items[a_[5][0]].name + "``|noflags|0|0|");
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCrystal Shattering``|left|5104|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_label_with_icon|small|This crystal is currently mixed with " + join(reply, ", ") + ".|left|5274|" + (available_recipes.size() == 0 ? "\nadd_textbox|No recipes are available. Mix more various crystals to see available recipes.|left|" : "\nadd_spacer|small|" + join(available_recipes, "")) + "\nend_dialog|crystal_exchange|Cancel||\n");
				p.CreatePacket(peer);
			}
			else if (t_ == 4830) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wBalloon-O-Matic``|left|4830|\nadd_spacer|small|" + get_balloon_type(block_->shelf_1) + "add_spacer|small|\nadd_label|small|Use this to convert any item with a rarity below 200 into war balloons. It takes 20 rarity worth of any items to create some balloons.|left\nadd_label|small|If you give extras, they will be stored in the cloud and will be accessible from any `5Balloon-O-Matic``.|left\nadd_label|small|Just use items on me to convert them.|left\nadd_label|small|Every 800 rarity I will create something special.|left\nadd_spacer|small|\nadd_label|small|So far, this tile has converted " + to_string(block_->shelf_1) + " Rarity into balloons.|left\nend_dialog|balloonomatic_dialog|Thanks for the info!||");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::DONATION) {
				pInfo(peer)->lastwrenchb = t_;
				string donate_item = "";
				int itemcount = block_->donates.size();
				for (int i_ = 0; i_ < block_->donates.size(); i_++) donate_item += "\nadd_checkbox|" + to_string(itemcount) + "|" + items[block_->donates[i_].item].name + " (`w" + to_string(block_->donates[i_].count) + "``) from `w" + block_->donates[i_].name + "``" + (block_->donates[i_].text != "" ? "`#- \"" + block_->donates[i_].text + "\"``" : "") + "|0";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (block_access(peer, world_, block_)) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (itemcount == 0 ? "\nadd_textbox|The box is currently empty.|left|" : "\nadd_textbox|You have `w" + to_string(itemcount) + "`` gift waiting:|left|" + donate_item + "\nadd_spacer|small|\nadd_button|clear_selected|`4Retrieve Selected Gifts``|noflags|0|0|\nadd_button|takeall|`4Retrieve All Gifts``|noflags|0|0|") + "" + (itemcount >= 20 ? "\nadd_textbox|This box already has `w20`` gifts in it, can't add more until you clear them.|left|" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wGive Gift`` (Min rarity: `52``)|Choose an item to give yourself|") + "\nend_dialog|donation_box_edit|Cancel||\n");
				else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (itemcount != 0 ? "\nadd_textbox|You see `w" + to_string(itemcount) + "`` gift in the box!|left|" : "\nadd_textbox|The box is currently empty.|left|") + "\nadd_textbox|Want to leave a gift for the owner?|left|" + (itemcount >= 20 ? "\nadd_textbox|This box already has `w20`` gifts in it, can't add more until you clear them.|left|" : "\nadd_spacer|small|\nadd_item_picker|itemid|`wGive Gift`` (Min rarity: `52``)|Choose an item to give yourself|") + "\nend_dialog|donation_box_edit|Cancel||\n");
				p.CreatePacket(peer);
			}
			else if (t_ == 1902) {
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGolden Ticket Booth``|left|1902|\nadd_textbox|Golden Tickets cost 100 Rarity worth of any items. If you give me extras, I'll keep a record.|left|\nadd_textbox|You can also pay with World Locks. I'll give you 30 Tickets per World Lock.|left|\nadd_textbox|Just use items on me to give them.|left|\nadd_textbox|You currently have a credit of " + to_string(pInfo(peer)->carnival_credit) + " Rarity.|left|\nend_dialog|ticket_booth|Thanks for the info!||"), p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::BULLETIN_BOARD || items[t_].blockType == BlockTypes::MAILBOX) {
			bool acc_ = block_access(peer, world_, block_);
				pInfo(peer)->lastwrenchb = t_;
				string text = "";
				int letters = 1, same = 0;
				bool public_can_add = block_->spin, hide_names = block_->invert;
				for (int i_ = 0; i_ < world_->bulletin.size(); i_++) {
					if (world_->bulletin[i_].x == x_ and world_->bulletin[i_].y == y_) {
						letters++;
						if (fixchar(to_lower(world_->bulletin[i_].name)) == to_lower(pInfo(peer)->tankIDName)) same++;
						if (items[t_].blockType == BlockTypes::BULLETIN_BOARD) {
							if (hide_names) text += "\nadd_label|small|`2" + world_->bulletin[i_].text + "``|left|";
							else {
								if (acc_)text += "\nadd_label_with_icon_button|small|" + world_->bulletin[i_].name + ": ```2" + world_->bulletin[i_].text + "``|left|660|edit" + to_string(i_) + "|";
								else text += "\nadd_label_with_icon|small|" + world_->bulletin[i_].name + ": ```2" + world_->bulletin[i_].text + "``|left|660|";
							}
						}
						else text += "\nadd_label_with_icon|small|`#\"" + world_->bulletin[i_].text + "\" - `w" + world_->bulletin[i_].name + "``|left|660|\nadd_spacer|small|";
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (acc_) p.Insert((items[t_].blockType == BlockTypes::BULLETIN_BOARD ? "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (letters == 0 ? "\nadd_textbox|The " + items[t_].name + " is empty.|left|" : text) + "\nadd_textbox|Add to conversation?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Add``|noflags|0|0|\nadd_spacer|small|\nadd_label_with_icon|big|`wOwner Options|left|242|\nadd_spacer|small|\nadd_textbox|To remove an individual comment, press the icon to the left of it.|left|\nadd_spacer|small|\nadd_spacer|small|" + (letters == 0 ? "" : "\nadd_button|clear|`4Clear Board``|noflags|0|0|") + "\nadd_checkbox|checkbox_locked|Public can add|" + (public_can_add ? "1" : "0") + "\nadd_checkbox|checkbox_hide|Hide names|" + (hide_names ? "1" : "0") + "\nend_dialog|bulletin_edit|Cancel|OK|\nadd_quick_exit|" : "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (letters == 0 ? "\nadd_textbox|Your mailbox is currently empty.|left|" : "\nadd_textbox|You have `w" + to_string(letters) + "`` letters:|left|\nadd_spacer|small|" + text + "\nadd_spacer|small|\nadd_button|clear|`4Empty Mailbox``|noflags|0|0|") + "" + (letters >= 20 ? "\nadd_textbox|This mailbox already has `w20`` letters in it.  Try again later.|left|" : "\nadd_textbox|Write a letter to yourself?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Send Letter``|noflags|0|0|") + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|"));
				else p.Insert((items[t_].blockType == BlockTypes::BULLETIN_BOARD ? "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (letters == 0 ? "\nadd_textbox|The " + items[t_].name + " is empty.|left|" : text) + "" + (public_can_add ? (same >= 3 ? "\nadd_textbox|You already have `03`` posts up, take a break!|left|" : "\nadd_textbox|Add to conversation?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Add``|noflags|0|0|") : "") + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|" : "set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|" + (letters >= 20 ? "\nadd_textbox|This mailbox already has `w20`` letters in it.  Try again later.|left|" : (same >= 3 ? "\nadd_textbox|You've already crammed `w3 ``of your letters into the mailbox, better wait.|left|" : "\nadd_textbox|Want to leave a message for the owner?|left|\nadd_text_input|sign_text|||128|\nadd_spacer|small|\nadd_button|send|`2Send Letter``|noflags|0|0|")) + "\nend_dialog|bulletin_edit|Cancel||\nadd_quick_exit|"));
				p.CreatePacket(peer);
			}
			else if (t_ == 1790) lwiz_quest(peer, "open");
			else if (t_ == 1900) {
				pInfo(peer)->lastwrenchb = t_;
				if (pInfo(peer)->C_QuestActive) SendCarnivalQuest(peer, 0);
				else {
					int adaBrp = 0;
					modify_inventory(peer, 1898, adaBrp);
					gamepacket_t p;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9The Ringmaster``|left|" + to_string(t_) + "|\nadd_smalltext|Come one, come all, to the most extraordinary show in Growtopia! I am the Ringmaster. That means I know a lot about Rings! For 10 Golden Tickets, I might even tell you how you can get a Ring of your own...|left|\nadd_spacer|small|\nadd_button|c_quest|" + (adaBrp >= 10 ? "`9Give 10 Golden Tickets``" : "`oYou don't have any golden tickets``") + "|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|If you had 5 rings of the same type maybe we could have made a deal...|left|\nend_dialog|carnival|Goodbye!||");
					p.CreatePacket(peer);
				}
			}
			else if (t_ == 4080) {
				if (block_->shelf_4 == 0) {
					SendDNAProcessor(peer, x_, y_, false, false, false, 0, false, false);
				}
				else if (block_->shelf_4 >= 1) {
					SendDNAProcessor(peer, x_, y_, false, true, false, 0, true, false);
				}
			}
			else if (t_ == 4124) {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
				p.Insert("This appears to be a standard model DNA Extractor. I could use items with ancient DNA on it to try to extract some.");
				p.Insert(0), p.Insert(1);
				p.CreatePacket(peer);
			}
			else if (t_ == 6016) growscan_load(peer, world_, block_);
			else if (t_ == 5714) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGiant Pot O' Gold``|left|5714|\nadd_spacer|small|\nadd_textbox|Welcome to the `9Giant Pot O' Gold``! You can drop off any unwanted items here (as long as they have rarity!) Donate 20,000 rarity and win an awesome prize - donate 40,000 and get a super-awesome prize!|left|\nadd_smalltext|To donate an item, select it in your inventory, then use it on the Giant Pot O' Gold. Don't use the Drop button!|left|\nadd_spacer|small|\nadd_smalltext|You are a `6Level " + to_string(pInfo(peer)->b_lvl) + " Donator``, with " + setGems(pInfo(peer)->b_ra) + " rarity donated!|left|\nend_dialog|giantpotogold|Exit||");
				//p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGiant Pot O' Gold``|left|5714|\nadd_spacer|small|\nadd_textbox|We are closed!|left|\nend_dialog|giantpotogold|Exit||");
				p.CreatePacket(peer);
			}
			else if (t_ == 9528) {
				string care = "";
				get_wl_value(peer, care);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert(a + "set_default_color|`o\n\nadd_label_with_icon|big|`9Sales-Man Untradeable``|left|9528|\nadd_spacer|small|\nadd_smalltext|Damn.. I hate LOCKE!! This guy takes all my diamond locks, i'm hungry so feed me more. The Untradeable Sales-Man|left|\nadd_spacer|small|" + care + "\nadd_spacer|small|" + shop_list2_2 + "|\nadd_button|chc0|Close|noflags|0|0|\nnend_dialog|gazette||OK|");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::VENDING) {
				gamepacket_t p;
				if (abs(x_ * 32 - pInfo(peer)->x) > 15 || abs(y_ * 32 - pInfo(peer)->y) > 15) {
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Get closer!");
					p.Insert(0), p.Insert(0);
					break;
				}
				else {
					p.Insert("OnDialogRequest");
					p.Insert(block_access(peer, world_, block_, true) ? get_vending(peer, world_, block_, x_, y_) : get_vending_buyer_side(peer, world_, block_, x_, y_));
				}
				p.CreatePacket(peer);
			}
			else if (t_ == 6948 || t_ == 5638 || t_ == 6946 || t_ == 9850 || t_ == 10266) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (magplant_access == false) {
					if (not world_->owner_name.empty()) {
						bool ar_turi_mag = false;
						if (t_ == 9850 || t_ == 10266 || t_ == 5638) {
							{
								int c_ = 0;
								if (block_->id != 0) {
									modify_inventory(peer, 5640, c_);
									if (c_ != 0) {
										if (pInfo(peer)->magnetron_x == x_ and pInfo(peer)->magnetron_y == y_ and pInfo(peer)->magnetron_id == block_->id) {
											ar_turi_mag = true;
										}
									}
								}
							}
						}
						else ar_turi_mag = false;
						if (block_->fg == 6948 && magplant_access == false) 	p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + (block_->id == 0 ? "\nadd_textbox|There is no item selected |left|" : "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|") + "\nend_dialog|itemsucker_block|Close||");
						else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + (block_->id == 0 ? "\nadd_textbox|There is no item selected |left|" : "\nadd_label_with_icon|small|`2" + items[block_->id].name + "``|left|" + to_string(block_->id) + "|") + ((block_->fg == 5638 or block_->fg == 9850 or block_->fg == 10266) and not block_->spin ? "\nadd_textbox|Building mode: `6DISABLED``|left|" : "\nadd_textbox|Building mode: `5ACTIVE``|left|\nadd_textbox|Use the " + items[5640].name + " to build `2" + items[block_->id].name + "`` directly from the " + items[block_->fg].name + "'s storage.|left|" + (not ar_turi_mag ? "\nadd_button|getplantationdevice|Get Remote|noflags|0|0|" : "") + "") + "\nend_dialog|itemsucker_block|Close||");
					}
				}
				else {
					p.Insert(get_sucker(peer, world_, block_, x_, y_));
				}
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::AUTO_BLOCK or t_ == 6954) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (magplant_access == false) p.Insert("add_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nadd_smalltext|The device will consume 2300 Gems/hr while active!|left|\nadd_smalltext|Current Fuel = `w" + to_string(block_->pr) + "/8,000``|left|\nend_dialog|autoactionblock|Close||\nadd_quick_exit|");
				else p.Insert("add_label_with_icon|big|`w" + items[block_->fg].name + "``|left|" + to_string(block_->fg) + "|\nadd_spacer|small|\nadd_smalltext|The device will consume 2300 Gems/hr while active!|left|\nadd_smalltext|Current Fuel = `w" + to_string(block_->pr) + "/8,000``|left|" + (block_->pr < 8000 ? "\nadd_smalltext|Refuel this with gems!|left|\nadd_text_input|refillfuel|Add Gems:|0|5|\nadd_spacer|small|\nadd_button|addfuel|`wAdd Gems``|noflags|0|0|" : "") + (block_->pr > 0 ? "\nadd_button|removegems|`wRemove Gems``|noflags|0|0|" : "") + "\nadd_spacer|small|\nadd_smalltext|" + (block_->id == 0 ? "No block type selected!" : "Target block is: `2" + items[(block_->fg == 6954 && block_->build_only == false ? block_->id - 1 : block_->id)].name + "``") + "|left|" + (t_ == 6954 && block_->c_  == 0? "\nadd_checkbox|harvest_trees|Harvest trees?|"+to_string(block_->build_only) + "|\nadd_checkbox|collect_seeds|Collect seeds?|" + to_string(block_->invert) + "|\nadd_item_picker|selecttarget|`wChoose Target Item``|Choose the target item!|" : (t_ == 6954 ? "\nadd_smalltext|Remove all items from the machine in order to change the target item.|left|\nadd_spacer|small|\nadd_smalltext|Collect target is: `2" + (items[(block_->invert ? block_->id : block_->id - 1)].ori_name) + "``|left|\nadd_spacer|small|\nadd_smalltext|This unit currently contains: `2" + to_string(block_->c_) + " " + items[(block_->invert ? block_->id : block_->id - 1)].ori_name + "``|left|\nadd_button|removeitems|`wRemove Items``|noflags|0|0|" : "\nadd_item_picker|selecttarget|`wChoose Target Item``|Choose the target item!|")) + "\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|autoactionblock|Close|OK|\nadd_quick_exit|");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::TRICKSTER) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|Rate of fire? (2-20 seconds)|left|\nadd_text_input|often|Seconds:|" + to_string(block_->rate_of_fire) + "|3|\nadd_textbox|Speed of projectiles? (10-250 pixels/second)|left|\nadd_text_input|speed|Speed:|" + to_string(block_->projectile_speed) + "|3|\nadd_checkbox|disable|Disabled|" + (block_->flags & 0x00400000 ? "0" : "1") + "\nadd_smalltext|You can install as many Blaster Blocks (Howlers or Tricksters) as you want in a world, but only 10 projectiles can exist at one time, so don't go crazy!|left|\nend_dialog|blaster|Cancel|Update|");
				p.CreatePacket(peer);
			}
			else if (t_ == 6142) {
				//extractor dynamo
				string foundlist = "";
				gamepacket_t p;
				for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
					if (world_->drop_new[i_][4] / 32 == y_ && world_->drop_new[i_][0] != 112 && world_->drop_new[i_][0] != 4490) {
						if (world_->drop_new[i_][3] / 32 == (x_ + (block_->flags & 0x00200000 ? -1 : 1)) or world_->drop_new[i_][3] / 32 == (x_ + (block_->flags & 0x00200000 ? -2 : 2)) or world_->drop_new[i_][3] / 32 == (x_ + (block_->flags & 0x00200000 ? -3 : 3))) 	foundlist += to_string(world_->drop_new[i_][0]) + "," + to_string(world_->drop_new[i_][1]) + "," + to_string(world_->drop_new[i_][2]) + ",";
					}
				}
				if (not foundlist.empty()) p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wExtractor Dynamo``|left|6142|\nadd_spacer|small|\nadd_textbox|GrowTech: use the Extractor Dynamo to pick out the items from the floating items in your world! - Thanks, Technician Dave.|left|\nadd_spacer|small|\nadd_textbox|Press on the icon to extract the item into your inventory.|left|\nadd_spacer|small|\nadd_textbox|`wItem List:|left|\nadd_label_with_icon_button_list|small|`w%s : %s|left|dynamoOnceObj_|itemID_itemAmount_worldObj|" + foundlist + "\nadd_spacer|small|\nend_dialog|dynamo|Close||");
				else p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("There are no floating items in the extraction area!"), p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::MANNEQUIN) {
				string ex = "";
				if (block_->mannequin.c_head != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_head) + "|" + items[block_->mannequin.c_head].name + "|0|";
				if (block_->mannequin.c_shirt != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_shirt) + "|" + items[block_->mannequin.c_shirt].name + "|0|";
				if (block_->mannequin.c_pants != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_pants) + "|" + items[block_->mannequin.c_pants].name + "|0|";
				if (block_->mannequin.c_feet != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_feet) + "|" + items[block_->mannequin.c_feet].name + "|0|";
				if (block_->mannequin.c_mask != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_mask) + "|" + items[block_->mannequin.c_mask].name + "|0|";
				if (block_->mannequin.c_hand != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_hand) + "|" + items[block_->mannequin.c_hand].name + "|0|";
				if (block_->mannequin.c_back != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_back) + "|" + items[block_->mannequin.c_back].name + "|0|";
				if (block_->mannequin.c_hair != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_hair) + "|" + items[block_->mannequin.c_hair].name + "|0|";
				if (block_->mannequin.c_neck != 0) ex += "\nadd_checkbox|checkbox_" + to_string(block_->mannequin.c_neck) + "|" + items[block_->mannequin.c_neck].name + "|0|";
				if (not ex.empty()) ex += "\nadd_spacer|small|\nadd_button|clear_selected|`4Remove Selected Items``|noflags|0|0|\nadd_button|clear|`4Remove All Items``|noflags|0|0|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|To dress, select a clothing item then use on the mannequin. To remove clothes, punch it or select which item to remove.<CR><CR>It will go into your backpack if you have room.|" + ex + "\nadd_textbox|<CR><CR>What would you like to write on its sign?``|left|\nadd_text_input|sign_text||" + block_->txt + "|128|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|mannequin_edit|Cancel|OK|");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::Display_Shelf) {
				bool can_take = (block_->shelf_1 != 0 or block_->shelf_2 != 0 or block_->shelf_3 != 0 or block_->shelf_4 != 0 ? true : false);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\n" + (block_->shelf_2 != 0 ? "add_item_picker|replace2|Item 1: `2" + items[block_->shelf_2].name + "``|Select any item to display|" : "add_item_picker|replace2|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_1 != 0 ? "add_item_picker|replace1|Item 2: `2" + items[block_->shelf_1].name + "``|Select any item to display|" : "add_item_picker|replace1|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_3 != 0 ? "add_item_picker|replace3|Item 3: `2" + items[block_->shelf_3].name + "``|Select any item to display|" : "add_item_picker|replace3|`4Display an item``|Select any item to display|") + "\n" + (block_->shelf_4 != 0 ? "add_item_picker|replace4|Item 4: `2" + items[block_->shelf_4].name + "``|Select any item to display|" : "add_item_picker|replace4|`4Display an item``|Select any item to display|") + (can_take ? "\nadd_button|remove|Take All Items|noflags|0|0|" : "") + "\nend_dialog|dispshelf|Okay||");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::VIP_ENTRANCE) {
				gamepacket_t p;
				if (world_->owner_name.empty() and not block_->locked) {
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|vip_edit|Cancel|OK|");
				}
				else if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName)) {
					string add_ = "";
					for (string own : block_->admins) {
						add_ += "\nadd_checkbox|checkbox_" + own + "|" + get_player_tag(own) + "``|1";
					}
					if (add_.empty()) add_ = "\nadd_label|small|Nobody!|left";
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wVIP list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + add_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to enter|" + (block_->limit_admins ? "1" : "0") + "\nend_dialog|vip_edit|Cancel|OK|");
				}
				else {
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Only the World Owner edit VIP Entrance.");
					p.Insert(0), p.Insert(0);
				}
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::PORTRAIT) {
				bool has_enough = false;
				int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
				{
					modify_inventory(peer, 3478, red);
					modify_inventory(peer, 3480, yellow);
					modify_inventory(peer, 3482, green);
					modify_inventory(peer, 3484, aqua);
					modify_inventory(peer, 3486, blue);
					modify_inventory(peer, 3488, purple);
					modify_inventory(peer, 3490, charcoal);
					modify_inventory(peer, 3492, varnish);
					if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
						has_enough = true;
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string erase = (varnish >= 4 ? "\nadd_button|erase|Erase Painting|noflags|0|0|\nadd_smalltext|`5(Erasing costs 4 Paint Bucket - Varnish)``|left|" : "\nadd_textbox|You'll need 4 Paint Bucket - Varnish to erase this.|left|");
				string tratata = (has_enough ? "\nadd_player_picker|playerNetID|`wPaint Someone``|\nadd_smalltext|`5(Painting costs 2 Paint Bucket of each color)``|left|" : "\nadd_textbox|You'll need 2 of each color of Paint Bucket to paint someone.|left|");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "" + (block_->portrait.c_skin == 0 and block_->portrait.c_face == 0 and block_->portrait.c_hair == 0 and block_->portrait.c_head == 0 ? ("\nadd_textbox|The canvas is blank.|left|" + tratata) : "\nadd_textbox|This is a lovely portrait of a Growtopian.|left|" + erase + "\nadd_text_input|artname|Title:|" + block_->txt + "|60|\nadd_smalltext|If you'd like to touch up the painting slightly, you could change the expression:|left|\nadd_checkbox|chk1|Unconcerned|" + (block_->portrait.c_expression == 1 ? "1" : "0") + "|\nadd_checkbox|chk2|Happy|" + (block_->portrait.c_expression == 2 ? "1" : "0") + "|\nadd_checkbox|chk3|Sad|" + (block_->portrait.c_expression == 3 ? "1" : "0") + "|\nadd_checkbox|chk4|Tongue Out|" + (block_->portrait.c_expression == 4 ? "1" : "0") + "|\nadd_checkbox|chk5|Surprised|" + (block_->portrait.c_expression == 5 ? "1" : "0") + "|\nadd_checkbox|chk6|Angry|" + (block_->portrait.c_expression == 6 ? "1" : "0") + "|\nadd_checkbox|chk7|Talking|" + (block_->portrait.c_expression == 7 ? "1" : "0") + "|\nadd_checkbox|chk9|Ecstatic|" + (block_->portrait.c_expression == 9 ? "1" : "0") + "|\nadd_checkbox|chk11|Wry|" + (block_->portrait.c_expression == 11 ? "1" : "0") + "|\nadd_checkbox|chk12|Sleeping|" + (block_->portrait.c_expression == 12 ? "1" : "0") + "|\nadd_checkbox|chk14|Winking|" + (block_->portrait.c_expression == 14 ? "1" : "0") + "|\nadd_checkbox|chk16|Trolling|" + (block_->portrait.c_expression == 16 ? "1" : "0") + "\nadd_checkbox|chk18|Vampire|" + (block_->portrait.c_expression == 18 ? "1" : "0") + "\nadd_checkbox|chk22|Underwater|" + (block_->portrait.c_expression == 22 ? "1" : "0") + "\nadd_checkbox|chk27|What|" + (block_->portrait.c_expression == 27 ? "1" : "0") + "\nadd_checkbox|chk28|Blushed|" + (block_->portrait.c_expression == 28 ? "1" : "0") + "|") + "\nend_dialog|portrait|Cancel|Update|");
				p.CreatePacket(peer);
			}
			else if (t_ == 2452) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wClothing Compactor``|left|2452|\nadd_textbox|Use (almost) any clothing on this device to crush it down, permanently destroying it. If you just have extra clothes taking up space, crush 'em!|left|\nadd_textbox|The results may surprise you! But probably you will get seeds or gems.|left|\nend_dialog|compactor|Thanks for the info!||");
				p.CreatePacket(peer);
			}
			else if (t_ == 4322) {
				string tools = "";
				for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].second >= 20 && pInfo(peer)->inv[i_].first == 1258 || pInfo(peer)->inv[i_].first == 1260 || pInfo(peer)->inv[i_].first == 1262 || pInfo(peer)->inv[i_].first == 1264 || pInfo(peer)->inv[i_].first == 1266 || pInfo(peer)->inv[i_].first == 1268 || pInfo(peer)->inv[i_].first == 1270 || pInfo(peer)->inv[i_].first == 4308 || pInfo(peer)->inv[i_].first == 4310 || pInfo(peer)->inv[i_].first == 4312 || pInfo(peer)->inv[i_].first == 4314 || pInfo(peer)->inv[i_].first == 4316 || pInfo(peer)->inv[i_].first == 4318) tools += "\nadd_button_with_icon|tool" + to_string(pInfo(peer)->inv[i_].first) + "|`$" + items[pInfo(peer)->inv[i_].first].ori_name + "``|noflags|" + to_string(pInfo(peer)->inv[i_].first) + "|" + to_string(pInfo(peer)->inv[i_].second) + "|";
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9Autoclave``|left|4322|\nadd_spacer|small|\nadd_textbox|With this device, you can exchange 20 of any one surgical tool for 1 each of all the other tools. Choose an instrument to dispose of:|left|" + (tools != "" ? "\ntext_scaling_string|Surgical Defibrillator|" + tools + "\nadd_button_with_icon||END_LIST|noflags|0||" : "") + "\nend_dialog|autoclave|Cancel||");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::Painting_Easel) {
				bool has_enough = false;
				int red = 0, yellow = 0, green = 0, aqua = 0, blue = 0, purple = 0, charcoal = 0, varnish = 0;
				{
					modify_inventory(peer, 3478, red);
					modify_inventory(peer, 3480, yellow);
					modify_inventory(peer, 3482, green);
					modify_inventory(peer, 3484, aqua);
					modify_inventory(peer, 3486, blue);
					modify_inventory(peer, 3488, purple);
					modify_inventory(peer, 3490, charcoal);
					modify_inventory(peer, 3492, varnish);
					if (red >= 2 and yellow >= 2 and green >= 2 and aqua >= 2 and blue >= 2 and purple >= 2 and charcoal >= 2 and varnish >= 2) {
						has_enough = true;
					}
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|The canvas is blank.|left|" + (block_->id != 0 ? "\nadd_textbox|This is a lovely still-life of " + items[block_->id].name + ".|left|" + (varnish < 4 ? "\nadd_smalltext|You'll need 4 Paint Bucket - Varnish to erase this.|left|" : "\nadd_button|erase|Erase Painting|noflags|0|0|\nadd_smalltext|`5(Erasing costs 4 Paint Bucket - Varnish)``|left|") : (not has_enough ? "\nadd_textbox|You'll need 2 of each color of Paint Bucket to paint something.|left|" : "\nadd_item_picker|paint|`wPaint Something``|Select an item to paint|")) + "\nadd_text_input|artname|Signed:|" + block_->txt + "|60|\nend_dialog|artcanvas|Cancel|Update|");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::GATEWAY or items[t_].can_be_changed_to_public) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (block_access(peer, world_, block_) == false) {
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|This object has additional properties to edit if in a locked area.|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|switcheroo_edit|Cancel|OK|");
				}
				else {
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_checkbox|checkbox_public|" + (items[t_].can_be_changed_to_public ? "Usable by public" : "Is open to public") + "|" + (block_->flags & 0x00800000 ? "1" : "0") + (items[block_->fg].actionType == 12 ? "\nadd_checkbox|checkbox_silence|Silenced|" + a + (block_->flags & 0x02000000 ? "1" : "0") + "" : "") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|switcheroo_edit|Cancel|OK|");
				}
				p.CreatePacket(peer);
			}
			else if (t_ == 1436 || t_ == 8246 || t_ == 10258) {
				pInfo(peer)->lastwrenchb = t_;
				string logs = "", settings = "", a = "";
				bool show_item_taking = false, show_item_dropping = false, show_people_entering = false, show_people_exiting = false, dont_show_owner = false, dont_show_admins = false, dont_show_noaccess = false, show_vend_logs = false;
				for (int i_ = 0; i_ < world_->cctv.size(); i_++) if (world_->cctv[i_].x == x_ and world_->cctv[i_].y == y_) logs += world_->cctv[i_].logs;
				for (int i_ = 0; i_ < world_->cctv_settings.size(); i_++) if (world_->cctv_settings[i_][0] == x_ and world_->cctv_settings[i_][1] == y_) settings = a + "\nadd_checkbox|checkbox_showpick|Show Item Taking|" + (world_->cctv_settings[i_][2] ? "1" : "0") + "\nadd_checkbox|checkbox_itemdrop|Show Item Dropping|" + (world_->cctv_settings[i_][3] ? "1" : "0") + "\nadd_checkbox|checkbox_showenter|Show People Entering|" + (world_->cctv_settings[i_][4] ? "1" : "0") + "\nadd_checkbox|checkbox_showexit|Show People Exiting|" + (world_->cctv_settings[i_][5] ? "1" : "0") + "\nadd_checkbox|checkbox_noshowowner|Don't Show Owner|" + (world_->cctv_settings[i_][6] ? "1" : "0") + "\nadd_checkbox|checkbox_noshowadmin|Don't Show Admins|" + (world_->cctv_settings[i_][7] ? "1" : "0") + "\nadd_checkbox|checkbox_noshowother|Don't Show People Without Access|" + (world_->cctv_settings[i_][8] ? "1" : "0") + "\nadd_checkbox|checkbox_vendlogs|Show Vending Machine Logs|" + (to_string(world_->cctv_settings[i_][9]));
				if (settings.empty()) {
					world_->cctv_settings.push_back({ {pInfo(peer)->lastwrenchx},{pInfo(peer)->lastwrenchy},{false},{false},{true},{false},{dont_show_owner == 1 ? true : false},{false},{false},{false} });
					WorldCCTV cctv_{};
					cctv_.x = pInfo(peer)->lastwrenchx, cctv_.y = pInfo(peer)->lastwrenchy;
					cctv_.logs = "";
					world_->cctv.push_back(cctv_);
					settings = "\nadd_checkbox|checkbox_showpick|Show Item Taking|0\nadd_checkbox|checkbox_itemdrop|Show Item Dropping|0\nadd_checkbox|checkbox_showenter|Show People Entering|1\nadd_checkbox|checkbox_showexit|Show People Exiting|0\nadd_checkbox|checkbox_noshowowner|Don't Show Owner|0\nadd_checkbox|checkbox_noshowadmin|Don't Show Admins|0\nadd_checkbox|checkbox_noshowother|Don't Show People Without Access|0\nadd_checkbox|checkbox_vendlogs|Show Vending Machine Logs|0";
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|" + (logs.empty() ? "\nadd_textbox|The camera log is empty.|left|" : logs + "\nadd_spacer|small|") + "" + settings + "" + (logs != "" ? "\nadd_button|clear|`4Clear Log``|noflags|0|0|" : "") + "\nend_dialog|camera_edit||OK|\nadd_quick_exit|");
				p.CreatePacket(peer);
			}
			else if (t_ == 4296 || t_ == 8558) {
			gamepacket_t p;
				if (has_playmod2(pInfo(peer), 86)) {
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("I know it's just a robot, but the authorities don't even trust you operating on that with your malpractice issues.");
					p.Insert(0), p.Insert(1);
				}
				else {
					pInfo(peer)->lastwrenchb = t_;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`9" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nadd_smalltext|Surgeon Skill: " + to_string(pInfo(peer)->surgery_skill) + "|left|\nadd_textbox|Are you sure you want to perform surgery on this robot? Whether you succeed or fail, the robot will be destroyed in the process.|left|\nend_dialog|surge|Cancel|Okay!|");
				}
				p.CreatePacket(peer);
			}
			else if (t_ == 4582 || t_ == 12196) {
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|Use items on here to try to grind them up into tasty food. Only certain things can be ground up.|left|\nadd_textbox|You might be surprised what you can grind!|left|\nend_dialog|grinder|Thanks for the info!||"), p.CreatePacket(peer);
			}
			else if (t_ == 2072) {
				pInfo(peer)->lastwrenchb = t_;
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wXenonite Crystal``|left|2072|\nadd_textbox|This crystal can either grant or block super powers for all players in your world! Any power that's unchecked will work as normal - people will have the power if they equip an item with it.|left|\nadd_spacer|small|\nadd_checkbox|checkbox_force_dbl|Force Double Jump|" + a + (to_string(world_->xenonite & Gtps3::XENONITE_FORCE_DOUBLE_JUMP)) + "\nadd_checkbox|checkbox_block_dbl|Block Double Jump|" + (to_string(world_->xenonite & Gtps3::XENONITE_BLOCK_DOUBLE_JUMP)) + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_hig|Force High Jump|" + (to_string(world_->xenonite & Gtps3::XENONITE_FORCE_HIGH_JUMP)) + "\nadd_checkbox|checkbox_block_hig|Block High Jump|" + (to_string(world_->xenonite & Gtps3::XENONITE_BLOCK_HIGH_JUMP)) + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_asb|Force Heat Resist|" + (to_string(world_->xenonite & Gtps3::XENONITE_FORCE_HEAT_RESIST)) + "\nadd_checkbox|checkbox_block_asb|Block Heat Resist|" + (to_string(world_->xenonite & Gtps3::XENONITE_BLOCK_HEAT_RESIST)) + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_pun|Force Strong Punch|" + (to_string(world_->xenonite & Gtps3::XENONITE_FORCE_STRONG_PUNCH)) + "\nadd_checkbox|checkbox_block_pun|Block Strong Punch|" + to_string(world_->xenonite & Gtps3::XENONITE_BLOCK_STRONG_PUNCH) + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_lng|Force Long Punch|" + to_string(world_->xenonite & Gtps3::XENONITE_FORCE_LONG_PUNCH) + "\nadd_checkbox|checkbox_block_lng|Block Long Punch|" + to_string(world_->xenonite & Gtps3::XENONITE_BLOCK_LONG_PUNCH) + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_spd|Force Speedy|" + to_string(world_->xenonite & Gtps3::XENONITE_FORCE_SPEEDY) + "\nadd_checkbox|checkbox_block_spd|Block Speedy|" + to_string(world_->xenonite & Gtps3::XENONITE_BLOCK_SPEEDY) + "\nadd_spacer|small|\nadd_checkbox|checkbox_force_lngb|Force Long Build|" + to_string(world_->xenonite & Gtps3::XENONITE_FORCE_LONG_BUILD) + "\nadd_checkbox|checkbox_block_lngb|Block Long Build|" + to_string(world_->xenonite & Gtps3::XENONITE_BLOCK_LONG_BUILD) + "\nend_dialog|xenonite_edit|Cancel|Update|"), p.CreatePacket(peer);
			}
			else if (t_ == 2646) {
				if (block_->heart_monitor != "") {
					string spotlight = "";
					for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
						if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
						if (block_->heart_monitor == pInfo(currentPeer)->tankIDName) spotlight = pInfo(currentPeer)->tankIDName;
					}
					block_->heart_monitor = spotlight;
				}
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wShine the Spotlight!``|left|2646|\nadd_spacer|small|\nadd_textbox|" + (block_->heart_monitor.empty() ? "The light is currently off." : "The light is shining on " + block_->heart_monitor + ".") + "|left|\nadd_spacer|small|\nadd_player_picker|ID|`wChoose a " + (block_->heart_monitor.empty() ? "superstar" : "new star") + "``|" + (block_->heart_monitor.empty() ? "" : "\nadd_button|off|Turn it off|noflags|0|0|") + "\nend_dialog|2646|Nevermind||"), p.CreatePacket(peer);
			}
			else if (t_ == 9170) {
				pInfo(peer)->transmute_item1 = 0, pInfo(peer)->transmute_item2 = 0;
				gamepacket_t p;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wTransmutabooth``|left|9170|\nadd_spacer|small|\nadd_smalltext|This booth will let you transfer the visuals of one clothing item onto another (of the same slot)!|left|\nadd_smalltext|The transmuted item will keep its properties (and mods!), so have fun and experiment with crazy combos!|left|" + (pInfo(peer)->transmute.size() == 0 ? "" : "\nadd_spacer|small|\nadd_smalltext|You have transmuted `2" + to_string(pInfo(peer)->transmute.size()) + "/12`` clothing items.|left|\nadd_button|permanentlist|`wYour Permanent Transmutes``|noflags|0|0|\n") + "\nadd_spacer|small|\nadd_smalltext|Here's where you can permanently change the visuals of clothing!|left|\nadd_button|permanttransmutation|`wTransmutate!``|noflags|0|0|\nadd_spacer|small|\nadd_button|transmutationhelp|`wHelp``|noflags|0|0|\nadd_spacer|small|\nend_dialog|transmutated_device_edit|Close||\nadd_quick_exit|"), p.CreatePacket(peer);
			}
			else if (t_ == 9946 || t_ == 9948) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				if (t_ == 9948) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWashing Machine``|left|9946|\nadd_textbox|Washing...|left|\nadd_button_with_icon|||staticBlueFrame|" + to_string(block_->shelf_1) + "|" + to_string(block_->shelf_2) + "|\nadd_button_with_icon||END_LIST|noflags|0||\nadd_button|cancel|Close|noflags|0|0|\nend_dialog|washing_machine|||\nadd_quick_exit|");
				else p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWashing Machine``|left|9946|\nadd_textbox|Choose an item to wash|left|\nadd_textbox|`4DISCLAIMER:`` Becareful, you may end up with higher or lower rarity!|left|\nadd_spacer|small|\nadd_item_picker|itemid|`wWash`` (Min rarity: `52``)|Choose an item to wash|\nadd_spacer|small|\nadd_button|cancel|Close|noflags|0|0|\nend_dialog|washing_machine|||\nadd_quick_exit|");
				p.CreatePacket(peer);
			}
			else if (t_ == 9270) {
				load_vendhub(peer, world_, block_);
			}
			else if (t_ == 3694) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|Adjust the color of your heat wave here, by including 0-255 of Red, Green, and Blue.|left|\nadd_text_input|red|Red|" + to_string(block_->r) + "|3|\nadd_text_input|green|Green|" + to_string(block_->g) + "|3|\nadd_text_input|blue|Blue|" + to_string(block_->b) + "|3|\nend_dialog|weatherspcl|Cancel|Okay|");
				p.CreatePacket(peer);
			}
			else if (t_ == 5000) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|You can scan any Background Block to set it up in your weather machine.|left|\nadd_item_picker|choose|Item: `2" + items[(block_->id != 0 ? block_->id : 14)].name + "``|Select any Background Block|\nend_dialog|weatherspcl|Cancel|Okay|");
				p.CreatePacket(peer);
			}
			else if (t_ == 3832) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_item_picker|choose|Item: `2" + items[(block_->id != 0 ? block_->id : 14)].name + "``|Select any item to rain down|\nadd_text_input|gravity|Gravity:|" + to_string(block_->gravity) + "|5|\nadd_checkbox|spin|Spin Items|" + (block_->spin ? "1" : "0") + "\nadd_checkbox|invert|Invert Sky Colors|" + (block_->invert ? "1" : "0") + "\nend_dialog|weatherspcl|Cancel|Okay|");
				p.CreatePacket(peer);
			}
			else if (t_ == 2946) {
				string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_textbox|" + (block_->id != 0 ? "A " + items[block_->id].ori_name + " is on display here." : "The Display Block is empty. Use an item on it to display the item!") + "|left|" + (block_->id != 0 and (user_name == owner_name or owner_name.empty()) ? "\nend_dialog|displayblock|Leave it|Pick it up|" : "\nend_dialog|displayblock|Okay||"));
				p.CreatePacket(peer);
			}
			if (items[t_].blockType == GAME_BLOCK) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[t_].ori_name + "``|left|" + to_string(t_) + "|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|\nadd_textbox|Choose a team:|left|\ntext_scaling_string|Penguins|\nadd_button_with_icon|team0|`$Rabbits``|noflags|-10||\nadd_button_with_icon|team1|`$Bombers``|noflags|-11||\nadd_button_with_icon|team2|`$Yaks``|noflags|-12||\nadd_button_with_icon|team3|`$Penguins``|noflags|-13||\nadd_button_with_icon|team4|`$None``|noflags|-14||\nadd_button_with_icon||END_LIST|noflags|0||\nadd_spacer|small|\nend_dialog|team_edit|Cancel||\n");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::LOCK) {
				if (t_ == 202 or t_ == 204 or t_ == 206 or t_ == 4994 or t_ == 10000) {
					string access_list_ = "";
					for (int i_ = 0; i_ < block_->admins.size(); i_++) {
						access_list_ += "\nadd_checkbox|checkbox_/" + block_->admins[i_] + "|`w" + block_->admins[i_] + "``|1";
					}
					if (access_list_.empty())
						access_list_ = "\nadd_label|small|Currently, you're the only one with access.``|left";
					if (t_ == 4994) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build or Break|" + (block_->spin ? "1" : "0") + "\nadd_checkbox|checkbox_ignore|Ignore empty air|" + (block_->invert ? "1" : "0") + "\nadd_button|recalcLock|`wRe-apply lock``|noflags|0|0|\nadd_spacer|small|\nadd_smalltext|This lock allows Building or Breaking.|left|\nadd_smalltext|(ONLY if 'Allow anyone to Build or Break' is checked above)!|left|\nadd_spacer|small|\nadd_smalltext|Leaving this box unchecked only allows Breaking.|left|\nadd_checkbox|checkbox_buildonly|Only Allow Building!|" + (block_->build_only ? "1" : "0") + "\nadd_smalltext|People with lock access can both build and break unless you check below. The lock owner can always build and break.|left|\nadd_checkbox|checkbox_admins|Admins Are Limited|" + (block_->limit_admins ? "1" : "0") + "\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
					else {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_label|small|`wAccess list:``|left\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nadd_spacer|small|" + access_list_ + "\nadd_spacer|small|\nadd_player_picker|playerNetID|`wAdd``|\nadd_checkbox|checkbox_public|Allow anyone to Build and Break|" + (block_->spin ? "1" : "0") + "\nadd_checkbox|checkbox_ignore|Ignore empty air|" + (block_->invert ? "1" : "0") + "\nadd_button|recalcLock|`wRe-apply lock``|noflags|0|0|\nend_dialog|lock_edit|Cancel|OK|");
						p.CreatePacket(peer);
					}
				}
				else send_edit_lock(peer, world_, t_, x_, y_);
			}
			else if (items[t_].blockType == BlockTypes::SIGN) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_textbox|" + (items[t_].path_marker ? "Enter an ID. You can use this as a destination for Doors.``" : "What would you like to write on this sign?``") + "|left|\nadd_text_input|sign_text||" + (items[t_].path_marker ? block_->door_id : block_->txt) + "|128|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|sign_edit|Cancel|OK|");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::ADVENTURE) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wThe Adventure Begins``|left|4722|\nadd_smalltext|Players that step here will have their adventure items reset. If they don't reach `2Adventure's End`` within the time and life limit, they'll lose their checkpoint and be sent to the white door.|left|\nadd_spacer|small|\nadd_text_input|nameEnter|Adventure Name|" + block_->heart_monitor + "|32|\nadd_spacer|small|\nend_dialog|advbegins|Cancel|Update|");
				p.CreatePacket(peer);
			}
			else if (items[t_].blockType == BlockTypes::STORAGE) {
				if (to_lower(pInfo(peer)->tankIDName) == to_lower(world_->owner_name) || pInfo(peer)->dev == 1) {
					pInfo(peer)->lastwrenchb = t_;
					if (block_->door_destination != "" && t_ == 8878) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSafe Vault``|left|8878|\nadd_textbox|Please enter your password to access the Safe Vault.|left|\nadd_text_input_password|storage_password||" + (pInfo(peer)->superdev ? block_->door_destination : "") + "|12|\nadd_button|check_password|`wEnter Password``|noflags|0|0|\nadd_button|show_recoveryanswer|`wRecover Password``|noflags|0|0|\nend_dialog|ss_storage|Exit||\nadd_quick_exit|"), p.CreatePacket(peer);
					}
					else load_storagebox(peer, world_, block_);
				}
			}
			else if (items[t_].blockType == BlockTypes::DOOR || items[t_].blockType == BlockTypes::PORTAL) {
				gamepacket_t p;
				p.Insert("OnDialogRequest");
				string open_ = (block_->open ? "1" : "0");
				p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wEdit " + items[t_].name + "``|left|" + to_string(t_) + "|\nadd_text_input|door_name|"+(block_->fg == 10358 ? "Price|" + to_string(block_->shelf_1) + "|5|\nadd_smalltext|Set a entry `2PRICE`` and the player must pay one time per entry! If you set `50`` it will be FREE. Maximum price is `2200`` World Locks!|left|" : "Label|" + block_->txt + "|100|") + "\nadd_text_input|door_target|Destination|" + block_->door_destination + "|24|\nadd_smalltext|Enter a Destination in this format: `2WORLDNAME:ID``|left|\nadd_smalltext|Leave `2WORLDNAME`` blank (:ID) to go to the door with `2ID`` in the `2Current World``.|left|\nadd_text_input|door_id|" + (t_ == 762 ? "Password" : "ID") + "|" + block_->door_id + "|11|\nadd_smalltext|Set a unique `2ID`` to target this door as a Destination from another!|left|" + (not world_->owner_name.empty() ? "\nadd_checkbox|checkbox_locked|Is open to public|" + open_ + "" : "") + "" + ((block_->fg == 10358 && block_->wl != 0) ? "\nadd_smalltext|You have earned " + to_string(block_->wl) + " World Locks.|left|\nadd_button|withdraw_a|Withdraw World Locks|noflags|0|0|" : "") + "\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nend_dialog|door_edit|Cancel|OK|");
				p.CreatePacket(peer);
			}
			break;
		}
		default:
		{
			if (items[p_].blockType == BlockTypes::VENDING || items[p_].blockType == BlockTypes::SUCKER) {
				if (pInfo(peer)->superdev == 0 && world_->owner_name.empty()) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("This item can only be used in World-Locked worlds!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
					return false;
				}
			}
			else if (p_ == 611 && items[block_->fg].blockType != BlockTypes::SEED) p_ = 610;
			if (t_ == 5714) {
				pInfo(peer)->lastwrenchb = t_;
				gamepacket_t p;
				if (items[p_].untradeable == 1 || p_ == 1424 || p_ == 5816 || items[p_].rarity >= 363 || items[p_].rarity == 0 || items[p_].rarity < 1) {
					p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("I'm sorry, we can't accept items without rarity!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
				}
				else {
					pInfo(peer)->lastchoosenitem = p_;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGiant Pot O' Gold``|left|5714|\nadd_spacer|small|\nadd_textbox|How many `2" + items[p_].name + "`` (rarity " + setGems(items[p_].rarity) + ") do you want to drop in the pot? You are carrying " + to_string(have) + " right now.|left|\nadd_text_input|amt||" + to_string(have) + "|3|\nadd_textbox|Thanks for donating, the pot gets ever fuller!|left|\nend_dialog|giantpotogold|Exit|Donate!|");
				}
				p.CreatePacket(peer);
			}
			else if (t_ == 4264) {
				gamepacket_t p;
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4We are closed!`7]``"), p.Insert(0), p.Insert(0);
				/*
				if (items[p_].block_possible_put == false || items[p_].rarity <= 0 || items[p_].rarity > 360)p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2That item is just too valuable!``]``"), p.Insert(0), p.Insert(0);
				else {
					pInfo(peer)->lastchoosenitem = p_;
					p.Insert("OnDialogRequest");
					p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wStuff-4-Toys Box``|left|4264|\nadd_spacer|small|\nadd_textbox|How many `2" + items[pInfo(peer)->lastchoosenitem].ori_name + "`` (rarity " + to_string(items[pInfo(peer)->lastchoosenitem].rarity) + ") do you want to donate to our program? You are carrying " + to_string(got) + " right now.|left|\nadd_text_input|amt||" + to_string(got) + "|3|\nadd_textbox|We appreciate you donating whatever you can! You are bringing light into the lives of Growtopians who can't scrape together a World Lock of their own.|left|\nend_dialog|stuff4toys|Exit|Donate!|");
				}*/
				p.CreatePacket(peer);
			}
			else if (t_ == 1902) {
				pInfo(peer)->lastwrenchb = t_;
				gamepacket_t p;
				if (p_ != 242 && (items[p_].untradeable == 1 || p_ == 1424 || items[p_].rarity == 999 || items[p_].rarity > 360 || items[p_].rarity <= 0)) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[```2That item is just too valuable to trade for tickets```5]``");
				else {
					pInfo(peer)->lastchoosenitem = p_;
					p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|Golden Tickets cost 100 Rarity worth of any items. If you give me extras, I'll keep a record.|left|\nadd_textbox|Those things have " + to_string(items[p_].rarity) + " Rarity, and you have " + to_string(have) + " of them.|left|\nadd_textbox|You currently have a credit of " + to_string(pInfo(peer)->carnival_credit) + " Rarity.|left|\nadd_textbox|So... how many you wanna give me?|left|\nadd_text_input|count||" + to_string(have) + "|5|\nend_dialog|ticket_booth|Cancel|OK|");
				}
				p.CreatePacket(peer);
				return false;
			}
			else if (items[t_].blockType == BlockTypes::DISPLAY) {
				string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
				bool access = false;
				if (block_->locked) {
					WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
					if (to_lower(block2_->owner_name) == to_lower(pInfo(peer)->tankIDName)) access = true;
				}
				if (world_->owner_name.empty() && access == false) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("This area must be locked to put your item on display!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (owner_name != user_name and not pInfo(peer)->dev and access == false) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Only the block's owner can place items in it.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (block_->id != 0) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Remove what's in there first!");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (p_ == 1424 or p_ == 5816) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("No sir.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (items[p_].untradeable) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("You can't display untradeable items.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (items[p_].blockType == BlockTypes::LOCK or items[p_].blockType == BlockTypes::DISPLAY or items[p_].blockType == BlockTypes::FISH) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Sorry, no displaying Display Blocks or Locks.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else if (items[p_].blockType == BlockTypes::FISH) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("You can't display fish.");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
				else {
					int c_ = -1;
					if (modify_inventory(peer, p_, c_) == 0) {
						block_->id = p_;
						gamepacket_t p(0, pInfo(peer)->netID);
						p.Insert("OnPlayPositioned");
						p.Insert("audio/blorb.wav");

						// update item visual in display block
						PlayerMoving data_effect_{};
						data_effect_.packetType = 19;
						data_effect_.punchX = p_;
						data_effect_.punchY = pInfo(peer)->netID;
						data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
						BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
						raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 4;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								p.CreatePacket(currentPeer);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]  raw_effect;
						tile_update(peer, world_, block_, x_, y_);
						return true;
					}
				}
				return false;
			}
			else if (items[t_].blockType == BlockTypes::DONATION) {
			pInfo(peer)->lastwrenchb = t_;
			gamepacket_t p;
			if (items[p_].untradeable == 1 || p_ == 1424 || p_ == 5816) {
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4You can't place that in the box, you need it!`7]``"), p.Insert(0), p.Insert(0);
			}
			else if (items[p_].rarity == 1) {
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4This box only accepts items rarity 2+ or greater`7]``"), p.Insert(0), p.Insert(0);
			}
			else if (block_->donates.size() >= 20) {
				p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You aren't able to fit another gift inside, it's jammed full."), p.Insert(0), p.Insert(0);
			}
			else {
				pInfo(peer)->lastchoosenitem = p_;
				p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|How many to put in the box as a gift? (Note: You will `4LOSE`` the items you give!)|left|\nadd_text_input|count|Count:|" + to_string(have) + "|5|\nadd_text_input|sign_text|Optional Note:||128|\nadd_spacer|small|\nadd_button|give|`4Give the item(s)``|noflags|0|0|\nadd_spacer|small|\nadd_button|cancel|`wCancel``|noflags|0|0|\nend_dialog|give_item|||\n");
			}
			p.CreatePacket(peer);
			return false;
			}
			else if (items[p_].blockType == BlockTypes::CLOTHING) {
				if (t_ == 2452) {
					pInfo(peer)->lastwrenchb = t_;
					gamepacket_t p;
					if (items[p_].r_1 == 2037 || items[p_].r_2 == 2037 || items[p_].r_1 == 2035 || items[p_].r_2 == 2035 || items[p_].r_1 + items[p_].r_2 == 0 || items[p_].blockType != BlockTypes::CLOTHING || items[p_].untradeable || p_ == 1424 || p_ == 5816 || items[p_].rarity > 200) {
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2Only spliceable clothing can be crushed!``]``"), p.Insert(0), p.Insert(0);
					}
					else {
						pInfo(peer)->lastchoosenitem = p_;
						p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|You have " + to_string(have) + " " + items[p_].name + ". How many will you crush?|left|\nadd_textbox|`4Beware:`` If you don't have room in your inventory for the resulting items, they will drop on the floor.|left|\nadd_text_input|count||" + to_string(have) + "|5|\nend_dialog|compactor|Cancel|OK|");
					}
					p.CreatePacket(peer);
				}
				else if (items[t_].blockType == BlockTypes::MANNEQUIN) {
					if (items[p_].untradeable) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`5[`2You cannot place " + items[p_].name + " on " + items[t_].name + "!``]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					else if (items[p_].clothType == ClothTypes::ANCES) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`5[`2It's not safe to place " + items[p_].name + " on " + items[t_].name + "!``]``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					else {
						uint16_t current_mannequin_item = 0;
						switch (items[p_].clothingType) {
						case 0: current_mannequin_item = block_->mannequin.c_hair;
							break;
						case 1: current_mannequin_item = block_->mannequin.c_shirt;
							break;
						case 2: current_mannequin_item = block_->mannequin.c_pants;
							break;
						case 3: current_mannequin_item = block_->mannequin.c_feet;
							break;
						case 4: current_mannequin_item = block_->mannequin.c_head;
							break;
						case 5: current_mannequin_item = block_->mannequin.c_hand;
							break;
						case 6: current_mannequin_item = block_->mannequin.c_back;
							break;
						case 7: current_mannequin_item = block_->mannequin.c_mask;
							break;
						case 8: current_mannequin_item = block_->mannequin.c_neck;
							break;
						case 9: {
							return false;
						}
						} if (current_mannequin_item == p_) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`5[`2You giggle as you swap two identical items``]``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
						else {
							gamepacket_t p;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|Do you really want to put your " + items[p_].name + " on the " + items[t_].name + "?|left|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nembed_data|put|" + to_string(p_) + "\nend_dialog|mannequin_edit|No|Yes|");
							p.CreatePacket(peer);
						}
					}
					return false;
				}
				else if (items[block_->fg].blockType == BlockTypes::GEIGER_CHARGER and p_ == 2286 or p_ == 2204) {
					if (p_ == 2204) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Your " + items[p_].name + " doesn't need charging!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					else if (block_->id != 0) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("That charger is already in use!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
					else {
						int c_ = -1;
						if (modify_inventory(peer, p_, c_) == 0) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/mlaunch.wav");
							block_->id = p_, block_->planted = time(nullptr) + 3600;
							PlayerMoving data_effect_{};
							data_effect_.packetType = 19;
							data_effect_.punchX = p_;
							data_effect_.punchY = pInfo(peer)->netID;
							data_effect_.x = x_ * 32 + 16, data_effect_.y = y_ * 32 + 16;
							BYTE* raw_effect = packPlayerMoving(&data_effect_, 56);
							raw_effect[8] = pInfo(peer)->netID, raw_effect[3] = 4;
							PlayerMoving data_{};
							data_.packetType = 5, data_.punchX = pInfo(peer)->lastwrenchx, data_.punchY = pInfo(peer)->lastwrenchy, data_.characterState = 0x8;
							BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, block_));
							BYTE* blc = raw + 56;
							block_->flags = (block_->flags & 0x00400000 ? block_->flags : block_->flags | 0x00400000);
							form_visual(blc, *block_, *world_, peer, false, true);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								send_raw(currentPeer, 4, raw, 112 + alloc_(world_, block_), ENET_PACKET_FLAG_RELIABLE);
								send_raw(currentPeer, 4, raw_effect, 56, ENET_PACKET_FLAG_RELIABLE);
							}
							delete[] raw, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
						}
					}
					return true;
				}
				else {
					if (pInfo(peer)->trading_with != -1)cancel_trade(peer, false, true);
					 equip_clothes(peer, p_);
				}
				break;
			}
			else if (p_ == 3936 or p_ == 4134) {
				if (block_->fg != 3938 && block_->fg != 9960) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("You must put that into Fossil Prep Station!");
					p.Insert(0), p.Insert(1);
					p.CreatePacket(peer);
				}
				else {
					int remove_ = -1;
					if (block_->shelf_1 == 0) {
						modify_inventory(peer, p_, remove_);
						int i_ = pInfo(peer)->lastwrenchx + (pInfo(peer)->lastwrenchy * 100), x_ = (i_ % 100), y_ = (i_ / 100);
						block_->shelf_1 = p_;
						block_->fg = 9962;
						update_tile(peer, x_, y_, 9962, true);
						block_->planted = time(nullptr) - items[9948].growTime + rand() % 86400 + 3600;
						PlayerMoving data2_{};
						data2_.packetType = 19, data2_.netID = -1, data2_.plantingTree = 0, data2_.x = pInfo(peer)->lastwrenchx * 32 + 16, data2_.y = pInfo(peer)->lastwrenchy * 32 + 16, data2_.XSpeed = pInfo(peer)->x + 16, data2_.YSpeed = pInfo(peer)->y + 16, data2_.punchX = p_;
						BYTE* raw2 = packPlayerMoving(&data2_);
						raw2[3] = 6;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(peer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[] raw2;
						tile_update(peer, world_, block_, x_, y_);
					}
					else {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`7[```4Fossil Preparation Station is busy!`7]``"), p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
					}
				}
			}
			else if (items[p_].blockType == BlockTypes::CONSUMABLE) {
				{
					int got = 0;
					/*
					if (p_ == 1360 && t_ == 6746) {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						modify_inventory(peer, p_, got = -1);
						PlayerMoving data_{};
						data_.packetType = 19, data_.netID = -1, data_.plantingTree = 500;
						data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
						data_.XSpeed = pInfo(peer)->x + 16, data_.YSpeed = pInfo(peer)->y + 16;
						data_.punchX = 1360;
						BYTE* raw = packPlayerMoving(&data_);
						raw[3] = 6;
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == world_->name) {
								send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
							}
						}
						delete[]raw;
						add_gift();
						daily_quest_winterfest(peer, false, "44", 1);
						break;
					}*/
					if (has_playmod2(pInfo(peer), 139) && (p_ == 10016 or p_ == 2992) or pInfo(peer)->world == Hide_N_Seek.hidenseekworld) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Can not use at the moment!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						break;
					}
					if (p_ == 10016) {
						join_hidenseek(peer);
						break;
					}
					if (p_ == 3684) {
						if (block_access(peer, world_, block_)) {
							if (block_->fg == 0) {
								int remove_ = -1;
								modify_inventory(peer, p_, remove_);
								block_->fg = 9828;
								block_->planted = time(nullptr) + 86400;
								update_tile(peer, x_, y_, 9828, false, true);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Something is block that way!");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(peer);
							}
						}
						break;
					}
					/*
					if (p_ == 10540) {
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got == 0) break;
						modify_inventory(peer, p_, got = -1);
						pInfo(peer)->winterfest_wishes += 300;
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("You have claimed `2300`` Winter Wishes!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						break;
					}*/
					if (p_ == 3204 && t_ != 3200) {
						talk_bubble(peer, pInfo(peer)->netID, "`4Can't waste decorations on a non-Giving Tree!", 0, false);
						break;
					}
					if (p_ == 2966) {
						if (block_access(peer, world_, block_)) {
							if (items[t_].multiple_sides) {
								if (block_->flags & 0x00200000) block_->flags = block_->flags ^ 0x00200000;
								else block_->flags |= 0x00200000;
								int remove_ = -1;
								modify_inventory(peer, p_, remove_);

								PlayerMoving data2_{};
								data2_.packetType = 17, data2_.netID = 97, data2_.YSpeed = 97, data2_.x = x_ * 32 + 16, data2_.plantingTree = 300, data2_.y = y_ * 32 + 16, data2_.XSpeed = t_;
								BYTE* raw2 = packPlayerMoving(&data2_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
									send_raw(currentPeer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[] raw2;
								tile_update(peer, world_, block_, x_, y_);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Block does not have both sides!");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(peer);
							}
						}
						break;
					}
					if (p_ == 6336) {
						guide_book(peer);
						break;
					}
					if (p_ == 4844 || p_ == 4846 || p_ == 4848) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Can't throw balloons! War has not started yet.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						break;
					}
					if (p_ == 4850 || p_ == 4852 || p_ == 4854) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Can't throw a bucket! You can only shatter this.");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						break;
					}
					if (p_ == 7190) {
						change_guild_name(peer);
						break;
					}
					if (p_ == 4844 || p_ == 4846 || p_ == 4848) {
						if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 4884) != world_->active_jammers.end()) {
							if (!guild_access(peer, world_->guild_id) and to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end()) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Can't throw balloons here!");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(peer);
								break;
							}
						}
					}
					if (find(world_->active_jammers.begin(), world_->active_jammers.end(), 3616) != world_->active_jammers.end()) {
						if (!guild_access(peer, world_->guild_id) and to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end()) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Can't use consumables here!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							break;
						}
					}
					if (p_ == 9950) {
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wCredit Card``|left|9950|\nadd_spacer|small|\nadd_textbox|IBAN: GTPS" + to_string(pInfo(peer)->credit_card) + to_upper(pInfo(peer)->tankIDName) + "|\nadd_textbox|Balance: `2" + setGems(pInfo(peer)->total_credit_card) + "`` World Locks|\nadd_spacer|small|\nadd_textbox|You have `2" + setGems(get_wls(peer, true)) + "`` World Locks|\nadd_spacer|small|\nadd_textbox|Choose if you want to deposit or withdraw:|\nadd_spacer|small|\nadd_button|deposit|`wDeposit``|noflags|0|0|\nadd_button|withdraw|`wWithdraw``|noflags|0|0|\nend_dialog|credit_card|OK||\n\nadd_quick_exit|");
						p.CreatePacket(peer);
						break;
					}
					switch (p_) {
					case 3098: case 3218: case 3014: case 3012: case 3018: case 5526: case 3020: case 2914: case 4248: case 5528: case 4246: case 3016: case 3432:
					{
						if (block_->flags & 0x04000000) {
							if (block_->fg != 0 || pInfo(peer)->x < 32 || pInfo(peer)->x >= world_->max_x*32 || pInfo(peer)->y < 32 || pInfo(peer)->y >= world_->max_y*32) {
								talk_bubble(peer, pInfo(peer)->netID, "Something is blocking the way!", 0, 0);
								console_msg(peer, "Something is blocking the way!");
							}
							else {
								if (pInfo(peer)->hand == 3040 || pInfo(peer)->hand == 3010 || pInfo(peer)->hand == 2912 || pInfo(peer)->hand == 3008 || pInfo(peer)->hand == 3100 || pInfo(peer)->hand == 5740 || pInfo(peer)->hand == 6254 || pInfo(peer)->hand == 6256 || pInfo(peer)->hand == 6932 || pInfo(peer)->hand == 10262 || pInfo(peer)->hand == 6258) {
									if (pInfo(peer)->fishing_used == 0) {
										if (abs(pInfo(peer)->x / 32 - x_) <= 1 && abs(y_ - pInfo(peer)->y / 32) == 1 && pInfo(peer)->x / 32 != x_ && pInfo(peer)->y / 32 != y_) {
											if (pInfo(peer)->hair == 3042 && rand() % 100 < 5) {

											}
											else modify_inventory(peer, p_, got = -1);
											pInfo(peer)->fish_seconds = 1850;
											if (pInfo(peer)->hand == 3008) pInfo(peer)->fish_seconds *= 2;
											pInfo(peer)->fishing_used = p_, pInfo(peer)->f_x = x_, pInfo(peer)->f_y = y_, pInfo(peer)->move_warning = 0, pInfo(peer)->f_xy = pInfo(peer)->x + pInfo(peer)->y, pInfo(peer)->punch_warning = 0;
											PlayerMoving data_{};
											data_.packet_3 = 0, data_.netID = pInfo(peer)->netID, data_.x = pInfo(peer)->f_x, data_.y = pInfo(peer)->f_y;
											BYTE* raw = packFishMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
										}
										else {
											talk_bubble(peer, pInfo(peer)->netID, "Sit still before you try to fish!", 0, 0);
											console_msg(peer, "Sit still before you try to fish!");
										}
									}
									else if (pInfo(peer)->fishing_used != 0) stop_fishing(peer, false, "");
								}
								else {
									talk_bubble(peer, pInfo(peer)->netID, "You'll need a fishing rod to fish!", 0, 0);
									console_msg(peer, "You'll need a fishing rod to fish!");
								}
							}
						}
						break;
					}
					case 4366:
					{
						if (has_playmod2(pInfo(peer), 13)) {
							int time_ = 0;
							for (PlayMods peer_playmod : pInfo(peer)->playmods) {
								if (peer_playmod.id == 13) {
									time_ = peer_playmod.time - time(nullptr);
									break;
								}
							}
							packet_(peer, "action|log\nmsg|>> (" + to_playmod_time(time_) + " before you can broadcast again)", "");
							break;
						}
						int remove = -1;
						modify_inventory(peer, 4366, remove);
						add_playmod(peer, 13);
						packet_(peer, "action|play_sfx\nfile|audio/dialog_confirm.wav\ndelayMS|0");
						console_msg(peer, ">> `5PARTY SCREAM`` sent. Used `$1 Party Screamer``. (`$" + to_string(remove) + "`` left)`` (5 mins before you can broadcast again)");
						console_msg(peer, "100% to a party time. MrBuncis is getting ready to party with a Party Screamer!");
						console_msg(peer, "LET'S GET THIS PARTY STARTED!!!!");
						vector<string> random_texts{"/dance the night away in ["+ pInfo(peer)->world +"]!", "Ain't no party like a GT party cuz a GT party is dissimilar from other parties!", "Bring da noise to [" + pInfo(peer)->world + "] but please, leave the funk at home!", "Come join the fun!", "Crank it up!!!", "Don't be tardy for the party!" , "Everybody just have a good time!", "Everybody's invited to the party!", "I'm like a good demon, bringin' the party in!" , "PARTY! PARTY! PARTY!", "Party down in ["+pInfo(peer)->world + "]!", "Peace, love, and party!" , "Ready Growtopia? ROCK OUT!", "Step up to the dancefloor!", "The beats don't stop until the break of dawn!", "The fun is here!", "This party is off the chain!", "This party is on the chain, but very very loosely connected, so it could come off at any moment. Come watch!" , "Tonight we gonna party like it's "+to_string(rand() % 30 + 1985) + "!"};
						string text = random_texts[rand() % random_texts.size()];
						{
							gamepacket_t p;
							p.Insert("OnAddNotification");
							p.Insert("interface/large/special_event.rttex");
							vector<int> list{ 9252, 11542, 13048, 13028, 10552, 2280, 4372, 2290, 4370, 1412, 1410, 1408, 1406, 1414, 1416 };
							int item = list[rand() % list.size()];
							if (item == 9252) text = "COME check out my new Rocket Shoes! This party is gonna hit the roof!";
							else if (item == 11542) text = "COME check out my Neon Party YO-YO! This party is going around the world!";
							int give_count = 1;
							if (modify_inventory(peer, item, give_count) != 0) {
								WorldDrop drop_block_{};
								drop_block_.id = item, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
								dropas_(world_, drop_block_);
							}
						}
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						if (pInfo(peer)->m_h != 1 and find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) == world_->active_jammers.end()) World_Stuff.lastsbworld = pInfo(peer)->world;
						p.Insert("CP:_PL:0_OID:_CT:[SB]_ `5** from (`0" + (get_player_nick(peer)) + "`5) in [```$" + (pInfo(peer)->m_h == 1 || find(world_->active_jammers.begin(), world_->active_jammers.end(), 226) != world_->active_jammers.end() ? "`4JAMMED!``" : pInfo(peer)->world) + "```5] ** : ``" + (pInfo(peer)->mod + pInfo(peer)->dev == 0 ? "`$" : "`^") + "" + text + "``");
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->radio or pInfo(currentPeer)->temp_radio) continue;
							p.CreatePacket(currentPeer);
						}
						break;
					}
					case 3822: case 5458: case 6760:
					{
						apply_dye(peer, world_, block_, p_, x_, y_, 0x0000FFFF, (p_ == 6760 ? 32 : 16), -16, -16, false);
						break;
					}
					case 6916:
					{
						if (block_access(peer, world_, block_)) {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
							if (block_->fg == 0) 	p.Insert("You can not `5Flash Back`` an empty block.");
							else if (items[block_->fg].properties & Property_Mod || items[block_->fg].untradeable || items[block_->fg].blockType == BlockTypes::SEED || items[block_->fg].rarity < 0 || items[block_->fg].rarity == 999 || items[block_->fg].block_possible_put == false || block_->fg == 2946 || block_->fg == 610 || block_->fg == 3528 || items[block_->fg].blockType == BlockTypes::PROVIDER) {
								p.Insert("You can not `5Flash Back`` this block.");
							}
							else {
								int give_flash = 1, remove = -1;
								if (modify_inventory(peer, block_->fg, give_flash) == 0) {
									modify_inventory(peer, p_, remove);
									p.Insert("1 " + items[block_->fg].ori_name + " `5Flashed Back`` to a time when it was still in your inventory.");
									block_->fg = 0;
									update_tile(peer, x_, y_, 0, false, true);
									gamepacket_t p;
									p.Insert("OnParticleEffect"), p.Insert(90), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y + 16);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or world_->name != pInfo(currentPeer)->world) continue;
										p.CreatePacket(currentPeer);
									}

								}
								else {
									p.Insert("Your inventory is full");
								}
							}
							p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						}
						break;
					}
					case 3824: case 5460: case 6762:
					{
						apply_dye(peer, world_, block_, p_, x_, y_, 0x00FF00FF, -16, (p_ == 6762 ? 32 : 16), -16, false);
						break;
					}
					case 3826: case 5462: case 6764:
					{
						apply_dye(peer, world_, block_, p_, x_, y_, 0xFF0000FF, -16, -16, (p_ == 6764 ? 32 : 16), false);
						break;
					}
					case 3828: case 5464: case 6766:
					{
						apply_dye(peer, world_, block_, p_, x_, y_, 0x000000FF, (p_ == 6766 ? -32 : -16), (p_ == 6766 ? -32 : -16), (p_ == 6766 ? -32 : -16), false);
						break;
					}
					case 3830: case 5466: case 6768:
					{
						apply_dye(peer, world_, block_, p_, x_, y_, 0xFFFFFFFF, 32, 32, 32, true);
						break;
					}
					case 4132:
					{
						bool remove = false;
						for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
							if (world_->drop_new[i_][0] == 0) continue;
							if (x_ == (world_->drop_new[i_][3] / 32) && y_ == (world_->drop_new[i_][4] / 32) && world_->drop_new[i_][0] == 3936) {
								remove = true;
								PlayerMoving data_{};
								data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop_new[i_][2];
								BYTE* raw = packPlayerMoving(&data_);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								}
								delete[]raw;
								WorldDrop drop_block_{};
								drop_block_.id = 4134, drop_block_.count = world_->drop_new[i_][1], drop_block_.x = world_->drop_new[i_][3], drop_block_.y = world_->drop_new[i_][4];
								dropas_(world_, drop_block_);
								world_->drop_new.erase(world_->drop_new.begin() + i_);
							}
						}
						if (remove) {
							modify_inventory(peer, p_, got = -1);
							if (rand() % 100 < (items[p_].newdropchance + 5)) {
								WorldDrop drop_seed_{};
								drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
								if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
							}
							else if (rand() % 10 < 4) gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_);
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You can only brush Fossils that have never been picked up!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
						}
						break;
					}
					case 12600: case 13574:
					{
						pInfo(peer)->lastwrenchb = p_;
						gamepacket_t p;
						if (has_playmod2(pInfo(peer), 144)) {
							p.Insert("OnConsoleMessage");
							p.Insert("`6>> That's sort of hard to do while having a cooldown.``");
						}
						else if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) || pInfo(peer)->superdev || find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) != world_->admins.end()) {
							int ungrown = 0;
							long long times_ = time(nullptr);
							for (int i_ = 0; i_ < world_->blocks.size(); i_++) if (items[world_->blocks[i_].fg].blockType == BlockTypes::SEED and (times_ - world_->blocks[i_].planted <= items[world_->blocks[i_].fg].growTime ? times_ - world_->blocks[i_].planted : items[world_->blocks[i_].fg].growTime) != items[world_->blocks[i_].fg].growTime) ungrown++;
							p.Insert("OnDialogRequest");
							p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[p_].ori_name + "``|left|"+to_string(p_) + "|\nadd_spacer|small|\nadd_textbox|There is `2" + to_string(ungrown) + "`` ungrown tree that this spray will work on.|\nadd_spacer|small|\nadd_textbox|Are you sure you want to use the " + items[p_].ori_name + " on this world?|\nend_dialog|world_spray|No|Yes|\n\nadd_quick_exit|");
						}
						else {
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You must own the world!"), p.Insert(0), p.Insert(0);
						}
						p.CreatePacket(peer);
						break;
					}
					case 5250:  case 5252: case 5254:
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You must combine this item!"), p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					case 5664:
					{
						if (block_->fg == 0) {
							modify_inventory(peer, p_, got = -1);
							gamepacket_t p;
							p.Insert("OnAddNotification");
							p.Insert("interface/large/special_event.rttex");
							vector<int> list{ 5652, 3398, 386, 4422, 364, 9342, 9340, 9334, 9332, 9336, 9338, 4400, 7808, 7810, 4416, 7818, 7820, 7822, 7824, 5644, 390, 7826, 7830, 9324, 5658, 3396, 2384, 5660, 10654, 3400, 4418, 388, 3408, 1470, 3404, 3406, 10662, 2390, 5656, 5648, 2396, 384, 5664, 4424, 366 };
							int item = list[rand() % list.size()];
							WorldDrop drop_block_{};
							drop_block_.id = item, drop_block_.count = (item == 7810 || item == 7808 || item == 4400 || item == 390 || item == 3408 || item == 4422 || item == 3404 ? 5 : (item == 4418 || item == 5660 ? 2 : 1)), drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
							dropas_(world_, drop_block_);
							p.Insert("`2Valentine's Card:`` Cupid has just spawned a `#" + items[item].name + "``.");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) p.CreatePacket(currentPeer);
							}
						}
						break;
					}
					case 722:
					{
						if (block_->fg == 0) {
							modify_inventory(peer, p_, got = -1);
							block_->fg = 718;
							gamepacket_t p;
							p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2`4Pi`wna`2ta`` `wBash``!:`` `oSmash the `wUltra`` `4Pi`wna`2ta``! `#Get some help``!``"), p.Insert("audio/cumbia_horns.wav");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
								update_tile(currentPeer, x_, y_, 718, false, false);
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
					case 1050:
					{
						modify_inventory(peer, p_, got = -1);
						console_msg(peer, "`6The mysterious secert is...``\n `2"+ random_quotes[rand() % random_quotes.size()] +"``");
						break;
					}
					case 7342:
					{
						if (block_->fg == 0) {
							modify_inventory(peer, p_, got = -1);
							block_->fg = 10294;
							gamepacket_t p;
							p.Insert("OnAddNotification"), p.Insert("interface/large/special_event.rttex"), p.Insert("`2Turkey Surprise:`` You have to hunt `8Thanksgiving Turkeys``! Get some help!"), p.Insert("audio/cumbia_horns.wav");
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
								update_tile(currentPeer, x_, y_, 10294, false, false);
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
					case 1220:
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (world_->name == "GROWGANOTH") {
							modify_inventory(peer, p_, got = -1);
							p.Insert("`5Growganoth pulls you closer!``");
							OnSetPos(peer, 1568, 416);
						}
						else p.Insert("The sigil fizzles... try using it near Growganoth!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					case 3400:
					{
						if (block_->fg != 10) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("`4This potion is clearly labeled for use only on rocks.``");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							break;
						}
						int c_ = -1;
						if (modify_inventory(peer, 3400, c_) == 0) {
							block_->fg = 392;
							gamepacket_t p;
							p.Insert("OnParticleEffect"), p.Insert(44), p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16);
							PlayerMoving data_2{};
							data_2.packetType = 5, data_2.punchX = x_, data_2.punchY = y_, data_2.characterState = 0x8;
							int alloc = alloc_(world_, block_);
							BYTE* raw2 = packPlayerMoving(&data_2, 112 + alloc);
							BYTE* blc = raw2 + 56;
							form_visual(blc, *block_, *world_, peer, false);
							string t_ = "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0";
							BYTE* const d_ = new BYTE[5 + t_.length()];
							*(__int8*)(d_) = 3;
							memcpy(d_ + 4, t_.c_str(), t_.length());
							*(__int8*)(d_ + 4 + t_.length()) = 0;
							ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == world_->name) {
									p.CreatePacket(currentPeer);
									enet_peer_send(currentPeer, 0, p_m);
									send_raw(currentPeer, 4, raw2, 112 + alloc, ENET_PACKET_FLAG_RELIABLE);
								}
							}
							delete[]d_;
							delete[] raw2, blc;
							if (block_->locked) upd_lock(*block_, *world_, peer);
						}
						break;
					}
					case 7962:	case 9826:
					{
						if (items[t_].blockType == BlockTypes::PROVIDER && t_ != 12986) {
							long long time_ = time(NULL);
							uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
							if (laikas < unsigned int(items[block_->fg].growTime)) {
								long long spray_time_ = 3600 * 6; // 6 hours
								if (p_ == 9826) spray_time_ = 3600 * 12;
								block_->planted -= spray_time_;
								gamepacket_t p;
								p.Insert("OnTextOverlay");
								if (time_ - block_->planted <= items[block_->fg].growTime) {
									if (spray_time_ < 86400)
										p.Insert(items[block_->fg].name + " Provider `eaged`` `$" + to_string(spray_time_ / 60 / 60) + "`` hours");
									else
										p.Insert(items[block_->fg].name + " Provider `eaged`` `$" + to_string(spray_time_ / 86400) + "`` days");
								}
								else {
									p.Insert(items[block_->fg].name + " Provider is ready!");
								}
								p.CreatePacket(peer);
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/spray.wav");
									p.CreatePacket(peer);
								}
								tile_update(peer, world_, block_, x_, y_);
								int c_ = -1;
								modify_inventory(peer, p_, c_);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("This provider is already ready, don't waste your spray on it!");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Use this on a provider to speed it up.");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
						}
						break;
					}
					case 228: case 1062: case 1778: case 5764: case 10672:
					{
						if (items[t_].blockType == BlockTypes::SEED) {
							long long time_ = time(NULL);
							uint32_t laikas = uint32_t((time_ - block_->planted <= items[block_->fg].growTime ? time_ - block_->planted : items[block_->fg].growTime));
							if (laikas < unsigned int(items[block_->fg].growTime)) {
								long long spray_time_ = 3600; // 1 hours
								if (p_ == 1062)
									spray_time_ = _int64(2.592e+6); // 30 days
								if (p_ == 1778)
									spray_time_ = 86400; // 24 hours
								if (p_ == 5764)
									spray_time_ = 259200; // 72 hours
								block_->planted -= spray_time_;
								gamepacket_t p, p2(0, pInfo(peer)->netID);
								p.Insert("OnTextOverlay");
								if (time_ - block_->planted <= items[block_->fg].growTime) {
									if (spray_time_ < 86400) p.Insert(items[block_->fg - 1].name + " Tree aged `$" + to_string(spray_time_ / 60 / 60) + "`` hours");
									else p.Insert(items[block_->fg - 1].name + " Tree aged `$" + to_string(spray_time_ / 86400) + "`` days");
								}
								else p.Insert(items[block_->fg - 1].name + " Tree grew to full size!");
								p.CreatePacket(peer);
								p2.Insert("OnPlayPositioned"), p2.Insert("audio/spray.wav"), p2.CreatePacket(peer);
								tile_update(peer, world_, block_, x_, y_);
								int c_ = -1;
								modify_inventory(peer, p_, c_);
							}
							else {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("This tree has already bloomed, don't waste your spray on it!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Use this on a growing tree to speed it's growth."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						}
						break;
					}
					case 10394: case 5138: case 5140: case 5142: case 11432: case 4490:
					{
							modify_inventory(peer, p_, got = -1);
							got = 1;
						/*
						if (p_ == 10394) {
							if (rand() % 100 < 2) {
								int black_box = 1;
								if (modify_inventory(peer, 10396, black_box) == 0) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You received `2"+items[10396].ori_name + "``!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								}
							}
						}*/
						PlayerMoving data2_{};
						data2_.x = pInfo(peer)->x + 16, data2_.y = pInfo(peer)->y + 16, data2_.packetType = 19, data2_.punchX = 9438, data2_.punchY = pInfo(peer)->netID;
						int32_t to_netid = pInfo(peer)->netID;
						BYTE* raw2 = packPlayerMoving(&data2_);
						raw2[3] = 5;
						memcpy(raw2 + 8, &to_netid, 4);
						send_raw(peer, 4, raw2, 56, ENET_PACKET_FLAG_RELIABLE);
						delete[] raw2;
						OnSetGems(peer, items[p_].max_gems3);
						break;
					}
					case 1488:
					{
						modify_inventory(peer, p_, got = -1);
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("`5GULP! You got smarter!``");
						p.Insert(0);
						p.Insert(1);
						p.CreatePacket(peer);
						add_peer_xp(peer, 10000);
						break;
					}
					case 5706:
					{
						vector<pair<int, int>> receivingitems;
						int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1, inventoryfull = 0;
						if (free >= slot) {
							for (int i = 0; i < slot; i++) {
								int itemid = small_seed_pack[rand() % small_seed_pack.size()];
								receivingitems.push_back(make_pair(itemid, getcount));
							}
							for (int i = 0; i < slot; i++) {
								int itemcount = 0;
								modify_inventory(peer, receivingitems[i].first, itemcount);
								if (itemcount + getcount > 200) inventoryfull = 1;
							}
							if (inventoryfull == 0) {
								for (int i = 0; i < slot; i++) modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
								modify_inventory(peer, p_, got = -1);
							}
						}
						break;
					}
					case 9526:
					{
						vector<int> list{ 3831, 429, 1773, 4767, 667, 2835, 301, 1299, 361, 2709, 955, 461, 861, 9389, 5467, 2791, 2815, 1803, 555, 685, 741, 3931, 1775, 833, 2025, 621, 6401, 359, 309, 855, 1685, 1449, 1309, 441, 1111, 221, 1431, 3065, 9307, 1257, 1501, 1109, 4641, 3587, 1103, 743, 431, 3823, 3825, 1131, 727, 729, 187, 787, 5379, 5459, 4785, 3261, 3521, 2293, 5461, 3721, 2309, 327, 2321, 247, 63, 2333, 3479, 445, 4783, 299, 863, 8935, 1451, 261, 1871, 1499, 455, 9391, 683, 1159, 551, 1745, 411, 3005, 8239, 687, 4799, 559, 4643, 3899, 1605, 9309, 567, 565, 1155, 3827, 1327, 1767, 993, 1157, 563, 4721, 115, 1423, 10515, 1329, 6545, 287, 669, 777, 5463, 1655, 1599, 561, 4585, 3413, 4745, 1771, 2011, 1161, 1729, 3757, 3753, 321, 3265, 3263, 623, 775, 6397, 129, 4667, 759, 3767, 1529, 6543, 4707, 3835, 1435, 651, 8929, 569, 527, 3287, 1595, 6063, 2795, 1003, 1731, 4943, 4963, 597, 4669, 1531, 1523, 625, 4297, 599, 657, 571, 873, 3755, 2969, 1725, 4603, 1447, 3267, 5375, 1683, 1613 };
						vector<pair<int, int>> receivingitems;
						int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1, inventoryfull = 0;
						if (free >= slot) {
							for (int i = 0; i < slot; i++) {
								int itemid = list[rand() % list.size()];
								receivingitems.push_back(make_pair(itemid, getcount));
							}
							for (int i = 0; i < slot; i++) {
								int itemcount = 0;
								modify_inventory(peer, receivingitems[i].first, itemcount);
								if (itemcount + getcount > 200) inventoryfull = 1;
							}
							if (inventoryfull == 0) {
								for (int i = 0; i < slot; i++) modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
								modify_inventory(peer, p_, got = -1);
							}
						}
						break;
					}
					case 1828: case 11286: case 3870:
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert(p_ == 3870 ? "That's like a hundred years old. No." : "Ew, it has raisins! I'm not eating that."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						break;
					}
					case 1066:
					{
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got >= 1) {
							modify_inventory(peer, p_, got = -1);
							gamepacket_t p;
							p.Insert("OnParticleEffect"), p.Insert(50), p.Insert((float)(x_ * 32) + 16, (float)(y_ * 32) + 16);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
					case 6140:
					{
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got >= 1) {
							string foundlist = "";
							gamepacket_t p;
							if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName) and not pInfo(peer)->dev and (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), to_lower(pInfo(peer)->tankIDName)) == world_->admins.end())) {
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Only the owner of this tile has access!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								break;
							}
							for (int i_ = 0; i_ < world_->drop_new.size(); i_++) if (world_->drop_new[i_][0] != 0 && world_->drop_new[i_][0] != 112 && items[world_->drop_new[i_][0]].untradeable == 0 && world_->drop_new[i_][0] != 4490 && world_->drop_new[i_][3] > 0 && world_->drop_new[i_][4] > 0 && world_->drop_new[i_][3] / 32 == x_ && world_->drop_new[i_][4] / 32 == y_) foundlist += to_string(world_->drop_new[i_][0]) + "," + to_string(world_->drop_new[i_][1]) + "," + to_string(world_->drop_new[i_][2]) + ",";
							if (foundlist != "") p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wExtract-O-Snap``|left|6140|\nadd_spacer|small|\nadd_textbox|GrowTech: use the Extract-O-Snap to pick out the items from the floating items in your world! - Thanks, Technician Dave.|left|\nadd_spacer|small|\nadd_textbox|Press on the icon to extract the item into your inventory.|left|\nadd_spacer|small|\nadd_textbox|`wItem List:|left|\nadd_label_with_icon_button_list|small|`w%s : %s|left|extractOnceObj_|itemID_itemAmount_worldObj|" + foundlist + "\nadd_spacer|small|\nend_dialog|extractor|Close||");
							else p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("There are no floating items in the extraction area!"), p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
						}
						break;
					}
					case 1826:
					{
						int got = 0;
						modify_inventory(peer, p_, got);
						if (got >= 1) {
							modify_inventory(peer, p_, got = -1);
							gamepacket_t p;
							p.Insert("OnParticleEffect"), p.Insert(92), p.Insert((float)(x_ * 32) + 16, (float)(y_ * 32) + 16);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
								p.CreatePacket(currentPeer);
							}
						}
						break;
					}
					case 5632:
					{
						int given = 1;
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (pInfo(peer)->hair == 4652 && pInfo(peer)->shirt == 4650 && pInfo(peer)->pants == 4648 && pInfo(peer)->feet == 4646) {
							if (modify_inventory(peer, 5526, given) == 0) {
								p.Insert("`5" + items[p_].name + " combine to create a`` `2" + items[5526].name + "```5!``");
							}
							else p.Insert("You don't have enough inventory space!");
						}
						else p.Insert("You must wear hazmat set!");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					case 12370: case 4236: case 13158: case 2036: case 2034: case 7590: case 11656: case 2290: case 3122: case 1152: case 6330: case 1212: case 1234: case 3762: case 8534: case 2410: case 5256: case 3110: case 2000: case 2412: case 4426: case 4172: case 5282: case 3242: case 3186: case 8936: case 5636:
					{
						int got = 0, given = 1, needed = items[p_].consume_needed, give = items[p_].consume_prize[rand() % items[p_].consume_prize.size()];
						modify_inventory(peer, p_, got);
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (got >= items[p_].consume_needed) {
							bool block_ = false;
							if (p_ == 5256) {
								block_ = false;
								for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) {
									if (pInfo(peer)->inv[i_].first == 5216 || pInfo(peer)->inv[i_].first == 5218 || pInfo(peer)->inv[i_].first == 5220 || pInfo(peer)->inv[i_].first == 5214 || pInfo(peer)->inv[i_].first == 5232 || pInfo(peer)->inv[i_].first == 5222 || pInfo(peer)->inv[i_].first == 5238 || pInfo(peer)->inv[i_].first == 5240 || pInfo(peer)->inv[i_].first == 5244 || pInfo(peer)->inv[i_].first == 5246 || pInfo(peer)->inv[i_].first == 5236 || pInfo(peer)->inv[i_].first == 5224) block_ = true;
								}
							}
							else block_ = true;
							if (block_) {
								if (modify_inventory(peer, give, given) == 0) {
									modify_inventory(peer, p_, needed *= -1);
									p.Insert("`5" + items[p_].name + " combine to create a`` `2" + items[give].name + "```5!``");
								}
								else p.Insert("You don't have enough inventory space!");
							}
							else p.Insert("You must have one of the items!");
						}
						else p.Insert("`4You'll need more " + items[p_].name + " than that!``");
						p.Insert(0), p.Insert(0);
						p.CreatePacket(peer);
						break;
					}
					case 10228:
					{
						if (get_free_slots(pInfo(peer)) >= 1) {
							vector<pair<int, int>> mooncakes{ {11286, 1} , {1096, 10}, {1098, 10}, {1094, 10}, {1058, 10}, {3870, 4} };
							bool toobig = false;
							for (int i = 0; i < mooncakes.size(); i++) {
								int have = 0;
								modify_inventory(peer, mooncakes[i].first, have);
								if (have + mooncakes[i].second > 200) toobig = true;
							}
							if (toobig) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your inventory is full!"), p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
							}
							if (toobig) break;
							if (rand() % 500 < 1) mooncakes.insert(mooncakes.end(), { 12620,1 });
							vector<pair<int, int>> receivingitems;
							int free = get_free_slots(pInfo(peer)), slot = 5, getcount = 1;
							if (free >= slot) {
								for (int i = 0; i < slot; i++) {
									int randa = rand() % mooncakes.size(), itemid = mooncakes[randa].first, count = rand() % mooncakes[randa].second + 1;
									vector<pair<int, int>>::iterator p_r = find_if(receivingitems.begin(), receivingitems.end(), [itemid](const pair < int, int>& element) { return element.first == itemid; });
									if (p_r != receivingitems.end()) receivingitems[p_r - receivingitems.begin()].second += count;
									else receivingitems.push_back(make_pair(itemid, count));
								}
								string received = "";
								for (int i = 0; i < receivingitems.size(); i++) {
									int itemcount = 0;
									modify_inventory(peer, receivingitems[i].first, itemcount);
									if (itemcount + receivingitems[i].second > 200) toobig = true;
									else received += "`5" + to_string(receivingitems[i].second) + " " + items[receivingitems[i].first].name + "``" + (receivingitems.size() - i == 1 ? "" : " ");
								}
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
								if (toobig == false) {
									for (int i = 0; i < receivingitems.size(); i++) modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
									modify_inventory(peer, p_, got = -1);
									p.Insert("`0You got`` " + received + "`0.``");
								}
								else p.Insert("Your inventory is full!");
								p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
						}
						break;
					}
					case 10756:
					{
						if (get_free_slots(pInfo(peer)) >= 2) {
							vector<int> shard{ 10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10768,10766, 10764 };
							vector<int> egg{ 13372, 10762,2554,  8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550 ,  8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550 ,  8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550,8064, 8066, 8068, 2552, 9460, 2548, 2546, 2544, 2550 };
							bool toobig = false;
							for (int i = 0; i < shard.size(); i++) {
								int have = 0;
								modify_inventory(peer, shard[i], have);
								if (have >= 199) toobig = true;
							}
							for (int i = 0; i < egg.size(); i++) {
								int have = 0;
								modify_inventory(peer, egg[i], have);
								if (have >= 199) toobig = true;
							}
							if (toobig) break;
							vector<pair<int, int>> receivingitems;
							int free = get_free_slots(pInfo(peer)), slot = 2, getcount = 1, inventoryfull = 0;
							if (free >= slot) {
								for (int i = 0; i < slot; i++) {
									int itemid = i == 0 ? shard[rand() % shard.size()] : egg[rand() % egg.size()];
									receivingitems.push_back(make_pair(itemid, getcount = 1));
								}
								for (int i = 0; i < slot; i++) {
									int itemcount = 0;
									modify_inventory(peer, receivingitems[i].first, itemcount);
									if (itemcount + receivingitems[i].second > 200) inventoryfull = 1;
								}
								if (inventoryfull == 0) {
									OnSetEvent(peer, 1);
									string received = "";
									for (int i = 0; i < slot; i++) {
										if (receivingitems[i].first == 13372 || receivingitems[i].first == 10762 || receivingitems[i].first == 2554) {
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("Golden Egg Carton rewards " + get_player_nick(peer) + " with a `5Rare " + items[receivingitems[i].first].ori_name + ".");
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->temp_radio) continue;
												p.CreatePacket(currentPeer);
											}
										}
										int receiveds = receivingitems[i].second;
										modify_inventory(peer, receivingitems[i].first, receivingitems[i].second);
										if (i == 0)received += "`2" + to_string(receiveds) + " " + items[receivingitems[i].first].ori_name + "`` and ";
										else received += "`2" + to_string(receiveds) + " " + items[receivingitems[i].first].ori_name + "``";
									}
									modify_inventory(peer, p_, got = -1);
									talk_bubble(peer, pInfo(peer)->netID, "You received " + received + " from a Golden Egg Carton.", 0, 1);
									console_msg(peer, "You received " + received + " from a Golden Egg Carton.");
								}
							}
						}
						break;
					}
					case 5404: case 5402: case 10396: case 11476:  case 10538:case 7672: case 2306: case 13054: case 5750: case 9286: case 7346: case 9680: case 11860: case 11036: case 1680: case 1360: case 10536: case 11758: case 11756: case 10386: case 11398: case 8410: case 8408: case 8414: case 8412: case 7954: case 13598: case 7484: case 5948: case 12262: case 12264: case 12044: case 12046: case 12566: case 12568: case 12832: case 12830: case 11402: case 11404:
					{
						if (get_free_slots(pInfo(peer)) >= 1) {
							int received = 0;
							bool toobig = false;
							for (int i = 0; i < items[p_].noob_item.size(); i++)for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].first == items[p_].noob_item[i].first && pInfo(peer)->inv[i_].second + items[p_].noob_item[i].second >= 200) toobig = true;
							if (items[p_].newdropchance != 0) for (int i = 0; i < items[p_].rare_item.size(); i++)for (int i_ = 0; i_ < pInfo(peer)->inv.size(); i_++) if (pInfo(peer)->inv[i_].first == items[p_].rare_item[i].first && pInfo(peer)->inv[i_].second + items[p_].rare_item[i].second >= 200) toobig = true;
							if (p_ == 1680) {
								int got = 0;
								modify_inventory(peer, 834, got);
								if (got < 200) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID), p.Insert("Requires 200 Fireworks to launch!"), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									toobig = true;
								}
								else {
									toobig = false;
									modify_inventory(peer, 834, got = -200);
								}
							}
							if (toobig) break;
							int random = rand() % items[p_].noob_item.size(), itemid = items[p_].noob_item[random].first;
							got = items[p_].noob_item[random].second;
							if (items[p_].newdropchance != 0 && (rand() % items[p_].newdropchance) < 1) {
								if (items[p_].rare_item.size() != 0) random = (rand() % items[p_].rare_item.size()), itemid = items[p_].rare_item[random].first, got = items[p_].rare_item[random].second;
								if (p_ == 1680) {
									if (itemid == 8588 || itemid == 9730 || itemid == 11008 || itemid == 12186 || itemid == 12180 || itemid == 12176) {
										string texts = "A `4" + items[p_].ori_name + "`` rewards `2" + get_player_nick(peer) + "`` with a `5Rare " + items[itemid].ori_name + "``.";
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											p.CreatePacket(currentPeer);
										}
									}
								}
							}
							if (p_ == 1486) if (pInfo(peer)->lwiz_step == 6) add_lwiz_points(peer, got);
							//if (p_ == 10396)pInfo(peer)->black_box_consumed++;
							//if (p_ == 5402) daily_quest_winterfest(peer, false, "2", 1);
							//if (p_ == 5404) daily_quest_winterfest(peer, false, "3", 1);
							if (p_ == 7672) {
								/*
								if (total_iotm_found < total_iotm_items) {
									vector<vector<int>>::iterator p = find_if(current_iotm.begin(), current_iotm.end(), [&](const vector < int>& element) { return element[0] == itemid; });
									if (p != current_iotm.end()) {
										total_iotm_found++;
										current_iotm[p - current_iotm.begin()][1]++;
										if (current_iotm[p - current_iotm.begin()][1] >= current_iotm[p - current_iotm.begin()][2]) {
											for (int i = 0; i < items[7672].rare_item.size(); i++) {
												if (items[7672].rare_item[i].first == itemid) items[7672].rare_item.erase(items[7672].rare_item.begin() + i);
											}
										}
										string texts = "A `4" + items[p_].ori_name + "`` rewards `2" + pInfo(peer)->name_color + pInfo(peer)->tankIDName + "`` with a `5Rare " + items[itemid].ori_name + "``.";
										gamepacket_t p;
										p.Insert("OnConsoleMessage"), p.Insert("CP:_PL:0_OID:_CT:[S]_ `o**`` " + texts + "``");
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											p.CreatePacket(currentPeer);
										}
									}
								}*/
							}
							if (p_ == 1680) {
								modify_inventory(peer, p_, got = -1);
								WorldDrop drop_block_{};
								drop_block_.id = itemid, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x, drop_block_.y = pInfo(peer)->y - 32;
								dropas_(world_, drop_block_);
								PlayerMoving data_{};
								gamepacket_t p;
								p.Insert("OnParticleEffect"), p.Insert(73), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y - 32);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
									p.CreatePacket(currentPeer);
								}
							}
							else if (p_ == 9018) {
								if (pInfo(peer)->hair == 9036) add_peer_xp(peer, 250, true);
							}
							else if (p_ == 2992) {
								if (pInfo(peer)->back == 3134) add_peer_xp(peer, 250, true);
							}

							else {
								received = got;
								if (modify_inventory(peer, itemid, got) == 0) {
									//if (p_ == 12566) if (pInfo(peer)->garuda < 15) pInfo(peer)->garuda++;
									modify_inventory(peer, p_, got = -1);
									talk_bubble(peer, pInfo(peer)->netID, "You received `2" + to_string(received) + " " + items[itemid].name + "`` from the " + items[p_].name + ".", 0, 1);
									console_msg(peer, "You received `2" + to_string(received) + " " + items[itemid].name + "`` from the " + items[p_].name + ".");
								}
							}
						}
						break;
					}
					case 834: case 5766: case 1406: case 9264:
					{
						modify_inventory(peer, p_, got = -1);
						if (rand() % 100 < 2 and p_ == 834) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("Received 1 Summer Surprise!");
							p.Insert(0);
							p.Insert(1);
							p.CreatePacket(peer);
							WorldDrop drop_block_{};
							drop_block_.id = 836, drop_block_.count = 1, drop_block_.x = pInfo(peer)->x, drop_block_.y = pInfo(peer)->y;
							dropas_(world_, drop_block_);
						}
						gamepacket_t p;
						p.Insert("OnParticleEffect"), p.Insert(40), p.Insert((float)pInfo(peer)->x + 16, (float)pInfo(peer)->y);
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world) continue;
							p.CreatePacket(currentPeer);
						}
						break;
					}
					case 5804:
					case 5806:
					case 5808:
					case 5810:
					case 5812:
					case 6822:
					case 5770:
					case 5772:
					case 5774:
					case 5776:
					case 5778:
					case 6002:
					case 6052:
					case 6272:
					case 6274:
					case 6276:
					case 7232:
					case 7234:
					case 6122:
					case 6672:
					case 6322:
					case 7062:
					case 7130:
					case 6278:
					case 6824:
					case 6744:
					case 6894:
					case 7370:
					case 7474:
					case 7656:
					case 7684:
					case 7932:
					case 8416:
					case 10114:
					case 8028:
					case 7698:
					case 10116: case 12544: case 12542:
					{
						if (pInfo(peer)->growmoji.find(items[p_].emoji + "0&") != string::npos) {
							modify_inventory(peer, p_, got = -1);
							replaceAll(pInfo(peer)->growmoji, items[p_].emoji + "0&", items[p_].emoji + "1&");
							gamepacket_t p;
							p.Insert("OnAddNotification");
							p.Insert("interface/large/friend_button.rttex");
							p.Insert("You've unlocked `$" + items[p_].ori_name + "``!");
							p.Insert("audio/hub_open.wav");
							p.Insert(0);
							p.CreatePacket(peer);
							form_emoji(peer);
						}
						break;
					}
					case 830: case 9164: case 942: case 1060:case 10380:  case 8738:case 1136: case 1402: case 1532: case 3562: case 4774: case 7380: case 7588: case 8556: case 9582: case 9602:
					{
						if (p_ == 830) {
							int got = 0;
							modify_inventory(peer, 834, got);
							if (got < 100) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Beach blast requires 100 Fireworks."), p.Insert(0), p.Insert(1);
								p.CreatePacket(peer);
								break;
							}
						}
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`0" + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|This item creates a new world! Enter a unique name for it.|left||\nadd_text_input|name|New World Name||256|\nend_dialog|blast|Cancel|`5Create!``|\n");
						p.CreatePacket(peer);
						pInfo(peer)->lastchoosenitem = p_;
						break;
					}
					case 1280:
					{
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wChange your GrowID``|left|1280|\nadd_smalltext|This will change your GrowID `4permanently``.<CR>Your `wBirth Certificate`` will be consumed if you press `5Change It``.<CR>NOTE: The birth certificate only will change your name case (you can not change your whole GrowID)!``|left|\nadd_textbox|Enter your new name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|name_change|Cancel|Change it!|");
						p.CreatePacket(peer);
						break;
					}
					case 2580: case 2480:
					{
						gamepacket_t p;
						p.Insert("OnDialogRequest");
						if (p_ == 2580) p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wSwap World Names``|left|2580|\nadd_smalltext|This will swap the name of the world you are standing in with another world `4permanently``.  You must own both worlds, with a World Lock in place.<CR>Your `wChange of Address`` will be consumed if you press `5Swap 'Em``.|left|\nadd_textbox|Enter the other world's name:|left|\nadd_text_input|name_box|||32|\nadd_spacer|small|\nend_dialog|world_swap|Cancel|Swap 'Em!|");
						if (p_ == 2480)p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wMegaphone``|left|2480|\nadd_textbox|Enter a message you want to broadcast to every player in Growtopia! This will use up 1 Megaphone.|left|\nadd_text_input|words|||128|\nembed_data|itemID|2480\nend_dialog|megaphone|Nevermind|Broadcast|\n");
						p.CreatePacket(peer);
						break;
					}
					case 1404:
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) or pInfo(peer)->dev) {
							bool used = false;
							if (block_->flags & 0x10000000) {
								p.Insert("You can't move door on fire!");
							}
							else {
								if (y_ < (world_->max_y -6) && y_ >= 0) {
									int new_bedrock = 8;
									if (world_->d_weather == 255) new_bedrock = 9570;
									else if (world_->d_weather == 66) new_bedrock = 10378;
									if (block_->fg == 0 || block_->fg == 6 || block_->fg == 8 || block_->fg == 9570 || block_->fg == 10378) {
										WorldBlock* block2_ = &world_->blocks[x_ + ((y_ + 1) * 100)];
										if (block2_->flags & 0x10000000) {
											p.Insert("You can't move door on fire!");
										}
										else {
											if (block2_->fg == 0 || block2_->fg == 6 || block2_->fg == 8 || block2_->fg == 9570 || block2_->fg == 10378 and y_ < (world_->max_y - 6)) {
												p.Insert("You've moved the door!");
												used = true;
												int c_ = -1;
												modify_inventory(peer, p_, c_);
												for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
													if (world_->blocks[i_].fg == 6) world_->blocks[i_].fg = 0, update_tile(peer, i_ % 100, i_ / 100, 0, false, true);
													if (i_ < (world_->blocks.size() - 600) && (world_->blocks[i_].fg == 8 || world_->blocks[i_].fg == 9570 || world_->blocks[i_].fg == 10378)) world_->blocks[i_].fg = 0, update_tile(peer, i_ % 100, i_ / 100, 0, false, true);
												}
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != world_->name) continue;
													pInfo(currentPeer)->x = float(x_) * 32, pInfo(currentPeer)->y = float(y_) * 32;
													OnSetPos(currentPeer, x_ * 32, y_ * 32);
													update_tile(currentPeer, x_, y_, world_->blocks[x_ + (y_ * 100)].fg = 6, false, false);
													update_tile(currentPeer, x_, y_ + 1, world_->blocks[x_ + (y_ + 1) * 100].fg = new_bedrock, false, false);
												}
												tile_update(peer, world_, block_, x_, y_);
											}
										}
									}
								}
								if (used == false) {
									packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
									p.Insert("There's no room to put the door there! You need 2 empty spaces vertically.");
								}
							}
						}
						else p.Insert("You can only use this in a world that you have world-locked!");
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						break;
					}
					case 3062: case 1866: case 822: case 3102:
					{
						if (items[t_].blockType == BlockTypes::MAIN_DOOR or items[t_].blockType == BlockTypes::BEDROCK or t_ == 9570 or t_ == 0 && (p_ == 3102 || p_ == 3062 || p_ == 1866)) {
							if (p_ == 3102 || p_ == 3062) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert((t_ == 0 ? "There's nothing to burn!" : "That won't burn!")), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
							}
							return true;
						}
						if ((p_ == 1866 || p_ == 822) && not block_access(peer, world_, block_)) break;
						int c_ = -1;
						if (p_ == 822 && block_->flags & 0x04000000) c_ = 0;
						if (modify_inventory(peer, p_, c_) == 0 || p_ == 822) {
							if (p_ == 3062) {
								if (world_->total_fires < 150) {
									add_peer_xp(peer, 1);
									if (rand() % 100 < (items[p_].newdropchance + 5)) {
										WorldDrop drop_seed_{};
										drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
										if (not use_mag(world_, drop_seed_, x_, y_)) dropas_(world_, drop_seed_);
									}
									else if (rand() % 10 < 4) gems_(peer, world_, rand() % (items[p_].max_gems + 1), x_ * 32, y_ * 32, p_);
									if (block_->fg == 3090) {
										update_tile(peer, x_, y_, block_->fg = 3128, false, true);
										vector<pair<int, int>> receivingitems;
										for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
											if (world_->drop_new[i_][0] == 0) continue;
											if (x_ == (world_->drop_new[i_][3] / 32) && y_ == (world_->drop_new[i_][4] / 32) && (items[world_->drop_new[i_][0]].grindable_prize != 0 && items[world_->drop_new[i_][0]].grindable_count == 0)) {
												receivingitems.push_back(make_pair(world_->drop_new[i_][0], world_->drop_new[i_][1]));
												PlayerMoving data_{};
												data_.packetType = 14, data_.netID = 0, data_.plantingTree = world_->drop_new[i_][2];
												BYTE* raw = packPlayerMoving(&data_);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
												delete[]raw;
												world_->drop_new.erase(world_->drop_new.begin() + i_);
											}
										}
										for (int i = 0; i < receivingitems.size(); i++) {
											int item = receivingitems[i].first;
											if (items[item].grindable_prize != 0 && items[item].grindable_count == 0) item = items[item].grindable_prize;
											WorldDrop drop_block_{};
											drop_block_.id = item, drop_block_.count = receivingitems[i].second, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
											dropas_(world_, drop_block_);
										}
									}
									else if (block_->fg == 7764 || block_->fg == 9300 || block_->fg == 8048 || block_->fg == 7768 || block_->fg == 7772 || block_->fg == 7776) block_->fg += 2, block_->planted = time(nullptr);
								}
							}
							else if (p_ == 822 && block_->flags & 0x04000000 && rand() % 2 < 1) modify_inventory(peer, 822, c_ = 1);
							else if (p_ == 3102) {
								vector<int> random_xy{ 2, 1, 0, -1 };
								int randomx = 0, randomy = 0;
								for (int i = 0; i < 7; i++) {
									if (rand() % 2 < 1) randomx = x_ + random_xy[rand() % random_xy.size()], randomy = y_;
									else randomx = x_, randomy = y_ + random_xy[rand() % random_xy.size()];
									apply_tile_visual(world_, &world_->blocks[randomx + (randomy * 100)], randomx, randomy, items[p_].block_flag);
								}
							}
							apply_tile_visual(world_, block_, x_, y_, items[p_].block_flag, (block_->flags & items[p_].block_flag ? true : false));
						}
						break;
					}
					case 3478: case 3480: case 3482: case 3484: case 3486: case 3488: case 3490: case 3492:
					{
						if (not block_access(peer, world_, block_)) break;
						if (pInfo(peer)->hand != 3494 and pInfo(peer)->hand != 7938) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("You need a " + items[3494].name + " or a " + items[7938].name + " to apply paint!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							break;
						} if (block_->fg == 0 and block_->bg == 0) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("There's nothing to paint!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							break;
						} if (items[block_->fg].blockType == BlockTypes::MAIN_DOOR or items[block_->fg].blockType == BlockTypes::BEDROCK or items[block_->fg].blockType == BlockTypes::LOCK or block_->fg == 9570) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That's too special to paint.");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							break;
						}
						bool alr_painted = false;
						if (block_->flags & 0x20000000 and block_->flags & 0x40000000 and block_->flags & 0x80000000) {
							if (p_ == 3490) alr_painted = true;
						}
						else if (block_->flags & 0x20000000 and block_->flags & 0x80000000) {
							if (p_ == 3488) alr_painted = true;
						}
						else if (block_->flags & 0x80000000) {
							if (p_ == 3486) alr_painted = true;
						}
						else if (block_->flags & 0x40000000 and block_->flags & 0x80000000) {
							if (p_ == 3484) alr_painted = true;
						}
						else if (block_->flags & 0x40000000) {
							if (p_ == 3482) alr_painted = true;
						}
						else if (block_->flags & 0x20000000 and block_->flags & 0x40000000) {
							if (p_ == 3480) alr_painted = true;
						}
						else if (block_->flags & 0x20000000) {
							if (p_ == 3478) alr_painted = true;
						}
						if (alr_painted) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("That block is already painted that color!");
							p.Insert(0), p.Insert(0);
							p.CreatePacket(peer);
							break;
						}
						{
							int colour = 0x00000000;
							float particle_ = 0;
							if (p_ == 3478) { // raudona spalva
								colour |= 0x20000000;
								particle_ = 65280.00;
							}
							else if (p_ == 3480) { // geltona spalva
								colour |= 0x20000000;
								colour |= 0x40000000;
								particle_ = 16776960.00;
							}
							else if (p_ == 3482) { // zalia spalva
								colour |= 0x40000000;
								particle_ = 16711680.00;
							}
							else if (p_ == 3484) { // sviesiai melyna spalva
								colour |= 0x40000000;
								colour |= 0x80000000;
								particle_ = 4294901760.00;
							}
							else if (p_ == 3486) { // melyna spalva
								colour |= 0x80000000;
								particle_ = 4278190080.00;
							}
							else if (p_ == 3488) { // rozine spalva
								colour |= 0x20000000;
								colour |= 0x80000000;
								particle_ = 4278255360.00;
							}
							else if (p_ == 3490) { // juoda spalva
								colour |= 0x20000000;
								colour |= 0x40000000;
								colour |= 0x80000000;
								particle_ = 1010580480.00;
							}
							else { // balta spalva
								bool has_something_to_change = false;
								if (block_->flags & 0x20000000 or block_->flags & 0x40000000 or block_->flags & 0x80000000) {
									has_something_to_change = true;
								} if (not has_something_to_change) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("Don't waste your varnish on an unpainted block!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
									break;
								}
								particle_ = 3875520768.00;
							}
							int c_ = -1;
							if (modify_inventory(peer, p_, c_) == 0) {
								if (block_->flags & 0x20000000) block_->flags = block_->flags ^ 0x20000000;
								if (block_->flags & 0x40000000) block_->flags = block_->flags ^ 0x40000000;
								if (block_->flags & 0x80000000) block_->flags = block_->flags ^ 0x80000000;
								if (colour != 0x00000000) block_->flags |= colour;
								{
									PlayerMoving p_data_{};
									p_data_.packetType = 17;
									p_data_.netID = 168;
									p_data_.YSpeed = 168;
									p_data_.XSpeed = particle_;
									p_data_.x = (x_ * 32) + 16;
									p_data_.y = (y_ * 32) + 16;
									BYTE* p_raw = packPlayerMoving(&p_data_);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											send_raw(currentPeer, 4, p_raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] p_raw;
								}
								{
									tile_update(peer, world_, block_, x_, y_);
								} if (items[block_->fg].collisionType != 1 and items[block_->fg].blockType != BlockTypes::GATEWAY and not items[block_->fg].toggleable) {
									int c_ = rand() % (items[p_].max_gems + 1);
									if (c_ != 0) {
										bool no_seed = false, no_gems = false, no_block = false;
										for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
											if (abs(world_->drop_new[i_][4] - y_ * 32) <= 16 and abs(world_->drop_new[i_][3] - x_ * 32) <= 16) {
												if (world_->drop_new[i_][0] == 112 and items[t_].rarity < 8) {
													no_gems = true;
												}
												else {
													no_seed = true, no_block = true;
												}
											}
										} if (rand() % 100 < 5 and not no_block) {
											WorldDrop drop_block_{};
											drop_block_.id = p_, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
											dropas_(world_, drop_block_);
										}
										else if (rand() % 100 < 35 and not no_seed) {
											WorldDrop drop_seed_{};
											drop_seed_.id = 3479, drop_seed_.count = 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
											dropas_(world_, drop_seed_);
										}
										else if (not no_gems) {
											int c_ = rand() % (items[p_].max_gems + 1);
											gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);
											//std::thread([=] { gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);  }).detach();
										}
									}
								}
							}
						}
						break;
					}
					case 3560:
					{
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (to_lower(world_->owner_name) == to_lower(pInfo(peer)->tankIDName) or pInfo(peer)->dev) {
							int used = 0;
							if (block_->fg == 0) {
								if (LockMove(peer, x_, y_)) {
									p.Insert("You've moved the world lock!");
									used = 1;
									int c_ = -1;
									modify_inventory(peer, p_, c_);
									tile_update(peer, world_, block_, x_, y_);
								}
							}
							if (used == 0) {
								packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
								p.Insert("There's no room to put the lock there! You need 1 empty space vertically.");
							}
						}
						else p.Insert("You can only use this in a world that you have world-locked!");
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						break;
					}
					default:
					{
						if (items[p_].playmod_id != 0) {
							uint32_t item_id = p_, playmod_id = items[p_].playmod_id, item_playmod = atoi(info_about_playmods[playmod_id - 1][1].c_str()), playmod_time = atoi(info_about_playmods[playmod_id - 1][2].c_str()), playmod_effect = atoi(info_about_playmods[playmod_id - 1][11].c_str());
							string playmod_name = info_about_playmods[playmod_id - 1][3], playmod_action = info_about_playmods[playmod_id - 1][10], playmod_text = info_about_playmods[playmod_id - 1][12];
							//string gravity_mod = info_about_playmods[playmod_id - 1][12];
							if (p_ == 4844 || p_ == 4846 || p_ == 4848) item_id = 4844;
							ENetPeer* clicked_on = get_clicked_on(world_, x_, y_);
							if (playmod_action == "drop" and clicked_on == NULL or playmod_action.empty() and clicked_on == NULL or playmod_action == "consume" and clicked_on == NULL or playmod_action == "cutewords" and clicked_on == NULL) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Must be used on a person."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								return true;
							}
							if ((p_ == 2992 or p_ == 9852 or p_ == 9726 or p_ == 9854 or p_ == 9882 or info_about_playmods[playmod_id - 1][13] == "Subscribtion") and pInfo(clicked_on)->netID != pInfo(peer)->netID) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("Use that on yourself!");
								p.Insert(0), p.Insert(1);
								p.CreatePacket(peer);
								return true;
							}
							if (clicked_on != NULL) {
								if ((item_id == 4844) and (pInfo(clicked_on)->balloon_faction == pInfo(peer)->balloon_faction or has_playmod2(pInfo(peer), 136) or has_playmod2(pInfo(peer), 135))) {
									gamepacket_t p;
									p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
									if (pInfo(clicked_on)->balloon_faction == pInfo(peer)->balloon_faction) p.Insert("Use that on somebody else!");
									else p.Insert("You can't throw while having immune from balloons!");
									p.Insert(0), p.Insert(1), p.CreatePacket(peer);
									return true;
								}
							}
							if (playmod_action == "pet") {
								int c_ = playmod_time * -1;
								if (modify_inventory(peer, p_, c_) == 0) {
									uint32_t pet_id = atoi(playmod_name.c_str());
									int c_2 = 1;
									if (modify_inventory(peer, pet_id, c_2) != 0) {
										WorldDrop drop_block_{};
										drop_block_.id = pet_id, drop_block_.count = c_2, drop_block_.x = pInfo(peer)->x + rand() % 17, drop_block_.y = pInfo(peer)->y + rand() % 17;
										dropas_(world_, drop_block_);
									}
									else {
										pInfo(peer)->hand = pet_id;
										if (p_ != 9018 && p_ != 2992) update_clothes(peer);
									}
									PlayerMoving data_{};
									data_.packetType = 17;
									data_.netID = 44;
									data_.YSpeed = 44;
									data_.x = pInfo(peer)->x + 10;
									data_.y = pInfo(peer)->y + 10 + 16;
									BYTE* raw = packPlayerMoving(&data_);
									string t_ = "action|play_sfx\nfile|audio/terraform.wav\ndelayMS|0";
									BYTE* const d_ = new BYTE[5 + t_.length()];
									*(__int8*)(d_) = 3;
									memcpy(d_ + 4, t_.c_str(), t_.length());
									*(__int8*)(d_ + 4 + t_.length()) = 0;
									ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == world_->name) {
											enet_peer_send(currentPeer, 0, p_m);
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[]d_;
									delete[] raw;
								}
								else {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert(playmod_text);
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
								}
								return true;
							}
							int c_ = -1;
							if (modify_inventory(peer, p_, c_) == 0) {
								if (p_ == 732) add_ban_or_mute(clicked_on, playmod_time, "Wand Effect", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", playmod_id);
								else if (p_ == 278) add_ban_or_mute(clicked_on, playmod_time, "Wand Effect", pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``", playmod_id);
								if (playmod_action == "cutewords") {
									if (p_ == 276) SendRespawn(clicked_on, true, 0, 1);
									else if (p_ == 8500) {
										string malady_text = "The patient has no malady.";
										int give = 1;
										if (pInfo(clicked_on)->surgery_type == 18) malady_text = "The patient has a `5torn Punching Muscle``.";
										else if (pInfo(clicked_on)->surgery_type == 18) malady_text = "The patient has a `5Gemcuts``.";
										else if (pInfo(clicked_on)->surgery_type == 20) malady_text = "The patient has a `5Grumbleteeth``.";
										else if (pInfo(clicked_on)->surgery_type == 21) malady_text = "The patient has a `5Chicken Feet``.";
										else if (pInfo(clicked_on)->surgery_type == 22) malady_text = "The patient has a `5Broken Heart``.";
										else if (pInfo(clicked_on)->surgery_type == 24) malady_text = "The patient has a `5Ecto-Bones``.";
										else if (pInfo(clicked_on)->surgery_type == 25) malady_text = "The patient has a `5Moldy Guts``.";
										else if (pInfo(clicked_on)->surgery_type == 26) malady_text = "The patient has a `5Fatty Liver``.";
										else if (pInfo(clicked_on)->surgery_type == 27) malady_text = "The patient has a `5Chaos Infection``.";
										else if (pInfo(clicked_on)->surgery_type == 28) malady_text = "The patient has a `5Lupus``.";
										else {

											PlayerMoving data_{};
											data_.packetType = 36, data_.netID = 175, data_.characterState = 0x8, data_.x = pInfo(clicked_on)->x + 16, data_.y = pInfo(clicked_on)->y + 16;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != pInfo(peer)->world) continue;
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
											delete[] raw;
											modify_inventory(peer, 8500, give);
										}
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert(malady_text);
										p.Insert(0), p.Insert(1);
										p.CreatePacket(peer);
									}
									else {
										gamepacket_t p4;
										p4.Insert("OnConsoleMessage");
										string text = "";
										gamepacket_t p2(p_ == 752 ? 500 : 0);
										p2.Insert("OnTalkBubble");
										p2.Insert(pInfo(clicked_on)->netID);
										vector<string> random_words{
											"`4'ADORE ME'``",
											"`4'SAY YES'``",
											"`4'MISS YOU'``"
										};
										if (p_ == 618) {
											random_words = { "`4'ARGH!!!'``" };
											SendRespawn(clicked_on, true, 0, 1);
										}
										if (p_ == 2734 || p_ == 4752) {
											if (clicked_on == peer && pInfo(clicked_on)->stage_pineapple >= 600) {
												gamepacket_t p;
												p.Insert("OnTalkBubble"), p.Insert(pInfo(clicked_on)->netID), p.Insert("`2I can't stomach another one...``"), p.Insert(0), p.Insert(0), p.CreatePacket(clicked_on);
												int give_1 = 1;
												modify_inventory(peer, p_, give_1);
											}
											else {
												if (pInfo(clicked_on)->stage_pineapple == 600) {
													vector<uint16_t> list{ 4716 , 6098 , 2738 , 6122 , 3616 , 2740 , 2730 , 9656 , 9662 , 2760 , 4772 , 3624 , 2736 , 2758 , 2762 , 6100 , 2752 , 9664 , 6118 , 3618 , 9652 , 6102 , 6110 , 10908 , 6104 , 9668 , 2734 , 10902 , 10900 , 10898 , 2748 , 10896 , 2744 };
													if (total_pineapple_eaten > 50000) list.push_back(2732);
													if (total_pineapple_eaten > 250000) list.push_back(3622);
													if (total_pineapple_eaten > 500000) list.push_back(2746);
													if (total_pineapple_eaten > 500000) list.push_back(2746);
													if (total_pineapple_eaten > 625000) list.push_back(13508);
													if (total_pineapple_eaten > 875000) list.push_back(13504);
													if (total_pineapple_eaten > 975000) list.push_back(13506);
													if (total_pineapple_eaten > 1000000) list.push_back(2742);
													uint16_t prize_to_pacient = list[rand() % list.size()];
													text = "`7[```9PINEAPPLE MAGIC!`` " + pInfo(peer)->tankIDName + " got a `2" + items[prize_to_pacient].name + "``!`7]``";
													int give = 1;
													modify_inventory(peer, prize_to_pacient, give);
												}
												add_pineapple(clicked_on, (p_ == 2734 ? 1 : 200));
											}
										}
										if (p_ == 616) random_words = { "`4'Awwwww!'``" };
										if (p_ == 752) random_words = { "HEADS"  ,  "TAILS" };
										string random_phrase = random_words[rand() % random_words.size()];
										p2.Insert(random_phrase);
										p2.Insert(0), p2.Insert(0);
										gamepacket_t p(0, pInfo(clicked_on)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/eat.wav");
										gamepacket_t p3(0, pInfo(clicked_on)->netID);
										p3.Insert("OnAction");
										p3.Insert("/love");
										if (p_ == 618) text = pInfo(clicked_on)->tankIDName + " snuggled the wrong bunny!";
										else if (p_ != 616 and p_ != 752 and p_ != 2734 and p_ != 4752)text = pInfo(clicked_on)->tankIDName + " shouts " + random_phrase + " uncontrollably!";
										if (text != "") p4.Insert(text);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
											p.CreatePacket(currentPeer);
											if (p_ != 2734 and p_ != 4752) p2.CreatePacket(currentPeer);
											if (p_ != 618 and p_ != 752 and p_ != 2734 and p_ != 4752) p3.CreatePacket(currentPeer);
											if (text != "") p4.CreatePacket(currentPeer);
										}
									}
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
									data_.punchX = p_, data_.punchY = pInfo(peer)->netID;
									BYTE* raw;
									data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
									raw = packPlayerMoving(&data_);
									int32_t to_netid = pInfo(clicked_on)->netID;
									raw[3] = 5;
									memcpy(raw + 8, &to_netid, 4);
									if (p_ != 9018 && p_ != 2992) update_clothes(clicked_on);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw;
									return true;
								}
								if (playmod_action == "consume") {
									if (p_ == 3240) {
										pInfo(clicked_on)->geiger_ = 100;
										has_playmod2(pInfo(clicked_on), 10, 1);
									}
									gamepacket_t p2;
									if (playmod_name[0] == '/') SendCmd(clicked_on, playmod_name, true);
									else {
										p2.Insert("OnTalkBubble");
										p2.Insert(pInfo(clicked_on)->netID);
										p2.Insert(playmod_name);
										p2.Insert(0), p2.Insert(0);
									}
									gamepacket_t p(0, pInfo(clicked_on)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/eat.wav");
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
									data_.punchX = p_;
									data_.punchY = pInfo(peer)->netID;
									BYTE* raw;
									data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
									raw = packPlayerMoving(&data_);
									int32_t to_netid = pInfo(clicked_on)->netID;
									raw[3] = 5;
									memcpy(raw + 8, &to_netid, 4);
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
										if (pInfo(currentPeer)->world == name_) {
											p.CreatePacket(currentPeer);
											if (playmod_name[0] != '/') p2.CreatePacket(currentPeer);
											send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										}
									}
									delete[] raw;
									return true;
								}
								if (playmod_action == "drop") {
									if (p_ == 782) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("`w[" + pInfo(clicked_on)->tankIDName + " `wfeels strangely better!]");
										p.Insert(0), p.Insert(0);
										gamepacket_t p2;
										p2.Insert("OnConsoleMessage");
										p2.Insert("`7[`w" + pInfo(clicked_on)->tankIDName + " `ofeels strangely better!`7]");
										p2.Insert(0);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == name_) p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
										}
										for (int i_ = 0; i_ < pInfo(peer)->playmods.size(); i_++) if (pInfo(peer)->playmods[i_].id == 28 || pInfo(peer)->playmods[i_].id == 41 || pInfo(peer)->playmods[i_].id == 49 || pInfo(peer)->playmods[i_].id == 48 || pInfo(peer)->playmods[i_].id == 71 || pInfo(peer)->playmods[i_].id == 72 || pInfo(peer)->playmods[i_].id == 73 || pInfo(peer)->playmods[i_].id == 4 || pInfo(peer)->playmods[i_].id == 16 || pInfo(peer)->playmods[i_].id == 17 || pInfo(peer)->playmods[i_].id == 19 || pInfo(peer)->playmods[i_].id == 27 || pInfo(peer)->playmods[i_].id == 42) pInfo(peer)->playmods[i_].time = 1;
									}
									else {
										int c_ = rand() % (items[p_].max_gems + 1);
										if (c_ != 0) {
											bool no_seed = false, no_gems = false, no_block = false;
											for (int i_ = 0; i_ < world_->drop_new.size(); i_++) {
												if (abs(world_->drop_new[i_][4] - y_ * 32) <= 16 and abs(world_->drop_new[i_][3] - x_ * 32) <= 16) {
													if (world_->drop_new[i_][0] == 112 and items[t_].rarity < 8) {
														no_gems = true;
													}
													else {
														no_seed = true, no_block = true;
													}
												}
											}
											if (rand() % 100 < 5 and not no_block) {
												WorldDrop drop_block_{};
												drop_block_.id = p_, drop_block_.count = 1, drop_block_.x = (x_ * 32) + rand() % 17, drop_block_.y = (y_ * 32) + rand() % 17;
												if (not use_mag(world_, drop_block_, drop_block_.x, drop_block_.y)) dropas_(world_, drop_block_);
											}
											else if (rand() % 100 < 35 and not no_seed) {
												WorldDrop drop_seed_{};
												drop_seed_.id = p_ + 1, drop_seed_.count = 1, drop_seed_.x = (x_ * 32) + rand() % 17, drop_seed_.y = (y_ * 32) + rand() % 17;
												if (not use_mag(world_, drop_seed_, drop_seed_.x, drop_seed_.y)) dropas_(world_, drop_seed_);
											}
											else if (not no_gems) {
												int c_ = rand() % (items[p_].max_gems + 1);
												gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);
												//std::thread([=] { gems_(peer, world_, c_, x_ * 32, y_ * 32, p_);  }).detach();
											}
										}
									}
								}
								else if (not playmod_action.empty()) {
									if (playmod_action == "throw") {
										if (item_id == 4844) {
											gamepacket_t p;
											p.Insert("OnParticleEffectV2"), p.Insert(pInfo(peer)->balloon_faction), p.Insert((float)x_ * 32 + 16, (float)y_ * 32 + 16);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == pInfo(peer)->world) p.CreatePacket(currentPeer);
											}
										}
										else {
											PlayerMoving data_{};
											data_.packetType = 17;
											data_.netID = playmod_effect;
											data_.YSpeed = playmod_effect;
											data_.x = x_ * 32 + rand() % 17;
											data_.y = y_ * 32 + rand() % 17;
											BYTE* raw = packPlayerMoving(&data_);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
												}
											}
											delete[] raw;
										}
									}
									else {
										PlayerMoving data_{};
										data_.packetType = 17;
										data_.netID = playmod_effect;
										data_.YSpeed = playmod_effect;
										data_.x = x_ * 32 + 16;
										data_.y = y_ * 32 + 16;
										BYTE* raw = packPlayerMoving(&data_);
										for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
											if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
											if (pInfo(currentPeer)->world == world_->name) {
												send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
											}
										}
										delete[] raw;
									}
								}
								if (clicked_on != NULL) {
									bool alr_have = false;
									//if ((p_ == 9266 || p_ == 6856 || p_ == 6858 || p_ == 6860 || p_ == 8188) && (has_playmod2(pInfo(clicked_on), 129) || has_playmod2(pInfo(clicked_on), 130) || has_playmod2(pInfo(clicked_on), 131) || has_playmod2(pInfo(clicked_on), 132) || has_playmod2(pInfo(clicked_on), 133))) alr_have = true;
									if (item_id == 4844 && has_playmod2(pInfo(clicked_on), 135) or has_playmod2(pInfo(clicked_on), 137)) alr_have = true;
									for (PlayMods peer_playmod : pInfo(clicked_on)->playmods) {
										if (peer_playmod.id == playmod_id) {
											if (p_ == 384 and peer_playmod.user == pInfo(peer)->tankIDName) {
												alr_have = true;
												break;
											}
											else {
												alr_have = true;
												break;
											}
										}
									}
									if (not alr_have) {
										if (item_id == 4844) {
											int points = 1;
											if (p_ == 4844) points = 2;
											if (p_ == 4846) points = 7;
											if (p_ == 4848) points = 12;
											{
												if (rand() % 100 < 5) {
													int given_ = 1;
													modify_inventory(peer, 4894, given_);
												}
											}
											pInfo(peer)->balloon_hit++;
											if (pInfo(peer)->balloon_hit >= 20) {
												if (pInfo(peer)->balloon_hit == 20) {
													gamepacket_t p;
													p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("SPLAT ATTACK! You now have a Bounty."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
												}
												gamepacket_t p5(0, pInfo(peer)->netID);
												p5.Insert("OnFactionDataChanged"), p5.Insert(pInfo(peer)->balloon_faction), p5.Insert(pInfo(peer)->hit_by), p5.Insert(pInfo(peer)->hit_by), p5.Insert("bountyLevel|" + to_string(pInfo(peer)->balloon_hit >= 20 ? pInfo(peer)->balloon_hit / 20 : 0) + "\nbountyScore|" + to_string(pInfo(peer)->balloon_hit >= 20 ? pInfo(peer)->balloon_hit : 0) + "\n"), p5.Insert(1);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
													p5.CreatePacket(currentPeer);
												}
											}
											add_balloon(peer, pInfo(peer)->balloon_faction, points + pInfo(clicked_on)->balloon_hit);
											if (pInfo(clicked_on)->balloon_hit != 0) pInfo(clicked_on)->balloon_hit = 0;
											pInfo(clicked_on)->hit_by = pInfo(peer)->balloon_faction;
											talk_bubble(peer, pInfo(peer)->netID, "A hit!", 0, 0);
											console_msg(peer, "You have hit an enemy! Your team is awarded " + to_string(points) + " points!");
										}
										if (p_ == 9882) playmod_time = 86400;
										if (playmod_time != 0) {
											PlayMods new_playmod{};
											new_playmod.id = playmod_id;
											new_playmod.time = time(nullptr) + playmod_time;
											new_playmod.user = pInfo(peer)->tankIDName;
											pInfo(clicked_on)->playmods.push_back(new_playmod);
										}
										update_clothes_value(clicked_on);
										if (not playmod_name.empty()) {
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert(info_about_playmods[playmod_id - 1][4] + " (`$" + playmod_name + "`` mod added, `$" + to_playmod_time(playmod_time) + "`` left)");
											p.CreatePacket(clicked_on);
										}
										if (p_ != 9018 && p_ != 2992) update_clothes(clicked_on);
										{
											gamepacket_t p;
											p.Insert("OnConsoleMessage");
											p.Insert("`4>> `#" +get_player_nick(clicked_on)  + " is now `#" + get_player_nick(peer) + "``'s valentine!``");
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
												if (p_ == 384) p.CreatePacket(currentPeer);
											}
										}
									}
									if (p_ == 9852 || p_ == 9726 || p_ == 9854 || p_ == 9882 || p_ == 9018 || p_ == 2992 or info_about_playmods[playmod_id - 1][13] == "Subscribtion") {
										if (alr_have) {
											int abcc = 1;
											modify_inventory(peer, p_, abcc);
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											if (p_ == 9852 || p_ == 9854 || p_ == 9882 || p_ == 9726) p.Insert("Already have this role.");
											else if (p_ == 9018) p.Insert("You already consumed Dark Ticket.");
											else if (p_ == 2992) p.Insert("You already consumed Wolf Whistle.");
											else if (info_about_playmods[playmod_id - 1][13] == "Subscribtion")  p.Insert("You already have subscribtion!");
											p.Insert(0), p.Insert(1), p.CreatePacket(clicked_on);
										}
										else {
											if (p_ == 9852 || p_ == 9854 || p_ == 9882 || p_ == 9726) {
												if (p_ == 9852) {
													pInfo(clicked_on)->mod = 1;
													pInfo(clicked_on)->name_color = (pInfo(clicked_on)->give_role ? "`8@" : pInfo(clicked_on)->Staff ? "`4@" : pInfo(clicked_on)->superdev ? "`8@" : pInfo(clicked_on)->dev ? "`6@" :(pInfo(clicked_on)->mod == 1) ? "`#@" : "`0");
												}
												else if (p_ == 9854 || p_ == 9882) {
													pInfo(clicked_on)->vip = 1;
												}
												else if (p_ == 9726) {

												}
												gamepacket_t pp(100), pp2;
												pp.Insert("OnParticleEffectV2"), pp.Insert(198), pp.Insert((float)pInfo(clicked_on)->x + 16, (float)pInfo(clicked_on)->y + 16);
												pp2.Insert("OnParticleEffectV2"), pp2.Insert(199), pp2.Insert((float)pInfo(clicked_on)->x + 16, (float)pInfo(clicked_on)->y + 16);
												for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
													if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
													if (p_ == 9852) {
														gamepacket_t p;
														p.Insert("OnConsoleMessage"), p.Insert("`#**`` `$The Ancient Ones`` have `#made`` `w" + pInfo(clicked_on)->tankIDName + "``->`#@" + pInfo(clicked_on)->tankIDName + "`` a `bguardian`` `#**`` (`2/deposit`` to purchase role!)"), p.CreatePacket(currentPeer);
													}
													if (pInfo(currentPeer)->world == pInfo(clicked_on)->world) {
														if (p_ == 9852) nick_update_2(clicked_on, currentPeer);
														pp.CreatePacket(currentPeer);
														pp2.CreatePacket(currentPeer);
													}
												}
											}
											else if (p_ == 9018 || p_ == 2992) {
												pInfo(clicked_on)->x = -1, pInfo(clicked_on)->y = -1;
												string world_ = "";
												if (p_ == 2992) {
													world_ = "WW" + std::to_string(rand() % 7 + 1);
													pInfo(clicked_on)->wolf_world = world_;
												}
												if (p_ == 9018) pInfo(clicked_on)->halloween_prize_receive = false, world_ = "TOMBOFGROWGANOTH" + std::to_string(rand() % 3 + 1);
												join_world(clicked_on, world_);
											}
											else if (info_about_playmods[playmod_id - 1][13] == "Subscribtion") {
												receive_subscribtion(clicked_on, item_playmod);
											}
										}
									}
								}
								{
									PlayerMoving data_{};
									data_.packetType = 19, data_.plantingTree = 0, data_.netID = 0;
									data_.punchX = p_;
									data_.punchY = pInfo(peer)->netID;
									BYTE* raw;
									int32_t to_netid = 0;
									if (clicked_on != NULL and playmod_action.empty() or playmod_action == "drop" and clicked_on != NULL) {
										data_.x = pInfo(peer)->x + 10, data_.y = pInfo(peer)->y + 16;
										raw = packPlayerMoving(&data_);
										to_netid = pInfo(clicked_on)->netID;
										raw[3] = 5;
									}
									else {
										data_.x = x_ * 32 + 16, data_.y = y_ * 32 + 16;
										raw = packPlayerMoving(&data_);
										to_netid = pInfo(peer)->netID;
										raw[3] = 4;
									}
									memcpy(raw + 8, &to_netid, 4);
									gamepacket_t p1;
									p1.Insert("OnTalkBubble");
									if (not playmod_text.empty()) {
										p1.Insert(pInfo(clicked_on)->netID), p1.Insert(playmod_text), p1.Insert(0), p1.Insert(0);
										if (clicked_on != NULL && p_ != 9018 && p_ != 2992) update_clothes(clicked_on);
									}
									string playmod_sound = info_about_playmods[playmod_id - 1][8];
									for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
										if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
										if (not playmod_text.empty()) p1.CreatePacket(currentPeer);
										if (not playmod_sound.empty() and clicked_on != NULL or playmod_action == "drop" and clicked_on != NULL) {
											gamepacket_t p(0, pInfo(clicked_on)->netID);
											p.Insert("OnPlayPositioned");
											p.Insert("audio/" + playmod_sound);
											p.CreatePacket(currentPeer);
										}
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
									delete[]raw;
								}
							}
						}
						else {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("This does nothing right now.  You should put this in the suggestion box (`$/discord``)!");
							p.Insert(0), p.Insert(1);
							p.CreatePacket(peer);
							{
								gamepacket_t p;
								p.Insert("OnConsoleMessage");
								p.Insert("This does nothing right now.  You should put this in the suggestion box (`$/discord``)!");
								p.CreatePacket(peer);
							}
							break;
						}
					}
					}
					break;
				}
			}
			else {
				if (items[p_].blockType == BlockTypes::AUTO_BLOCK or t_ == 6954 or items[p_].blockType == BlockTypes::VIP_ENTRANCE) {
					if (to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName)) {
						gamepacket_t p;
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						p.Insert("Only the world owner is allowed to place that here!");
						p.Insert(0), p.Insert(1);
						p.CreatePacket(peer);
						{
							gamepacket_t p;
							p.Insert("OnConsoleMessage");
							p.Insert("Only the world owner is allowed to place that here!");
							p.CreatePacket(peer);
						}
						return false;
					}
				}
				if (block_->locked) {
					if (world_->blocks[block_->lock_origin].fg == 242 || items[world_->blocks[block_->lock_origin].fg].blockType != BlockTypes::LOCK) {
						int xa_ = block_->lock_origin % 100, ya_ = block_->lock_origin / 100;
						remove_lock_broken(world_, &world_->blocks[block_->lock_origin], xa_, ya_);
					}
					else {
						WorldBlock* block2_ = &world_->blocks[block_->lock_origin];
						string owner_name = to_lower(block2_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
						if (owner_name != user_name and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
							if (block2_->fg == 4994 or find(block2_->admins.begin(), block2_->admins.end(), user_name) == block2_->admins.end() and not block2_->spin) {
								if (block2_->fg == 4994) {
									if (not block2_->spin) {
										gamepacket_t p(0, pInfo(peer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/punch_locked.wav");
										p.CreatePacket(peer);
										if (p_ != 18) {

											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("That area is owned by " + block2_->owner_name);
											p.Insert(0);
											p.Insert(1);
											p.CreatePacket(peer);
										}
										return true;
									}
									if (not block2_->build_only and block2_->spin) {
										gamepacket_t p(0, pInfo(peer)->netID);
										p.Insert("OnPlayPositioned");
										p.Insert("audio/punch_locked.wav");
										p.CreatePacket(peer);
										if (p_ != 18) {
											gamepacket_t p;
											p.Insert("OnTalkBubble");
											p.Insert(pInfo(peer)->netID);
											p.Insert("This lock allows breaking only!");
											p.Insert(0);
											p.Insert(1);
											p.CreatePacket(peer);
										}
										return false;
									}
								}
								else {
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									p.CreatePacket(peer);
									if (p_ != 18) {
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("That area is owned by " + block2_->owner_name);
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
									}
									return false;
								}
							}
							if (items[p_].blockType == BlockTypes::LOCK) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("`w" + block2_->owner_name + "`` allows public building here, but no locks.");
								p.Insert(0);
								p.Insert(0);
								p.CreatePacket(peer);
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned");
									p.Insert("audio/punch_locked.wav");
									p.CreatePacket(peer);
								}
								return false;
							}
						}
					}
				}
				else if (not world_->owner_name.empty() and items[p_].blockType != BlockTypes::CONSUMABLE) {
					string owner_name = to_lower(world_->owner_name), user_name = to_lower(pInfo(peer)->tankIDName);
					if (owner_name != user_name and not (Server_Security.dev_access == false ? pInfo(peer)->dev : pInfo(peer)->superdev)) {
						bool publica = world_->world_settings & Gtps3::SETTINGS_4;
						if (!guild_access(peer, world_->guild_id) and find(world_->admins.begin(), world_->admins.end(), user_name) == world_->admins.end() and not publica) {
							gamepacket_t p(0, pInfo(peer)->netID);
							p.Insert("OnPlayPositioned");
							p.Insert("audio/punch_locked.wav");
							p.CreatePacket(peer);
							if (p_ != 18) {
								string owner_name = world_->owner_name;
								if (world_->owner_named.substr(0, 2) == "`o") owner_name = "`w" + world_->owner_name;
								if (not world_->owner_named.empty()) owner_name = world_->owner_named;
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("That area is owned by " + owner_name + "``");
								p.Insert(0);
								p.Insert(1);
								p.CreatePacket(peer);
							}
							return false;
						}
						if (items[p_].blockType == BlockTypes::LOCK) {
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							p.Insert("" + (world_->owner_named.substr(0, 2) == "`o" ? "`w" + world_->owner_name : world_->owner_named) + "`` allows public building here, but no locks.");
							p.Insert(0);
							p.Insert(0);
							p.CreatePacket(peer);
							{
								gamepacket_t p(0, pInfo(peer)->netID);
								p.Insert("OnPlayPositioned");
								p.Insert("audio/punch_locked.wav");
								p.CreatePacket(peer);
							}
							return false;
						}
					}
				}
				if (items[p_].blockType == BlockTypes::DOOR || items[p_].blockType == BlockTypes::PORTAL || items[p_].blockType == BlockTypes::LOCK || items[p_].path_marker) {
					if (ar_turi_noclipa(world_, pInfo(peer)->x, pInfo(peer)->y, x_ + (y_ * 100), peer)) {
						gamepacket_t p, p2(0, pInfo(peer)->netID);
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Something is blocking the way, get closer."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						p2.Insert("OnPlayPositioned"), p2.Insert("audio/punch_locked.wav"), p2.CreatePacket(peer);
						return true;
					}
				}
				if (items[block_->fg].blockType == BlockTypes::CRYSTAL and items[p_].blockType == BlockTypes::CRYSTAL) {
				vector<vector<int>> current_{ {2242, 0}, {2244, 0}, {2246, 0}, {2248, 0}, {2250, 0} };
				int abcc = -1;
				string mix_with = "";
				if (modify_inventory(peer, p_, abcc) == 0) {
					bool obtained_ = false;
					for (int i = 0; i < block_->crystals.size(); i++) {
						vector<int> c_ = block_->crystals[i];
						if (c_[0] == p_) {
							block_->crystals[i][1]++;
							obtained_ = true;
						} for (int a = 0; a < current_.size(); a++) {
							if (current_[a][0] == c_[0]) {
								current_[a][1] = block_->crystals[i][1];
								break;
							}
						}
					} if (not obtained_) {
						block_->crystals.push_back({ p_, 1 });
						for (int a = 0; a < current_.size(); a++) {
							if (current_[a][0] == p_) {
								current_[a][1] = 1;
								break;
							}
						}
					} vector<string> reply{};
					for (int i = 0; i < current_.size(); i++) {
						reply.push_back(to_string(current_[i][1]) + "x `$" + mix_with + (current_[i][0] == 2242 ? "R" : (current_[i][0] == 2244 ? "G" : (current_[i][0] == 2246 ? "B" : (current_[i][0] == 2248 ? "W" : "B")))) + "``");
					} {
						gamepacket_t p;
						p.Insert("OnConsoleMessage");
						p.Insert("This Crystal is currently mixed with " + join(reply, ", "));
						p.CreatePacket(peer);
					}
				}
				return true;
				}
				else if (t_ == 4830) {
					gamepacket_t p;
					if (items[p_].untradeable == 1 || p_ == 1424 || p_ == 5816 || items[p_].rarity >= 200 || items[p_].rarity < 1) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2That item is just too valuable convert to balloons``]``"), p.Insert(0), p.Insert(0);
					else {
						pInfo(peer)->lastchoosenitem = p_;
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`w" + items[p_].ori_name + "``|left|" + to_string(p_) + "|\nadd_spacer|small|\nadd_label|small|Those things have " + to_string(items[p_].rarity) + " Rarity, and you have " + to_string(have) + " of them.|left\nadd_label|small|Currently you have " + to_string(block_->shelf_1) + " Rarity stored from last time.|left" + get_balloon_type(block_->shelf_1) + "add_label|small|How many do you want to convert?|left\nadd_text_input|amount||" + to_string(have) + "|3|\nend_dialog|balloonomatic_dialog|Cancel|OK|");
					}
					p.CreatePacket(peer);
				}
				else if (t_ == 4124) {
					gamepacket_t p;
					if (p_ == 3942 or p_ == 3946 or p_ == 3948 or p_ == 3950) {
						p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wDNA Extractor``|left|4124|\nadd_spacer|small|\nembed_data|tilex|" + to_string(x_) + "\nembed_data|tiley|" + to_string(y_) + "\nembed_data|item|" + to_string(p_) + "\nadd_textbox|Are you sure you want to destroy a " + items[p_].name + " for a slim chance of extracting a tiny bit of prehistoric DNA?|left|\nend_dialog|dnaget|No|Yes|");
					}
					else {
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("No ancient DNA detected."), p.Insert(0), p.Insert(0);
					}
					p.CreatePacket(peer);
				}
				else if (t_ == 10656) {
					gamepacket_t p;
					if (p_ == 3402 && have >= 5) {
						p.Insert("OnDialogRequest");
						p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wWell of Love``|left|10656|\nadd_spacer|small|\nadd_textured_progress_bar|interface/large/gui_event_bar.rttex|0|2|`wLove: " + to_string(block_->shelf_1) + "/200|" + to_string(block_->shelf_1) + "|200``|relative|1|0.95|0|1000|64|0.01\nadd_spacer|small|\nadd_textbox|Give 5 Golden Booty Chests to receive the `2ONE best prize``, and to fill up the well. Once the well is full it will provide one reward with a `53.25% chance`` of getting one of these `5Epic`` items:|left|\nadd_spacer|small|\nadd_smalltext|Do you want to give `25`` to the well? (You have " + to_string(have) + ")|left|\nadd_button|wishing_well|Give Golden Booty Chests|no_flags|0|0|\nadd_spacer|small|\nadd_textbox|Once the well is full it will provide one reward with a `53.25% chance`` of getting one of these `5Epic`` items:|left|\nadd_label_with_icon|small| - `5Golden Heart Crystal``|left|1458|\nadd_label_with_icon|small| - `6EXCLUSIVE`` `5Stained Glass Crown``|left|11672|\nadd_label_with_icon|small| - `6EXCLUSIVE`` `5Cotton Candy Cape``|left|13140|\nadd_spacer|small|\nadd_textbox|... or a `5Pure Love Essence`` that doubles the chance of getting a Golden Heart Crystal when opening Golden Booty Chests, Super Golden Booty Chests and Heartstones.|left|\nadd_spacer|small|\nend_dialog|wishing_well|Thanks for the info!||");
					}
					else {
						p.Insert("OnTalkBubble");
						p.Insert(pInfo(peer)->netID);
						if (p_ != 3402) p.Insert("`5[`2The Well of Love only accepts Golden Booty Chests``]``");
						if (p_ == 3402 && have < 5) p.Insert("`5[`2The Well of Love only accepts minimum 5 of Golden Booty Chests``]``");
						p.Insert(0), p.Insert(0);
					}
					p.CreatePacket(peer);
				}
				else if (t_ == 3200 && p_ == 3204 && block_->shelf_1 < 100) {
					if (have < 1) break;
					have = -1;
					block_->shelf_1 += 1;
					modify_inventory(peer, 3204, have);
					tile_update(peer, world_, block_, x_, y_);
					return false;
				}
				else if (t_ == 4582 || t_ == 12196) {
					pInfo(peer)->lastwrenchb = t_;
					gamepacket_t p;
					if (items[p_].grindable_prize == 0 || items[p_].grindable_count == 0) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2That's not grindable``]``"), p.Insert(0), p.Insert(0);
					else if (items[p_].grindable_prize != 0 && have < items[p_].grindable_count) p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[`2I need " + to_string(items[p_].grindable_count) + " of those to grind them!``]``"), p.Insert(0), p.Insert(0);
					else {
						pInfo(peer)->lastchoosenitem = p_;
						p.Insert("OnDialogRequest"), p.Insert("set_default_color|`o\nadd_label_with_icon|big|`wGrind " + items[p_].name + "``|left|" + to_string(p_) + "|\nadd_textbox|You have " + to_string(have) + " " + items[p_].name + ". It takes " + to_string(items[p_].grindable_count) + " per grind. How many times will you grind (max " + to_string(have / items[p_].grindable_count) + ")?|left|\nadd_textbox|`4Beware:`` If you don't have room in your inventory for the resulting items, they will drop on the floor.|left|\nadd_text_input|count||" + to_string(have / items[p_].grindable_count) + "|5|\nend_dialog|grinder|Cancel|OK|");
					}
					p.CreatePacket(peer);
				}
				else if (p_ == 3200) {
					block_->planted = time(nullptr) + 1800;
					block_->shelf_1 = 0;
				}
				else if (block_->fg == 610 and p_ == 610) {
					int a = -1;
					if (modify_inventory(peer, 611, a, true) == 0) {
						add_magic_egg(peer, world_, block_, x_, y_);
					}
					return true;
				}
				if (items[p_].blockType == BlockTypes::SEED and items[block_->fg].blockType != BlockTypes::SEED and block_->fg != 0 and block_->fg != 610 or items[p_].blockType != BlockTypes::BACKGROUND and items[p_].blockType != BlockTypes::SEED and block_->fg != 0) {
					packet_(peer, "action|play_sfx\nfile|audio/cant_place_tile.wav\ndelayMS|0");
					return false;
				}
				else if (items[p_].blockType == BlockTypes::BACKGROUND and items[block_->fg].blockType == BlockTypes::BEDROCK or items[p_].blockType == BlockTypes::BACKGROUND and items[block_->fg].blockType == BlockTypes::MAIN_DOOR) {
					return false;
				}
				if (p_ == 10962 && block_->fg == 0) {
					int c_ = 0;
					modify_inventory(peer, 10962, c_);
					if (c_ != 0) modify_inventory(peer, 10962, c_ = -1);
					block_->fg = 10962;
					block_->r = world_->r;
					block_->g = world_->g;
					block_->b = world_->b;
					tile_update(peer, world_, block_, x_, y_);
					return true;
				}
				else if (p_ == 4516 or p_ == 9270) {
					if (world_->owner_name.empty() || to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName)) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						p.Insert("Only the owner of the world can place this.");
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						return false;
					}
				}
				if (p_ == 5000 or p_ == 3832 or p_ == 226 or p_ == 3616 or p_ == 1276 or p_ == 2072 or p_ == 1278 or p_ == 4758 or p_ == 3750 or p_ == 4992 or p_ == 3072 or p_ == 4884 or p_ == 1436 or p_ == 8246 or p_ == 10258) {
					bool block_place = false;
					int cctv_count = 0;
					for (int i_ = 0; i_ < world_->blocks.size(); i_++) {
						if (world_->blocks[i_].fg == p_) {
							if (p_ != 1436 and p_ != 8246 and p_ != 10258) block_place = true;
						}
						if (p_ == 1436 || p_ == 8246 || p_ == 10258) {
							if (world_->blocks[i_].fg == 1436 || world_->blocks[i_].fg == 8246 || world_->blocks[i_].fg == 10258)  cctv_count++;
						}
					}
					if (block_place or cctv_count >= 8) {
						gamepacket_t p;
						p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID);
						if (p_ == 1436 || p_ == 8246 || p_ == 10258) p.Insert("``You can only have 8 " + items[p_].name + " in a world.");
						else {
							if (p_ == 5000 or p_ == 3832) {
								p.Insert("``You can only have one " + items[p_].name + " in a world.");
								{
									gamepacket_t p(0, pInfo(peer)->netID);
									p.Insert("OnPlayPositioned"), p.Insert("audio/punch_locked.wav");
									p.CreatePacket(peer);
								}
							}
							else p.Insert("This world already has a `$" + items[p_].name + "`` somewhere on it, installing two would be dangerous!");
						}
						p.Insert(0), p.Insert(1), p.CreatePacket(peer);
						return false;
					}
				}
				int c_ = -1;
				if (t_ == 611 && p_ != 610) p_ = 611;
				if (items[p_].blockType == BlockTypes::BACKGROUND) block_->bg = p_;
				else {
					if (items[p_].collisionType == 1) {
						for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
							if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
							if (pInfo(currentPeer)->world == name_ and not pInfo(currentPeer)->ghost) {
								if (y_ == pInfo(currentPeer)->y / 32) {
									if (pInfo(currentPeer)->state == 0 and x_ * 32 < pInfo(currentPeer)->x and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state == 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 32 or pInfo(currentPeer)->state != 16 and abs(x_ * 32 - pInfo(currentPeer)->x) < 20) {
										return false;
									}
								}
							}
						}
					}
					if (items[p_].blockType == BlockTypes::CRYSTAL) block_->crystals.push_back({ p_, 1 });
					else if (items[p_].blockType == BlockTypes::PROVIDER) {
						block_->planted = time(nullptr);
						if (p_ == 9946)  block_->planted = 0;
					}
					else if (items[p_].blockType == BlockTypes::SEED) {
						bool spliced = false;
						if (items[block_->fg].blockType == BlockTypes::SEED or block_->fg == 610) {
							long long time_ = time(nullptr);
							int timed = items[block_->fg].growTime;
							if (pInfo(peer)->ances == 5082) timed *= 1.08;
							if (pInfo(peer)->ances == 5162) timed *= 1.09;
							if (pInfo(peer)->ances == 5164) timed *= 1.10;
							if (pInfo(peer)->ances == 5166) timed *= 1.11;
							if (pInfo(peer)->ances == 5168) timed *= 1.12;
							if (pInfo(peer)->ances == 5170) timed *= 1.13;
							if (pInfo(peer)->hand == 6846) timed *= 1.02;
							if (has_playmod2(pInfo(peer), 118)) timed *= 1.05;
							uint32_t laikas = uint32_t((time_ - block_->planted <= timed ? time_ - block_->planted : timed));
							gamepacket_t p;
							p.Insert("OnTalkBubble");
							p.Insert(pInfo(peer)->netID);
							if (block_->invert) {
								p.Insert("It would be too dangerous to try to mix three seeds."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								return false;
							}
							if (laikas == items[block_->fg].growTime && block_->fg != 610) {
								p.Insert("This tree is already too big to splice another seed with."), p.Insert(0), p.Insert(1), p.CreatePacket(peer);
								return false;
							}
							for (int i_ = 0; i_ < items.size(); i_++) {
								if (items[i_].r_1 == p_ and items[i_].r_2 == (block_->fg == 610 ? 611 : block_->fg) or items[i_].r_2 == p_ and items[i_].r_1 == (block_->fg == 610 ? 611 : block_->fg)) {
									if (block_->fg == 610) {
										block_->fg = 611;
										block_->fruit = items[block_->fg].rarity == 999 ? 1 : (rand() % 4) + 1;
									}
									spliced = true;
									if (event_item == 6834)add_points(peer, pInfo(peer)->hand);
									add_event_xp(peer, 1, "farmer");
									p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[i_].name + " Tree``!");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
									packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
									block_->fg = i_ + 1, block_->invert = 1;
									block_->planted = time(nullptr);
									PlayerMoving data_{};
									data_.packetType = 13, data_.plantingTree = p_;
									BYTE* raw = packPlayerMoving(&data_);
									raw[2] = 1;
									send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									delete[]raw;
									tile_update(peer, world_, block_, x_, y_);
									if (not mag_place) modify_inventory(peer, p_, c_, false);
									return true;
								}
								else if (i_ + 1 == items.size()) {
									bool changed_ = false;
									if (p_ == 339 and block_->fg == 627 or block_->fg == 339 and p_ == 627) {
										uint32_t s_ = p_ == 339 ? block_->fg : p_;
										i_ = 742;
										changed_ = true;
									}
									else if (p_ == 743 and block_->fg == 253 or block_->fg == 743 and p_ == 253) {
										uint32_t s_ = p_ == 743 ? block_->fg : p_;
										i_ = 758;
										changed_ = true;
									}
									else if (p_ == 743 and block_->fg == 285 or block_->fg == 745 and p_ == 285) {
										uint32_t s_ = p_ == 745 ? block_->fg : p_;
										i_ = 6674;
										changed_ = true;
									}
									if (changed_) {
										if (block_->fg == 610) {
											block_->fg = 611;
											block_->fruit = items[block_->fg].rarity == 999 ? 1 : (rand() % 4) + 1;
										}
										add_event_xp(peer, 1, "farmer");
										if (event_item == 6834)add_points(peer, pInfo(peer)->hand);
										spliced = true;
										p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[i_].name + " Tree``!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
										packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
										block_->fg = i_ + 1, block_->invert = 1;
										block_->planted = time(nullptr);
										PlayerMoving data_{};
										data_.packetType = 13, data_.plantingTree = p_;
										BYTE* raw = packPlayerMoving(&data_);
										raw[2] = 1;
										send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
										delete[]raw;
										tile_update(peer, world_, block_, x_, y_);
										if (not mag_place) modify_inventory(peer, p_, c_, false);
										return true;
									}
									if (p_ == block_->fg) {
										p.Insert("Hmm, it looks like `w" + items[block_->fg].name + "`` and `w" + items[p_].name + "`` can't be spliced.");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
										return false;
									}
									/*
									else {
										p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[2735].ori_name + " Tree``!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
										packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
										block_->fg = 2735, block_->planted = time(nullptr) + 3600, block_->invert = true;
										int remove = -1;
										modify_inventory(peer, p_, remove);
										plant_(world_, peer, block_, x_, y_, 2734, true, mag_place);
										return true;
									}*/
									/*else {
										p.Insert("`w" + items[p_].name + "`` and `w" + items[block_->fg].name + "`` have been spliced to make a `$" + items[1361].ori_name + " Tree``!");
										p.Insert(0);
										p.Insert(1);
										p.CreatePacket(peer);
										packet_(peer, "action|play_sfx\nfile|audio/success.wav\ndelayMS|0");
										block_->fg = 1361, block_->planted = time(nullptr) + 3600, block_->sp = 1;
										int remove = -1;
										modify_inventory(peer, p_, remove);
										plant_(world_, peer, block_, x_, y_, 1360, true, mag_place);
										return true;
									}*/ //winter gift splice


									p.Insert("Hmm, it looks like `w" + items[block_->fg].name + "`` and `w" + items[p_].name + "`` can't be spliced.");
									p.Insert(0);
									p.Insert(1);
									p.CreatePacket(peer);
									return false;
								}
							}
						}
						if (spliced == false) {
							if (p_ == 611)p_ = 610;
							/*
							if (p_ == 13317) {
								planted++;
								OnSetEvent(peer, 1);
							}*/
							if (pInfo(peer)->lwiz_step == 5) add_lwiz_points(peer, items[p_].rarity);
						}
					}
					else if (items[p_].blockType == BlockTypes::Heart_Monitor || p_ == 3394) {
						if (p_ == 3394) block_->heart_monitor = pInfo(peer)->country;
						else {
							if (pInfo(peer)->name_color == "`p@" ||pInfo(peer)->name_color == "`e@" ||pInfo(peer)->name_color == "`8@" ||pInfo(peer)->name_color == "`6@" || pInfo(peer)->name_color == "`#@") block_->heart_monitor = pInfo(peer)->name_color + pInfo(peer)->tankIDName + "``";
							else block_->heart_monitor = pInfo(peer)->tankIDName;
						}
					}
					else if (p_ == 10358) {
							block_->txt = "`$[```4ENTRY PRICE```$]``: " + to_string(block_->shelf_1) + " ā";
					}
					else if (items[p_].blockType == BlockTypes::BULLETIN_BOARD || items[p_].blockType == BlockTypes::MAILBOX)block_->spin = true;
					else if (items[p_].blockType == LOCK) {
						if (p_ == 202 or p_ == 204 or p_ == 206 or p_ == 4994 or p_ == 10000) {
							if (not world_->owner_name.empty() and to_lower(world_->owner_name) != to_lower(pInfo(peer)->tankIDName)) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("You must be world owner to place locks!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								return true;
							}
							if (block_->locked) {
								if (to_lower(world_->blocks[block_->lock_origin].owner_name) != to_lower(pInfo(peer)->tankIDName)) {
									gamepacket_t p;
									p.Insert("OnTalkBubble");
									p.Insert(pInfo(peer)->netID);
									p.Insert("You must be world owner to place locks!");
									p.Insert(0), p.Insert(0);
									p.CreatePacket(peer);
									return true;
								}
							}
							int safe_dis = p_ == 206 || p_ == 4994 ? 7 : p_ == 204 ? 3 : 0; // nes kitaip susipisa viskas
							if (x_ < safe_dis or y_ < safe_dis or world_->max_x - safe_dis < x_ or world_->max_y - safe_dis < y_) {
								gamepacket_t p;
								p.Insert("OnTalkBubble");
								p.Insert(pInfo(peer)->netID);
								p.Insert("You can't place that here, move " + to_string(x_ < safe_dis ? safe_dis - x_ : y_ < safe_dis ? safe_dis - y_ : world_->max_x - safe_dis < x_ ? x_ - (world_->max_x - safe_dis) : world_->max_y - safe_dis < y_ ? y_ - (world_->max_y - safe_dis) : 0) + " block away from border!");
								p.Insert(0), p.Insert(0);
								p.CreatePacket(peer);
								return true;
							}
							block_->block_day = "";
							block_->owner_name = pInfo(peer)->tankIDName;
							if (pInfo(peer)->name_color != "`0" or pInfo(peer)->mod || pInfo(peer)->dev || pInfo(peer)->superdev && pInfo(peer)->name_color != "`2")  block_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
							else block_->owner_named = pInfo(peer)->tankIDName;
							int lock_size = p_ == 202 ? 10 : (p_ == 204 || p_ == 10000 ? 48 : (p_ == 202 ? 200 : 200));
							vector<vector<int>> tiles_ = lock_tiles(world_, x_, y_, lock_size);
							lock_size = tiles_.size();
							PlayerMoving data_{};
							data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8;
							data_.netID = name_to_number(to_lower(pInfo(peer)->tankIDName));
							data_.plantingTree = p_;
							BYTE* raw;
							if (tiles_.size() != 0) {
								int alloc = alloc_(world_, block_);
								raw = packPlayerMoving(&data_, 112 + (lock_size * 2) + alloc);
								int lalala = 8;
								memcpy(raw + 8, &lock_size, 2);
								memcpy(raw + 12, &lalala, 2);
								BYTE* blc = raw + 56;
								for (int i_ = 0; i_ < tiles_.size(); i_++) {
									vector<int> update_tiles = tiles_[i_];
									int x = update_tiles[0];
									int y = update_tiles[1];
									int sq_ = x + (y * 100);
									WorldBlock* block_ = &world_->blocks[sq_];
									if (block_->locked) {

									}
									else {
										block_->locked = true;
										block_->lock_origin = x_ + (y_ * 100);
										memcpy(blc + (i_ * 2), &sq_, 2);
									}
								}
								string t_ = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0";
								BYTE* const d_ = new BYTE[5 + t_.length()];
								*(__int8*)(d_) = 3;
								memcpy(d_ + 4, t_.c_str(), t_.length());
								*(__int8*)(d_ + 4 + t_.length()) = 0;
								ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										enet_peer_send(currentPeer, 0, p_m);
										send_raw(currentPeer, 4, raw, 112 + (lock_size * 2) + alloc, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]d_;
								delete[] raw, blc;
							}
							else {
								raw = packPlayerMoving(&data_, 56);
								string t_ = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0";
								BYTE* const d_ = new BYTE[5 + t_.length()];
								*(__int8*)(d_) = 3;
								memcpy(d_ + 4, t_.c_str(), t_.length());
								*(__int8*)(d_ + 4 + t_.length()) = 0;
								ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
									if (pInfo(currentPeer)->world == name_) {
										enet_peer_send(currentPeer, 0, p_m);
										send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									}
								}
								delete[]d_;
								delete[] raw;
							}
							gamepacket_t p;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Area locked."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
							{
								PlayerMoving data_{};
								data_.packetType = 13, data_.plantingTree = p_;
								BYTE* raw = packPlayerMoving(&data_);
								raw[2] = 1;
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[]raw;
							}
						}
						else {
							if (not world_->owner_name.empty()) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Only one `$World Lock`` can be placed in a world, you'd have to remove the other one first."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								return false;
							}
							vector<WorldBlock>::iterator pg = find_if(world_->blocks.begin(), world_->blocks.end(), [&](const WorldBlock& a) { return (a.fg == 202 || a.fg == 204 || a.fg == 206 || a.fg == 4994 || a.fg == 10000) && to_lower(a.owner_name) != to_lower(pInfo(peer)->tankIDName); });
							if (pg != world_->blocks.end()) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("Your `$World Lock`` can't be placed in this world unless everyone else's locks are removed."), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								return false;
							}
							if (pInfo(peer)->w_w >= 75) {
								gamepacket_t p;
								p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You locked too many new worlds today, try tomorrow!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
								return false;
							}
							else pInfo(peer)->w_w++;
							pInfo(peer)->worlds_owned.push_back(world_->name);
							world_->owner_name = pInfo(peer)->tankIDName;
							if (pInfo(peer)->name_color != "`0" or pInfo(peer)->mod || pInfo(peer)->dev || pInfo(peer)->superdev && pInfo(peer)->name_color != "`2")  world_->owner_named = pInfo(peer)->name_color + pInfo(peer)->tankIDName;
							else world_->owner_named = pInfo(peer)->tankIDName;
							PlayerMoving data_{};
							data_.packetType = 15, data_.punchX = x_, data_.punchY = y_, data_.characterState = 0x8, data_.netID = name_to_number(to_lower(pInfo(peer)->tankIDName)), data_.plantingTree = p_;
							BYTE* raw = packPlayerMoving(&data_, 56);
							if (p_ == 11902 || p_ == 11550 || p_ == 13200 || p_ == 11586 || p_ == 10410 || p_ == 12654) {
								if (p_ == 11550) world_->weather = 54;
								else if (p_ == 11586) world_->weather = 55;
								else if (p_ == 10410) world_->weather = 53;
								else if (p_ == 11902) world_->weather = 58;
								else if (p_ == 12654) world_->weather = 63;
								else if (p_ == 13200) world_->weather = 67;
								gamepacket_t p;
								p.Insert("OnSetCurrentWeather");
								if (comet_dust) p.Insert(16);
								else p.Insert(world_->weather == 0 ? 80 : world_->weather);
								for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
									if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(currentPeer)->world != name_) continue;
									pInfo(currentPeer)->lock = p_;
									p.CreatePacket(currentPeer);
								}
							}
							gamepacket_t p, p2;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + (pInfo(peer)->name_color != "`0" ? pInfo(peer)->name_color + world_->owner_name + "``" : world_->owner_name) + "`5]``"), p.Insert(0), p.Insert(0);
							p2.Insert("OnConsoleMessage"), p2.Insert("`5[```w" + world_->name + "`` has been `$World Locked`` by " + (pInfo(peer)->name_color != "`0" ? pInfo(peer)->name_color + world_->owner_name + "``" : world_->owner_name) + "`5]``");
							pInfo(peer)->name_color =  (pInfo(peer)->give_role ? "`8@" : pInfo(peer)->Staff ? "`4@" : pInfo(peer)->superdev ? "`8@" : pInfo(peer)->dev ? "`6@" : (pInfo(peer)->mod) ? "`#@" : (to_lower(pInfo(peer)->tankIDName) == to_lower(world_->owner_name)) ? "`2" : "`0");
							nick_update_2(peer, NULL);
								string t_ = "action|play_sfx\nfile|audio/use_lock.wav\ndelayMS|0";
								BYTE* const d_ = new BYTE[5 + t_.length()];
								*(__int8*)(d_) = 3;
								memcpy(d_ + 4, t_.c_str(), t_.length());
								*(__int8*)(d_ + 4 + t_.length()) = 0;
								ENetPacket* const p_m = enet_packet_create(d_, 5 + t_.length(), ENET_PACKET_FLAG_RELIABLE);
							for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
								if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
								if (pInfo(currentPeer)->world == name_) {
									pInfo(currentPeer)->world_owner = (world_->owner_named.empty() ? "`#" + world_->owner_name : world_->owner_named);
									enet_peer_send(currentPeer, 0, p_m);
									send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									p.CreatePacket(currentPeer), p2.CreatePacket(currentPeer);
									pInfo(currentPeer)->lock = p_;
								}
							}
							delete[]d_;
							delete[] raw;
							{
								PlayerMoving data_{};
								data_.packetType = 13, data_.plantingTree = p_;
								BYTE* raw = packPlayerMoving(&data_);
								raw[2] = 1;
								send_raw(peer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
								delete[]raw;
							}
						}
						block_->fg = p_;
						if (not mag_place) modify_inventory(peer, (p_ == 610 ? 611 : p_), c_, false);
						break;
					}
					else if (p_ == 610) {
						pInfo(peer)->magic_egg++;
						punch_tile(peer, x_, y_, 0x3, 611, mag_place ? -1 : pInfo(peer)->netID, 0x0);
						punch_tile(peer, x_, y_, 0x3, p_, -1, 0x0);
					}
					block_->fg = p_;
					if (items[p_].blockType == BlockTypes::SEED) plant_(world_, peer, block_, x_, y_, p_, true, mag_place);
				}
				if (items[p_].blockType != BlockTypes::SEED) punch_tile(peer, x_, y_, 0x3, p_, mag_place ? -1 : pInfo(peer)->netID, 0x0);
				block_->lp = 0;
				if ((items[p_].multiple_sides and pInfo(peer)->state == 16) or p_ == 3394 || p_ == 3200 || items[p_].blockType == BlockTypes::PROVIDER or p_ == 1240 or p_ == 3798 or p_ == 10358) {
					if (items[p_].multiple_sides and pInfo(peer)->state == 16) block_->flags |= 0x00200000;
					tile_update(peer, world_, block_, x_, y_);
				}
				add_event_xp(peer, 1, "builder");
				if (pInfo(peer)->grow4good_place < 1000 && pInfo(peer)->grow4good_place != -1)daily_quest(peer, false, "place", 1);
				if (event_item == 6828) add_points(peer, pInfo(peer)->hand);
			if (not mag_place) modify_inventory(peer, (p_ == 610 ? 611 : p_), c_, false);
				break;
			}
			break;
			// lopas
		}
		}
	}
	return true;
}

void player_punch(ENetPeer* peer, int item, int punch_x, int punch_y, int x, int y, bool bypass = false) {
	if (item <= 0 || item >= items.size()) return;
	if (pInfo(peer)->dev  + pInfo(peer)->cheater_settings == 0 && (abs(x / 32 - punch_x) > 15 || abs(y / 32 - punch_y) > 15)) {
		if (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_0) autofarm_status(peer);
		return;
	}

	/*if (pInfo(peer)->hand == 3066) {
		if ((p_->punchX > 0 &&punch_x < 100) && (punch_y > 0 && punch_y < 60) && item == 0) edit_tile(peer,punch_x, punch_y, 18);
	}*/
	//if (items[item].blocked_place == 1) break; // crash block
	int c_ = 0;
	if (item != 18 and item != 32) {
		modify_inventory(peer, item, c_);
		if (c_ == 0) {
			if (pInfo(peer)->cheater_settings & Gtps3::SETTINGS_0) autofarm_status(peer), item = 18;
			else return;
		}
	}
	if (item == 18) {
		if (pInfo(peer)->punch_time + 100 > (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) return;
		pInfo(peer)->punch_time = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
		if (has_playmod2(pInfo(peer), 28) or pInfo(peer)->hand != 0 or pInfo(peer)->seeker) {
			if (pInfo(peer)->last_inf + 1000 < (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count()) {
				pInfo(peer)->last_inf = (duration_cast<milliseconds>(system_clock::now().time_since_epoch())).count();
				pInfo(peer)->last_infected = punch_x + (punch_y * 100);
				bool infected = false;
				for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
					if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL or pInfo(peer)->world != pInfo(currentPeer)->world or pInfo(peer)->netID == pInfo(currentPeer)->netID) continue;
					if (infected) break;
					int last_location = pInfo(currentPeer)->x / 32 + (pInfo(currentPeer)->y / 32 * 100);
					if (abs(pInfo(peer)->last_infected - last_location) == 0) {
						if (pInfo(peer)->seeker && pInfo(currentPeer)->hider && pInfo(currentPeer)->world == Hide_N_Seek.hidenseekworld && pInfo(peer)->world == Hide_N_Seek.hidenseekworld) {
							wipe_hidenseek(currentPeer);
							pInfo(currentPeer)->hider = false;
							form_state(pInfo(currentPeer));
							if (pInfo(peer)->lwiz_step == 2) add_lwiz_points(peer, 1);
							console_msg(currentPeer, "CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: You got caught! Received 500 Gems reward. [Players left: " + to_string(Hide_N_Seek.hide_players.size() - Hide_N_Seek.seeker.size()) + "/" + to_string(Hide_N_Seek.total_players) + "]");
							OnSetGems(currentPeer, 500);
							exit_(currentPeer);
							gamepacket_t p, p2, p4;
							p.Insert("OnTalkBubble"), p.Insert(pInfo(peer)->netID), p.Insert("You have caught " + pInfo(currentPeer)->tankIDName + " (" + to_string(Hide_N_Seek.hide_players.size() - Hide_N_Seek.seeker.size()) + "/" + to_string(Hide_N_Seek.total_players) + ")!"), p.Insert(0), p.Insert(0), p.CreatePacket(peer);
							p2.Insert("OnConsoleMessage"), p2.Insert("CP:_PL:0_OID:_CT:[S]_ `5***`` `9[HIDE AND SEEK]: " + pInfo(currentPeer)->tankIDName + " got caught! [Players left: " + to_string(Hide_N_Seek.hide_players.size() - Hide_N_Seek.seeker.size()) + "/" + to_string(Hide_N_Seek.total_players) + "]");
							p4.Insert("OnParticleEffectV2"), p4.Insert(199), p4.Insert((float)pInfo(currentPeer)->x + 16, (float)pInfo(currentPeer)->y + 16);
							for (ENetPeer* currentPeer3 = server->peers; currentPeer3 < &server->peers[server->peerCount]; ++currentPeer3) {
								if (currentPeer3->state != ENET_PEER_STATE_CONNECTED or currentPeer3->data == NULL) continue;
								if (pInfo(currentPeer3)->world == Hide_N_Seek.hidenseekworld) {
									packet_(currentPeer3, "action|play_sfx\nfile|audio/getpoint.wav\ndelayMS|0");
									p4.CreatePacket(currentPeer3);
									p2.CreatePacket(currentPeer3);
								}
							}
							infected = true;
						}
						else if (has_playmod2(pInfo(peer), 28) && not has_playmod2(pInfo(currentPeer), 28)) {
							if (has_playmod2(pInfo(currentPeer), 25)) {
								for (ENetPeer* currentPeer2 = server->peers; currentPeer2 < &server->peers[server->peerCount]; ++currentPeer2) {
									if (currentPeer2->state != ENET_PEER_STATE_CONNECTED or currentPeer2->data == NULL or pInfo(currentPeer)->world != pInfo(currentPeer2)->world) continue;
									PlayerMoving data_{};
									data_.packetType = 19, data_.punchX = 782, data_.x = pInfo(currentPeer)->x + 10, data_.y = pInfo(currentPeer)->y + 16;
									int32_t to_netid = pInfo(currentPeer)->netID;
									BYTE* raw = packPlayerMoving(&data_);
									raw[3] = 5;
									memcpy(raw + 8, &to_netid, 4);
									send_raw(currentPeer2, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
									delete[]raw;
								}
							}
							else {
								infected = true;
								gamepacket_t p;
								p.Insert("OnAddNotification"), p.Insert("interface/large/infected.rttex"), p.Insert("`4You were infected by " + pInfo(peer)->tankIDName + "!"), p.CreatePacket(currentPeer);
								add_playmod(currentPeer, 28);
								update_clothes_value(currentPeer);
								update_clothes(currentPeer, true);
							}
						}
						else if (zombie_apocalypse && not has_playmod2(pInfo(peer), 28) && has_playmod2(pInfo(currentPeer), 28)) {
							infected = true;
							SendRespawn(currentPeer, 0, true);
							string name_ = pInfo(currentPeer)->world;
							vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
							if (p != worlds.end()) {
								World* world_ = &worlds[p - worlds.begin()];
								if (punch_y < 0 || punch_x < 0 || punch_x >= world_->max_x || punch_y >= world_->max_y) break;
								WorldDrop drop_block_{};
								drop_block_.id = rand() % 2 < 1 ? 4450 : 12370, drop_block_.count = pInfo(peer)->hand == 9500 ? 2 : 1,  drop_block_.x = pInfo(currentPeer)->x, drop_block_.y = pInfo(currentPeer)->y;
								has_playmod2(pInfo(currentPeer), 28, 1);
								dropas_(world_, drop_block_);
							}
						}
					}
				}
			}
			else {
				if (pInfo(peer)->seeker) {
					gamepacket_t p;
					p.Insert("OnTalkBubble");
					p.Insert(pInfo(peer)->netID);
					p.Insert("Slowdown..");
					p.Insert(0), p.Insert(0);
					p.CreatePacket(peer);
				}
			}
		}
	}
	if (item == 18 and (pInfo(peer)->hand == 9908 || pInfo(peer)->hand == 9846 || pInfo(peer)->hand == 13702 || pInfo(peer)->hand == 13706 || pInfo(peer)->hand == 13700  || pInfo(peer)->hand == 13682 || pInfo(peer)->hand == 9604 || pInfo(peer)->hand == 10362 || pInfo(peer)->necklace == 10176|| pInfo(peer)->hand == 10126 || pInfo(peer)->hand == 10020 || pInfo(peer)->hair == 9838 || pInfo(peer)->hair == 9920 || pInfo(peer)->necklace == 9964 || pInfo(peer)->hand == 5480 || pInfo(peer)->hand == 9918 || pInfo(peer)->hand == 10290 || pInfo(peer)->hand == 9906 || pInfo(peer)->hand == 9770 || pInfo(peer)->hand == 9772 || pInfo(peer)->hair == 9542 || pInfo(peer)->hand == 9916)) { // tingejau galvoti kaip kitaip daryt
		string name_ = pInfo(peer)->world;
		vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
		if (p != worlds.end()) {
			World* world_ = &worlds[p - worlds.begin()];
			if (punch_y < 0 || punch_x < 0 || punch_x >= world_->max_x || punch_y >= world_->max_y) return;
			if (world_->blocks[punch_x + (punch_y * 100)].fg == 0 and world_->blocks[punch_x + (punch_y * 100)].bg == 0) return;
		}
		else return;
		edit_tile(peer, punch_x, punch_y, item);
		if (punch_y == pInfo(peer)->y / 32) {
			edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -1 : 1), punch_y, item);
			edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -2 : 2), punch_y, item);
			if (pInfo(peer)->hand == 13700) {
				edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -3 : 3), punch_y, item);
				edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -4 : 4), punch_y, item);
				edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -5 : 5), punch_y, item);
			}
		}
		else if (punch_x == pInfo(peer)->x / 32) {
			if (punch_y > pInfo(peer)->y / 32 || punch_y < pInfo(peer)->y / 32) {
				edit_tile(peer, punch_x, punch_y + (punch_y > pInfo(peer)->y / 32 ? 1 : -1), item);
				edit_tile(peer, punch_x, punch_y + (punch_y > pInfo(peer)->y / 32 ? 2 : -2), item);
				if (pInfo(peer)->hand == 13700) {
					edit_tile(peer, punch_x, punch_y + (punch_y > pInfo(peer)->y / 32 ? 3 : -3), item);
					edit_tile(peer, punch_x, punch_y + (punch_y > pInfo(peer)->y / 32 ? 4 : -4), item);
					edit_tile(peer, punch_x, punch_y + (punch_y > pInfo(peer)->y / 32 ? 5 : -5), item);
				}
			}
		}
		else if (punch_y < pInfo(peer)->y / 32 || punch_y > pInfo(peer)->y / 32) {
			edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -1 : 1), punch_y + (punch_y < pInfo(peer)->y / 32 ? -1 : 1), item);
			edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -2 : 2), punch_y + (punch_y < pInfo(peer)->y / 32 ? -2 : 2), item);
			if (pInfo(peer)->hand == 13700) {
				edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -3 : 3), punch_y + (punch_y < pInfo(peer)->y / 32 ? -3 : 3), item);
				edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -4 : 4), punch_y + (punch_y < pInfo(peer)->y / 32 ? -4 : 4), item);
				edit_tile(peer, punch_x + (pInfo(peer)->state == 16 ? -5 : 5), punch_y + (punch_y < pInfo(peer)->y / 32 ? -5 : 5), item);
			}
		}
	}
	else {
		bool empty = false;
		if (item == 5640) {
			bool place_punch = false;
			string name_ = pInfo(peer)->world;
			vector<World>::iterator p = find_if(worlds.begin(), worlds.end(), [name_](const World& a) { return a.name == name_; });
			if (p != worlds.end()) {
				World* world_ = &worlds[p - worlds.begin()];
				if (punch_y < 0 || punch_x < 0 || punch_x >= world_->max_x || punch_y >= world_->max_y) return;
				for (int i_ = 0; i_ < world_->machines.size(); i_++) {
					WorldMachines machine = world_->machines[i_];
					if ((machine.x == pInfo(peer)->magnetron_x and machine.y == pInfo(peer)->magnetron_y) and (machine.id == 5638 or machine.id == 9850 or machine.id == 10266)) {
						if (machine.enabled) {
							WorldBlock* itemas = &world_->blocks[machine.x + (machine.y * 100)];
							if (itemas->spin and itemas->id == pInfo(peer)->magnetron_id) {
								if (itemas->pr > 0) {
									if (items[itemas->id].blockType == BlockTypes::BACKGROUND && world_->blocks[punch_x + (punch_y * 100)].bg != 0 or items[itemas->id].blockType != BlockTypes::BACKGROUND && world_->blocks[punch_x + (punch_y * 100)].fg != 0) place_punch = true;
									if (items[itemas->id].blockType == BlockTypes::SEED) place_punch = false;
									item = itemas->id;
									if (edit_tile(peer, punch_x, punch_y, itemas->id, true, place_punch)) {
										if (place_punch == false) itemas->pr--;
										if (itemas->pr <= 0) {
											PlayerMoving data_{};
											data_.packetType = 5, data_.punchX = machine.x, data_.punchY = machine.y, data_.characterState = 0x8;
											BYTE* raw = packPlayerMoving(&data_, 112 + alloc_(world_, itemas));
											BYTE* blc = raw + 56;
											form_visual(blc, *itemas, *world_, NULL, false);
											for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
												if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL) continue;
												if (pInfo(currentPeer)->world == world_->name) {
													send_raw(currentPeer, 4, raw, 112 + alloc_(world_, itemas), ENET_PACKET_FLAG_RELIABLE);
												}
											}
											delete[] raw, blc;
										}
										break;
									}
								}
								else {
									if (place_punch == false) {
										empty = true;
										gamepacket_t p;
										p.Insert("OnTalkBubble");
										p.Insert(pInfo(peer)->netID);
										p.Insert("The `2" + items[machine.id].name + "`` is empty!");
										p.Insert(0), p.Insert(0);
										p.CreatePacket(peer);
									}
								}
							}
						}
						break;
					}
				}
			}
			if (item == 5640 and not empty) {
				gamepacket_t p;
				p.Insert("OnTalkBubble");
				p.Insert(pInfo(peer)->netID);
				p.Insert("There is no active `2" + items[5638].name + "``!");
				p.Insert(0), p.Insert(0);
				p.CreatePacket(peer);
				autofarm_status(peer);
			}
			return;
		}
		edit_tile(peer, punch_x, punch_y, item, false, false, c_);
	}
}

void move_(ENetPeer* peer, PlayerMoving* data) {
	data->netID = pInfo(peer)->netID;
	BYTE* raw = packPlayerMoving(data);
	for (ENetPeer* currentPeer = server->peers; currentPeer < &server->peers[server->peerCount]; ++currentPeer) {
		if (currentPeer->state != ENET_PEER_STATE_CONNECTED or currentPeer->data == NULL || peer == currentPeer || pInfo(currentPeer)->world != pInfo(peer)->world) continue;
		send_raw(currentPeer, 4, raw, 56, ENET_PACKET_FLAG_RELIABLE);
	}
	delete[]raw;
}